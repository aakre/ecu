
ecu_user_board.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         000059b8  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80007a00  80007a00  00007e00  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000234  80007c00  80007c00  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  80007e34  80007e34  00008234  2**0
                  ALLOC
  6 .data         000001e8  00000004  80007e38  00008404  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .hsb_ram_loc  00000200  000001ec  80008020  000085ec  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .balign       00000004  000003ec  80008220  000087ec  2**0
                  ALLOC
  9 .bss          0000cc18  000003f0  80008220  000087f0  2**2
                  ALLOC
 10 .comment      00000030  00000000  00000000  000087ec  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000e70  00000000  00000000  00008820  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00002f15  00000000  00000000  00009690  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00018a6c  00000000  00000000  0000c5a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 000039ec  00000000  00000000  00025011  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00011fc8  00000000  00000000  000289fd  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002460  00000000  00000000  0003a9c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    000061e0  00000000  00000000  0003ce28  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00006146  00000000  00000000  00043008  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 0202fb3d  00000000  00000000  0004914e  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  0000f000  0000f000  00000400  2**0
                  ALLOC
 21 .debug_ranges 00000eb8  00000000  00000000  02078c90  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf b6 84 	sub	pc,pc,-18812

Disassembly of section .text:

80002004 <getBaudDiv>:
80002004:	f8 c8 00 01 	sub	r8,r12,1
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80002008:	f0 0b 00 0b 	add	r11,r8,r11
8000200c:	f6 0c 0d 0a 	divu	r10,r11,r12
80002010:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80002012:	f4 c8 00 01 	sub	r8,r10,1
80002016:	e0 48 00 fe 	cp.w	r8,254
8000201a:	e0 88 00 03 	brls	80002020 <getBaudDiv+0x1c>
8000201e:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80002020:	5c 8c       	casts.h	r12
}
80002022:	5e fc       	retal	r12

80002024 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80002024:	30 18       	mov	r8,1
80002026:	99 08       	st.w	r12[0x0],r8
}
80002028:	5e fc       	retal	r12
8000202a:	d7 03       	nop

8000202c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000202c:	d4 01       	pushm	lr
8000202e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002032:	c0 58       	rjmp	8000203c <spi_unselectChip+0x10>
		if (!timeout--) {
80002034:	58 08       	cp.w	r8,0
80002036:	c0 21       	brne	8000203a <spi_unselectChip+0xe>
80002038:	da 0a       	popm	pc,r12=1
8000203a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000203c:	78 49       	ld.w	r9,r12[0x10]
8000203e:	e2 19 02 00 	andl	r9,0x200,COH
80002042:	cf 90       	breq	80002034 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002044:	78 18       	ld.w	r8,r12[0x4]
80002046:	ea 18 00 0f 	orh	r8,0xf
8000204a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000204c:	fc 18 01 00 	movh	r8,0x100
80002050:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80002052:	30 09       	mov	r9,0
80002054:	12 9a       	mov	r10,r9
80002056:	12 9b       	mov	r11,r9
80002058:	48 38       	lddpc	r8,80002064 <spi_unselectChip+0x38>
8000205a:	70 0c       	ld.w	r12,r8[0x0]
8000205c:	f0 1f 00 03 	mcall	80002068 <spi_unselectChip+0x3c>
80002060:	d8 0a       	popm	pc,r12=0
80002062:	00 00       	add	r0,r0
80002064:	00 00       	add	r0,r0
80002066:	cf 34       	brge	8000204c <spi_unselectChip+0x20>
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	2e c8       	sub	r8,-20

8000206c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000206c:	eb cd 40 f8 	pushm	r3-r7,lr
80002070:	18 94       	mov	r4,r12
80002072:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80002074:	49 a6       	lddpc	r6,800020dc <spi_selectChip+0x70>
80002076:	30 07       	mov	r7,0
80002078:	31 45       	mov	r5,20
8000207a:	0e 99       	mov	r9,r7
8000207c:	0a 9a       	mov	r10,r5
8000207e:	0e 9b       	mov	r11,r7
80002080:	6c 0c       	ld.w	r12,r6[0x0]
80002082:	f0 1f 00 18 	mcall	800020e0 <spi_selectChip+0x74>
80002086:	cf a0       	breq	8000207a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002088:	68 18       	ld.w	r8,r4[0x4]
8000208a:	ea 18 00 0f 	orh	r8,0xf
8000208e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80002090:	68 18       	ld.w	r8,r4[0x4]
80002092:	e2 18 00 04 	andl	r8,0x4,COH
80002096:	c1 10       	breq	800020b8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80002098:	30 e8       	mov	r8,14
8000209a:	f0 03 18 00 	cp.b	r3,r8
8000209e:	e0 8b 00 1c 	brhi	800020d6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800020a2:	68 19       	ld.w	r9,r4[0x4]
800020a4:	e6 08 15 10 	lsl	r8,r3,0x10
800020a8:	ea 18 ff f0 	orh	r8,0xfff0
800020ac:	e8 18 ff ff 	orl	r8,0xffff
800020b0:	12 68       	and	r8,r9
800020b2:	89 18       	st.w	r4[0x4],r8
800020b4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800020b8:	30 38       	mov	r8,3
800020ba:	f0 03 18 00 	cp.b	r3,r8
800020be:	e0 8b 00 0c 	brhi	800020d6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800020c2:	68 19       	ld.w	r9,r4[0x4]
800020c4:	2f 03       	sub	r3,-16
800020c6:	30 18       	mov	r8,1
800020c8:	f0 03 09 48 	lsl	r8,r8,r3
800020cc:	5c d8       	com	r8
800020ce:	12 68       	and	r8,r9
800020d0:	89 18       	st.w	r4[0x4],r8
800020d2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800020d6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800020d8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800020dc:	00 00       	add	r0,r0
800020de:	cf 34       	brge	800020c4 <spi_selectChip+0x58>
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	2d ac       	sub	r12,-38

800020e4 <wdt_set_ctrl>:
 *
 * \note The KEY bit-field of \a ctrl is assumed to be zero.
 */
static void wdt_set_ctrl(uint32_t ctrl)
{
	AVR32_WDT.ctrl = ctrl | (AVR32_WDT_KEY_VALUE << AVR32_WDT_CTRL_KEY_OFFSET);
800020e4:	18 99       	mov	r9,r12
800020e6:	ea 19 55 00 	orh	r9,0x5500
800020ea:	fe 78 10 00 	mov	r8,-61440
800020ee:	91 09       	st.w	r8[0x0],r9
	AVR32_WDT.ctrl = ctrl | ((uint32_t) (~AVR32_WDT_KEY_VALUE << AVR32_WDT_CTRL_KEY_OFFSET) & AVR32_WDT_CTRL_KEY_MASK);
800020f0:	ea 1c aa 00 	orh	r12,0xaa00
800020f4:	91 0c       	st.w	r8[0x0],r12
}
800020f6:	5e fc       	retal	r12

800020f8 <wdt_get_us_timeout_period>:

int64_t wdt_get_us_timeout_period(wdt_opt_t *opt)
{
800020f8:	eb cd 40 c0 	pushm	r6-r7,lr
	// RCOSC
	if (opt->cssel == WDT_CLOCK_SOURCE_SELECT_RCSYS) {
800020fc:	f9 39 00 10 	ld.ub	r9,r12[16]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c3 11       	brne	80002168 <wdt_get_us_timeout_period+0x70>
		// Read CTRL.PSEL and translate it into us.
		return (AVR32_WDT.ctrl & AVR32_WDT_CTRL_EN_MASK) ?
80002108:	fe 78 10 00 	mov	r8,-61440
8000210c:	70 08       	ld.w	r8,r8[0x0]
8000210e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002112:	c0 41       	brne	8000211a <wdt_get_us_timeout_period+0x22>
80002114:	3f f8       	mov	r8,-1
80002116:	3f f9       	mov	r9,-1
80002118:	c5 78       	rjmp	800021c6 <wdt_get_us_timeout_period+0xce>
				((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
8000211a:	fe 78 10 00 	mov	r8,-61440
8000211e:	70 08       	ld.w	r8,r8[0x0]
int64_t wdt_get_us_timeout_period(wdt_opt_t *opt)
{
	// RCOSC
	if (opt->cssel == WDT_CLOCK_SOURCE_SELECT_RCSYS) {
		// Read CTRL.PSEL and translate it into us.
		return (AVR32_WDT.ctrl & AVR32_WDT_CTRL_EN_MASK) ?
80002120:	f1 d8 c1 05 	bfextu	r8,r8,0x8,0x5
80002124:	2f f8       	sub	r8,-1
80002126:	10 9c       	mov	r12,r8
80002128:	e2 1c 00 20 	andl	r12,0x20,COH
8000212c:	30 09       	mov	r9,0
8000212e:	f0 07 11 ff 	rsub	r7,r8,-1
80002132:	e6 7e a1 20 	mov	lr,500000
80002136:	fc 07 0a 4b 	lsr	r11,lr,r7
8000213a:	ee 77 42 40 	mov	r7,1000000
8000213e:	ee 08 09 4a 	lsl	r10,r7,r8
80002142:	12 3c       	cp.w	r12,r9
80002144:	f4 0b 17 10 	movne	r11,r10
80002148:	f2 0a 17 10 	movne	r10,r9
8000214c:	e0 78 c2 00 	mov	r8,115200
80002150:	30 09       	mov	r9,0
80002152:	e0 66 e1 00 	mov	r6,57600
80002156:	30 07       	mov	r7,0
80002158:	0c 0a       	add	r10,r6
8000215a:	f6 07 00 4b 	adc	r11,r11,r7
8000215e:	f0 1f 00 1d 	mcall	800021d0 <wdt_get_us_timeout_period+0xd8>
80002162:	16 99       	mov	r9,r11
80002164:	14 98       	mov	r8,r10
80002166:	c3 08       	rjmp	800021c6 <wdt_get_us_timeout_period+0xce>
				((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
				1000000 + AVR32_SCIF_RCOSC_FREQUENCY / 2) / AVR32_SCIF_RCOSC_FREQUENCY :
				-1ULL;
	} else {
		// Read CTRL.PSEL and translate it into us.
		return (AVR32_WDT.ctrl & AVR32_WDT_CTRL_EN_MASK) ?
80002168:	fe 78 10 00 	mov	r8,-61440
8000216c:	70 08       	ld.w	r8,r8[0x0]
8000216e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002172:	c0 41       	brne	8000217a <wdt_get_us_timeout_period+0x82>
80002174:	3f f8       	mov	r8,-1
80002176:	3f f9       	mov	r9,-1
80002178:	c2 78       	rjmp	800021c6 <wdt_get_us_timeout_period+0xce>
				((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
8000217a:	fe 78 10 00 	mov	r8,-61440
8000217e:	70 0a       	ld.w	r10,r8[0x0]
				((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
				1000000 + AVR32_SCIF_RCOSC_FREQUENCY / 2) / AVR32_SCIF_RCOSC_FREQUENCY :
				-1ULL;
	} else {
		// Read CTRL.PSEL and translate it into us.
		return (AVR32_WDT.ctrl & AVR32_WDT_CTRL_EN_MASK) ?
80002180:	f5 da c1 05 	bfextu	r10,r10,0x8,0x5
80002184:	2f fa       	sub	r10,-1
80002186:	14 9c       	mov	r12,r10
80002188:	e2 1c 00 20 	andl	r12,0x20,COH
8000218c:	30 0b       	mov	r11,0
8000218e:	f4 0e 11 ff 	rsub	lr,r10,-1
80002192:	e6 77 a1 20 	mov	r7,500000
80002196:	ee 0e 0a 49 	lsr	r9,r7,lr
8000219a:	ee 7e 42 40 	mov	lr,1000000
8000219e:	fc 0a 09 48 	lsl	r8,lr,r10
800021a2:	16 3c       	cp.w	r12,r11
800021a4:	f0 09 17 10 	movne	r9,r8
800021a8:	f6 08 17 10 	movne	r8,r11
800021ac:	e0 6a 40 00 	mov	r10,16384
800021b0:	30 0b       	mov	r11,0
800021b2:	f0 0a 00 0a 	add	r10,r8,r10
800021b6:	f2 0b 00 4b 	adc	r11,r9,r11
800021ba:	f4 08 16 0f 	lsr	r8,r10,0xf
800021be:	f1 eb 11 18 	or	r8,r8,r11<<0x11
800021c2:	f6 09 16 0f 	lsr	r9,r11,0xf
				((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
				1000000 + AVR32_SCIF_OSC32_FREQUENCY / 2) / AVR32_SCIF_OSC32_FREQUENCY :
				-1ULL;
	}
}
800021c6:	12 9b       	mov	r11,r9
800021c8:	10 9a       	mov	r10,r8
800021ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	75 e2       	ld.w	r2,r10[0x78]

800021d4 <wdt_disable>:
				-1ULL;
	}
}

void wdt_disable(void)
{
800021d4:	d4 01       	pushm	lr
	wdt_set_ctrl(AVR32_WDT.ctrl & ~AVR32_WDT_CTRL_EN_MASK);
800021d6:	fe 78 10 00 	mov	r8,-61440
800021da:	70 0c       	ld.w	r12,r8[0x0]
800021dc:	a1 cc       	cbr	r12,0x0
800021de:	f0 1f 00 02 	mcall	800021e4 <wdt_disable+0x10>
}
800021e2:	d8 02       	popm	pc
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	20 e4       	sub	r4,14

800021e8 <wdt_reenable>:
	// Return the actual wdt period in us.
	return wdt_get_us_timeout_period(opt);
}

void wdt_reenable(void)
{
800021e8:	d4 01       	pushm	lr
	wdt_set_ctrl(AVR32_WDT.ctrl | AVR32_WDT_CTRL_EN_MASK | AVR32_WDT_CTRL_CEN_MASK );
800021ea:	fe 78 10 00 	mov	r8,-61440
800021ee:	70 0c       	ld.w	r12,r8[0x0]
800021f0:	ea 1c 00 01 	orh	r12,0x1
800021f4:	e8 1c 00 01 	orl	r12,0x1
800021f8:	f0 1f 00 02 	mcall	80002200 <wdt_reenable+0x18>
}
800021fc:	d8 02       	popm	pc
800021fe:	00 00       	add	r0,r0
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	20 e4       	sub	r4,14

80002204 <wdt_clear>:

void wdt_clear(void)
{
	while (!(AVR32_WDT.sr & AVR32_WDT_SR_CLEARED_MASK));
80002204:	fe 78 10 00 	mov	r8,-61440
80002208:	70 29       	ld.w	r9,r8[0x8]
8000220a:	e2 19 00 02 	andl	r9,0x2,COH
8000220e:	cf d0       	breq	80002208 <wdt_clear+0x4>
	AVR32_WDT.clr = ( (AVR32_WDT_KEY_VALUE << AVR32_WDT_KEY_OFFSET) | AVR32_WDT_CLR_WDTCLR_MASK );
80002210:	fe 78 10 00 	mov	r8,-61440
80002214:	30 19       	mov	r9,1
80002216:	ea 19 55 00 	orh	r9,0x5500
8000221a:	91 19       	st.w	r8[0x4],r9
	AVR32_WDT.clr = ( (~AVR32_WDT_KEY_VALUE << AVR32_WDT_KEY_OFFSET) | AVR32_WDT_CLR_WDTCLR_MASK );
8000221c:	30 19       	mov	r9,1
8000221e:	ea 19 aa 00 	orh	r9,0xaa00
80002222:	91 19       	st.w	r8[0x4],r9
}
80002224:	5e fc       	retal	r12
80002226:	d7 03       	nop

80002228 <wdt_enable>:
{
	wdt_set_ctrl(AVR32_WDT.ctrl & ~AVR32_WDT_CTRL_EN_MASK);
}

uint64_t wdt_enable(wdt_opt_t *opt)
{
80002228:	d4 31       	pushm	r0-r7,lr
8000222a:	18 97       	mov	r7,r12
	// RCOSC
	if (opt->cssel == WDT_CLOCK_SOURCE_SELECT_RCSYS) {
8000222c:	f9 38 00 10 	ld.ub	r8,r12[16]
80002230:	58 08       	cp.w	r8,0
80002232:	e0 81 00 88 	brne	80002342 <wdt_enable+0x11a>
		// Set the CTRL.EN bit
		// Translate the us timeout to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fRCosc
		// Translate the us timeban to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fRCosc
		wdt_set_ctrl(AVR32_WDT_CTRL_EN_MASK | AVR32_WDT_CTRL_CEN_MASK |
				(opt->dar << AVR32_WDT_CTRL_DAR_OFFSET) |
80002236:	f9 35 00 14 	ld.ub	r5,r12[20]
				(opt->mode << AVR32_WDT_CTRL_MODE_OFFSET) |
8000223a:	f9 36 00 13 	ld.ub	r6,r12[19]
				(opt->sfv << AVR32_WDT_CTRL_SFV_OFFSET) |
8000223e:	f9 34 00 12 	ld.ub	r4,r12[18]
				(opt->fcd << AVR32_WDT_CTRL_FCD_OFFSET) |
80002242:	f9 33 00 11 	ld.ub	r3,r12[17]
				(opt->cssel << AVR32_WDT_CTRL_CSSEL_OFFSET) |
				((32 - clz(((((Min(Max(opt->us_timeout_period, MIN_US_TIMEOUT_PERIOD_RCSYS), MAX_US_TIMEOUT_PERIOD_RCSYS) *
80002246:	f8 e8 00 00 	ld.d	r8,r12[0]
8000224a:	e0 6a e3 8d 	mov	r10,58253
8000224e:	ea 1a ae 38 	orh	r10,0xae38
80002252:	30 8b       	mov	r11,8
80002254:	14 38       	cp.w	r8,r10
80002256:	f6 09 13 00 	cpc	r9,r11
8000225a:	e0 88 00 04 	brls	80002262 <wdt_enable+0x3a>
8000225e:	3f f2       	mov	r2,-1
80002260:	c2 58       	rjmp	800022aa <wdt_enable+0x82>
80002262:	59 18       	cp.w	r8,17
80002264:	5c 29       	cpc	r9
80002266:	f9 b8 03 11 	movlo	r8,17
8000226a:	f9 b9 03 00 	movlo	r9,0
8000226e:	e0 7c c2 00 	mov	r12,115200
80002272:	f0 0c 06 4a 	mulu.d	r10,r8,r12
80002276:	f8 09 03 4b 	mac	r11,r12,r9
8000227a:	ee 78 42 40 	mov	r8,1000000
8000227e:	30 09       	mov	r9,0
80002280:	e6 70 a1 20 	mov	r0,500000
80002284:	30 01       	mov	r1,0
80002286:	00 0a       	add	r10,r0
80002288:	f6 01 00 4b 	adc	r11,r11,r1
8000228c:	f0 1f 00 5c 	mcall	800023fc <wdt_enable+0x1d4>
80002290:	14 0a       	add	r10,r10
80002292:	f6 0b 00 4b 	adc	r11,r11,r11
80002296:	3f f8       	mov	r8,-1
80002298:	3f f9       	mov	r9,-1
8000229a:	f4 08 00 08 	add	r8,r10,r8
8000229e:	f6 09 00 49 	adc	r9,r11,r9
800022a2:	f0 02 16 01 	lsr	r2,r8,0x1
800022a6:	e5 e9 11 f2 	or	r2,r2,r9<<0x1f
800022aa:	e4 02 12 00 	clz	r2,r2
				AVR32_SCIF_RCOSC_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_PSEL_OFFSET) |
				((32 - clz(((((Min(Max(opt->us_timeban_period, MIN_US_TIMEBAN_PERIOD_RCSYS), MAX_US_TIMEBAN_PERIOD_RCSYS) *
800022ae:	ee e8 00 08 	ld.d	r8,r7[8]
800022b2:	e0 6a e3 8d 	mov	r10,58253
800022b6:	ea 1a ae 38 	orh	r10,0xae38
800022ba:	30 8b       	mov	r11,8
800022bc:	14 38       	cp.w	r8,r10
800022be:	f6 09 13 00 	cpc	r9,r11
800022c2:	e0 88 00 04 	brls	800022ca <wdt_enable+0xa2>
800022c6:	3f fc       	mov	r12,-1
800022c8:	c2 58       	rjmp	80002312 <wdt_enable+0xea>
800022ca:	59 18       	cp.w	r8,17
800022cc:	5c 29       	cpc	r9
800022ce:	f9 b8 03 11 	movlo	r8,17
800022d2:	f9 b9 03 00 	movlo	r9,0
800022d6:	e0 7c c2 00 	mov	r12,115200
800022da:	f0 0c 06 4a 	mulu.d	r10,r8,r12
800022de:	f8 09 03 4b 	mac	r11,r12,r9
800022e2:	ee 78 42 40 	mov	r8,1000000
800022e6:	30 09       	mov	r9,0
800022e8:	e6 70 a1 20 	mov	r0,500000
800022ec:	30 01       	mov	r1,0
800022ee:	00 0a       	add	r10,r0
800022f0:	f6 01 00 4b 	adc	r11,r11,r1
800022f4:	f0 1f 00 42 	mcall	800023fc <wdt_enable+0x1d4>
800022f8:	14 0a       	add	r10,r10
800022fa:	f6 0b 00 4b 	adc	r11,r11,r11
800022fe:	3f f8       	mov	r8,-1
80002300:	3f f9       	mov	r9,-1
80002302:	f4 08 00 08 	add	r8,r10,r8
80002306:	f6 09 00 49 	adc	r9,r11,r9
8000230a:	f0 0c 16 01 	lsr	r12,r8,0x1
8000230e:	f9 e9 11 fc 	or	r12,r12,r9<<0x1f
80002312:	f8 0c 12 00 	clz	r12,r12
	// RCOSC
	if (opt->cssel == WDT_CLOCK_SOURCE_SELECT_RCSYS) {
		// Set the CTRL.EN bit
		// Translate the us timeout to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fRCosc
		// Translate the us timeban to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fRCosc
		wdt_set_ctrl(AVR32_WDT_CTRL_EN_MASK | AVR32_WDT_CTRL_CEN_MASK |
80002316:	a3 66       	lsl	r6,0x2
80002318:	ed e5 10 15 	or	r5,r6,r5<<0x1
8000231c:	ea 15 00 01 	orh	r5,0x1
80002320:	e8 15 00 01 	orl	r5,0x1
80002324:	eb e4 10 34 	or	r4,r5,r4<<0x3
80002328:	e9 e3 10 73 	or	r3,r4,r3<<0x7
8000232c:	e4 02 11 1f 	rsub	r2,r2,31
80002330:	e7 e2 10 83 	or	r3,r3,r2<<0x8
80002334:	f8 0c 11 1f 	rsub	r12,r12,31
80002338:	e7 ec 11 2c 	or	r12,r3,r12<<0x12
8000233c:	f0 1f 00 31 	mcall	80002400 <wdt_enable+0x1d8>
80002340:	c5 58       	rjmp	800023ea <wdt_enable+0x1c2>
		wdt_set_ctrl(AVR32_WDT_CTRL_EN_MASK | AVR32_WDT_CTRL_CEN_MASK |
				(opt->dar << AVR32_WDT_CTRL_DAR_OFFSET) |
				(opt->mode << AVR32_WDT_CTRL_MODE_OFFSET) |
				(opt->sfv << AVR32_WDT_CTRL_SFV_OFFSET) |
				(opt->fcd << AVR32_WDT_CTRL_FCD_OFFSET) |
				(opt->cssel << AVR32_WDT_CTRL_CSSEL_OFFSET) |
80002342:	f9 39 00 14 	ld.ub	r9,r12[20]
80002346:	f9 36 00 13 	ld.ub	r6,r12[19]
8000234a:	a3 66       	lsl	r6,0x2
8000234c:	ed e9 10 16 	or	r6,r6,r9<<0x1
80002350:	ea 16 00 01 	orh	r6,0x1
80002354:	e8 16 00 01 	orl	r6,0x1
80002358:	f9 39 00 12 	ld.ub	r9,r12[18]
8000235c:	ed e9 10 36 	or	r6,r6,r9<<0x3
80002360:	f9 39 00 11 	ld.ub	r9,r12[17]
80002364:	ed e9 10 76 	or	r6,r6,r9<<0x7
80002368:	ed e8 11 16 	or	r6,r6,r8<<0x11
				((32 - clz(((((Min(Max(opt->us_timeout_period, MIN_US_TIMEOUT_PERIOD_OSC32K), MAX_US_TIMEOUT_PERIOD_OSC32K) *
8000236c:	f8 e8 00 00 	ld.d	r8,r12[0]
80002370:	e0 6a ff ff 	mov	r10,65535
80002374:	ea 1a 84 7f 	orh	r10,0x847f
80002378:	31 eb       	mov	r11,30
8000237a:	14 38       	cp.w	r8,r10
8000237c:	f6 09 13 00 	cpc	r9,r11
80002380:	e0 8b 00 39 	brhi	800023f2 <wdt_enable+0x1ca>
80002384:	e0 48 00 3d 	cp.w	r8,61
80002388:	5c 29       	cpc	r9
8000238a:	f9 b8 03 3d 	movlo	r8,61
8000238e:	f9 b9 03 00 	movlo	r9,0
80002392:	f2 0b 15 0f 	lsl	r11,r9,0xf
80002396:	f7 e8 13 1b 	or	r11,r11,r8>>0x11
8000239a:	f0 0a 15 0f 	lsl	r10,r8,0xf
8000239e:	ee 78 42 40 	mov	r8,1000000
800023a2:	30 09       	mov	r9,0
800023a4:	e6 74 a1 20 	mov	r4,500000
800023a8:	30 05       	mov	r5,0
800023aa:	08 0a       	add	r10,r4
800023ac:	f6 05 00 4b 	adc	r11,r11,r5
800023b0:	f0 1f 00 13 	mcall	800023fc <wdt_enable+0x1d4>
800023b4:	14 0a       	add	r10,r10
800023b6:	f6 0b 00 4b 	adc	r11,r11,r11
800023ba:	3f f8       	mov	r8,-1
800023bc:	3f f9       	mov	r9,-1
800023be:	f4 08 00 08 	add	r8,r10,r8
800023c2:	f6 09 00 49 	adc	r9,r11,r9
800023c6:	f0 0a 16 01 	lsr	r10,r8,0x1
800023ca:	f5 e9 11 f8 	or	r8,r10,r9<<0x1f
800023ce:	f0 09 12 00 	clz	r9,r8
				AVR32_SCIF_OSC32_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_PSEL_OFFSET) |
800023d2:	f2 09 11 1f 	rsub	r9,r9,31
800023d6:	ed e9 10 86 	or	r6,r6,r9<<0x8
				((32 - clz(((((Min(Max(opt->us_timeout_period, MIN_US_TIMEBAN_PERIOD_OSC32K), MAX_US_TIMEBAN_PERIOD_OSC32K) *
800023da:	f0 08 12 00 	clz	r8,r8
				AVR32_SCIF_RCOSC_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_TBAN_OFFSET));
	} else {
		// Set the CTRL.EN bit
		// Translate the us timeout to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fROSC32K
		// Translate the us timeban to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fROSC32K
		wdt_set_ctrl(AVR32_WDT_CTRL_EN_MASK | AVR32_WDT_CTRL_CEN_MASK |
800023de:	f0 0c 11 1f 	rsub	r12,r8,31
800023e2:	ed ec 11 2c 	or	r12,r6,r12<<0x12
800023e6:	f0 1f 00 07 	mcall	80002400 <wdt_enable+0x1d8>
				AVR32_SCIF_OSC32_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_PSEL_OFFSET) |
				((32 - clz(((((Min(Max(opt->us_timeout_period, MIN_US_TIMEBAN_PERIOD_OSC32K), MAX_US_TIMEBAN_PERIOD_OSC32K) *
				AVR32_SCIF_OSC32_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_TBAN_OFFSET));
	}
	// Return the actual wdt period in us.
	return wdt_get_us_timeout_period(opt);
800023ea:	0e 9c       	mov	r12,r7
800023ec:	f0 1f 00 06 	mcall	80002404 <wdt_enable+0x1dc>
}
800023f0:	d8 32       	popm	r0-r7,pc
				(opt->mode << AVR32_WDT_CTRL_MODE_OFFSET) |
				(opt->sfv << AVR32_WDT_CTRL_SFV_OFFSET) |
				(opt->fcd << AVR32_WDT_CTRL_FCD_OFFSET) |
				(opt->cssel << AVR32_WDT_CTRL_CSSEL_OFFSET) |
				((32 - clz(((((Min(Max(opt->us_timeout_period, MIN_US_TIMEOUT_PERIOD_OSC32K), MAX_US_TIMEOUT_PERIOD_OSC32K) *
				AVR32_SCIF_OSC32_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_PSEL_OFFSET) |
800023f2:	e8 16 1f 00 	orl	r6,0x1f00
800023f6:	3f f8       	mov	r8,-1
800023f8:	cf 1b       	rjmp	800023da <wdt_enable+0x1b2>
800023fa:	00 00       	add	r0,r0
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	75 e2       	ld.w	r2,r10[0x78]
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	20 e4       	sub	r4,14
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	20 f8       	sub	r8,15

80002408 <spi_read_packet>:
#endif
}

status_code_t spi_read_packet(volatile avr32_spi_t *spi,
		uint8_t *data, size_t len)
{
80002408:	eb cd 40 80 	pushm	r7,lr
	unsigned int timeout = SPI_TIMEOUT;
	uint8_t val;
	size_t i=0;
	while(len) {
8000240c:	58 0a       	cp.w	r10,0
8000240e:	c0 61       	brne	8000241a <spi_read_packet+0x12>
80002410:	c2 28       	rjmp	80002454 <spi_read_packet+0x4c>
		timeout = SPI_TIMEOUT;
		while (!spi_is_tx_ready(spi)) {
			if (!timeout--) {
80002412:	58 08       	cp.w	r8,0
80002414:	c1 d0       	breq	8000244e <spi_read_packet+0x46>
80002416:	20 18       	sub	r8,1
80002418:	c0 68       	rjmp	80002424 <spi_read_packet+0x1c>
8000241a:	e0 6e 3a 98 	mov	lr,15000
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(volatile avr32_spi_t *spi, uint16_t data)
{
	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000241e:	e0 67 00 ff 	mov	r7,255
80002422:	1c 98       	mov	r8,lr
 *   \retval 1  All transmissions complete.
 *   \retval 0  Transmissions not complete.
 */
static inline bool spi_is_tx_ready(volatile avr32_spi_t *spi)
{
	return (spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0;
80002424:	78 49       	ld.w	r9,r12[0x10]
	unsigned int timeout = SPI_TIMEOUT;
	uint8_t val;
	size_t i=0;
	while(len) {
		timeout = SPI_TIMEOUT;
		while (!spi_is_tx_ready(spi)) {
80002426:	e2 19 00 02 	andl	r9,0x2,COH
8000242a:	cf 40       	breq	80002412 <spi_read_packet+0xa>
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(volatile avr32_spi_t *spi, uint16_t data)
{
	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000242c:	99 37       	st.w	r12[0xc],r7
8000242e:	1c 98       	mov	r8,lr
				return ERR_TIMEOUT;
			}
		}
		spi_write_single(spi,CONFIG_SPI_MASTER_DUMMY);
		timeout = SPI_TIMEOUT;
		while (!spi_is_rx_ready(spi)) {
80002430:	c0 48       	rjmp	80002438 <spi_read_packet+0x30>
			if (!timeout--) {
80002432:	58 08       	cp.w	r8,0
80002434:	c0 d0       	breq	8000244e <spi_read_packet+0x46>
80002436:	20 18       	sub	r8,1
 *
 * \return \c 1 if the SPI Receiver is ready, otherwise \c 0.
 */
static inline bool spi_is_rx_ready(volatile avr32_spi_t *spi)
{
	return (spi->sr &
80002438:	78 49       	ld.w	r9,r12[0x10]
				return ERR_TIMEOUT;
			}
		}
		spi_write_single(spi,CONFIG_SPI_MASTER_DUMMY);
		timeout = SPI_TIMEOUT;
		while (!spi_is_rx_ready(spi)) {
8000243a:	e2 19 02 01 	andl	r9,0x201,COH
8000243e:	e0 49 02 01 	cp.w	r9,513
80002442:	cf 81       	brne	80002432 <spi_read_packet+0x2a>
 * \return The data byte
 *
 */
static inline uint16_t spi_get(volatile avr32_spi_t *spi)
{
	return (spi->rdr >> AVR32_SPI_RDR_RD_OFFSET);
80002444:	78 28       	ld.w	r8,r12[0x8]
			if (!timeout--) {
				return ERR_TIMEOUT;
			}
		}
		spi_read_single(spi,&val);
		data[i] = val;
80002446:	16 c8       	st.b	r11++,r8
		i++;
		len--;
80002448:	20 1a       	sub	r10,1
		uint8_t *data, size_t len)
{
	unsigned int timeout = SPI_TIMEOUT;
	uint8_t val;
	size_t i=0;
	while(len) {
8000244a:	ce c1       	brne	80002422 <spi_read_packet+0x1a>
8000244c:	c0 48       	rjmp	80002454 <spi_read_packet+0x4c>
8000244e:	3f dc       	mov	r12,-3
80002450:	e3 cd 80 80 	ldm	sp++,r7,pc
80002454:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

80002458 <spi_write_packet>:
	return STATUS_OK;
}

status_code_t spi_write_packet(volatile avr32_spi_t *spi, const uint8_t *data,
		size_t len)
{
80002458:	d4 01       	pushm	lr
	unsigned int timeout = SPI_TIMEOUT;
	size_t i=0;
	uint8_t val;
	while(len) {
8000245a:	58 0a       	cp.w	r10,0
8000245c:	c0 81       	brne	8000246c <spi_write_packet+0x14>
8000245e:	c1 28       	rjmp	80002482 <spi_write_packet+0x2a>
		timeout = SPI_TIMEOUT;
		while (!spi_is_tx_ready(spi)) {
			if (!timeout--) {
80002460:	58 08       	cp.w	r8,0
80002462:	c0 31       	brne	80002468 <spi_write_packet+0x10>
80002464:	3f dc       	mov	r12,-3
80002466:	d8 02       	popm	pc
80002468:	20 18       	sub	r8,1
8000246a:	c0 48       	rjmp	80002472 <spi_write_packet+0x1a>
8000246c:	e0 6e 3a 98 	mov	lr,15000
80002470:	1c 98       	mov	r8,lr
 *   \retval 1  All transmissions complete.
 *   \retval 0  Transmissions not complete.
 */
static inline bool spi_is_tx_ready(volatile avr32_spi_t *spi)
{
	return (spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0;
80002472:	78 49       	ld.w	r9,r12[0x10]
	unsigned int timeout = SPI_TIMEOUT;
	size_t i=0;
	uint8_t val;
	while(len) {
		timeout = SPI_TIMEOUT;
		while (!spi_is_tx_ready(spi)) {
80002474:	e2 19 00 02 	andl	r9,0x2,COH
80002478:	cf 40       	breq	80002460 <spi_write_packet+0x8>
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(volatile avr32_spi_t *spi, uint16_t data)
{
	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000247a:	17 38       	ld.ub	r8,r11++
8000247c:	99 38       	st.w	r12[0xc],r8
			}
		}
		val = data[i];
		spi_write_single(spi,val);
		i++;
		len--;
8000247e:	20 1a       	sub	r10,1
		size_t len)
{
	unsigned int timeout = SPI_TIMEOUT;
	size_t i=0;
	uint8_t val;
	while(len) {
80002480:	cf 81       	brne	80002470 <spi_write_packet+0x18>
80002482:	d8 0a       	popm	pc,r12=0

80002484 <spi_master_setup_device>:
#endif

void spi_master_setup_device(volatile avr32_spi_t *spi,
		struct spi_device *device, spi_flags_t flags, uint32_t baud_rate,
		board_spi_select_id_t sel_id)
{
80002484:	eb cd 40 e0 	pushm	r5-r7,lr
80002488:	18 97       	mov	r7,r12
8000248a:	16 96       	mov	r6,r11
8000248c:	14 95       	mov	r5,r10
static inline void spi_set_chipselect_delay_bct(volatile avr32_spi_t *spi,
		uint8_t chip_select, uint8_t delay)
{
	Assert(chip_select <= 3);

	switch (chip_select) {
8000248e:	17 88       	ld.ub	r8,r11[0x0]
80002490:	30 1a       	mov	r10,1
80002492:	f4 08 18 00 	cp.b	r8,r10
80002496:	c1 10       	breq	800024b8 <spi_master_setup_device+0x34>
80002498:	c0 a3       	brcs	800024ac <spi_master_setup_device+0x28>
8000249a:	30 2a       	mov	r10,2
8000249c:	f4 08 18 00 	cp.b	r8,r10
800024a0:	c1 20       	breq	800024c4 <spi_master_setup_device+0x40>
800024a2:	30 3a       	mov	r10,3
800024a4:	f4 08 18 00 	cp.b	r8,r10
800024a8:	c1 91       	brne	800024da <spi_master_setup_device+0x56>
800024aa:	c1 38       	rjmp	800024d0 <spi_master_setup_device+0x4c>
	case 0:
		spi->CSR0.dlybct = delay;
800024ac:	78 c8       	ld.w	r8,r12[0x30]
800024ae:	30 0a       	mov	r10,0
800024b0:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
800024b4:	99 c8       	st.w	r12[0x30],r8
800024b6:	c1 28       	rjmp	800024da <spi_master_setup_device+0x56>
		break;

	case 1:
		spi->CSR1.dlybct  = delay;
800024b8:	78 d8       	ld.w	r8,r12[0x34]
800024ba:	30 0a       	mov	r10,0
800024bc:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
800024c0:	99 d8       	st.w	r12[0x34],r8
800024c2:	c0 c8       	rjmp	800024da <spi_master_setup_device+0x56>
		break;

	case 2:
		spi->CSR2.dlybct  = delay;
800024c4:	78 e8       	ld.w	r8,r12[0x38]
800024c6:	30 0a       	mov	r10,0
800024c8:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
800024cc:	99 e8       	st.w	r12[0x38],r8
800024ce:	c0 68       	rjmp	800024da <spi_master_setup_device+0x56>
		break;

	case 3:
		spi->CSR3.dlybct  = delay;
800024d0:	78 f8       	ld.w	r8,r12[0x3c]
800024d2:	30 0a       	mov	r10,0
800024d4:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
800024d8:	99 f8       	st.w	r12[0x3c],r8
static inline void spi_set_chipselect_delay_bs(volatile avr32_spi_t *spi,
		uint8_t chip_select, uint8_t delay)
{
	Assert(chip_select <= 3);

	switch (chip_select) {
800024da:	0d 88       	ld.ub	r8,r6[0x0]
800024dc:	30 1a       	mov	r10,1
800024de:	f4 08 18 00 	cp.b	r8,r10
800024e2:	c1 10       	breq	80002504 <spi_master_setup_device+0x80>
800024e4:	c0 a3       	brcs	800024f8 <spi_master_setup_device+0x74>
800024e6:	30 2a       	mov	r10,2
800024e8:	f4 08 18 00 	cp.b	r8,r10
800024ec:	c1 20       	breq	80002510 <spi_master_setup_device+0x8c>
800024ee:	30 3a       	mov	r10,3
800024f0:	f4 08 18 00 	cp.b	r8,r10
800024f4:	c1 91       	brne	80002526 <spi_master_setup_device+0xa2>
800024f6:	c1 38       	rjmp	8000251c <spi_master_setup_device+0x98>
	case 0:
		spi->CSR0.dlybs = delay;
800024f8:	6e c8       	ld.w	r8,r7[0x30]
800024fa:	30 0a       	mov	r10,0
800024fc:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
80002500:	8f c8       	st.w	r7[0x30],r8
80002502:	c1 28       	rjmp	80002526 <spi_master_setup_device+0xa2>
		break;

	case 1:
		spi->CSR1.dlybs  = delay;
80002504:	6e d8       	ld.w	r8,r7[0x34]
80002506:	30 0a       	mov	r10,0
80002508:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
8000250c:	8f d8       	st.w	r7[0x34],r8
8000250e:	c0 c8       	rjmp	80002526 <spi_master_setup_device+0xa2>
		break;

	case 2:
		spi->CSR2.dlybs  = delay;
80002510:	6e e8       	ld.w	r8,r7[0x38]
80002512:	30 0a       	mov	r10,0
80002514:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
80002518:	8f e8       	st.w	r7[0x38],r8
8000251a:	c0 68       	rjmp	80002526 <spi_master_setup_device+0xa2>
		break;

	case 3:
		spi->CSR3.dlybs  = delay;
8000251c:	6e f8       	ld.w	r8,r7[0x3c]
8000251e:	30 0a       	mov	r10,0
80002520:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
80002524:	8f f8       	st.w	r7[0x3c],r8
		uint8_t chip_select,
		uint8_t len)
{
	Assert((len >= 8) && (len <= 16));

	switch (chip_select) {
80002526:	0d 88       	ld.ub	r8,r6[0x0]
80002528:	30 1a       	mov	r10,1
8000252a:	f4 08 18 00 	cp.b	r8,r10
8000252e:	c1 10       	breq	80002550 <spi_master_setup_device+0xcc>
80002530:	c0 a3       	brcs	80002544 <spi_master_setup_device+0xc0>
80002532:	30 2a       	mov	r10,2
80002534:	f4 08 18 00 	cp.b	r8,r10
80002538:	c1 20       	breq	8000255c <spi_master_setup_device+0xd8>
8000253a:	30 3a       	mov	r10,3
8000253c:	f4 08 18 00 	cp.b	r8,r10
80002540:	c1 91       	brne	80002572 <spi_master_setup_device+0xee>
80002542:	c1 38       	rjmp	80002568 <spi_master_setup_device+0xe4>
	case 0:
		spi->CSR0.bits = len - 8;
80002544:	6e c8       	ld.w	r8,r7[0x30]
80002546:	30 0a       	mov	r10,0
80002548:	f1 da d0 84 	bfins	r8,r10,0x4,0x4
8000254c:	8f c8       	st.w	r7[0x30],r8
8000254e:	c1 28       	rjmp	80002572 <spi_master_setup_device+0xee>
		break;

	case 1:
		spi->CSR1.bits  = len - 8;
80002550:	6e d8       	ld.w	r8,r7[0x34]
80002552:	30 0a       	mov	r10,0
80002554:	f1 da d0 84 	bfins	r8,r10,0x4,0x4
80002558:	8f d8       	st.w	r7[0x34],r8
8000255a:	c0 c8       	rjmp	80002572 <spi_master_setup_device+0xee>
		break;

	case 2:
		spi->CSR2.bits  = len - 8;
8000255c:	6e e8       	ld.w	r8,r7[0x38]
8000255e:	30 0a       	mov	r10,0
80002560:	f1 da d0 84 	bfins	r8,r10,0x4,0x4
80002564:	8f e8       	st.w	r7[0x38],r8
80002566:	c0 68       	rjmp	80002572 <spi_master_setup_device+0xee>
		break;

	case 3:
		spi->CSR3.bits  = len - 8;
80002568:	6e f8       	ld.w	r8,r7[0x3c]
8000256a:	30 0a       	mov	r10,0
8000256c:	f1 da d0 84 	bfins	r8,r10,0x4,0x4
80002570:	8f f8       	st.w	r7[0x3c],r8
 * \return Frequency of the bus attached to the specified peripheral, in Hz.
 */
static inline uint32_t sysclk_get_peripheral_bus_hz(const volatile void *module)
{
	/* Fallthroughs intended for modules sharing the same peripheral bus. */
	switch ((uintptr_t)module) {
80002572:	fe 57 10 00 	cp.w	r7,-61440
80002576:	e0 80 00 87 	breq	80002684 <spi_master_setup_device+0x200>
8000257a:	e0 8b 00 41 	brhi	800025fc <spi_master_setup_device+0x178>
8000257e:	fe 47 00 00 	cp.w	r7,-131072
80002582:	e0 80 00 86 	breq	8000268e <spi_master_setup_device+0x20a>
80002586:	e0 8b 00 1c 	brhi	800025be <spi_master_setup_device+0x13a>
8000258a:	fc 57 18 00 	cp.w	r7,-190464
8000258e:	e0 80 00 85 	breq	80002698 <spi_master_setup_device+0x214>
80002592:	e0 8b 00 0c 	brhi	800025aa <spi_master_setup_device+0x126>
80002596:	fc 57 10 00 	cp.w	r7,-192512
8000259a:	c7 f0       	breq	80002698 <spi_master_setup_device+0x214>
8000259c:	fc 57 14 00 	cp.w	r7,-191488
800025a0:	c7 c0       	breq	80002698 <spi_master_setup_device+0x214>
800025a2:	fc 57 00 00 	cp.w	r7,-196608
800025a6:	c6 d1       	brne	80002680 <spi_master_setup_device+0x1fc>
800025a8:	c7 88       	rjmp	80002698 <spi_master_setup_device+0x214>
800025aa:	fc 57 20 00 	cp.w	r7,-188416
800025ae:	c7 50       	breq	80002698 <spi_master_setup_device+0x214>
800025b0:	fc 57 24 00 	cp.w	r7,-187392
800025b4:	c7 20       	breq	80002698 <spi_master_setup_device+0x214>
800025b6:	fc 57 1c 00 	cp.w	r7,-189440
800025ba:	c6 31       	brne	80002680 <spi_master_setup_device+0x1fc>
800025bc:	c6 e8       	rjmp	80002698 <spi_master_setup_device+0x214>
800025be:	fe 47 30 00 	cp.w	r7,-118784
800025c2:	c6 60       	breq	8000268e <spi_master_setup_device+0x20a>
800025c4:	e0 8b 00 0c 	brhi	800025dc <spi_master_setup_device+0x158>
800025c8:	fe 47 20 00 	cp.w	r7,-122880
800025cc:	c6 10       	breq	8000268e <spi_master_setup_device+0x20a>
800025ce:	fe 47 24 00 	cp.w	r7,-121856
800025d2:	c5 e0       	breq	8000268e <spi_master_setup_device+0x20a>
800025d4:	fe 47 10 00 	cp.w	r7,-126976
800025d8:	c5 41       	brne	80002680 <spi_master_setup_device+0x1fc>
800025da:	c5 a8       	rjmp	8000268e <spi_master_setup_device+0x20a>
800025dc:	fe 57 04 00 	cp.w	r7,-64512
800025e0:	c5 20       	breq	80002684 <spi_master_setup_device+0x200>
800025e2:	e0 8b 00 06 	brhi	800025ee <spi_master_setup_device+0x16a>
800025e6:	fe 57 00 00 	cp.w	r7,-65536
800025ea:	c4 b1       	brne	80002680 <spi_master_setup_device+0x1fc>
800025ec:	c4 c8       	rjmp	80002684 <spi_master_setup_device+0x200>
800025ee:	fe 57 08 00 	cp.w	r7,-63488
800025f2:	c4 90       	breq	80002684 <spi_master_setup_device+0x200>
800025f4:	fe 57 0c 00 	cp.w	r7,-62464
800025f8:	c4 41       	brne	80002680 <spi_master_setup_device+0x1fc>
800025fa:	c4 58       	rjmp	80002684 <spi_master_setup_device+0x200>
800025fc:	fe 57 40 00 	cp.w	r7,-49152
80002600:	c4 20       	breq	80002684 <spi_master_setup_device+0x200>
80002602:	e0 8b 00 21 	brhi	80002644 <spi_master_setup_device+0x1c0>
80002606:	fe 57 28 00 	cp.w	r7,-55296
8000260a:	c3 d0       	breq	80002684 <spi_master_setup_device+0x200>
8000260c:	e0 8b 00 0c 	brhi	80002624 <spi_master_setup_device+0x1a0>
80002610:	fe 57 18 00 	cp.w	r7,-59392
80002614:	c3 80       	breq	80002684 <spi_master_setup_device+0x200>
80002616:	fe 57 20 00 	cp.w	r7,-57344
8000261a:	c3 50       	breq	80002684 <spi_master_setup_device+0x200>
8000261c:	fe 57 14 00 	cp.w	r7,-60416
80002620:	c3 01       	brne	80002680 <spi_master_setup_device+0x1fc>
80002622:	c3 18       	rjmp	80002684 <spi_master_setup_device+0x200>
80002624:	fe 57 30 00 	cp.w	r7,-53248
80002628:	c2 e0       	breq	80002684 <spi_master_setup_device+0x200>
8000262a:	e0 8b 00 06 	brhi	80002636 <spi_master_setup_device+0x1b2>
8000262e:	fe 57 2c 00 	cp.w	r7,-54272
80002632:	c2 71       	brne	80002680 <spi_master_setup_device+0x1fc>
80002634:	c2 88       	rjmp	80002684 <spi_master_setup_device+0x200>
80002636:	fe 57 38 00 	cp.w	r7,-51200
8000263a:	c2 50       	breq	80002684 <spi_master_setup_device+0x200>
8000263c:	fe 57 3c 00 	cp.w	r7,-50176
80002640:	c2 01       	brne	80002680 <spi_master_setup_device+0x1fc>
80002642:	c2 18       	rjmp	80002684 <spi_master_setup_device+0x200>
80002644:	fe 57 50 00 	cp.w	r7,-45056
80002648:	c1 e0       	breq	80002684 <spi_master_setup_device+0x200>
8000264a:	e0 8b 00 0c 	brhi	80002662 <spi_master_setup_device+0x1de>
8000264e:	fe 57 48 00 	cp.w	r7,-47104
80002652:	c1 90       	breq	80002684 <spi_master_setup_device+0x200>
80002654:	fe 57 4c 00 	cp.w	r7,-46080
80002658:	c1 60       	breq	80002684 <spi_master_setup_device+0x200>
8000265a:	fe 57 44 00 	cp.w	r7,-48128
8000265e:	c1 11       	brne	80002680 <spi_master_setup_device+0x1fc>
80002660:	c1 28       	rjmp	80002684 <spi_master_setup_device+0x200>
80002662:	fe 57 60 00 	cp.w	r7,-40960
80002666:	c0 f0       	breq	80002684 <spi_master_setup_device+0x200>
80002668:	e0 8b 00 06 	brhi	80002674 <spi_master_setup_device+0x1f0>
8000266c:	fe 57 5c 00 	cp.w	r7,-41984
80002670:	c0 81       	brne	80002680 <spi_master_setup_device+0x1fc>
80002672:	c0 98       	rjmp	80002684 <spi_master_setup_device+0x200>
80002674:	fe 57 68 00 	cp.w	r7,-38912
80002678:	c0 60       	breq	80002684 <spi_master_setup_device+0x200>
8000267a:	fe 57 70 00 	cp.w	r7,-36864
8000267e:	c0 30       	breq	80002684 <spi_master_setup_device+0x200>
80002680:	30 0b       	mov	r11,0
80002682:	c0 f8       	rjmp	800026a0 <spi_master_setup_device+0x21c>
 *
 * \return Frequency of the Peripheral Bus A clock, in Hz.
 */
static inline uint32_t sysclk_get_pba_hz(void)
{
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_PBA_DIV;
80002684:	e0 6b 36 00 	mov	r11,13824
80002688:	ea 1b 01 6e 	orh	r11,0x16e
8000268c:	c0 a8       	rjmp	800026a0 <spi_master_setup_device+0x21c>
 *
 * \return Frequency of the Peripheral Bus B clock, in Hz.
 */
static inline uint32_t sysclk_get_pbb_hz(void)
{
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_PBB_DIV;
8000268e:	e0 6b 36 00 	mov	r11,13824
80002692:	ea 1b 01 6e 	orh	r11,0x16e
80002696:	c0 58       	rjmp	800026a0 <spi_master_setup_device+0x21c>
 *
 * \return Frequency of the Peripheral Bus C clock, in Hz.
 */
static inline uint32_t sysclk_get_pbc_hz(void)
{
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_PBC_DIV;
80002698:	e0 6b 36 00 	mov	r11,13824
8000269c:	ea 1b 01 6e 	orh	r11,0x16e
	spi_set_chipselect_delay_bct(spi,device->id,CONFIG_SPI_MASTER_DELAY_BCT);
	spi_set_chipselect_delay_bs(spi,device->id,CONFIG_SPI_MASTER_DELAY_BS);
	spi_set_bits_per_transfer(spi,device->id,
			CONFIG_SPI_MASTER_BITS_PER_TRANSFER);
	spi_set_baudrate_register(spi,device->id,
			getBaudDiv(baud_rate, sysclk_get_peripheral_bus_hz(spi)));
800026a0:	12 9c       	mov	r12,r9
800026a2:	f0 1f 00 54 	mcall	800027f0 <spi_master_setup_device+0x36c>
{
	spi_set_chipselect_delay_bct(spi,device->id,CONFIG_SPI_MASTER_DELAY_BCT);
	spi_set_chipselect_delay_bs(spi,device->id,CONFIG_SPI_MASTER_DELAY_BS);
	spi_set_bits_per_transfer(spi,device->id,
			CONFIG_SPI_MASTER_BITS_PER_TRANSFER);
	spi_set_baudrate_register(spi,device->id,
800026a6:	5c 5c       	castu.b	r12
 */
static inline void spi_set_baudrate_register(volatile avr32_spi_t *spi,
		uint8_t chip_select,
		uint8_t scbr)
{
	switch (chip_select) {
800026a8:	0d 88       	ld.ub	r8,r6[0x0]
800026aa:	30 19       	mov	r9,1
800026ac:	f2 08 18 00 	cp.b	r8,r9
800026b0:	c1 00       	breq	800026d0 <spi_master_setup_device+0x24c>
800026b2:	c0 a3       	brcs	800026c6 <spi_master_setup_device+0x242>
800026b4:	30 29       	mov	r9,2
800026b6:	f2 08 18 00 	cp.b	r8,r9
800026ba:	c1 00       	breq	800026da <spi_master_setup_device+0x256>
800026bc:	30 39       	mov	r9,3
800026be:	f2 08 18 00 	cp.b	r8,r9
800026c2:	c1 51       	brne	800026ec <spi_master_setup_device+0x268>
800026c4:	c1 08       	rjmp	800026e4 <spi_master_setup_device+0x260>
	case 0:
		spi->CSR0.scbr = scbr;
800026c6:	6e c8       	ld.w	r8,r7[0x30]
800026c8:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
800026cc:	8f c8       	st.w	r7[0x30],r8
800026ce:	c0 f8       	rjmp	800026ec <spi_master_setup_device+0x268>
		break;

	case 1:
		spi->CSR1.scbr  = scbr;
800026d0:	6e d8       	ld.w	r8,r7[0x34]
800026d2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
800026d6:	8f d8       	st.w	r7[0x34],r8
800026d8:	c0 a8       	rjmp	800026ec <spi_master_setup_device+0x268>
		break;

	case 2:
		spi->CSR2.scbr  = scbr;
800026da:	6e e8       	ld.w	r8,r7[0x38]
800026dc:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
800026e0:	8f e8       	st.w	r7[0x38],r8
800026e2:	c0 58       	rjmp	800026ec <spi_master_setup_device+0x268>
		break;

	case 3:
		spi->CSR3.scbr  = scbr;
800026e4:	6e f8       	ld.w	r8,r7[0x3c]
800026e6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
800026ea:	8f f8       	st.w	r7[0x3c],r8
 * \param chip_select Chip Select.
 */
static inline void spi_enable_active_mode(volatile avr32_spi_t *spi,
		uint8_t chip_select)
{
	switch (chip_select) {
800026ec:	0d 88       	ld.ub	r8,r6[0x0]
800026ee:	30 19       	mov	r9,1
800026f0:	f2 08 18 00 	cp.b	r8,r9
800026f4:	c1 10       	breq	80002716 <spi_master_setup_device+0x292>
800026f6:	c0 a3       	brcs	8000270a <spi_master_setup_device+0x286>
800026f8:	30 29       	mov	r9,2
800026fa:	f2 08 18 00 	cp.b	r8,r9
800026fe:	c1 20       	breq	80002722 <spi_master_setup_device+0x29e>
80002700:	30 39       	mov	r9,3
80002702:	f2 08 18 00 	cp.b	r8,r9
80002706:	c1 91       	brne	80002738 <spi_master_setup_device+0x2b4>
80002708:	c1 38       	rjmp	8000272e <spi_master_setup_device+0x2aa>
	case 0:
		spi->CSR0.csaat = 1;
8000270a:	6e c8       	ld.w	r8,r7[0x30]
8000270c:	30 19       	mov	r9,1
8000270e:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
80002712:	8f c8       	st.w	r7[0x30],r8
80002714:	c1 28       	rjmp	80002738 <spi_master_setup_device+0x2b4>
		break;

	case 1:
		spi->CSR1.csaat  = 1;
80002716:	6e d8       	ld.w	r8,r7[0x34]
80002718:	30 19       	mov	r9,1
8000271a:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
8000271e:	8f d8       	st.w	r7[0x34],r8
80002720:	c0 c8       	rjmp	80002738 <spi_master_setup_device+0x2b4>
		break;

	case 2:
		spi->CSR2.csaat  = 1;
80002722:	6e e8       	ld.w	r8,r7[0x38]
80002724:	30 19       	mov	r9,1
80002726:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
8000272a:	8f e8       	st.w	r7[0x38],r8
8000272c:	c0 68       	rjmp	80002738 <spi_master_setup_device+0x2b4>
		break;

	case 3:
		spi->CSR3.csaat  = 1;
8000272e:	6e f8       	ld.w	r8,r7[0x3c]
80002730:	30 19       	mov	r9,1
80002732:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
80002736:	8f f8       	st.w	r7[0x3c],r8
			getBaudDiv(baud_rate, sysclk_get_peripheral_bus_hz(spi)));
	spi_enable_active_mode(spi,device->id);
	spi_set_mode(spi,device->id,flags);
80002738:	0a 99       	mov	r9,r5
 * \param flags       SPI Mode.
 */
static inline void spi_set_mode(volatile avr32_spi_t *spi, uint8_t chip_select,
		uint8_t flags)
{
	switch (chip_select) {
8000273a:	0d 88       	ld.ub	r8,r6[0x0]
8000273c:	30 1a       	mov	r10,1
8000273e:	f4 08 18 00 	cp.b	r8,r10
80002742:	c1 80       	breq	80002772 <spi_master_setup_device+0x2ee>
80002744:	c0 a3       	brcs	80002758 <spi_master_setup_device+0x2d4>
80002746:	30 2a       	mov	r10,2
80002748:	f4 08 18 00 	cp.b	r8,r10
8000274c:	c2 00       	breq	8000278c <spi_master_setup_device+0x308>
8000274e:	30 3a       	mov	r10,3
80002750:	f4 08 18 00 	cp.b	r8,r10
80002754:	c3 51       	brne	800027be <spi_master_setup_device+0x33a>
80002756:	c2 88       	rjmp	800027a6 <spi_master_setup_device+0x322>
	case 0:
		spi->CSR0.cpol = flags >> 1;
80002758:	eb d5 c0 21 	bfextu	r5,r5,0x1,0x1
8000275c:	6e c8       	ld.w	r8,r7[0x30]
8000275e:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
80002762:	8f c8       	st.w	r7[0x30],r8
		spi->CSR0.ncpha = (flags & 0x1) ^ 0x1;
80002764:	ec 19 00 01 	eorl	r9,0x1
80002768:	6e c8       	ld.w	r8,r7[0x30]
8000276a:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
8000276e:	8f c8       	st.w	r7[0x30],r8
80002770:	c2 78       	rjmp	800027be <spi_master_setup_device+0x33a>
		break;

	case 1:
		spi->CSR1.cpol  = flags >> 1;
80002772:	eb d5 c0 21 	bfextu	r5,r5,0x1,0x1
80002776:	6e d8       	ld.w	r8,r7[0x34]
80002778:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
8000277c:	8f d8       	st.w	r7[0x34],r8
		spi->CSR1.ncpha = (flags & 0x1) ^ 0x1;
8000277e:	ec 19 00 01 	eorl	r9,0x1
80002782:	6e d8       	ld.w	r8,r7[0x34]
80002784:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80002788:	8f d8       	st.w	r7[0x34],r8
8000278a:	c1 a8       	rjmp	800027be <spi_master_setup_device+0x33a>
		break;

	case 2:
		spi->CSR2.cpol  = flags >> 1;
8000278c:	eb d5 c0 21 	bfextu	r5,r5,0x1,0x1
80002790:	6e e8       	ld.w	r8,r7[0x38]
80002792:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
80002796:	8f e8       	st.w	r7[0x38],r8
		spi->CSR2.ncpha = (flags & 0x1) ^ 0x1;
80002798:	ec 19 00 01 	eorl	r9,0x1
8000279c:	6e e8       	ld.w	r8,r7[0x38]
8000279e:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800027a2:	8f e8       	st.w	r7[0x38],r8
800027a4:	c0 d8       	rjmp	800027be <spi_master_setup_device+0x33a>
		break;

	case 3:
		spi->CSR3.cpol  = flags >> 1;
800027a6:	eb d5 c0 21 	bfextu	r5,r5,0x1,0x1
800027aa:	6e f8       	ld.w	r8,r7[0x3c]
800027ac:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
800027b0:	8f f8       	st.w	r7[0x3c],r8
		spi->CSR3.ncpha = (flags & 0x1) ^ 0x1;
800027b2:	ec 19 00 01 	eorl	r9,0x1
800027b6:	6e f8       	ld.w	r8,r7[0x3c]
800027b8:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800027bc:	8f f8       	st.w	r7[0x3c],r8

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800027be:	48 e8       	lddpc	r8,800027f4 <spi_master_setup_device+0x370>
800027c0:	70 08       	ld.w	r8,r8[0x0]
800027c2:	58 08       	cp.w	r8,0
800027c4:	c1 41       	brne	800027ec <spi_master_setup_device+0x368>
		// Create the SPI mutex.
		vSemaphoreCreateBinary(xSPIMutex);
800027c6:	30 0a       	mov	r10,0
800027c8:	14 9b       	mov	r11,r10
800027ca:	30 1c       	mov	r12,1
800027cc:	f0 1f 00 0b 	mcall	800027f8 <spi_master_setup_device+0x374>
800027d0:	48 98       	lddpc	r8,800027f4 <spi_master_setup_device+0x370>
800027d2:	91 0c       	st.w	r8[0x0],r12
800027d4:	58 0c       	cp.w	r12,0
800027d6:	c0 a0       	breq	800027ea <spi_master_setup_device+0x366>
800027d8:	30 09       	mov	r9,0
800027da:	12 9a       	mov	r10,r9
800027dc:	12 9b       	mov	r11,r9
800027de:	f0 1f 00 08 	mcall	800027fc <spi_master_setup_device+0x378>
		if (!xSPIMutex) {
800027e2:	48 58       	lddpc	r8,800027f4 <spi_master_setup_device+0x370>
800027e4:	70 08       	ld.w	r8,r8[0x0]
800027e6:	58 08       	cp.w	r8,0
800027e8:	c0 21       	brne	800027ec <spi_master_setup_device+0x368>
800027ea:	c0 08       	rjmp	800027ea <spi_master_setup_device+0x366>
800027ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	20 04       	sub	r4,0
800027f4:	00 00       	add	r0,r0
800027f6:	cf 34       	brge	800027dc <spi_master_setup_device+0x358>
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	30 44       	mov	r4,4
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	2e c8       	sub	r8,-20

80002800 <ecu_can_send_slip_current>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_slip_current(uint16_t slip, uint16_t current) {
80002800:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_slip_current.can_msg->data.u64		= 0x0LL;
80002804:	48 de       	lddpc	lr,80002838 <ecu_can_send_slip_current+0x38>
80002806:	7c 18       	ld.w	r8,lr[0x4]
80002808:	30 06       	mov	r6,0
8000280a:	30 07       	mov	r7,0
8000280c:	f0 e7 00 08 	st.d	r8[8],r6
	mob_slip_current.can_msg->data.u16[0]	= slip;
80002810:	7c 18       	ld.w	r8,lr[0x4]
80002812:	b0 4c       	st.h	r8[0x8],r12
	mob_slip_current.can_msg->data.u16[1]	= current;
80002814:	7c 18       	ld.w	r8,lr[0x4]
80002816:	b0 5b       	st.h	r8[0xa],r11
	
	mob_slip_current.can_msg->id = (CANR_FCN_DATA_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID7_ID);
80002818:	7c 18       	ld.w	r8,lr[0x4]
8000281a:	e0 69 06 37 	mov	r9,1591
8000281e:	91 09       	st.w	r8[0x0],r9
	mob_slip_current.dlc = 4;
80002820:	30 48       	mov	r8,4
80002822:	fd 68 00 08 	st.b	lr[8],r8
	
	can_tx(CAN_BUS_0,
80002826:	7c 18       	ld.w	r8,lr[0x4]
80002828:	30 09       	mov	r9,0
8000282a:	30 4a       	mov	r10,4
8000282c:	1d 8b       	ld.ub	r11,lr[0x0]
8000282e:	12 9c       	mov	r12,r9
80002830:	f0 1f 00 03 	mcall	8000283c <ecu_can_send_slip_current+0x3c>
	mob_slip_current.handle,
	mob_slip_current.dlc,
	CAN_DATA_FRAME,
	mob_slip_current.can_msg);
}
80002834:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002838:	00 00       	add	r0,r0
8000283a:	00 e8       	st.h	--r0,r8
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	49 88       	lddpc	r8,8000289c <ecu_can_send_launch_ready+0x1c>

80002840 <ecu_can_send_launch_stop>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_launch_stop(void) {
80002840:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	= 0x0LL;
80002844:	48 db       	lddpc	r11,80002878 <ecu_can_send_launch_stop+0x38>
80002846:	76 18       	ld.w	r8,r11[0x4]
80002848:	30 06       	mov	r6,0
8000284a:	30 07       	mov	r7,0
8000284c:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u8[0]	= 0x255	;
80002850:	76 18       	ld.w	r8,r11[0x4]
80002852:	35 59       	mov	r9,85
80002854:	f1 69 00 08 	st.b	r8[8],r9
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID1_ID;
80002858:	76 18       	ld.w	r8,r11[0x4]
8000285a:	e0 69 02 31 	mov	r9,561
8000285e:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 1;
80002860:	30 18       	mov	r8,1
80002862:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
80002866:	76 18       	ld.w	r8,r11[0x4]
80002868:	30 09       	mov	r9,0
8000286a:	30 1a       	mov	r10,1
8000286c:	17 8b       	ld.ub	r11,r11[0x0]
8000286e:	12 9c       	mov	r12,r9
80002870:	f0 1f 00 03 	mcall	8000287c <ecu_can_send_launch_stop+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
80002874:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002878:	00 00       	add	r0,r0
8000287a:	00 a0       	st.w	r0++,r0
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	49 88       	lddpc	r8,800028dc <ecu_can_confirm_activate_launch+0x1c>

80002880 <ecu_can_send_launch_ready>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_launch_ready(void) {
80002880:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	= 0x0LL;
80002884:	48 db       	lddpc	r11,800028b8 <ecu_can_send_launch_ready+0x38>
80002886:	76 18       	ld.w	r8,r11[0x4]
80002888:	30 06       	mov	r6,0
8000288a:	30 07       	mov	r7,0
8000288c:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u8[0]	= 0x2;
80002890:	76 18       	ld.w	r8,r11[0x4]
80002892:	30 29       	mov	r9,2
80002894:	f1 69 00 08 	st.b	r8[8],r9
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID1_ID;
80002898:	76 18       	ld.w	r8,r11[0x4]
8000289a:	e0 69 02 31 	mov	r9,561
8000289e:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 1;
800028a0:	30 18       	mov	r8,1
800028a2:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
800028a6:	76 18       	ld.w	r8,r11[0x4]
800028a8:	30 09       	mov	r9,0
800028aa:	30 1a       	mov	r10,1
800028ac:	17 8b       	ld.ub	r11,r11[0x0]
800028ae:	12 9c       	mov	r12,r9
800028b0:	f0 1f 00 03 	mcall	800028bc <ecu_can_send_launch_ready+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
800028b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800028b8:	00 00       	add	r0,r0
800028ba:	00 a0       	st.w	r0++,r0
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	49 88       	lddpc	r8,8000291c <ecu_can_send_alive+0x1c>

800028c0 <ecu_can_confirm_activate_launch>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_confirm_activate_launch(void) {
800028c0:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	= 0x0LL;
800028c4:	48 db       	lddpc	r11,800028f8 <ecu_can_confirm_activate_launch+0x38>
800028c6:	76 18       	ld.w	r8,r11[0x4]
800028c8:	30 06       	mov	r6,0
800028ca:	30 07       	mov	r7,0
800028cc:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u8[0]	= 0x1;
800028d0:	76 19       	ld.w	r9,r11[0x4]
800028d2:	30 18       	mov	r8,1
800028d4:	f3 68 00 08 	st.b	r9[8],r8
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID1_ID;
800028d8:	76 19       	ld.w	r9,r11[0x4]
800028da:	e0 6a 02 31 	mov	r10,561
800028de:	93 0a       	st.w	r9[0x0],r10
	mob_tx_dash.dlc = 1;
800028e0:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
800028e4:	76 18       	ld.w	r8,r11[0x4]
800028e6:	30 09       	mov	r9,0
800028e8:	30 1a       	mov	r10,1
800028ea:	17 8b       	ld.ub	r11,r11[0x0]
800028ec:	12 9c       	mov	r12,r9
800028ee:	f0 1f 00 04 	mcall	800028fc <ecu_can_confirm_activate_launch+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
800028f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800028f6:	00 00       	add	r0,r0
800028f8:	00 00       	add	r0,r0
800028fa:	00 a0       	st.w	r0++,r0
800028fc:	80 00       	ld.sh	r0,r0[0x0]
800028fe:	49 88       	lddpc	r8,8000295c <ecu_can_send_alive+0x5c>

80002900 <ecu_can_send_alive>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_alive(uint8_t error) {
80002900:	d4 01       	pushm	lr
	mob_tx_dash.can_msg->data.u64	 = 0x0LL;
80002902:	49 68       	lddpc	r8,80002958 <ecu_can_send_alive+0x58>
80002904:	70 19       	ld.w	r9,r8[0x4]
80002906:	30 0a       	mov	r10,0
80002908:	30 0b       	mov	r11,0
8000290a:	f2 eb 00 08 	st.d	r9[8],r10
	mob_tx_dash.can_msg->data.u8[0]  = CANR_CMD_ALIVE;
8000290e:	70 19       	ld.w	r9,r8[0x4]
80002910:	30 9a       	mov	r10,9
80002912:	f3 6a 00 08 	st.b	r9[8],r10
	mob_tx_dash.can_msg->data.u8[1]  = DASH_ALIVE_ECU;
80002916:	70 18       	ld.w	r8,r8[0x4]
80002918:	30 09       	mov	r9,0
8000291a:	f1 69 00 09 	st.b	r8[9],r9
	if (error == 0) {
8000291e:	58 0c       	cp.w	r12,0
80002920:	c0 71       	brne	8000292e <ecu_can_send_alive+0x2e>
		mob_tx_dash.can_msg->data.u8[2]  = CANR_ALIVE_STATE_OPERATIVE;
80002922:	48 e8       	lddpc	r8,80002958 <ecu_can_send_alive+0x58>
80002924:	70 18       	ld.w	r8,r8[0x4]
80002926:	30 19       	mov	r9,1
80002928:	f1 69 00 0a 	st.b	r8[10],r9
8000292c:	c0 68       	rjmp	80002938 <ecu_can_send_alive+0x38>
		} else {
		mob_tx_dash.can_msg->data.u8[2]  = CANR_ALIVE_STATE_ERROR;
8000292e:	48 b8       	lddpc	r8,80002958 <ecu_can_send_alive+0x58>
80002930:	70 18       	ld.w	r8,r8[0x4]
80002932:	30 09       	mov	r9,0
80002934:	f1 69 00 0a 	st.b	r8[10],r9
	}
	
	mob_tx_dash.can_msg->id = CANR_FCN_DATA_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID7_ID;
80002938:	48 8b       	lddpc	r11,80002958 <ecu_can_send_alive+0x58>
8000293a:	76 18       	ld.w	r8,r11[0x4]
8000293c:	e0 69 06 67 	mov	r9,1639
80002940:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 3;
80002942:	30 38       	mov	r8,3
80002944:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
80002948:	76 18       	ld.w	r8,r11[0x4]
8000294a:	30 09       	mov	r9,0
8000294c:	30 3a       	mov	r10,3
8000294e:	17 8b       	ld.ub	r11,r11[0x0]
80002950:	12 9c       	mov	r12,r9
80002952:	f0 1f 00 03 	mcall	8000295c <ecu_can_send_alive+0x5c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
80002956:	d8 02       	popm	pc
80002958:	00 00       	add	r0,r0
8000295a:	00 a0       	st.w	r0++,r0
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	49 88       	lddpc	r8,800029bc <ecu_can_send_ready_to_drive+0x1c>

80002960 <ecu_can_send_drive_disabled>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_drive_disabled(void) {
80002960:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	 = 0x0LL;
80002964:	48 db       	lddpc	r11,80002998 <ecu_can_send_drive_disabled+0x38>
80002966:	76 18       	ld.w	r8,r11[0x4]
80002968:	30 06       	mov	r6,0
8000296a:	30 07       	mov	r7,0
8000296c:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u16[0]  = 0x4;
80002970:	76 18       	ld.w	r8,r11[0x4]
80002972:	30 49       	mov	r9,4
80002974:	b0 49       	st.h	r8[0x8],r9
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID0_ID;
80002976:	76 18       	ld.w	r8,r11[0x4]
80002978:	e0 69 02 30 	mov	r9,560
8000297c:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 2;
8000297e:	30 28       	mov	r8,2
80002980:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
80002984:	76 18       	ld.w	r8,r11[0x4]
80002986:	30 09       	mov	r9,0
80002988:	30 2a       	mov	r10,2
8000298a:	17 8b       	ld.ub	r11,r11[0x0]
8000298c:	12 9c       	mov	r12,r9
8000298e:	f0 1f 00 04 	mcall	8000299c <ecu_can_send_drive_disabled+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
80002992:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002996:	00 00       	add	r0,r0
80002998:	00 00       	add	r0,r0
8000299a:	00 a0       	st.w	r0++,r0
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	49 88       	lddpc	r8,800029fc <ecu_can_send_play_rtds+0x1c>

800029a0 <ecu_can_send_ready_to_drive>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_ready_to_drive(void) {
800029a0:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	 = 0x0LL;
800029a4:	48 db       	lddpc	r11,800029d8 <ecu_can_send_ready_to_drive+0x38>
800029a6:	76 18       	ld.w	r8,r11[0x4]
800029a8:	30 06       	mov	r6,0
800029aa:	30 07       	mov	r7,0
800029ac:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u16[0]  = 0x3;
800029b0:	76 18       	ld.w	r8,r11[0x4]
800029b2:	30 39       	mov	r9,3
800029b4:	b0 49       	st.h	r8[0x8],r9
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID0_ID;
800029b6:	76 18       	ld.w	r8,r11[0x4]
800029b8:	e0 69 02 30 	mov	r9,560
800029bc:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 2;
800029be:	30 28       	mov	r8,2
800029c0:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
800029c4:	76 18       	ld.w	r8,r11[0x4]
800029c6:	30 09       	mov	r9,0
800029c8:	30 2a       	mov	r10,2
800029ca:	17 8b       	ld.ub	r11,r11[0x0]
800029cc:	12 9c       	mov	r12,r9
800029ce:	f0 1f 00 04 	mcall	800029dc <ecu_can_send_ready_to_drive+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
800029d2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800029d6:	00 00       	add	r0,r0
800029d8:	00 00       	add	r0,r0
800029da:	00 a0       	st.w	r0++,r0
800029dc:	80 00       	ld.sh	r0,r0[0x0]
800029de:	49 88       	lddpc	r8,80002a3c <ecu_can_send_tractive_system_active+0x20>

800029e0 <ecu_can_send_play_rtds>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_play_rtds(void) {
800029e0:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	 = 0x0LL;
800029e4:	48 cb       	lddpc	r11,80002a14 <ecu_can_send_play_rtds+0x34>
800029e6:	76 18       	ld.w	r8,r11[0x4]
800029e8:	30 06       	mov	r6,0
800029ea:	30 07       	mov	r7,0
800029ec:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u16[0]  = 0x2;
800029f0:	76 19       	ld.w	r9,r11[0x4]
800029f2:	30 28       	mov	r8,2
800029f4:	b2 48       	st.h	r9[0x8],r8
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID0_ID;
800029f6:	76 19       	ld.w	r9,r11[0x4]
800029f8:	e0 6a 02 30 	mov	r10,560
800029fc:	93 0a       	st.w	r9[0x0],r10
	mob_tx_dash.dlc = 2;
800029fe:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
80002a02:	76 18       	ld.w	r8,r11[0x4]
80002a04:	30 09       	mov	r9,0
80002a06:	30 2a       	mov	r10,2
80002a08:	17 8b       	ld.ub	r11,r11[0x0]
80002a0a:	12 9c       	mov	r12,r9
80002a0c:	f0 1f 00 03 	mcall	80002a18 <ecu_can_send_play_rtds+0x38>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
80002a10:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a14:	00 00       	add	r0,r0
80002a16:	00 a0       	st.w	r0++,r0
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	49 88       	lddpc	r8,80002a78 <ecu_can_send_slow_data+0x1c>

80002a1c <ecu_can_send_tractive_system_active>:
	// 	mob_tx_inverter.dlc,
	// 	CAN_DATA_FRAME,
	// 	mob_tx_inverter.can_msg);
}

void ecu_can_send_tractive_system_active(void) {
80002a1c:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	 = 0x0LL;
80002a20:	48 db       	lddpc	r11,80002a54 <ecu_can_send_tractive_system_active+0x38>
80002a22:	76 18       	ld.w	r8,r11[0x4]
80002a24:	30 06       	mov	r6,0
80002a26:	30 07       	mov	r7,0
80002a28:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u16[0]  = 0x1;
80002a2c:	76 18       	ld.w	r8,r11[0x4]
80002a2e:	30 19       	mov	r9,1
80002a30:	b0 49       	st.h	r8[0x8],r9
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID0_ID;
80002a32:	76 18       	ld.w	r8,r11[0x4]
80002a34:	e0 69 02 30 	mov	r9,560
80002a38:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 2;
80002a3a:	30 28       	mov	r8,2
80002a3c:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
80002a40:	76 18       	ld.w	r8,r11[0x4]
80002a42:	30 09       	mov	r9,0
80002a44:	30 2a       	mov	r10,2
80002a46:	17 8b       	ld.ub	r11,r11[0x0]
80002a48:	12 9c       	mov	r12,r9
80002a4a:	f0 1f 00 04 	mcall	80002a58 <ecu_can_send_tractive_system_active+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
80002a4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a52:	00 00       	add	r0,r0
80002a54:	00 00       	add	r0,r0
80002a56:	00 a0       	st.w	r0++,r0
80002a58:	80 00       	ld.sh	r0,r0[0x0]
80002a5a:	49 88       	lddpc	r8,80002ab8 <ecu_can_send_fast_data+0x20>

80002a5c <ecu_can_send_slow_data>:
	mob_ecu_fast_data.dlc,
	CAN_DATA_FRAME,
	mob_ecu_fast_data.can_msg);
}

void ecu_can_send_slow_data(uint16_t motor_temp, uint16_t inverter_temp, uint8_t max_trq) {
80002a5c:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_ecu_slow_data.can_msg->data.u64	 = 0x0LL;
80002a60:	48 ce       	lddpc	lr,80002a90 <ecu_can_send_slow_data+0x34>
80002a62:	7c 18       	ld.w	r8,lr[0x4]
80002a64:	30 06       	mov	r6,0
80002a66:	30 07       	mov	r7,0
80002a68:	f0 e7 00 08 	st.d	r8[8],r6
	mob_ecu_slow_data.can_msg->data.u16[0] = motor_temp;
80002a6c:	7c 18       	ld.w	r8,lr[0x4]
80002a6e:	b0 4c       	st.h	r8[0x8],r12
	mob_ecu_slow_data.can_msg->data.u16[1] = inverter_temp;
80002a70:	7c 18       	ld.w	r8,lr[0x4]
80002a72:	b0 5b       	st.h	r8[0xa],r11
	mob_ecu_slow_data.can_msg->data.u8[4] = max_trq;
80002a74:	7c 18       	ld.w	r8,lr[0x4]
80002a76:	f1 6a 00 0c 	st.b	r8[12],r10
	
	can_tx(CAN_BUS_1,
80002a7a:	7c 18       	ld.w	r8,lr[0x4]
80002a7c:	30 09       	mov	r9,0
80002a7e:	fd 3a 00 08 	ld.ub	r10,lr[8]
80002a82:	1d 8b       	ld.ub	r11,lr[0x0]
80002a84:	30 1c       	mov	r12,1
80002a86:	f0 1f 00 04 	mcall	80002a94 <ecu_can_send_slow_data+0x38>
	mob_ecu_slow_data.handle,
	mob_ecu_slow_data.dlc,
	CAN_DATA_FRAME,
	mob_ecu_slow_data.can_msg);
}
80002a8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a8e:	00 00       	add	r0,r0
80002a90:	00 00       	add	r0,r0
80002a92:	01 40       	ld.w	r0,--r0
80002a94:	80 00       	ld.sh	r0,r0[0x0]
80002a96:	49 88       	lddpc	r8,80002af4 <ecu_can_inverter_read_reg+0x20>

80002a98 <ecu_can_send_fast_data>:
	mob_tx_bms.dlc,
	CAN_DATA_FRAME,
	mob_tx_bms.can_msg);
}

void ecu_can_send_fast_data(uint16_t inverter_vdc, uint16_t ecu_error, uint16_t rpm, int16_t trq_cmd) {
80002a98:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_ecu_fast_data.can_msg->data.u64	  = 0x0LL;
80002a9c:	48 ce       	lddpc	lr,80002acc <ecu_can_send_fast_data+0x34>
80002a9e:	7c 18       	ld.w	r8,lr[0x4]
80002aa0:	30 06       	mov	r6,0
80002aa2:	30 07       	mov	r7,0
80002aa4:	f0 e7 00 08 	st.d	r8[8],r6
	mob_ecu_fast_data.can_msg->data.u16[0] = inverter_vdc;
80002aa8:	7c 18       	ld.w	r8,lr[0x4]
80002aaa:	b0 4c       	st.h	r8[0x8],r12
	mob_ecu_fast_data.can_msg->data.u16[1] = ecu_error;
80002aac:	7c 18       	ld.w	r8,lr[0x4]
80002aae:	b0 5b       	st.h	r8[0xa],r11
	mob_ecu_fast_data.can_msg->data.u16[2] = rpm;
80002ab0:	7c 18       	ld.w	r8,lr[0x4]
80002ab2:	b0 6a       	st.h	r8[0xc],r10
	mob_ecu_fast_data.can_msg->data.s16[3] = trq_cmd;
80002ab4:	7c 18       	ld.w	r8,lr[0x4]
80002ab6:	b0 79       	st.h	r8[0xe],r9
	
	can_tx(CAN_BUS_0,
80002ab8:	7c 18       	ld.w	r8,lr[0x4]
80002aba:	30 09       	mov	r9,0
80002abc:	fd 3a 00 08 	ld.ub	r10,lr[8]
80002ac0:	1d 8b       	ld.ub	r11,lr[0x0]
80002ac2:	12 9c       	mov	r12,r9
80002ac4:	f0 1f 00 03 	mcall	80002ad0 <ecu_can_send_fast_data+0x38>
	mob_ecu_fast_data.handle,
	mob_ecu_fast_data.dlc,
	CAN_DATA_FRAME,
	mob_ecu_fast_data.can_msg);
}
80002ac8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002acc:	00 00       	add	r0,r0
80002ace:	00 64       	and	r4,r0
80002ad0:	80 00       	ld.sh	r0,r0[0x0]
80002ad2:	49 88       	lddpc	r8,80002b30 <ecu_can_inverter_torque_cmd+0x28>

80002ad4 <ecu_can_inverter_read_reg>:

void ecu_can_inverter_read_torque_periodic() {
	ecu_can_send_to_inverter(READ_CMD, 0x90FA); //FA = 250 ms period
}

void ecu_can_inverter_read_reg(uint8_t inverter_reg) {
80002ad4:	d4 01       	pushm	lr
80002ad6:	20 3d       	sub	sp,12
	/* Msg = 0x3D inverter_reg 00, ex: 0x3DE800 (read FRG_RUN) */
	
	inverter_can_msg_t message;
	
	message.data.u64 = 0x0LL;
80002ad8:	30 08       	mov	r8,0
80002ada:	30 09       	mov	r9,0
80002adc:	fa e9 00 00 	st.d	sp[0],r8
	message.data.u32[0] = READ_CMD << 24 | inverter_reg << 16;
80002ae0:	b1 6c       	lsl	r12,0x10
80002ae2:	ea 1c 3d 00 	orh	r12,0x3d00
80002ae6:	50 0c       	stdsp	sp[0x0],r12
	message.dlc = INVERTER_DLC_3;
80002ae8:	30 38       	mov	r8,3
80002aea:	50 28       	stdsp	sp[0x8],r8
	
	xQueueSendToBack(queue_to_inverter,&message,0);
80002aec:	30 09       	mov	r9,0
80002aee:	12 9a       	mov	r10,r9
80002af0:	1a 9b       	mov	r11,sp
80002af2:	48 48       	lddpc	r8,80002b00 <ecu_can_inverter_read_reg+0x2c>
80002af4:	70 0c       	ld.w	r12,r8[0x0]
80002af6:	f0 1f 00 04 	mcall	80002b04 <ecu_can_inverter_read_reg+0x30>
}
80002afa:	2f dd       	sub	sp,-12
80002afc:	d8 02       	popm	pc
80002afe:	00 00       	add	r0,r0
80002b00:	00 00       	add	r0,r0
80002b02:	cf 48       	rjmp	80002cea <xQueueGenericSendFromISR+0x3e>
80002b04:	80 00       	ld.sh	r0,r0[0x0]
80002b06:	2e c8       	sub	r8,-20

80002b08 <ecu_can_inverter_torque_cmd>:
	message.dlc = INVERTER_DLC_3;
	message.data.u32[0] = inverter_reg << 24 | data << 8;
	xQueueSendToBack(queue_to_inverter,&message,0);
}

void ecu_can_inverter_torque_cmd(int16_t torque) {
80002b08:	d4 01       	pushm	lr
80002b0a:	20 3d       	sub	sp,12
	/* This code also handles negative numbers */
	uint16_t torque_intel = ((torque >> 8) & 0xff) | ((torque & 0xff) << 8);
	
	inverter_can_msg_t message;
	
	message.data.u64 = 0x0LL;
80002b0c:	30 08       	mov	r8,0
80002b0e:	30 09       	mov	r9,0
80002b10:	fa e9 00 00 	st.d	sp[0],r8
	message.dlc = INVERTER_DLC_3;
80002b14:	30 38       	mov	r8,3
80002b16:	50 28       	stdsp	sp[0x8],r8
	message.data.u32[0] = TORQUE_CMD << 24 | torque_intel << 8;
80002b18:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
80002b1c:	f1 ec 10 88 	or	r8,r8,r12<<0x8
80002b20:	5c 78       	castu.h	r8
80002b22:	a9 68       	lsl	r8,0x8
80002b24:	ea 18 90 00 	orh	r8,0x9000
80002b28:	50 08       	stdsp	sp[0x0],r8
	
	xQueueSendToBack(queue_to_inverter,&message,0);
80002b2a:	30 09       	mov	r9,0
80002b2c:	12 9a       	mov	r10,r9
80002b2e:	1a 9b       	mov	r11,sp
80002b30:	48 38       	lddpc	r8,80002b3c <ecu_can_inverter_torque_cmd+0x34>
80002b32:	70 0c       	ld.w	r12,r8[0x0]
80002b34:	f0 1f 00 03 	mcall	80002b40 <ecu_can_inverter_torque_cmd+0x38>
}
80002b38:	2f dd       	sub	sp,-12
80002b3a:	d8 02       	popm	pc
80002b3c:	00 00       	add	r0,r0
80002b3e:	cf 48       	rjmp	80002d26 <prvUnlockQueue+0x1e>
80002b40:	80 00       	ld.sh	r0,r0[0x0]
80002b42:	2e c8       	sub	r8,-20

80002b44 <ecu_can_send_to_inverter>:
#include "ecu_can.h"
#include "ecu_can_mob.h"
#include "ecu_can_messages.h"


void ecu_can_send_to_inverter(uint8_t inverter_reg, uint16_t data) {
80002b44:	d4 01       	pushm	lr
80002b46:	20 3d       	sub	sp,12
	inverter_can_msg_t message;
	
	message.data.u64 = 0x0LL;
80002b48:	30 08       	mov	r8,0
80002b4a:	30 09       	mov	r9,0
80002b4c:	fa e9 00 00 	st.d	sp[0],r8
	message.dlc = INVERTER_DLC_3;
80002b50:	30 38       	mov	r8,3
80002b52:	50 28       	stdsp	sp[0x8],r8
	message.data.u32[0] = inverter_reg << 24 | data << 8;
80002b54:	5c 7b       	castu.h	r11
80002b56:	b9 6c       	lsl	r12,0x18
80002b58:	f9 eb 10 8b 	or	r11,r12,r11<<0x8
80002b5c:	50 0b       	stdsp	sp[0x0],r11
	xQueueSendToBack(queue_to_inverter,&message,0);
80002b5e:	30 09       	mov	r9,0
80002b60:	12 9a       	mov	r10,r9
80002b62:	1a 9b       	mov	r11,sp
80002b64:	48 38       	lddpc	r8,80002b70 <ecu_can_send_to_inverter+0x2c>
80002b66:	70 0c       	ld.w	r12,r8[0x0]
80002b68:	f0 1f 00 03 	mcall	80002b74 <ecu_can_send_to_inverter+0x30>
}
80002b6c:	2f dd       	sub	sp,-12
80002b6e:	d8 02       	popm	pc
80002b70:	00 00       	add	r0,r0
80002b72:	cf 48       	rjmp	80002d5a <prvUnlockQueue+0x52>
80002b74:	80 00       	ld.sh	r0,r0[0x0]
80002b76:	2e c8       	sub	r8,-20

80002b78 <ecu_can_inverter_disable_drive>:

void ecu_can_inverter_enable_drive() {
	ecu_can_send_to_inverter(MODE_REG, 0x0000);
}

void ecu_can_inverter_disable_drive() {
80002b78:	d4 01       	pushm	lr
	ecu_can_send_to_inverter(MODE_REG, 0x0400);
80002b7a:	e0 6b 04 00 	mov	r11,1024
80002b7e:	35 1c       	mov	r12,81
80002b80:	f0 1f 00 02 	mcall	80002b88 <ecu_can_inverter_disable_drive+0x10>
}
80002b84:	d8 02       	popm	pc
80002b86:	00 00       	add	r0,r0
80002b88:	80 00       	ld.sh	r0,r0[0x0]
80002b8a:	2b 44       	sub	r4,-76

80002b8c <ecu_can_inverter_enable_drive>:
	CAN_DATA_FRAME,
	mob_debug.can_msg);
}


void ecu_can_inverter_enable_drive() {
80002b8c:	d4 01       	pushm	lr
	ecu_can_send_to_inverter(MODE_REG, 0x0000);
80002b8e:	30 0b       	mov	r11,0
80002b90:	35 1c       	mov	r12,81
80002b92:	f0 1f 00 02 	mcall	80002b98 <ecu_can_inverter_enable_drive+0xc>
}
80002b96:	d8 02       	popm	pc
80002b98:	80 00       	ld.sh	r0,r0[0x0]
80002b9a:	2b 44       	sub	r4,-76

80002b9c <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
80002b9c:	5e fc       	retal	r12
80002b9e:	d7 03       	nop

80002ba0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80002ba0:	eb cd 40 c0 	pushm	r6-r7,lr
80002ba4:	18 97       	mov	r7,r12
void *pvReturn = NULL;
static unsigned char *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
80002ba6:	f1 dc c0 02 	bfextu	r8,r12,0x0,0x2
80002baa:	c0 40       	breq	80002bb2 <pvPortMalloc+0x12>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
80002bac:	e0 17 ff fc 	andl	r7,0xfffc
80002bb0:	2f c7       	sub	r7,-4
		}
	#endif

	vTaskSuspendAll();
80002bb2:	f0 1f 00 11 	mcall	80002bf4 <pvPortMalloc+0x54>
	{
		if( pucAlignedHeap == NULL )
80002bb6:	49 18       	lddpc	r8,80002bf8 <pvPortMalloc+0x58>
80002bb8:	70 08       	ld.w	r8,r8[0x0]
80002bba:	58 08       	cp.w	r8,0
80002bbc:	c0 71       	brne	80002bca <pvPortMalloc+0x2a>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
80002bbe:	49 09       	lddpc	r9,80002bfc <pvPortMalloc+0x5c>
80002bc0:	2f c9       	sub	r9,-4
80002bc2:	e0 19 ff fc 	andl	r9,0xfffc
80002bc6:	48 d8       	lddpc	r8,80002bf8 <pvPortMalloc+0x58>
80002bc8:	91 09       	st.w	r8[0x0],r9
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
80002bca:	48 e8       	lddpc	r8,80002c00 <pvPortMalloc+0x60>
80002bcc:	70 08       	ld.w	r8,r8[0x0]
80002bce:	10 07       	add	r7,r8
80002bd0:	e0 47 c7 fb 	cp.w	r7,51195
80002bd4:	e0 8b 00 0a 	brhi	80002be8 <pvPortMalloc+0x48>
80002bd8:	0e 38       	cp.w	r8,r7
80002bda:	c0 72       	brcc	80002be8 <pvPortMalloc+0x48>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
80002bdc:	48 79       	lddpc	r9,80002bf8 <pvPortMalloc+0x58>
80002bde:	72 06       	ld.w	r6,r9[0x0]
80002be0:	10 06       	add	r6,r8
			xNextFreeByte += xWantedSize;
80002be2:	48 88       	lddpc	r8,80002c00 <pvPortMalloc+0x60>
80002be4:	91 07       	st.w	r8[0x0],r7
80002be6:	c0 28       	rjmp	80002bea <pvPortMalloc+0x4a>
80002be8:	30 06       	mov	r6,0
		}

		traceMALLOC( pvReturn, xWantedSize );
	}	
	xTaskResumeAll();
80002bea:	f0 1f 00 07 	mcall	80002c04 <pvPortMalloc+0x64>
		}
	}
	#endif

	return pvReturn;
}
80002bee:	0c 9c       	mov	r12,r6
80002bf0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002bf4:	80 00       	ld.sh	r0,r0[0x0]
80002bf6:	58 7c       	cp.w	r12,7
80002bf8:	00 00       	add	r0,r0
80002bfa:	cb f4       	brge	80002b78 <ecu_can_inverter_disable_drive>
80002bfc:	00 00       	add	r0,r0
80002bfe:	03 f4       	ld.ub	r4,r1[0x7]
80002c00:	00 00       	add	r0,r0
80002c02:	03 f0       	ld.ub	r0,r1[0x7]
80002c04:	80 00       	ld.sh	r0,r0[0x0]
80002c06:	5b 54       	cp.w	r4,-11

80002c08 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
80002c08:	d4 01       	pushm	lr
80002c0a:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80002c0c:	78 09       	ld.w	r9,r12[0x0]
80002c0e:	58 09       	cp.w	r9,0
80002c10:	c1 10       	breq	80002c32 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
80002c12:	78 3a       	ld.w	r10,r12[0xc]
80002c14:	79 09       	ld.w	r9,r12[0x40]
80002c16:	f4 09 00 09 	add	r9,r10,r9
80002c1a:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
80002c1c:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
80002c1e:	14 39       	cp.w	r9,r10
80002c20:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80002c24:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
80002c28:	79 0a       	ld.w	r10,r12[0x40]
80002c2a:	78 3b       	ld.w	r11,r12[0xc]
80002c2c:	10 9c       	mov	r12,r8
80002c2e:	f0 1f 00 02 	mcall	80002c34 <prvCopyDataFromQueue+0x2c>
80002c32:	d8 02       	popm	pc
80002c34:	80 00       	ld.sh	r0,r0[0x0]
80002c36:	78 46       	ld.w	r6,r12[0x10]

80002c38 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80002c38:	eb cd 40 c0 	pushm	r6-r7,lr
80002c3c:	18 97       	mov	r7,r12
80002c3e:	14 96       	mov	r6,r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80002c40:	79 0a       	ld.w	r10,r12[0x40]
80002c42:	58 0a       	cp.w	r10,0
80002c44:	c2 d0       	breq	80002c9e <prvCopyDataToQueue+0x66>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
80002c46:	58 06       	cp.w	r6,0
80002c48:	c0 f1       	brne	80002c66 <prvCopyDataToQueue+0x2e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
80002c4a:	78 2c       	ld.w	r12,r12[0x8]
80002c4c:	f0 1f 00 17 	mcall	80002ca8 <prvCopyDataToQueue+0x70>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80002c50:	6e 29       	ld.w	r9,r7[0x8]
80002c52:	6f 08       	ld.w	r8,r7[0x40]
80002c54:	f2 08 00 08 	add	r8,r9,r8
80002c58:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80002c5a:	6e 19       	ld.w	r9,r7[0x4]
80002c5c:	12 38       	cp.w	r8,r9
80002c5e:	c2 03       	brcs	80002c9e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80002c60:	6e 08       	ld.w	r8,r7[0x0]
80002c62:	8f 28       	st.w	r7[0x8],r8
80002c64:	c1 d8       	rjmp	80002c9e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80002c66:	78 3c       	ld.w	r12,r12[0xc]
80002c68:	f0 1f 00 10 	mcall	80002ca8 <prvCopyDataToQueue+0x70>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
80002c6c:	6f 08       	ld.w	r8,r7[0x40]
80002c6e:	6e 39       	ld.w	r9,r7[0xc]
80002c70:	f2 08 01 08 	sub	r8,r9,r8
80002c74:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80002c76:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80002c78:	12 38       	cp.w	r8,r9
80002c7a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80002c7e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80002c82:	f3 d8 e3 19 	subcs	r9,r9,r8
80002c86:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}

		if( xPosition == queueOVERWRITE )
80002c8a:	58 26       	cp.w	r6,2
80002c8c:	c0 91       	brne	80002c9e <prvCopyDataToQueue+0x66>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80002c8e:	6e e8       	ld.w	r8,r7[0x38]
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
80002c90:	58 08       	cp.w	r8,0
80002c92:	ef f8 10 0e 	ld.wne	r8,r7[0x38]
80002c96:	f7 b8 01 01 	subne	r8,1
80002c9a:	ef f8 1a 0e 	st.wne	r7[0x38],r8
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
80002c9e:	6e e8       	ld.w	r8,r7[0x38]
80002ca0:	2f f8       	sub	r8,-1
80002ca2:	8f e8       	st.w	r7[0x38],r8
}
80002ca4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002ca8:	80 00       	ld.sh	r0,r0[0x0]
80002caa:	78 46       	ld.w	r6,r12[0x10]

80002cac <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80002cac:	eb cd 40 c0 	pushm	r6-r7,lr
80002cb0:	14 96       	mov	r6,r10
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
80002cb2:	18 97       	mov	r7,r12
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80002cb4:	78 ea       	ld.w	r10,r12[0x38]
80002cb6:	78 f8       	ld.w	r8,r12[0x3c]
80002cb8:	10 3a       	cp.w	r10,r8
80002cba:	c0 53       	brcs	80002cc4 <xQueueGenericSendFromISR+0x18>
80002cbc:	58 29       	cp.w	r9,2
80002cbe:	c0 30       	breq	80002cc4 <xQueueGenericSendFromISR+0x18>
80002cc0:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80002cc4:	12 9a       	mov	r10,r9
80002cc6:	0e 9c       	mov	r12,r7
80002cc8:	f0 1f 00 0e 	mcall	80002d00 <xQueueGenericSendFromISR+0x54>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80002ccc:	6f 28       	ld.w	r8,r7[0x48]
80002cce:	5b f8       	cp.w	r8,-1
80002cd0:	c0 f1       	brne	80002cee <xQueueGenericSendFromISR+0x42>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002cd2:	6e 98       	ld.w	r8,r7[0x24]
80002cd4:	58 08       	cp.w	r8,0
80002cd6:	c1 20       	breq	80002cfa <xQueueGenericSendFromISR+0x4e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002cd8:	ee cc ff dc 	sub	r12,r7,-36
80002cdc:	f0 1f 00 0a 	mcall	80002d04 <xQueueGenericSendFromISR+0x58>
80002ce0:	c0 d0       	breq	80002cfa <xQueueGenericSendFromISR+0x4e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
80002ce2:	58 06       	cp.w	r6,0
80002ce4:	c0 b0       	breq	80002cfa <xQueueGenericSendFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
80002ce6:	30 1c       	mov	r12,1
80002ce8:	8d 0c       	st.w	r6[0x0],r12
80002cea:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80002cee:	6f 28       	ld.w	r8,r7[0x48]
80002cf0:	2f f8       	sub	r8,-1
80002cf2:	ef 48 00 48 	st.w	r7[72],r8
80002cf6:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80002cfa:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80002cfe:	00 00       	add	r0,r0
80002d00:	80 00       	ld.sh	r0,r0[0x0]
80002d02:	2c 38       	sub	r8,-61
80002d04:	80 00       	ld.sh	r0,r0[0x0]
80002d06:	59 c0       	cp.w	r0,28

80002d08 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
80002d08:	eb cd 40 c0 	pushm	r6-r7,lr
80002d0c:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80002d0e:	f0 1f 00 24 	mcall	80002d9c <prvUnlockQueue+0x94>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002d12:	6f 28       	ld.w	r8,r7[0x48]
80002d14:	58 08       	cp.w	r8,0
80002d16:	e0 8a 00 19 	brle	80002d48 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002d1a:	6e 98       	ld.w	r8,r7[0x24]
80002d1c:	58 08       	cp.w	r8,0
80002d1e:	c1 50       	breq	80002d48 <prvUnlockQueue+0x40>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002d20:	ee c6 ff dc 	sub	r6,r7,-36
80002d24:	c0 48       	rjmp	80002d2c <prvUnlockQueue+0x24>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002d26:	6e 98       	ld.w	r8,r7[0x24]
80002d28:	58 08       	cp.w	r8,0
80002d2a:	c0 f0       	breq	80002d48 <prvUnlockQueue+0x40>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002d2c:	0c 9c       	mov	r12,r6
80002d2e:	f0 1f 00 1d 	mcall	80002da0 <prvUnlockQueue+0x98>
80002d32:	c0 30       	breq	80002d38 <prvUnlockQueue+0x30>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
80002d34:	f0 1f 00 1c 	mcall	80002da4 <prvUnlockQueue+0x9c>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
80002d38:	6f 28       	ld.w	r8,r7[0x48]
80002d3a:	20 18       	sub	r8,1
80002d3c:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002d40:	6f 28       	ld.w	r8,r7[0x48]
80002d42:	58 08       	cp.w	r8,0
80002d44:	fe 99 ff f1 	brgt	80002d26 <prvUnlockQueue+0x1e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
80002d48:	3f f8       	mov	r8,-1
80002d4a:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80002d4e:	f0 1f 00 17 	mcall	80002da8 <prvUnlockQueue+0xa0>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80002d52:	f0 1f 00 13 	mcall	80002d9c <prvUnlockQueue+0x94>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002d56:	6f 18       	ld.w	r8,r7[0x44]
80002d58:	58 08       	cp.w	r8,0
80002d5a:	e0 8a 00 19 	brle	80002d8c <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002d5e:	6e 48       	ld.w	r8,r7[0x10]
80002d60:	58 08       	cp.w	r8,0
80002d62:	c1 50       	breq	80002d8c <prvUnlockQueue+0x84>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002d64:	ee c6 ff f0 	sub	r6,r7,-16
80002d68:	c0 48       	rjmp	80002d70 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002d6a:	6e 48       	ld.w	r8,r7[0x10]
80002d6c:	58 08       	cp.w	r8,0
80002d6e:	c0 f0       	breq	80002d8c <prvUnlockQueue+0x84>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002d70:	0c 9c       	mov	r12,r6
80002d72:	f0 1f 00 0c 	mcall	80002da0 <prvUnlockQueue+0x98>
80002d76:	c0 30       	breq	80002d7c <prvUnlockQueue+0x74>
				{
					vTaskMissedYield();
80002d78:	f0 1f 00 0b 	mcall	80002da4 <prvUnlockQueue+0x9c>
				}

				--( pxQueue->xRxLock );
80002d7c:	6f 18       	ld.w	r8,r7[0x44]
80002d7e:	20 18       	sub	r8,1
80002d80:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002d84:	6f 18       	ld.w	r8,r7[0x44]
80002d86:	58 08       	cp.w	r8,0
80002d88:	fe 99 ff f1 	brgt	80002d6a <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80002d8c:	3f f8       	mov	r8,-1
80002d8e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80002d92:	f0 1f 00 06 	mcall	80002da8 <prvUnlockQueue+0xa0>
}
80002d96:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d9a:	00 00       	add	r0,r0
80002d9c:	80 00       	ld.sh	r0,r0[0x0]
80002d9e:	56 cc       	stdsp	sp[0x1b0],r12
80002da0:	80 00       	ld.sh	r0,r0[0x0]
80002da2:	59 c0       	cp.w	r0,28
80002da4:	80 00       	ld.sh	r0,r0[0x0]
80002da6:	59 20       	cp.w	r0,18
80002da8:	80 00       	ld.sh	r0,r0[0x0]
80002daa:	57 d8       	stdsp	sp[0x1f4],r8

80002dac <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80002dac:	d4 31       	pushm	r0-r7,lr
80002dae:	20 5d       	sub	sp,20
80002db0:	50 0b       	stdsp	sp[0x0],r11
80002db2:	50 2a       	stdsp	sp[0x8],r10
80002db4:	50 19       	stdsp	sp[0x4],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
80002db6:	18 97       	mov	r7,r12
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002db8:	f8 c1 ff dc 	sub	r1,r12,-36
80002dbc:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002dbe:	fa c4 ff f4 	sub	r4,sp,-12
80002dc2:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80002dc4:	0a 92       	mov	r2,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002dc6:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80002dca:	f0 1f 00 36 	mcall	80002ea0 <xQueueGenericReceive+0xf4>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80002dce:	6e e8       	ld.w	r8,r7[0x38]
80002dd0:	58 08       	cp.w	r8,0
80002dd2:	c2 40       	breq	80002e1a <xQueueGenericReceive+0x6e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
80002dd4:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80002dd6:	40 0b       	lddsp	r11,sp[0x0]
80002dd8:	0e 9c       	mov	r12,r7
80002dda:	f0 1f 00 33 	mcall	80002ea4 <xQueueGenericReceive+0xf8>

				if( xJustPeeking == pdFALSE )
80002dde:	40 18       	lddsp	r8,sp[0x4]
80002de0:	58 08       	cp.w	r8,0
80002de2:	c0 f1       	brne	80002e00 <xQueueGenericReceive+0x54>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
80002de4:	6e e8       	ld.w	r8,r7[0x38]
80002de6:	20 18       	sub	r8,1
80002de8:	8f e8       	st.w	r7[0x38],r8
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002dea:	6e 48       	ld.w	r8,r7[0x10]
80002dec:	58 08       	cp.w	r8,0
80002dee:	c1 20       	breq	80002e12 <xQueueGenericReceive+0x66>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80002df0:	ee cc ff f0 	sub	r12,r7,-16
80002df4:	f0 1f 00 2d 	mcall	80002ea8 <xQueueGenericReceive+0xfc>
80002df8:	58 1c       	cp.w	r12,1
80002dfa:	c0 c1       	brne	80002e12 <xQueueGenericReceive+0x66>
						{
							queueYIELD_IF_USING_PREEMPTION();
80002dfc:	d7 33       	scall
80002dfe:	c0 a8       	rjmp	80002e12 <xQueueGenericReceive+0x66>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
80002e00:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002e02:	6e 98       	ld.w	r8,r7[0x24]
80002e04:	58 08       	cp.w	r8,0
80002e06:	c0 60       	breq	80002e12 <xQueueGenericReceive+0x66>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002e08:	02 9c       	mov	r12,r1
80002e0a:	f0 1f 00 28 	mcall	80002ea8 <xQueueGenericReceive+0xfc>
80002e0e:	c0 20       	breq	80002e12 <xQueueGenericReceive+0x66>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
80002e10:	d7 33       	scall
						}
					}
				}

				taskEXIT_CRITICAL();
80002e12:	f0 1f 00 27 	mcall	80002eac <xQueueGenericReceive+0x100>
80002e16:	30 1c       	mov	r12,1
				return pdPASS;
80002e18:	c4 28       	rjmp	80002e9c <xQueueGenericReceive+0xf0>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80002e1a:	40 28       	lddsp	r8,sp[0x8]
80002e1c:	58 08       	cp.w	r8,0
80002e1e:	c0 51       	brne	80002e28 <xQueueGenericReceive+0x7c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80002e20:	f0 1f 00 23 	mcall	80002eac <xQueueGenericReceive+0x100>
80002e24:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80002e26:	c3 b8       	rjmp	80002e9c <xQueueGenericReceive+0xf0>
				}
				else if( xEntryTimeSet == pdFALSE )
80002e28:	58 05       	cp.w	r5,0
80002e2a:	c0 51       	brne	80002e34 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002e2c:	08 9c       	mov	r12,r4
80002e2e:	f0 1f 00 21 	mcall	80002eb0 <xQueueGenericReceive+0x104>
80002e32:	00 95       	mov	r5,r0
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
80002e34:	f0 1f 00 1e 	mcall	80002eac <xQueueGenericReceive+0x100>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80002e38:	f0 1f 00 1f 	mcall	80002eb4 <xQueueGenericReceive+0x108>
		prvLockQueue( pxQueue );
80002e3c:	f0 1f 00 19 	mcall	80002ea0 <xQueueGenericReceive+0xf4>
80002e40:	6f 18       	ld.w	r8,r7[0x44]
80002e42:	5b f8       	cp.w	r8,-1
80002e44:	ef f2 0a 11 	st.weq	r7[0x44],r2
80002e48:	6f 28       	ld.w	r8,r7[0x48]
80002e4a:	5b f8       	cp.w	r8,-1
80002e4c:	ef f2 0a 12 	st.weq	r7[0x48],r2
80002e50:	f0 1f 00 17 	mcall	80002eac <xQueueGenericReceive+0x100>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002e54:	06 9b       	mov	r11,r3
80002e56:	08 9c       	mov	r12,r4
80002e58:	f0 1f 00 18 	mcall	80002eb8 <xQueueGenericReceive+0x10c>
80002e5c:	c1 a1       	brne	80002e90 <xQueueGenericReceive+0xe4>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80002e5e:	f0 1f 00 11 	mcall	80002ea0 <xQueueGenericReceive+0xf4>
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
80002e62:	6e e6       	ld.w	r6,r7[0x38]
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
80002e64:	f0 1f 00 12 	mcall	80002eac <xQueueGenericReceive+0x100>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80002e68:	58 06       	cp.w	r6,0
80002e6a:	c0 d1       	brne	80002e84 <xQueueGenericReceive+0xd8>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002e6c:	40 2b       	lddsp	r11,sp[0x8]
80002e6e:	02 9c       	mov	r12,r1
80002e70:	f0 1f 00 13 	mcall	80002ebc <xQueueGenericReceive+0x110>
				prvUnlockQueue( pxQueue );
80002e74:	0e 9c       	mov	r12,r7
80002e76:	f0 1f 00 13 	mcall	80002ec0 <xQueueGenericReceive+0x114>
				if( xTaskResumeAll() == pdFALSE )
80002e7a:	f0 1f 00 13 	mcall	80002ec4 <xQueueGenericReceive+0x118>
80002e7e:	ca 61       	brne	80002dca <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80002e80:	d7 33       	scall
80002e82:	ca 4b       	rjmp	80002dca <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80002e84:	0e 9c       	mov	r12,r7
80002e86:	f0 1f 00 0f 	mcall	80002ec0 <xQueueGenericReceive+0x114>
				( void ) xTaskResumeAll();
80002e8a:	f0 1f 00 0f 	mcall	80002ec4 <xQueueGenericReceive+0x118>
80002e8e:	c9 eb       	rjmp	80002dca <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80002e90:	0e 9c       	mov	r12,r7
80002e92:	f0 1f 00 0c 	mcall	80002ec0 <xQueueGenericReceive+0x114>
			( void ) xTaskResumeAll();
80002e96:	f0 1f 00 0c 	mcall	80002ec4 <xQueueGenericReceive+0x118>
80002e9a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80002e9c:	2f bd       	sub	sp,-20
80002e9e:	d8 32       	popm	r0-r7,pc
80002ea0:	80 00       	ld.sh	r0,r0[0x0]
80002ea2:	56 cc       	stdsp	sp[0x1b0],r12
80002ea4:	80 00       	ld.sh	r0,r0[0x0]
80002ea6:	2c 08       	sub	r8,-64
80002ea8:	80 00       	ld.sh	r0,r0[0x0]
80002eaa:	59 c0       	cp.w	r0,28
80002eac:	80 00       	ld.sh	r0,r0[0x0]
80002eae:	57 d8       	stdsp	sp[0x1f4],r8
80002eb0:	80 00       	ld.sh	r0,r0[0x0]
80002eb2:	59 08       	cp.w	r8,16
80002eb4:	80 00       	ld.sh	r0,r0[0x0]
80002eb6:	58 7c       	cp.w	r12,7
80002eb8:	80 00       	ld.sh	r0,r0[0x0]
80002eba:	59 2c       	cp.w	r12,18
80002ebc:	80 00       	ld.sh	r0,r0[0x0]
80002ebe:	5d 18       	icall	r8
80002ec0:	80 00       	ld.sh	r0,r0[0x0]
80002ec2:	2d 08       	sub	r8,-48
80002ec4:	80 00       	ld.sh	r0,r0[0x0]
80002ec6:	5b 54       	cp.w	r4,-11

80002ec8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80002ec8:	d4 31       	pushm	r0-r7,lr
80002eca:	20 5d       	sub	sp,20
80002ecc:	50 1b       	stdsp	sp[0x4],r11
80002ece:	50 2a       	stdsp	sp[0x8],r10
80002ed0:	12 92       	mov	r2,r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
80002ed2:	18 97       	mov	r7,r12
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80002ed4:	f8 c8 ff f0 	sub	r8,r12,-16
80002ed8:	50 08       	stdsp	sp[0x0],r8
80002eda:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002edc:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80002ee0:	08 90       	mov	r0,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002ee2:	fa c1 ff f8 	sub	r1,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80002ee6:	f0 1f 00 30 	mcall	80002fa4 <xQueueGenericSend+0xdc>
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80002eea:	6e e9       	ld.w	r9,r7[0x38]
80002eec:	6e f8       	ld.w	r8,r7[0x3c]
80002eee:	10 39       	cp.w	r9,r8
80002ef0:	c0 33       	brcs	80002ef6 <xQueueGenericSend+0x2e>
80002ef2:	58 22       	cp.w	r2,2
80002ef4:	c1 41       	brne	80002f1c <xQueueGenericSend+0x54>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80002ef6:	04 9a       	mov	r10,r2
80002ef8:	40 1b       	lddsp	r11,sp[0x4]
80002efa:	0e 9c       	mov	r12,r7
80002efc:	f0 1f 00 2b 	mcall	80002fa8 <xQueueGenericSend+0xe0>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002f00:	6e 98       	ld.w	r8,r7[0x24]
80002f02:	58 08       	cp.w	r8,0
80002f04:	c0 80       	breq	80002f14 <xQueueGenericSend+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80002f06:	ee cc ff dc 	sub	r12,r7,-36
80002f0a:	f0 1f 00 29 	mcall	80002fac <xQueueGenericSend+0xe4>
80002f0e:	58 1c       	cp.w	r12,1
80002f10:	c0 21       	brne	80002f14 <xQueueGenericSend+0x4c>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
80002f12:	d7 33       	scall
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
80002f14:	f0 1f 00 27 	mcall	80002fb0 <xQueueGenericSend+0xe8>
80002f18:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80002f1a:	c4 38       	rjmp	80002fa0 <xQueueGenericSend+0xd8>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80002f1c:	40 28       	lddsp	r8,sp[0x8]
80002f1e:	58 08       	cp.w	r8,0
80002f20:	c0 51       	brne	80002f2a <xQueueGenericSend+0x62>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80002f22:	f0 1f 00 24 	mcall	80002fb0 <xQueueGenericSend+0xe8>
80002f26:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80002f28:	c3 c8       	rjmp	80002fa0 <xQueueGenericSend+0xd8>
				}
				else if( xEntryTimeSet == pdFALSE )
80002f2a:	58 04       	cp.w	r4,0
80002f2c:	c0 51       	brne	80002f36 <xQueueGenericSend+0x6e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002f2e:	06 9c       	mov	r12,r3
80002f30:	f0 1f 00 21 	mcall	80002fb4 <xQueueGenericSend+0xec>
80002f34:	30 14       	mov	r4,1
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
80002f36:	f0 1f 00 1f 	mcall	80002fb0 <xQueueGenericSend+0xe8>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80002f3a:	f0 1f 00 20 	mcall	80002fb8 <xQueueGenericSend+0xf0>
		prvLockQueue( pxQueue );
80002f3e:	f0 1f 00 1a 	mcall	80002fa4 <xQueueGenericSend+0xdc>
80002f42:	6f 18       	ld.w	r8,r7[0x44]
80002f44:	5b f8       	cp.w	r8,-1
80002f46:	ef f0 0a 11 	st.weq	r7[0x44],r0
80002f4a:	6f 28       	ld.w	r8,r7[0x48]
80002f4c:	5b f8       	cp.w	r8,-1
80002f4e:	ef f0 0a 12 	st.weq	r7[0x48],r0
80002f52:	f0 1f 00 18 	mcall	80002fb0 <xQueueGenericSend+0xe8>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002f56:	02 9b       	mov	r11,r1
80002f58:	06 9c       	mov	r12,r3
80002f5a:	f0 1f 00 19 	mcall	80002fbc <xQueueGenericSend+0xf4>
80002f5e:	c1 b1       	brne	80002f94 <xQueueGenericSend+0xcc>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80002f60:	f0 1f 00 11 	mcall	80002fa4 <xQueueGenericSend+0xdc>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
80002f64:	6e e5       	ld.w	r5,r7[0x38]
80002f66:	6e f6       	ld.w	r6,r7[0x3c]
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
80002f68:	f0 1f 00 12 	mcall	80002fb0 <xQueueGenericSend+0xe8>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
80002f6c:	0c 35       	cp.w	r5,r6
80002f6e:	c0 d1       	brne	80002f88 <xQueueGenericSend+0xc0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80002f70:	40 2b       	lddsp	r11,sp[0x8]
80002f72:	40 0c       	lddsp	r12,sp[0x0]
80002f74:	f0 1f 00 13 	mcall	80002fc0 <xQueueGenericSend+0xf8>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80002f78:	0e 9c       	mov	r12,r7
80002f7a:	f0 1f 00 13 	mcall	80002fc4 <xQueueGenericSend+0xfc>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
80002f7e:	f0 1f 00 13 	mcall	80002fc8 <xQueueGenericSend+0x100>
80002f82:	cb 21       	brne	80002ee6 <xQueueGenericSend+0x1e>
				{
					portYIELD_WITHIN_API();
80002f84:	d7 33       	scall
80002f86:	cb 0b       	rjmp	80002ee6 <xQueueGenericSend+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80002f88:	0e 9c       	mov	r12,r7
80002f8a:	f0 1f 00 0f 	mcall	80002fc4 <xQueueGenericSend+0xfc>
				( void ) xTaskResumeAll();
80002f8e:	f0 1f 00 0f 	mcall	80002fc8 <xQueueGenericSend+0x100>
80002f92:	ca ab       	rjmp	80002ee6 <xQueueGenericSend+0x1e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80002f94:	0e 9c       	mov	r12,r7
80002f96:	f0 1f 00 0c 	mcall	80002fc4 <xQueueGenericSend+0xfc>
			( void ) xTaskResumeAll();
80002f9a:	f0 1f 00 0c 	mcall	80002fc8 <xQueueGenericSend+0x100>
80002f9e:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80002fa0:	2f bd       	sub	sp,-20
80002fa2:	d8 32       	popm	r0-r7,pc
80002fa4:	80 00       	ld.sh	r0,r0[0x0]
80002fa6:	56 cc       	stdsp	sp[0x1b0],r12
80002fa8:	80 00       	ld.sh	r0,r0[0x0]
80002faa:	2c 38       	sub	r8,-61
80002fac:	80 00       	ld.sh	r0,r0[0x0]
80002fae:	59 c0       	cp.w	r0,28
80002fb0:	80 00       	ld.sh	r0,r0[0x0]
80002fb2:	57 d8       	stdsp	sp[0x1f4],r8
80002fb4:	80 00       	ld.sh	r0,r0[0x0]
80002fb6:	59 08       	cp.w	r8,16
80002fb8:	80 00       	ld.sh	r0,r0[0x0]
80002fba:	58 7c       	cp.w	r12,7
80002fbc:	80 00       	ld.sh	r0,r0[0x0]
80002fbe:	59 2c       	cp.w	r12,18
80002fc0:	80 00       	ld.sh	r0,r0[0x0]
80002fc2:	5d 18       	icall	r8
80002fc4:	80 00       	ld.sh	r0,r0[0x0]
80002fc6:	2d 08       	sub	r8,-48
80002fc8:	80 00       	ld.sh	r0,r0[0x0]
80002fca:	5b 54       	cp.w	r4,-11

80002fcc <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
80002fcc:	eb cd 40 c0 	pushm	r6-r7,lr
80002fd0:	16 96       	mov	r6,r11
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
80002fd2:	18 97       	mov	r7,r12

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
80002fd4:	f0 1f 00 18 	mcall	80003034 <xQueueGenericReset+0x68>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80002fd8:	6f 09       	ld.w	r9,r7[0x40]
80002fda:	6e fa       	ld.w	r10,r7[0x3c]
80002fdc:	f2 0a 02 4b 	mul	r11,r9,r10
80002fe0:	6e 08       	ld.w	r8,r7[0x0]
80002fe2:	f0 0b 00 0b 	add	r11,r8,r11
80002fe6:	8f 1b       	st.w	r7[0x4],r11
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80002fe8:	30 0b       	mov	r11,0
80002fea:	8f eb       	st.w	r7[0x38],r11
		pxQueue->pcWriteTo = pxQueue->pcHead;
80002fec:	8f 28       	st.w	r7[0x8],r8
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
80002fee:	20 1a       	sub	r10,1
80002ff0:	f4 09 02 49 	mul	r9,r10,r9
80002ff4:	12 08       	add	r8,r9
80002ff6:	8f 38       	st.w	r7[0xc],r8
		pxQueue->xRxLock = queueUNLOCKED;
80002ff8:	3f f8       	mov	r8,-1
80002ffa:	ef 48 00 44 	st.w	r7[68],r8
		pxQueue->xTxLock = queueUNLOCKED;
80002ffe:	ef 48 00 48 	st.w	r7[72],r8

		if( xNewQueue == pdFALSE )
80003002:	58 06       	cp.w	r6,0
80003004:	c0 c1       	brne	8000301c <xQueueGenericReset+0x50>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80003006:	6e 48       	ld.w	r8,r7[0x10]
80003008:	58 08       	cp.w	r8,0
8000300a:	c1 10       	breq	8000302c <xQueueGenericReset+0x60>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
8000300c:	ee cc ff f0 	sub	r12,r7,-16
80003010:	f0 1f 00 0a 	mcall	80003038 <xQueueGenericReset+0x6c>
80003014:	58 1c       	cp.w	r12,1
80003016:	c0 b1       	brne	8000302c <xQueueGenericReset+0x60>
				{
					queueYIELD_IF_USING_PREEMPTION();
80003018:	d7 33       	scall
8000301a:	c0 98       	rjmp	8000302c <xQueueGenericReset+0x60>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
8000301c:	ee cc ff f0 	sub	r12,r7,-16
80003020:	f0 1f 00 07 	mcall	8000303c <xQueueGenericReset+0x70>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
80003024:	ee cc ff dc 	sub	r12,r7,-36
80003028:	f0 1f 00 05 	mcall	8000303c <xQueueGenericReset+0x70>
		}
	}
	taskEXIT_CRITICAL();
8000302c:	f0 1f 00 05 	mcall	80003040 <xQueueGenericReset+0x74>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
80003030:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80003034:	80 00       	ld.sh	r0,r0[0x0]
80003036:	56 cc       	stdsp	sp[0x1b0],r12
80003038:	80 00       	ld.sh	r0,r0[0x0]
8000303a:	59 c0       	cp.w	r0,28
8000303c:	80 00       	ld.sh	r0,r0[0x0]
8000303e:	55 a8       	stdsp	sp[0x168],r8
80003040:	80 00       	ld.sh	r0,r0[0x0]
80003042:	57 d8       	stdsp	sp[0x1f4],r8

80003044 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
80003044:	eb cd 40 e0 	pushm	r5-r7,lr
80003048:	18 97       	mov	r7,r12
8000304a:	16 96       	mov	r6,r11
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000304c:	58 0c       	cp.w	r12,0
8000304e:	c1 c0       	breq	80003086 <xQueueGenericCreate+0x42>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80003050:	34 cc       	mov	r12,76
80003052:	f0 1f 00 0f 	mcall	8000308c <xQueueGenericCreate+0x48>
80003056:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80003058:	c1 70       	breq	80003086 <xQueueGenericCreate+0x42>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000305a:	ec 07 02 4c 	mul	r12,r6,r7
8000305e:	2f fc       	sub	r12,-1
80003060:	f0 1f 00 0b 	mcall	8000308c <xQueueGenericCreate+0x48>
80003064:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80003066:	c0 b0       	breq	8000307c <xQueueGenericCreate+0x38>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
80003068:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000306a:	eb 46 00 40 	st.w	r5[64],r6
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
8000306e:	30 1b       	mov	r11,1
80003070:	0a 9c       	mov	r12,r5
80003072:	f0 1f 00 08 	mcall	80003090 <xQueueGenericCreate+0x4c>
80003076:	0a 9c       	mov	r12,r5
80003078:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
8000307c:	0a 9c       	mov	r12,r5
8000307e:	f0 1f 00 06 	mcall	80003094 <xQueueGenericCreate+0x50>
80003082:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003086:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000308a:	00 00       	add	r0,r0
8000308c:	80 00       	ld.sh	r0,r0[0x0]
8000308e:	2b a0       	sub	r0,-70
80003090:	80 00       	ld.sh	r0,r0[0x0]
80003092:	2f cc       	sub	r12,-4
80003094:	80 00       	ld.sh	r0,r0[0x0]
80003096:	2b 9c       	sub	r12,-71

80003098 <mcp2515_read_array>:
	spi_deselect_device(MCP2515_SPI_ADDRESS,spi_dev);
	
	//Missing return? / --> Added 21/5-14
}

void mcp2515_read_array (struct spi_device * spi_dev, uint8_t * data, uint8_t len, uint8_t first_reg_addr ){
80003098:	eb cd 40 e0 	pushm	r5-r7,lr
8000309c:	20 1d       	sub	sp,4
8000309e:	18 97       	mov	r7,r12
800030a0:	16 95       	mov	r5,r11
800030a2:	14 96       	mov	r6,r10
	
	uint8_t dataToSend[2] = {MCP2515_INSTR_READ,first_reg_addr};
800030a4:	30 38       	mov	r8,3
800030a6:	ba 88       	st.b	sp[0x0],r8
800030a8:	ba 99       	st.b	sp[0x1],r9
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
800030aa:	19 8b       	ld.ub	r11,r12[0x0]
800030ac:	fc 7c 18 00 	mov	r12,-190464
800030b0:	f0 1f 00 0b 	mcall	800030dc <mcp2515_read_array+0x44>
		
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);
	spi_write_packet(MCP2515_SPI_ADDRESS,dataToSend,2);
800030b4:	30 2a       	mov	r10,2
800030b6:	1a 9b       	mov	r11,sp
800030b8:	fc 7c 18 00 	mov	r12,-190464
800030bc:	f0 1f 00 09 	mcall	800030e0 <mcp2515_read_array+0x48>
	spi_read_packet(MCP2515_SPI_ADDRESS,data,len);
800030c0:	0c 9a       	mov	r10,r6
800030c2:	0a 9b       	mov	r11,r5
800030c4:	fc 7c 18 00 	mov	r12,-190464
800030c8:	f0 1f 00 07 	mcall	800030e4 <mcp2515_read_array+0x4c>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
800030cc:	0f 8b       	ld.ub	r11,r7[0x0]
800030ce:	fc 7c 18 00 	mov	r12,-190464
800030d2:	f0 1f 00 06 	mcall	800030e8 <mcp2515_read_array+0x50>
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
	
800030d6:	2f fd       	sub	sp,-4
800030d8:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800030dc:	80 00       	ld.sh	r0,r0[0x0]
800030de:	20 6c       	sub	r12,6
800030e0:	80 00       	ld.sh	r0,r0[0x0]
800030e2:	24 58       	sub	r8,69
800030e4:	80 00       	ld.sh	r0,r0[0x0]
800030e6:	24 08       	sub	r8,64
800030e8:	80 00       	ld.sh	r0,r0[0x0]
800030ea:	20 2c       	sub	r12,2

800030ec <load_state>:
		ecu_data->config_max_trq
	}; 
	mcp2515_write_array(spi_dev,dataToWrite, ECU_DATA_BUF_LEN ,addr);
}

void load_state(struct spi_device * spi_dev, fsm_ecu_data_t *ecu_data) {
800030ec:	eb cd 40 80 	pushm	r7,lr
800030f0:	20 2d       	sub	sp,8
800030f2:	16 97       	mov	r7,r11
	uint8_t addr = ECU_DATA_BUF;
	uint8_t data[ECU_DATA_BUF_LEN] = {0};
800030f4:	30 09       	mov	r9,0
800030f6:	50 09       	stdsp	sp[0x0],r9
800030f8:	fa c8 ff fc 	sub	r8,sp,-4
800030fc:	b0 09       	st.h	r8[0x0],r9
800030fe:	fa c8 ff fa 	sub	r8,sp,-6
80003102:	b0 89       	st.b	r8[0x0],r9
	mcp2515_read_array(spi_dev, data, ECU_DATA_BUF_LEN, addr);
80003104:	35 69       	mov	r9,86
80003106:	30 7a       	mov	r10,7
80003108:	1a 9b       	mov	r11,sp
8000310a:	f0 1f 00 0e 	mcall	80003140 <load_state+0x54>
	ecu_data->state					 = (fsm_ecu_state_t)data[0];
8000310e:	1b 88       	ld.ub	r8,sp[0x0]
80003110:	8f 08       	st.w	r7[0x0],r8
	ecu_data->flag_start_precharge	 = data[1];
80003112:	1b 98       	ld.ub	r8,sp[0x1]
80003114:	ef 68 00 46 	st.b	r7[70],r8
	ecu_data->flag_drive_enable		 = (flag_drive_enable_t)data[2];
80003118:	1b a8       	ld.ub	r8,sp[0x2]
8000311a:	ef 48 00 4c 	st.w	r7[76],r8
	ecu_data->flag_brake_implausible = data[3];
8000311e:	1b b8       	ld.ub	r8,sp[0x3]
80003120:	ef 68 00 47 	st.b	r7[71],r8
	uint16_t temp					 = data[4] << 8;
	ecu_data->trq_pid				 = (int16_t)(temp | (uint16_t)data[5]);
80003124:	1b c9       	ld.ub	r9,sp[0x4]
80003126:	1b d8       	ld.ub	r8,sp[0x5]
80003128:	f1 e9 10 88 	or	r8,r8,r9<<0x8
8000312c:	5c 88       	casts.h	r8
8000312e:	e5 a6 08 08 	cop	cp0,cr8,cr0,cr8,0x4c
80003132:	8f 68       	st.w	r7[0x18],r8
	ecu_data->config_max_trq		 = (uint8_t)data[6];
80003134:	1b e8       	ld.ub	r8,sp[0x6]
80003136:	ef 68 00 65 	st.b	r7[101],r8
}
8000313a:	2f ed       	sub	sp,-8
8000313c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003140:	80 00       	ld.sh	r0,r0[0x0]
80003142:	30 98       	mov	r8,9

80003144 <mcp2515_readRXbuffer>:
	spi_write_packet(MCP2515_SPI_ADDRESS,bitModifyMessage,4);
	spi_deselect_device(MCP2515_SPI_ADDRESS,spi_dev);
	
}

uint8_t mcp2515_readRXbuffer ( struct spi_device * spi_dev, uint8_t bufferNumber, uint8_t * data, uint8_t dlc){
80003144:	d4 21       	pushm	r4-r7,lr
80003146:	18 96       	mov	r6,r12
80003148:	14 94       	mov	r4,r10
8000314a:	12 95       	mov	r5,r9
8000314c:	30 18       	mov	r8,1
8000314e:	f0 0b 18 00 	cp.b	r11,r8
80003152:	e0 88 00 04 	brls	8000315a <mcp2515_readRXbuffer+0x16>
80003156:	30 27       	mov	r7,2
80003158:	c0 48       	rjmp	80003160 <mcp2515_readRXbuffer+0x1c>
8000315a:	48 d8       	lddpc	r8,8000318c <mcp2515_readRXbuffer+0x48>
8000315c:	f0 0b 07 07 	ld.ub	r7,r8[r11]
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
80003160:	0d 8b       	ld.ub	r11,r6[0x0]
80003162:	fc 7c 18 00 	mov	r12,-190464
80003166:	f0 1f 00 0b 	mcall	80003190 <mcp2515_readRXbuffer+0x4c>
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(volatile avr32_spi_t *spi, uint16_t data)
{
	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000316a:	0e 98       	mov	r8,r7
8000316c:	e8 18 00 90 	orl	r8,0x90
80003170:	fc 77 18 00 	mov	r7,-190464
80003174:	8f 38       	st.w	r7[0xc],r8
	
	spi_select_device(MCP2515_SPI_ADDRESS,spi_dev);
	
	uint8_t spi_cmd = MCP2515_INSTR_READ_RX_BUF | rxBufferReadAddress;
	spi_write_single(MCP2515_SPI_ADDRESS, spi_cmd);
	spi_read_packet(MCP2515_SPI_ADDRESS,data,dlc);	
80003176:	0a 9a       	mov	r10,r5
80003178:	08 9b       	mov	r11,r4
8000317a:	0e 9c       	mov	r12,r7
8000317c:	f0 1f 00 06 	mcall	80003194 <mcp2515_readRXbuffer+0x50>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
80003180:	0d 8b       	ld.ub	r11,r6[0x0]
80003182:	0e 9c       	mov	r12,r7
80003184:	f0 1f 00 05 	mcall	80003198 <mcp2515_readRXbuffer+0x54>
	
	spi_deselect_device(MCP2515_SPI_ADDRESS,spi_dev);
	
	//Missing return? / --> Added 21/5-14
}
80003188:	d8 22       	popm	r4-r7,pc
8000318a:	00 00       	add	r0,r0
8000318c:	80 00       	ld.sh	r0,r0[0x0]
8000318e:	7c 00       	ld.w	r0,lr[0x0]
80003190:	80 00       	ld.sh	r0,r0[0x0]
80003192:	20 6c       	sub	r12,6
80003194:	80 00       	ld.sh	r0,r0[0x0]
80003196:	24 08       	sub	r8,64
80003198:	80 00       	ld.sh	r0,r0[0x0]
8000319a:	20 2c       	sub	r12,2

8000319c <mcp2515_write_array>:
	regValue &= MCP2515_MODE_bm;
	
	return ( regValue >> 5);
}

void mcp2515_write_array (struct spi_device * spi_dev, uint8_t * data, uint8_t len, uint8_t first_reg_addr ){		//This function is not working, must be fixed
8000319c:	d4 21       	pushm	r4-r7,lr
8000319e:	20 3d       	sub	sp,12
800031a0:	18 97       	mov	r7,r12
800031a2:	14 96       	mov	r6,r10
	
	uint8_t dataToSend[10] = {MCP2515_INSTR_WRITE,first_reg_addr};
800031a4:	30 04       	mov	r4,0
800031a6:	30 05       	mov	r5,0
800031a8:	fa e5 00 00 	st.d	sp[0],r4
800031ac:	30 08       	mov	r8,0
800031ae:	ba 48       	st.h	sp[0x8],r8
800031b0:	30 28       	mov	r8,2
800031b2:	ba 88       	st.b	sp[0x0],r8
800031b4:	ba 99       	st.b	sp[0x1],r9
800031b6:	fa c8 ff fe 	sub	r8,sp,-2
	regValue &= MCP2515_MODE_bm;
	
	return ( regValue >> 5);
}

void mcp2515_write_array (struct spi_device * spi_dev, uint8_t * data, uint8_t len, uint8_t first_reg_addr ){		//This function is not working, must be fixed
800031ba:	fa ca ff f5 	sub	r10,sp,-11
	
	uint8_t dataToSend[10] = {MCP2515_INSTR_WRITE,first_reg_addr};
	
	for ( uint8_t i = 2 ; i < 11 ; ++i){
		dataToSend[i] = data[i-2]; 
800031be:	17 39       	ld.ub	r9,r11++
800031c0:	10 c9       	st.b	r8++,r9

void mcp2515_write_array (struct spi_device * spi_dev, uint8_t * data, uint8_t len, uint8_t first_reg_addr ){		//This function is not working, must be fixed
	
	uint8_t dataToSend[10] = {MCP2515_INSTR_WRITE,first_reg_addr};
	
	for ( uint8_t i = 2 ; i < 11 ; ++i){
800031c2:	14 38       	cp.w	r8,r10
800031c4:	cf d1       	brne	800031be <mcp2515_write_array+0x22>
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
800031c6:	0f 8b       	ld.ub	r11,r7[0x0]
800031c8:	fc 7c 18 00 	mov	r12,-190464
800031cc:	f0 1f 00 08 	mcall	800031ec <mcp2515_write_array+0x50>
		dataToSend[i] = data[i-2]; 
	}
	
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);	
	spi_write_packet(MCP2515_SPI_ADDRESS,dataToSend,len+2);
800031d0:	ec ca ff fe 	sub	r10,r6,-2
800031d4:	1a 9b       	mov	r11,sp
800031d6:	fc 7c 18 00 	mov	r12,-190464
800031da:	f0 1f 00 06 	mcall	800031f0 <mcp2515_write_array+0x54>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
800031de:	0f 8b       	ld.ub	r11,r7[0x0]
800031e0:	fc 7c 18 00 	mov	r12,-190464
800031e4:	f0 1f 00 04 	mcall	800031f4 <mcp2515_write_array+0x58>
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);

}
800031e8:	2f dd       	sub	sp,-12
800031ea:	d8 22       	popm	r4-r7,pc
800031ec:	80 00       	ld.sh	r0,r0[0x0]
800031ee:	20 6c       	sub	r12,6
800031f0:	80 00       	ld.sh	r0,r0[0x0]
800031f2:	24 58       	sub	r8,69
800031f4:	80 00       	ld.sh	r0,r0[0x0]
800031f6:	20 2c       	sub	r12,2

800031f8 <save_state>:
	gpio_set_pin_high(LED1);
	return DLC;

}

void save_state(struct spi_device * spi_dev, fsm_ecu_data_t *ecu_data) {
800031f8:	eb cd 40 80 	pushm	r7,lr
800031fc:	20 2d       	sub	sp,8
	uint8_t addr = ECU_DATA_BUF;
	uint8_t dataToWrite[ECU_DATA_BUF_LEN] = { 
		ecu_data->state,
		ecu_data->flag_start_precharge,
800031fe:	f7 37 00 46 	ld.ub	r7,r11[70]
		(uint8_t)ecu_data->flag_drive_enable,
80003202:	f7 3e 00 4f 	ld.ub	lr,r11[79]
		ecu_data->flag_brake_implausible,
80003206:	f7 3a 00 47 	ld.ub	r10,r11[71]
		(int8_t)((int16_t)ecu_data->trq_pid >> 8),
		(int8_t)(ecu_data->trq_pid),
		ecu_data->config_max_trq
	}; 
8000320a:	76 68       	ld.w	r8,r11[0x18]
		ecu_data->flag_start_precharge,
		(uint8_t)ecu_data->flag_drive_enable,
		ecu_data->flag_brake_implausible,
		(int8_t)((int16_t)ecu_data->trq_pid >> 8),
		(int8_t)(ecu_data->trq_pid),
		ecu_data->config_max_trq
8000320c:	f7 39 00 65 	ld.ub	r9,r11[101]
	}; 
80003210:	76 0b       	ld.w	r11,r11[0x0]
80003212:	ba 8b       	st.b	sp[0x0],r11
80003214:	ba 97       	st.b	sp[0x1],r7
80003216:	ba ae       	st.b	sp[0x2],lr
80003218:	ba ba       	st.b	sp[0x3],r10
8000321a:	e5 ab 08 08 	cop	cp0,cr8,cr0,cr8,0x56
8000321e:	f5 d8 b1 08 	bfexts	r10,r8,0x8,0x8
80003222:	ba ca       	st.b	sp[0x4],r10
80003224:	ba d8       	st.b	sp[0x5],r8
80003226:	ba e9       	st.b	sp[0x6],r9
	mcp2515_write_array(spi_dev,dataToWrite, ECU_DATA_BUF_LEN ,addr);
80003228:	35 69       	mov	r9,86
8000322a:	30 7a       	mov	r10,7
8000322c:	1a 9b       	mov	r11,sp
8000322e:	f0 1f 00 03 	mcall	80003238 <save_state+0x40>
}
80003232:	2f ed       	sub	sp,-8
80003234:	e3 cd 80 80 	ldm	sp++,r7,pc
80003238:	80 00       	ld.sh	r0,r0[0x0]
8000323a:	31 9c       	mov	r12,25

8000323c <mcp2515_setToMode>:
	mcp2515_writeRegister (spi_dev, controlRegisterAddress, dataTransmissionSetting );
	gpio_set_pin_high(LED2);
	//done
}

void mcp2515_setToMode (struct spi_device * spi_dev, mcp2515_mode_t mode ){
8000323c:	eb cd 40 80 	pushm	r7,lr
80003240:	20 1d       	sub	sp,4
80003242:	18 97       	mov	r7,r12
	uint8_t data[4] = {
		MCP2515_CMD_BIT_MODIFY,
		MCP2515_CAN_CTRL_REG_ADDR,	
		MCP2515_MODE_bm ,	
		( mode << 5 )				// data
	};
80003244:	30 58       	mov	r8,5
80003246:	ba 88       	st.b	sp[0x0],r8
80003248:	30 f8       	mov	r8,15
8000324a:	ba 98       	st.b	sp[0x1],r8
8000324c:	3e 08       	mov	r8,-32
8000324e:	ba a8       	st.b	sp[0x2],r8
80003250:	a5 7b       	lsl	r11,0x5
80003252:	ba bb       	st.b	sp[0x3],r11
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
80003254:	19 8b       	ld.ub	r11,r12[0x0]
80003256:	fc 7c 18 00 	mov	r12,-190464
8000325a:	f0 1f 00 09 	mcall	8000327c <mcp2515_setToMode+0x40>
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);
	spi_write_packet(MCP2515_SPI_ADDRESS, data, 4);
8000325e:	30 4a       	mov	r10,4
80003260:	1a 9b       	mov	r11,sp
80003262:	fc 7c 18 00 	mov	r12,-190464
80003266:	f0 1f 00 07 	mcall	80003280 <mcp2515_setToMode+0x44>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
8000326a:	0f 8b       	ld.ub	r11,r7[0x0]
8000326c:	fc 7c 18 00 	mov	r12,-190464
80003270:	f0 1f 00 05 	mcall	80003284 <mcp2515_setToMode+0x48>
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
	
	
}
80003274:	2f fd       	sub	sp,-4
80003276:	e3 cd 80 80 	ldm	sp++,r7,pc
8000327a:	00 00       	add	r0,r0
8000327c:	80 00       	ld.sh	r0,r0[0x0]
8000327e:	20 6c       	sub	r12,6
80003280:	80 00       	ld.sh	r0,r0[0x0]
80003282:	24 58       	sub	r8,69
80003284:	80 00       	ld.sh	r0,r0[0x0]
80003286:	20 2c       	sub	r12,2

80003288 <mcp2515_readRegister>:
	
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
}


uint8_t mcp2515_readRegister ( struct spi_device * spi_dev, uint8_t reg_addr ){
80003288:	eb cd 40 c0 	pushm	r6-r7,lr
8000328c:	20 2d       	sub	sp,8
8000328e:	18 97       	mov	r7,r12
80003290:	16 96       	mov	r6,r11
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
80003292:	19 8b       	ld.ub	r11,r12[0x0]
80003294:	fc 7c 18 00 	mov	r12,-190464
80003298:	f0 1f 00 0f 	mcall	800032d4 <mcp2515_readRegister+0x4c>
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);
	
	uint8_t data[2] = {
		MCP2515_INSTR_READ,
		reg_addr
	};
8000329c:	30 38       	mov	r8,3
8000329e:	ba c8       	st.b	sp[0x4],r8
800032a0:	ba d6       	st.b	sp[0x5],r6
		
	spi_write_packet(MCP2515_SPI_ADDRESS, data, 2 );
800032a2:	30 2a       	mov	r10,2
800032a4:	fa cb ff fc 	sub	r11,sp,-4
800032a8:	fc 7c 18 00 	mov	r12,-190464
800032ac:	f0 1f 00 0b 	mcall	800032d8 <mcp2515_readRegister+0x50>
	uint8_t registerValue[1] = {0x00};
800032b0:	30 08       	mov	r8,0
800032b2:	ba 88       	st.b	sp[0x0],r8
	
	spi_read_packet(MCP2515_SPI_ADDRESS, registerValue, 1 );
800032b4:	30 1a       	mov	r10,1
800032b6:	1a 9b       	mov	r11,sp
800032b8:	fc 7c 18 00 	mov	r12,-190464
800032bc:	f0 1f 00 08 	mcall	800032dc <mcp2515_readRegister+0x54>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
800032c0:	0f 8b       	ld.ub	r11,r7[0x0]
800032c2:	fc 7c 18 00 	mov	r12,-190464
800032c6:	f0 1f 00 07 	mcall	800032e0 <mcp2515_readRegister+0x58>

	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
	return registerValue[0];
	
}
800032ca:	1b 8c       	ld.ub	r12,sp[0x0]
800032cc:	2f ed       	sub	sp,-8
800032ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800032d2:	00 00       	add	r0,r0
800032d4:	80 00       	ld.sh	r0,r0[0x0]
800032d6:	20 6c       	sub	r12,6
800032d8:	80 00       	ld.sh	r0,r0[0x0]
800032da:	24 58       	sub	r8,69
800032dc:	80 00       	ld.sh	r0,r0[0x0]
800032de:	24 08       	sub	r8,64
800032e0:	80 00       	ld.sh	r0,r0[0x0]
800032e2:	20 2c       	sub	r12,2

800032e4 <mcp2515_getCurrentMode>:
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
	
	
}

mcp2515_mode_t mcp2515_getCurrentMode ( struct spi_device * spi_dev ){
800032e4:	d4 01       	pushm	lr
	
	uint8_t regValue = mcp2515_readRegister(spi_dev, MCP2515_CAN_CTRL_REG_ADDR);
800032e6:	30 fb       	mov	r11,15
800032e8:	f0 1f 00 03 	mcall	800032f4 <mcp2515_getCurrentMode+0x10>
	regValue &= MCP2515_MODE_bm;
	
	return ( regValue >> 5);
}
800032ec:	f9 dc c0 a3 	bfextu	r12,r12,0x5,0x3
800032f0:	d8 02       	popm	pc
800032f2:	00 00       	add	r0,r0
800032f4:	80 00       	ld.sh	r0,r0[0x0]
800032f6:	32 88       	mov	r8,40

800032f8 <mcp2515_writeRegister>:
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);
	spi_write_single(MCP2515_SPI_ADDRESS, MCP2515_INSTR_RESET);
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
}

void mcp2515_writeRegister ( struct spi_device * spi_dev, uint8_t reg_addr, uint8_t reg_data ){
800032f8:	eb cd 40 e0 	pushm	r5-r7,lr
800032fc:	20 1d       	sub	sp,4
800032fe:	18 97       	mov	r7,r12
80003300:	16 96       	mov	r6,r11
80003302:	14 95       	mov	r5,r10
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
80003304:	19 8b       	ld.ub	r11,r12[0x0]
80003306:	fc 7c 18 00 	mov	r12,-190464
8000330a:	f0 1f 00 0b 	mcall	80003334 <mcp2515_writeRegister+0x3c>
	
	uint8_t data[3] = {
		MCP2515_INSTR_WRITE,
		reg_addr,
		reg_data
	};
8000330e:	30 28       	mov	r8,2
80003310:	ba 88       	st.b	sp[0x0],r8
80003312:	ba 96       	st.b	sp[0x1],r6
80003314:	ba a5       	st.b	sp[0x2],r5
	
	spi_write_packet(MCP2515_SPI_ADDRESS, data,3);
80003316:	30 3a       	mov	r10,3
80003318:	1a 9b       	mov	r11,sp
8000331a:	fc 7c 18 00 	mov	r12,-190464
8000331e:	f0 1f 00 07 	mcall	80003338 <mcp2515_writeRegister+0x40>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
80003322:	0f 8b       	ld.ub	r11,r7[0x0]
80003324:	fc 7c 18 00 	mov	r12,-190464
80003328:	f0 1f 00 05 	mcall	8000333c <mcp2515_writeRegister+0x44>
	
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
}
8000332c:	2f fd       	sub	sp,-4
8000332e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003332:	00 00       	add	r0,r0
80003334:	80 00       	ld.sh	r0,r0[0x0]
80003336:	20 6c       	sub	r12,6
80003338:	80 00       	ld.sh	r0,r0[0x0]
8000333a:	24 58       	sub	r8,69
8000333c:	80 00       	ld.sh	r0,r0[0x0]
8000333e:	20 2c       	sub	r12,2

80003340 <mcp2515_reset>:

	return 1;
	
}

void mcp2515_reset( struct spi_device * spi_dev ){
80003340:	eb cd 40 80 	pushm	r7,lr
80003344:	18 97       	mov	r7,r12
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
80003346:	19 8b       	ld.ub	r11,r12[0x0]
80003348:	fc 7c 18 00 	mov	r12,-190464
8000334c:	f0 1f 00 06 	mcall	80003364 <mcp2515_reset+0x24>
80003350:	fc 7c 18 00 	mov	r12,-190464
80003354:	e0 68 00 c0 	mov	r8,192
80003358:	99 38       	st.w	r12[0xc],r8
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
8000335a:	0f 8b       	ld.ub	r11,r7[0x0]
8000335c:	f0 1f 00 03 	mcall	80003368 <mcp2515_reset+0x28>
	
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);
	spi_write_single(MCP2515_SPI_ADDRESS, MCP2515_INSTR_RESET);
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
}
80003360:	e3 cd 80 80 	ldm	sp++,r7,pc
80003364:	80 00       	ld.sh	r0,r0[0x0]
80003366:	20 6c       	sub	r12,6
80003368:	80 00       	ld.sh	r0,r0[0x0]
8000336a:	20 2c       	sub	r12,2

8000336c <mcp2515_init>:
	spi_enable(SPI_ADRESS);
	return spi_device_conf;
}


uint8_t mcp2515_init ( struct spi_device * spi_dev ){
8000336c:	eb cd 40 80 	pushm	r7,lr
80003370:	18 97       	mov	r7,r12

	
	mcp2515_reset(spi_dev);
80003372:	f0 1f 00 1a 	mcall	800033d8 <mcp2515_init+0x6c>
	
	mcp2515_mode_t currentMode = mcp2515_getCurrentMode(spi_dev); 	
80003376:	0e 9c       	mov	r12,r7
80003378:	f0 1f 00 19 	mcall	800033dc <mcp2515_init+0x70>
	if ( currentMode != CONFIG ){
8000337c:	58 4c       	cp.w	r12,4
8000337e:	c0 30       	breq	80003384 <mcp2515_init+0x18>
80003380:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	}
	
	
	// setup receive buffers:
	uint8_t receiveBuffer0Settings = RX_MASK_FILTER_OFF_bm;
	mcp2515_writeRegister(spi_dev, RXB0CTRL, receiveBuffer0Settings );
80003384:	36 0a       	mov	r10,96
80003386:	14 9b       	mov	r11,r10
80003388:	0e 9c       	mov	r12,r7
8000338a:	f0 1f 00 16 	mcall	800033e0 <mcp2515_init+0x74>
	
	uint8_t receiveBuffer1Settings = RX_MASK_FILTER_OFF_bm;
	mcp2515_writeRegister(spi_dev, RXB1CTRL, receiveBuffer1Settings );
8000338e:	36 0a       	mov	r10,96
80003390:	37 0b       	mov	r11,112
80003392:	0e 9c       	mov	r12,r7
80003394:	f0 1f 00 13 	mcall	800033e0 <mcp2515_init+0x74>
	
	
	uint8_t interruptSettings = RX0IE_bm | RX1IE_bm;		//enable interrupts on full receive buffers
	mcp2515_writeRegister(spi_dev,CANINTE,interruptSettings);
80003398:	30 3a       	mov	r10,3
8000339a:	32 bb       	mov	r11,43
8000339c:	0e 9c       	mov	r12,r7
8000339e:	f0 1f 00 11 	mcall	800033e0 <mcp2515_init+0x74>
	
	
	
	// set timing bits
	uint8_t cnf1RegisterSettings = SJW_LENGTH_1XTQ_bm | CAN_BAUD_RATE_PRESCALER;
	mcp2515_writeRegister(spi_dev, CNF1, cnf1RegisterSettings );
800033a2:	30 0a       	mov	r10,0
800033a4:	32 ab       	mov	r11,42
800033a6:	0e 9c       	mov	r12,r7
800033a8:	f0 1f 00 0e 	mcall	800033e0 <mcp2515_init+0x74>
	
	uint8_t cnf2RegisterSettings = PRSEG_2_bm | PHSEG1_1_bm | BTLMODE_1_bm; 
	mcp2515_writeRegister(spi_dev,CNF2,cnf2RegisterSettings);
800033ac:	e0 6a 00 8a 	mov	r10,138
800033b0:	32 9b       	mov	r11,41
800033b2:	0e 9c       	mov	r12,r7
800033b4:	f0 1f 00 0b 	mcall	800033e0 <mcp2515_init+0x74>
	
	uint8_t cnf3RegisterSettings = 	PHSEG2_1_bm;
	mcp2515_writeRegister(spi_dev,CNF3,cnf3RegisterSettings);
800033b8:	30 1a       	mov	r10,1
800033ba:	32 8b       	mov	r11,40
800033bc:	0e 9c       	mov	r12,r7
800033be:	f0 1f 00 09 	mcall	800033e0 <mcp2515_init+0x74>
	
	
	
	
	mcp2515_setToMode(spi_dev,NORMAL);			// finish initializing
800033c2:	30 0b       	mov	r11,0
800033c4:	0e 9c       	mov	r12,r7
800033c6:	f0 1f 00 08 	mcall	800033e4 <mcp2515_init+0x78>
	currentMode = mcp2515_getCurrentMode(spi_dev);
800033ca:	0e 9c       	mov	r12,r7
800033cc:	f0 1f 00 04 	mcall	800033dc <mcp2515_init+0x70>
800033d0:	5f 0c       	sreq	r12
		return 0;
	}

	return 1;
	
}
800033d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800033d6:	00 00       	add	r0,r0
800033d8:	80 00       	ld.sh	r0,r0[0x0]
800033da:	33 40       	mov	r0,52
800033dc:	80 00       	ld.sh	r0,r0[0x0]
800033de:	32 e4       	mov	r4,46
800033e0:	80 00       	ld.sh	r0,r0[0x0]
800033e2:	32 f8       	mov	r8,47
800033e4:	80 00       	ld.sh	r0,r0[0x0]
800033e6:	32 3c       	mov	r12,35

800033e8 <mcp2515_getReceivedMessage>:
	interruptFlagRegister = mcp2515_readRegister(spi_dev, CANINTF );
	
	return interruptFlagRegister & ( 0b11 << 0 );
}

uint8_t mcp2515_getReceivedMessage ( struct spi_device * spi_dev, uint8_t bufferNum, uint8_t * data, uint8_t len ){
800033e8:	d4 21       	pushm	r4-r7,lr
800033ea:	18 95       	mov	r5,r12
800033ec:	16 97       	mov	r7,r11
800033ee:	14 94       	mov	r4,r10
	gpio_set_pin_low(LED1);
800033f0:	35 3c       	mov	r12,83
800033f2:	f0 1f 00 10 	mcall	80003430 <mcp2515_getReceivedMessage+0x48>
	uint8_t messageAddress;
	uint8_t messageDLCAddress;
	uint8_t receivedMessageInterrupt_bm;

	switch(bufferNum){
800033f6:	58 07       	cp.w	r7,0
800033f8:	c0 a0       	breq	8000340c <mcp2515_getReceivedMessage+0x24>
800033fa:	30 18       	mov	r8,1
800033fc:	f0 07 18 00 	cp.b	r7,r8
80003400:	c0 40       	breq	80003408 <mcp2515_getReceivedMessage+0x20>
80003402:	e0 66 00 ff 	mov	r6,255
80003406:	c1 28       	rjmp	8000342a <mcp2515_getReceivedMessage+0x42>
80003408:	37 5b       	mov	r11,117
8000340a:	c0 28       	rjmp	8000340e <mcp2515_getReceivedMessage+0x26>
8000340c:	36 5b       	mov	r11,101
			return 0xFF; //faulty call of function
	}
	
	
	//get DLC:
	uint8_t DLC =  mcp2515_readRegister(spi_dev, messageDLCAddress);
8000340e:	0a 9c       	mov	r12,r5
80003410:	f0 1f 00 09 	mcall	80003434 <mcp2515_getReceivedMessage+0x4c>
	DLC &= RX_DLC_BITS_bm;	// filter away any unwanted bits
80003414:	ed dc c0 04 	bfextu	r6,r12,0x0,0x4
	
	// get Data:
	mcp2515_readRXbuffer(spi_dev,bufferNum,data,DLC);	
80003418:	0c 99       	mov	r9,r6
8000341a:	08 9a       	mov	r10,r4
8000341c:	0e 9b       	mov	r11,r7
8000341e:	0a 9c       	mov	r12,r5
80003420:	f0 1f 00 06 	mcall	80003438 <mcp2515_getReceivedMessage+0x50>
	//mcp2515_read_array(spi_dev,data,DLC,messageAddress);
	
	
	//reset interrupt flag: (perhaps no longer needed due to the readRXbuffer function over - it should automatically reset the flag)
	//mcp2515_bitModifyRegister(spi_dev, CANINTF, receivedMessageInterrupt_bm,0x00);
	gpio_set_pin_high(LED1);
80003424:	35 3c       	mov	r12,83
80003426:	f0 1f 00 06 	mcall	8000343c <mcp2515_getReceivedMessage+0x54>
	return DLC;

}
8000342a:	0c 9c       	mov	r12,r6
8000342c:	d8 22       	popm	r4-r7,pc
8000342e:	00 00       	add	r0,r0
80003430:	80 00       	ld.sh	r0,r0[0x0]
80003432:	68 40       	ld.w	r0,r4[0x10]
80003434:	80 00       	ld.sh	r0,r0[0x0]
80003436:	32 88       	mov	r8,40
80003438:	80 00       	ld.sh	r0,r0[0x0]
8000343a:	31 44       	mov	r4,20
8000343c:	80 00       	ld.sh	r0,r0[0x0]
8000343e:	68 2a       	ld.w	r10,r4[0x8]

80003440 <mcp2515_sendCanMessage>:
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
	return registerValue[0];
	
}

void mcp2515_sendCanMessage ( struct spi_device * spi_dev, uint8_t DLC, uint8_t * data, uint16_t address, uint8_t bufferNumber ){
80003440:	eb cd 40 fe 	pushm	r1-r7,lr
80003444:	18 97       	mov	r7,r12
80003446:	16 94       	mov	r4,r11
80003448:	14 93       	mov	r3,r10
8000344a:	12 95       	mov	r5,r9
8000344c:	10 96       	mov	r6,r8
	
	gpio_set_pin_low(LED2);
8000344e:	35 2c       	mov	r12,82
80003450:	f0 1f 00 1b 	mcall	800034bc <mcp2515_sendCanMessage+0x7c>
	uint8_t messageAddress;
	uint8_t messageDLCAddress;
	uint8_t dataAddress;
	uint8_t controlRegisterAddress;
	
	switch(bufferNumber){
80003454:	58 06       	cp.w	r6,0
80003456:	c0 a0       	breq	8000346a <mcp2515_sendCanMessage+0x2a>
80003458:	30 18       	mov	r8,1
8000345a:	f0 06 18 00 	cp.b	r6,r8
8000345e:	c2 c1       	brne	800034b6 <mcp2515_sendCanMessage+0x76>
80003460:	34 01       	mov	r1,64
80003462:	34 62       	mov	r2,70
80003464:	34 5b       	mov	r11,69
80003466:	34 16       	mov	r6,65
80003468:	c0 58       	rjmp	80003472 <mcp2515_sendCanMessage+0x32>
8000346a:	33 01       	mov	r1,48
8000346c:	33 62       	mov	r2,54
8000346e:	33 5b       	mov	r11,53
80003470:	33 16       	mov	r6,49
	//	dataToSend[i] = data[i-5];
	//}
	//mcp2515_write_array(spi_dev,dataToSend,5+DLC,messageAddress);
	
	// Set up length of message
	mcp2515_writeRegister(spi_dev, messageDLCAddress, DLC );
80003472:	08 9a       	mov	r10,r4
80003474:	0e 9c       	mov	r12,r7
80003476:	f0 1f 00 13 	mcall	800034c0 <mcp2515_sendCanMessage+0x80>
	
	// set up address
	uint8_t addressMSB = ( address >> 3);
	mcp2515_writeRegister(spi_dev, messageAddress, addressMSB );
8000347a:	f5 d5 c0 68 	bfextu	r10,r5,0x3,0x8
8000347e:	0c 9b       	mov	r11,r6
80003480:	0e 9c       	mov	r12,r7
80003482:	f0 1f 00 10 	mcall	800034c0 <mcp2515_sendCanMessage+0x80>
	uint8_t addressLSB = (address << 5);
	mcp2515_writeRegister(spi_dev, messageAddress + 1 , addressLSB);
80003486:	ea 0a 15 05 	lsl	r10,r5,0x5
8000348a:	ec cb ff ff 	sub	r11,r6,-1
8000348e:	e2 1a 00 e0 	andl	r10,0xe0,COH
80003492:	5c 5b       	castu.b	r11
80003494:	0e 9c       	mov	r12,r7
80003496:	f0 1f 00 0b 	mcall	800034c0 <mcp2515_sendCanMessage+0x80>
	
	// set up data
	
	mcp2515_write_array(spi_dev,data,DLC,dataAddress);
8000349a:	04 99       	mov	r9,r2
8000349c:	08 9a       	mov	r10,r4
8000349e:	06 9b       	mov	r11,r3
800034a0:	0e 9c       	mov	r12,r7
800034a2:	f0 1f 00 09 	mcall	800034c4 <mcp2515_sendCanMessage+0x84>
	
	// Request data transmission, priority set to low
	uint8_t dataTransmissionSetting = MCP2515_CAN_MESSAGE_PRIORITY_HIGHEST_bm | MCP2515_CAN_TRANSMIT_REQUEST_bm;
	mcp2515_writeRegister (spi_dev, controlRegisterAddress, dataTransmissionSetting );
800034a6:	30 ba       	mov	r10,11
800034a8:	02 9b       	mov	r11,r1
800034aa:	0e 9c       	mov	r12,r7
800034ac:	f0 1f 00 05 	mcall	800034c0 <mcp2515_sendCanMessage+0x80>
	gpio_set_pin_high(LED2);
800034b0:	35 2c       	mov	r12,82
800034b2:	f0 1f 00 06 	mcall	800034c8 <mcp2515_sendCanMessage+0x88>
800034b6:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800034ba:	00 00       	add	r0,r0
800034bc:	80 00       	ld.sh	r0,r0[0x0]
800034be:	68 40       	ld.w	r0,r4[0x10]
800034c0:	80 00       	ld.sh	r0,r0[0x0]
800034c2:	32 f8       	mov	r8,47
800034c4:	80 00       	ld.sh	r0,r0[0x0]
800034c6:	31 9c       	mov	r12,25
800034c8:	80 00       	ld.sh	r0,r0[0x0]
800034ca:	68 2a       	ld.w	r10,r4[0x8]

800034cc <spi_init_module>:
	gpio_enable_module(MCP2515_SPI_GPIO_MAP,
	sizeof(MCP2515_SPI_GPIO_MAP) / sizeof(MCP2515_SPI_GPIO_MAP[0]));

}

struct spi_device spi_init_module(void) {
800034cc:	eb cd 40 c0 	pushm	r6-r7,lr
800034d0:	20 1d       	sub	sp,4
	struct spi_device spi_device_conf = {
		.id = 0
	};
800034d2:	fa c7 ff fc 	sub	r7,sp,-4
800034d6:	30 08       	mov	r8,0
800034d8:	0e f8       	st.b	--r7,r8
 * \brief Enable a module clock derived from the PBC clock
 * \param index Index of the module clock in the PBCMASK register
 */
static inline void sysclk_enable_pbc_module(unsigned int index)
{
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBC, index);
800034da:	30 3b       	mov	r11,3
800034dc:	30 4c       	mov	r12,4
800034de:	f0 1f 00 1b 	mcall	80003548 <spi_init_module+0x7c>
 * \param spi       Base address of the SPI instance.
 *
 */
static inline void spi_reset(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800034e2:	fc 76 18 00 	mov	r6,-190464
800034e6:	e0 68 00 80 	mov	r8,128
800034ea:	8d 08       	st.w	r6[0x0],r8
 *
 * \param spi         Base address of the SPI instance.
 */
static inline void spi_set_master_mode(volatile avr32_spi_t *spi)
{
	spi->MR.mstr = 1;
800034ec:	6c 18       	ld.w	r8,r6[0x4]
800034ee:	30 19       	mov	r9,1
800034f0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
800034f4:	8d 18       	st.w	r6[0x4],r8
 *
 * \param spi Base address of the SPI instance.
 */
static inline void spi_disable_modfault(volatile avr32_spi_t *spi)
{
	spi->MR.modfdis = 1;
800034f6:	6c 18       	ld.w	r8,r6[0x4]
800034f8:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
800034fc:	8d 18       	st.w	r6[0x4],r8
 *
 * \param spi Base address of the SPI instance.
 */
static inline void spi_disable_loopback(volatile avr32_spi_t *spi)
{
	spi->MR.llb = 0;
800034fe:	6c 18       	ld.w	r8,r6[0x4]
80003500:	30 0a       	mov	r10,0
80003502:	f1 da d0 e1 	bfins	r8,r10,0x7,0x1
80003506:	8d 18       	st.w	r6[0x4],r8
 * \param chip_select Chip Select.
 */
static inline void spi_set_chipselect(volatile avr32_spi_t *spi,
		uint8_t chip_select)
{
	spi->MR.pcs = chip_select;
80003508:	6c 18       	ld.w	r8,r6[0x4]
8000350a:	30 f9       	mov	r9,15
8000350c:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
80003510:	8d 18       	st.w	r6[0x4],r8
 *
 * \param spi         Base address of the SPI instance.
 */
static inline void spi_disable_variable_chipselect(volatile avr32_spi_t *spi)
{
	spi->MR.ps = 0;
80003512:	6c 18       	ld.w	r8,r6[0x4]
80003514:	f1 da d0 21 	bfins	r8,r10,0x1,0x1
80003518:	8d 18       	st.w	r6[0x4],r8
 *
 * \param spi Base address of the SPI instance.
 */
static inline void spi_disable_chipselect_decoding(volatile avr32_spi_t *spi)
{
	spi->MR.pcsdec = 0;
8000351a:	6c 18       	ld.w	r8,r6[0x4]
8000351c:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
80003520:	8d 18       	st.w	r6[0x4],r8
 * \param spi         Base address of the SPI instance.
 * \param delay       Delay.
 */
static inline void spi_set_delay(volatile avr32_spi_t *spi, uint8_t delay)
{
	spi->MR.dlybcs = delay;
80003522:	6c 18       	ld.w	r8,r6[0x4]
80003524:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
80003528:	8d 18       	st.w	r6[0x4],r8

	spi_master_init(SPI_ADRESS);
	spi_master_setup_device(SPI_ADRESS, &spi_device_conf, SPI_MODE_0, 1000000, 0);
8000352a:	14 98       	mov	r8,r10
8000352c:	ee 79 42 40 	mov	r9,1000000
80003530:	0e 9b       	mov	r11,r7
80003532:	0c 9c       	mov	r12,r6
80003534:	f0 1f 00 06 	mcall	8000354c <spi_init_module+0x80>
	spi_enable(SPI_ADRESS);
80003538:	0c 9c       	mov	r12,r6
8000353a:	f0 1f 00 06 	mcall	80003550 <spi_init_module+0x84>
	return spi_device_conf;
}
8000353e:	1b bc       	ld.ub	r12,sp[0x3]
80003540:	2f fd       	sub	sp,-4
80003542:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003546:	00 00       	add	r0,r0
80003548:	80 00       	ld.sh	r0,r0[0x0]
8000354a:	6b 70       	ld.w	r0,r5[0x5c]
8000354c:	80 00       	ld.sh	r0,r0[0x0]
8000354e:	24 84       	sub	r4,72
80003550:	80 00       	ld.sh	r0,r0[0x0]
80003552:	20 24       	sub	r4,2

80003554 <spi_init_pins>:
	MCP2515_CMD_RTS = 0x80,
	MCP2515_CMD_READ_STATUS = 0xA0,
	MCP2515_CMD_BIT_MODIFY = 0x05,
} MCP2515_CMD_t;

void spi_init_pins(void) {
80003554:	d4 01       	pushm	lr
		{SPI_MOSI_PIN,	SPI_MOSI_FUNCTION},
		{SPI_CS_PIN,	SPI_CS_FUNCTION},
	};

	// Assign I/Os to SPI.
	gpio_enable_module(MCP2515_SPI_GPIO_MAP,
80003556:	30 5b       	mov	r11,5
80003558:	48 2c       	lddpc	r12,80003560 <spi_init_pins+0xc>
8000355a:	f0 1f 00 03 	mcall	80003564 <spi_init_pins+0x10>
	sizeof(MCP2515_SPI_GPIO_MAP) / sizeof(MCP2515_SPI_GPIO_MAP[0]));

}
8000355e:	d8 02       	popm	pc
80003560:	80 00       	ld.sh	r0,r0[0x0]
80003562:	7c 04       	ld.w	r4,lr[0x0]
80003564:	80 00       	ld.sh	r0,r0[0x0]
80003566:	66 b4       	ld.w	r4,r3[0x2c]

80003568 <fsm_ecu_init>:
#define SOFTWARE_TIMER_0_5_SEC		25
#define SOFTWARE_TIMER_1_SEC		50

static uint16_t attempts =	0;

void fsm_ecu_init(fsm_ecu_data_t *ecu_data) {
80003568:	eb cd 00 c0 	pushm	r6-r7
	ecu_data->state = STATE_STARTUP;
8000356c:	30 08       	mov	r8,0
8000356e:	99 08       	st.w	r12[0x0],r8
	ecu_data->inverter_can_msg = (inverter_can_msg_t){.data.u64 = 0x0LL, .dlc = 0};
80003570:	30 06       	mov	r6,0
80003572:	30 07       	mov	r7,0
80003574:	f8 e7 00 04 	st.d	r12[4],r6
80003578:	99 38       	st.w	r12[0xc],r8
	ecu_data->trq_sens0 = 0;
8000357a:	f9 58 00 10 	st.h	r12[16],r8
	ecu_data->trq_sens1 = 0;
8000357e:	f9 58 00 12 	st.h	r12[18],r8
	ecu_data->trq_pedal = 0;
80003582:	30 0a       	mov	r10,0
80003584:	99 7a       	st.w	r12[0x1c],r10
	ecu_data->trq_sens0_err = 0;
80003586:	f9 68 00 14 	st.b	r12[20],r8
	ecu_data->trq_sens1_err = 0;
8000358a:	f9 68 00 15 	st.b	r12[21],r8
	ecu_data->trq_cmd = 0;
8000358e:	f9 58 00 16 	st.h	r12[22],r8
	ecu_data->trq_pid = 0;
80003592:	99 6a       	st.w	r12[0x18],r10
	ecu_data->dash_msg = (dash_can_msg_t){.data.u64 = 0x0LL, .id = 0};
80003594:	f8 e7 00 20 	st.d	r12[32],r6
80003598:	99 a8       	st.w	r12[0x28],r8
	ecu_data->bms_msg = (bms_can_msg_t){.data.u64 = 0x0LL, .id = 0};
8000359a:	f8 e7 00 2c 	st.d	r12[44],r6
8000359e:	99 d8       	st.w	r12[0x34],r8
	ecu_data->vdc_battery = 0;
800035a0:	f9 58 00 38 	st.h	r12[56],r8
	ecu_data->inverter_vdc = 0;
800035a4:	f9 58 00 3a 	st.h	r12[58],r8
	ecu_data->rpm = 0;
800035a8:	f9 58 00 3c 	st.h	r12[60],r8
	ecu_data->motor_temp = 0;
800035ac:	f9 58 00 3e 	st.h	r12[62],r8
	ecu_data->inverter_temp = 0;
800035b0:	f9 58 00 40 	st.h	r12[64],r8
	ecu_data->brake_front = 0;
800035b4:	f9 58 00 42 	st.h	r12[66],r8
	ecu_data->brake_rear = 0;
800035b8:	f9 58 00 44 	st.h	r12[68],r8
	ecu_data->flag_start_precharge = 0;
800035bc:	f9 68 00 46 	st.b	r12[70],r8
	ecu_data->flag_brake_implausible = 0;
800035c0:	f9 68 00 47 	st.b	r12[71],r8
	ecu_data->max_cell_temp = 0;
800035c4:	f9 68 00 48 	st.b	r12[72],r8
	ecu_data->flag_drive_enable = DRIVE_DISABLED;
800035c8:	f9 48 00 4c 	st.w	r12[76],r8
	ecu_data->arctos_mode = ARCTOS_MODE_NORMAL;
800035cc:	f9 48 00 50 	st.w	r12[80],r8
	ecu_data->inverter_error = 0;
800035d0:	f9 58 00 54 	st.h	r12[84],r8
	ecu_data->ecu_error = 0;
800035d4:	f9 58 00 56 	st.h	r12[86],r8
	ecu_data->WFL_sens = 0;
800035d8:	f9 58 00 58 	st.h	r12[88],r8
	ecu_data->WFR_sens = 0;
800035dc:	f9 58 00 5a 	st.h	r12[90],r8
	ecu_data->WRL_sens = 0;
800035e0:	f9 58 00 5c 	st.h	r12[92],r8
	ecu_data->WRR_sens = 0;
800035e4:	f9 58 00 5e 	st.h	r12[94],r8
	ecu_data->launch_control_flag = LAUNCH_CONTROL_INACTIVE;
800035e8:	f9 48 00 60 	st.w	r12[96],r8
	ecu_data->reboot = 0;
800035ec:	f9 68 00 64 	st.b	r12[100],r8
	ecu_data->config_max_trq = 50;
800035f0:	33 2b       	mov	r11,50
800035f2:	f9 6b 00 65 	st.b	r12[101],r11
	ecu_data->Kp = Kp_default;
800035f6:	fc 1b 42 c8 	movh	r11,0x42c8
800035fa:	f9 4b 00 68 	st.w	r12[104],r11
	ecu_data->Ki = Ki_default;
800035fe:	f9 4a 00 6c 	st.w	r12[108],r10
	ecu_data->Kd = Kd_default;
80003602:	fc 1a 41 f0 	movh	r10,0x41f0
80003606:	f9 4a 00 70 	st.w	r12[112],r10
	ecu_data->d_filter_gain = D_FILTER_GAIN_DEFAULT;
8000360a:	fc 1b 3d 80 	movh	r11,0x3d80
8000360e:	f9 4b 00 78 	st.w	r12[120],r11
	ecu_data->slip_target = SLIP_TARGET_DEFAULT;
80003612:	e0 6a cc cd 	mov	r10,52429
80003616:	ea 1a 3e 4c 	orh	r10,0x3e4c
8000361a:	f9 4a 00 74 	st.w	r12[116],r10
	ecu_data->inverter_timeout = 0;
8000361e:	f9 68 00 7c 	st.b	r12[124],r8
	ecu_data->lc_filter_gain = LC_FILTER_GAIN_DEFAULT;
80003622:	e0 69 94 36 	mov	r9,37942
80003626:	ea 19 3c 57 	orh	r9,0x3c57
8000362a:	f9 49 00 80 	st.w	r12[128],r9
	ecu_data->lc_trq_init = LC_TRQ_INIT_DEFAULT;
8000362e:	e0 6b 90 00 	mov	r11,36864
80003632:	ea 1b 46 19 	orh	r11,0x4619
80003636:	f9 4b 00 84 	st.w	r12[132],r11
	ecu_data->kers_factor = 0;
8000363a:	f9 58 00 88 	st.h	r12[136],r8
	ecu_data->bms_current = 0;
8000363e:	f9 58 00 8a 	st.h	r12[138],r8
}
80003642:	e3 cd 00 c0 	ldm	sp++,r6-r7
80003646:	5e fc       	retal	r12

80003648 <fsm_ecu_run_state>:
	fsm_ecu_state_deactivate_launch_func,
	fsm_ecu_state_plausibility_error_func,
	fsm_ecu_state_error_func,
};

fsm_ecu_state_t fsm_ecu_run_state( fsm_ecu_state_t current_state, fsm_ecu_data_t *data) {
80003648:	d4 01       	pushm	lr
	return fsm_ecu_state_table[ current_state ]( data );
8000364a:	48 48       	lddpc	r8,80003658 <fsm_ecu_run_state+0x10>
8000364c:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
80003650:	16 9c       	mov	r12,r11
80003652:	5d 18       	icall	r8
};
80003654:	d8 02       	popm	pc
80003656:	00 00       	add	r0,r0
80003658:	80 00       	ld.sh	r0,r0[0x0]
8000365a:	7c 2c       	ld.w	r12,lr[0x8]

8000365c <fsm_ecu_state_error_func>:
	return next_state;
};


	
fsm_ecu_state_t fsm_ecu_state_error_func( fsm_ecu_data_t *ecu_data ) {
8000365c:	eb cd 40 80 	pushm	r7,lr
80003660:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_ERROR;
	get_new_data(ecu_data);
80003662:	f0 1f 00 12 	mcall	800036a8 <fsm_ecu_state_error_func+0x4c>
	/* Disable AIR+ */
	gpio_set_pin_low(AIR_PLUS);
80003666:	30 4c       	mov	r12,4
80003668:	f0 1f 00 11 	mcall	800036ac <fsm_ecu_state_error_func+0x50>
	gpio_set_pin_low(FRG_PIN);
8000366c:	30 9c       	mov	r12,9
8000366e:	f0 1f 00 10 	mcall	800036ac <fsm_ecu_state_error_func+0x50>
	gpio_set_pin_low(RFE_PIN);
80003672:	31 0c       	mov	r12,16
80003674:	f0 1f 00 0e 	mcall	800036ac <fsm_ecu_state_error_func+0x50>
	ecu_data->trq_cmd = 0x0;
80003678:	30 08       	mov	r8,0
8000367a:	ef 58 00 16 	st.h	r7[22],r8
	ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
8000367e:	30 0c       	mov	r12,0
80003680:	f0 1f 00 0c 	mcall	800036b0 <fsm_ecu_state_error_func+0x54>
	
	if (ecu_data->reboot == 1) {
80003684:	ef 39 00 64 	ld.ub	r9,r7[100]
80003688:	30 18       	mov	r8,1
8000368a:	f0 09 18 00 	cp.b	r9,r8
8000368e:	c0 40       	breq	80003696 <fsm_ecu_state_error_func+0x3a>
80003690:	30 8c       	mov	r12,8
80003692:	e3 cd 80 80 	ldm	sp++,r7,pc
		ecu_data->reboot = 0;
80003696:	30 08       	mov	r8,0
80003698:	ef 68 00 64 	st.b	r7[100],r8
		fsm_ecu_init(ecu_data); // Reinitialize data struct
8000369c:	0e 9c       	mov	r12,r7
8000369e:	f0 1f 00 06 	mcall	800036b4 <fsm_ecu_state_error_func+0x58>
800036a2:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
800036a6:	00 00       	add	r0,r0
800036a8:	80 00       	ld.sh	r0,r0[0x0]
800036aa:	42 dc       	lddsp	r12,sp[0xb4]
800036ac:	80 00       	ld.sh	r0,r0[0x0]
800036ae:	68 40       	ld.w	r0,r4[0x10]
800036b0:	80 00       	ld.sh	r0,r0[0x0]
800036b2:	2b 08       	sub	r8,-80
800036b4:	80 00       	ld.sh	r0,r0[0x0]
800036b6:	35 68       	mov	r8,86

800036b8 <fsm_ecu_state_plausibility_error_func>:
		ecu_can_send_ready_to_drive();
		return STATE_READY;
	}
}

fsm_ecu_state_t fsm_ecu_state_plausibility_error_func( fsm_ecu_data_t *ecu_data ) {
800036b8:	eb cd 40 c0 	pushm	r6-r7,lr
800036bc:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_PLAUSIBILITY_ERROR;

	get_new_data(ecu_data);
800036be:	f0 1f 00 1b 	mcall	80003728 <fsm_ecu_state_plausibility_error_func+0x70>
	get_trq_sens(ecu_data);
800036c2:	0e 9c       	mov	r12,r7
800036c4:	f0 1f 00 1a 	mcall	8000372c <fsm_ecu_state_plausibility_error_func+0x74>

	if ( torque_plausibility_check(ecu_data) == true ) {
800036c8:	0e 9c       	mov	r12,r7
800036ca:	f0 1f 00 1a 	mcall	80003730 <fsm_ecu_state_plausibility_error_func+0x78>
800036ce:	c2 30       	breq	80003714 <fsm_ecu_state_plausibility_error_func+0x5c>
		if (ecu_data->flag_brake_implausible) {
800036d0:	ef 39 00 47 	ld.ub	r9,r7[71]
800036d4:	30 08       	mov	r8,0
800036d6:	f0 09 18 00 	cp.b	r9,r8
800036da:	c1 30       	breq	80003700 <fsm_ecu_state_plausibility_error_func+0x48>
			/* Can return to normal state if pedal travel < 5% (pedal = <0,1000>) */
			if (max(ecu_data->trq_sens0, ecu_data->trq_sens1) < 50) {
800036dc:	ef 08 00 10 	ld.sh	r8,r7[16]
800036e0:	ef 09 00 12 	ld.sh	r9,r7[18]
800036e4:	f0 09 0c 48 	max	r8,r8,r9
800036e8:	e0 48 00 31 	cp.w	r8,49
800036ec:	e0 89 00 14 	brgt	80003714 <fsm_ecu_state_plausibility_error_func+0x5c>
				ecu_data->flag_brake_implausible = 0;
800036f0:	30 08       	mov	r8,0
800036f2:	ef 68 00 47 	st.b	r7[71],r8
				gpio_set_pin_high(FRG_PIN);
800036f6:	30 9c       	mov	r12,9
800036f8:	f0 1f 00 0f 	mcall	80003734 <fsm_ecu_state_plausibility_error_func+0x7c>
800036fc:	30 36       	mov	r6,3
800036fe:	c0 c8       	rjmp	80003716 <fsm_ecu_state_plausibility_error_func+0x5e>
				next_state = STATE_READY;
			}
		} else {
			gpio_set_pin_high(FRG_PIN);
80003700:	30 9c       	mov	r12,9
80003702:	f0 1f 00 0d 	mcall	80003734 <fsm_ecu_state_plausibility_error_func+0x7c>
			if (ecu_data->launch_control_flag == LAUNCH_CONTROL_ACTIVE) {
80003706:	6f 86       	ld.w	r6,r7[0x60]
80003708:	58 36       	cp.w	r6,3
8000370a:	f9 b6 00 05 	moveq	r6,5
8000370e:	f9 b6 01 03 	movne	r6,3
80003712:	c0 28       	rjmp	80003716 <fsm_ecu_state_plausibility_error_func+0x5e>
80003714:	30 76       	mov	r6,7
			} else {
				next_state = STATE_READY;	
			}
		}
	}
	ecu_data->trq_cmd = 0x0;
80003716:	30 08       	mov	r8,0
80003718:	ef 58 00 16 	st.h	r7[22],r8
	ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
8000371c:	30 0c       	mov	r12,0
8000371e:	f0 1f 00 07 	mcall	80003738 <fsm_ecu_state_plausibility_error_func+0x80>
	return next_state;
};
80003722:	0c 9c       	mov	r12,r6
80003724:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003728:	80 00       	ld.sh	r0,r0[0x0]
8000372a:	42 dc       	lddsp	r12,sp[0xb4]
8000372c:	80 00       	ld.sh	r0,r0[0x0]
8000372e:	43 9c       	lddsp	r12,sp[0xe4]
80003730:	80 00       	ld.sh	r0,r0[0x0]
80003732:	3e dc       	mov	r12,-19
80003734:	80 00       	ld.sh	r0,r0[0x0]
80003736:	68 2a       	ld.w	r10,r4[0x8]
80003738:	80 00       	ld.sh	r0,r0[0x0]
8000373a:	2b 08       	sub	r8,-80

8000373c <fsm_ecu_state_deactivate_launch_func>:
	}
	
	return next_state;
}

fsm_ecu_state_t fsm_ecu_state_deactivate_launch_func( fsm_ecu_data_t *ecu_data ) {
8000373c:	d4 01       	pushm	lr
	//Wait for 5 seconds before returning to ready state
	static uint8_t timer = 0;
	if (timer < SOFTWARE_TIMER_5_SEC) {
8000373e:	48 d8       	lddpc	r8,80003770 <fsm_ecu_state_deactivate_launch_func+0x34>
80003740:	11 88       	ld.ub	r8,r8[0x0]
80003742:	3f 99       	mov	r9,-7
80003744:	f2 08 18 00 	cp.b	r8,r9
80003748:	e0 8b 00 0d 	brhi	80003762 <fsm_ecu_state_deactivate_launch_func+0x26>
		timer++;
8000374c:	2f f8       	sub	r8,-1
8000374e:	48 99       	lddpc	r9,80003770 <fsm_ecu_state_deactivate_launch_func+0x34>
80003750:	b2 88       	st.b	r9[0x0],r8
		ecu_data->trq_cmd = 0;
80003752:	30 08       	mov	r8,0
80003754:	f9 58 00 16 	st.h	r12[22],r8
		ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
80003758:	30 0c       	mov	r12,0
8000375a:	f0 1f 00 07 	mcall	80003774 <fsm_ecu_state_deactivate_launch_func+0x38>
8000375e:	30 6c       	mov	r12,6
		return STATE_DEACTIVATE_LAUNCH;
80003760:	d8 02       	popm	pc
	} else {
		timer = 0;
80003762:	30 09       	mov	r9,0
80003764:	48 38       	lddpc	r8,80003770 <fsm_ecu_state_deactivate_launch_func+0x34>
80003766:	b0 89       	st.b	r8[0x0],r9
		ecu_can_send_ready_to_drive();
80003768:	f0 1f 00 04 	mcall	80003778 <fsm_ecu_state_deactivate_launch_func+0x3c>
8000376c:	30 3c       	mov	r12,3
		return STATE_READY;
	}
}
8000376e:	d8 02       	popm	pc
80003770:	00 00       	add	r0,r0
80003772:	cb fc       	rcall	800038f0 <fsm_ecu_state_init_launch_func+0x7c>
80003774:	80 00       	ld.sh	r0,r0[0x0]
80003776:	2b 08       	sub	r8,-80
80003778:	80 00       	ld.sh	r0,r0[0x0]
8000377a:	29 a0       	sub	r0,-102

8000377c <fsm_ecu_state_launch_control_func>:
	}
	
	return next_state;
}	

fsm_ecu_state_t fsm_ecu_state_launch_control_func( fsm_ecu_data_t *ecu_data ) {
8000377c:	eb cd 40 80 	pushm	r7,lr
80003780:	18 97       	mov	r7,r12
	int16_t trq_min = 0;
	static uint16_t activation_timer = 0;
	fsm_ecu_state_t next_state = STATE_LAUNCH_CONTROL;
	
	get_new_data(ecu_data);
80003782:	f0 1f 00 35 	mcall	80003854 <fsm_ecu_state_launch_control_func+0xd8>
	get_trq_sens(ecu_data);
80003786:	0e 9c       	mov	r12,r7
80003788:	f0 1f 00 34 	mcall	80003858 <fsm_ecu_state_launch_control_func+0xdc>
	
	if (torque_plausibility_check(ecu_data)) {
8000378c:	0e 9c       	mov	r12,r7
8000378e:	f0 1f 00 34 	mcall	8000385c <fsm_ecu_state_launch_control_func+0xe0>
80003792:	c4 80       	breq	80003822 <fsm_ecu_state_launch_control_func+0xa6>
		trq_min = min(ecu_data->trq_sens0, ecu_data->trq_sens1);
80003794:	ef 08 00 10 	ld.sh	r8,r7[16]
80003798:	ef 09 00 12 	ld.sh	r9,r7[18]
8000379c:	f0 09 0d 49 	min	r9,r8,r9
		if (trq_min > 500) {
800037a0:	e0 68 01 f4 	mov	r8,500
800037a4:	f0 09 19 00 	cp.h	r9,r8
800037a8:	e0 8a 00 23 	brle	800037ee <fsm_ecu_state_launch_control_func+0x72>
			switch (ecu_data->launch_control_flag) {
800037ac:	6f 88       	ld.w	r8,r7[0x60]
800037ae:	58 28       	cp.w	r8,2
800037b0:	c0 d0       	breq	800037ca <fsm_ecu_state_launch_control_func+0x4e>
800037b2:	58 38       	cp.w	r8,3
800037b4:	c1 40       	breq	800037dc <fsm_ecu_state_launch_control_func+0x60>
800037b6:	58 18       	cp.w	r8,1
800037b8:	c0 30       	breq	800037be <fsm_ecu_state_launch_control_func+0x42>
800037ba:	30 5c       	mov	r12,5
800037bc:	c3 d8       	rjmp	80003836 <fsm_ecu_state_launch_control_func+0xba>
				case LAUNCH_CONTROL_INITIATE:
				activation_timer++;
800037be:	4a 98       	lddpc	r8,80003860 <fsm_ecu_state_launch_control_func+0xe4>
800037c0:	90 09       	ld.sh	r9,r8[0x0]
800037c2:	2f f9       	sub	r9,-1
800037c4:	b0 09       	st.h	r8[0x0],r9
800037c6:	30 5c       	mov	r12,5
				break;
800037c8:	c3 78       	rjmp	80003836 <fsm_ecu_state_launch_control_func+0xba>
				
				case LAUNCH_CONTROL_COUNTDOWN_COMPLETE:
				ecu_data->launch_control_flag = LAUNCH_CONTROL_ACTIVE;
800037ca:	30 38       	mov	r8,3
800037cc:	ef 48 00 60 	st.w	r7[96],r8
				activation_timer = 0;	
800037d0:	30 09       	mov	r9,0
800037d2:	4a 48       	lddpc	r8,80003860 <fsm_ecu_state_launch_control_func+0xe4>
800037d4:	b0 09       	st.h	r8[0x0],r9
800037d6:	30 5c       	mov	r12,5
				break;
800037d8:	e3 cd 80 80 	ldm	sp++,r7,pc
				
				case LAUNCH_CONTROL_ACTIVE:
				launch_control(ecu_data);
800037dc:	0e 9c       	mov	r12,r7
800037de:	f0 1f 00 22 	mcall	80003864 <fsm_ecu_state_launch_control_func+0xe8>
				ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
800037e2:	ef 0c 00 16 	ld.sh	r12,r7[22]
800037e6:	f0 1f 00 21 	mcall	80003868 <fsm_ecu_state_launch_control_func+0xec>
800037ea:	30 5c       	mov	r12,5
800037ec:	c2 58       	rjmp	80003836 <fsm_ecu_state_launch_control_func+0xba>
				default:
				break;	
			}
		} else {
			// Exit launch control
			switch (ecu_data->launch_control_flag) {
800037ee:	6f 88       	ld.w	r8,r7[0x60]
800037f0:	58 18       	cp.w	r8,1
800037f2:	c0 40       	breq	800037fa <fsm_ecu_state_launch_control_func+0x7e>
800037f4:	58 38       	cp.w	r8,3
800037f6:	c0 f1       	brne	80003814 <fsm_ecu_state_launch_control_func+0x98>
800037f8:	c0 88       	rjmp	80003808 <fsm_ecu_state_launch_control_func+0x8c>
				case LAUNCH_CONTROL_INITIATE:
					activation_timer = 0;
800037fa:	30 09       	mov	r9,0
800037fc:	49 98       	lddpc	r8,80003860 <fsm_ecu_state_launch_control_func+0xe4>
800037fe:	b0 09       	st.h	r8[0x0],r9
					ecu_can_send_launch_stop();
80003800:	f0 1f 00 1b 	mcall	8000386c <fsm_ecu_state_launch_control_func+0xf0>
80003804:	30 6c       	mov	r12,6
					next_state = STATE_DEACTIVATE_LAUNCH;
					break;
80003806:	c1 88       	rjmp	80003836 <fsm_ecu_state_launch_control_func+0xba>
				case LAUNCH_CONTROL_ACTIVE:
					activation_timer = 0;
80003808:	30 09       	mov	r9,0
8000380a:	49 68       	lddpc	r8,80003860 <fsm_ecu_state_launch_control_func+0xe4>
8000380c:	b0 09       	st.h	r8[0x0],r9
8000380e:	30 3c       	mov	r12,3
					next_state = STATE_READY;
					break;
80003810:	e3 cd 80 80 	ldm	sp++,r7,pc
				default:
					activation_timer = 0;
80003814:	30 09       	mov	r9,0
80003816:	49 38       	lddpc	r8,80003860 <fsm_ecu_state_launch_control_func+0xe4>
80003818:	b0 09       	st.h	r8[0x0],r9
					ecu_can_send_launch_stop();
8000381a:	f0 1f 00 15 	mcall	8000386c <fsm_ecu_state_launch_control_func+0xf0>
8000381e:	30 6c       	mov	r12,6
80003820:	c0 b8       	rjmp	80003836 <fsm_ecu_state_launch_control_func+0xba>
					break;
			}	
		}
	} else {
		//Torque sensor implausibility
		ecu_data->trq_cmd = 0;
80003822:	30 08       	mov	r8,0
80003824:	ef 58 00 16 	st.h	r7[22],r8
		ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
80003828:	30 0c       	mov	r12,0
8000382a:	f0 1f 00 10 	mcall	80003868 <fsm_ecu_state_launch_control_func+0xec>
		gpio_set_pin_low(FRG_PIN);
8000382e:	30 9c       	mov	r12,9
80003830:	f0 1f 00 10 	mcall	80003870 <fsm_ecu_state_launch_control_func+0xf4>
80003834:	30 7c       	mov	r12,7
		next_state = STATE_PLAUSIBILITY_ERROR;	
	}
	
	if (activation_timer == SOFTWARE_TIMER_10_SEC) {
80003836:	48 b8       	lddpc	r8,80003860 <fsm_ecu_state_launch_control_func+0xe4>
80003838:	90 09       	ld.sh	r9,r8[0x0]
8000383a:	e0 68 01 f4 	mov	r8,500
8000383e:	f0 09 19 00 	cp.h	r9,r8
80003842:	c0 71       	brne	80003850 <fsm_ecu_state_launch_control_func+0xd4>
		activation_timer = 0;
80003844:	30 09       	mov	r9,0
80003846:	48 78       	lddpc	r8,80003860 <fsm_ecu_state_launch_control_func+0xe4>
80003848:	b0 09       	st.h	r8[0x0],r9
		ecu_can_send_launch_stop();
8000384a:	f0 1f 00 09 	mcall	8000386c <fsm_ecu_state_launch_control_func+0xf0>
8000384e:	30 6c       	mov	r12,6
		next_state = STATE_DEACTIVATE_LAUNCH;
	}
	
	return next_state;
}
80003850:	e3 cd 80 80 	ldm	sp++,r7,pc
80003854:	80 00       	ld.sh	r0,r0[0x0]
80003856:	42 dc       	lddsp	r12,sp[0xb4]
80003858:	80 00       	ld.sh	r0,r0[0x0]
8000385a:	43 9c       	lddsp	r12,sp[0xe4]
8000385c:	80 00       	ld.sh	r0,r0[0x0]
8000385e:	3e dc       	mov	r12,-19
80003860:	00 00       	add	r0,r0
80003862:	cb fa       	rjmp	800035e0 <fsm_ecu_init+0x78>
80003864:	80 00       	ld.sh	r0,r0[0x0]
80003866:	45 4c       	lddsp	r12,sp[0x150]
80003868:	80 00       	ld.sh	r0,r0[0x0]
8000386a:	2b 08       	sub	r8,-80
8000386c:	80 00       	ld.sh	r0,r0[0x0]
8000386e:	28 40       	sub	r0,-124
80003870:	80 00       	ld.sh	r0,r0[0x0]
80003872:	68 40       	ld.w	r0,r4[0x10]

80003874 <fsm_ecu_state_init_launch_func>:
 	ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
 	
	return next_state;
};

fsm_ecu_state_t fsm_ecu_state_init_launch_func( fsm_ecu_data_t *ecu_data ) {	
80003874:	eb cd 40 80 	pushm	r7,lr
80003878:	18 97       	mov	r7,r12
	static uint16_t activation_timer = 0;
	static uint8_t verification_timer = 0;
	int16_t trq_min = 0;
	fsm_ecu_state_t next_state = STATE_INIT_LAUNCH;
	
	get_new_data(ecu_data);
8000387a:	f0 1f 00 25 	mcall	8000390c <fsm_ecu_state_init_launch_func+0x98>
	get_trq_sens(ecu_data);
8000387e:	0e 9c       	mov	r12,r7
80003880:	f0 1f 00 24 	mcall	80003910 <fsm_ecu_state_init_launch_func+0x9c>
	if (torque_plausibility_check(ecu_data)) {
80003884:	0e 9c       	mov	r12,r7
80003886:	f0 1f 00 24 	mcall	80003914 <fsm_ecu_state_init_launch_func+0xa0>
8000388a:	c0 31       	brne	80003890 <fsm_ecu_state_init_launch_func+0x1c>
8000388c:	30 4c       	mov	r12,4
8000388e:	c2 a8       	rjmp	800038e2 <fsm_ecu_state_init_launch_func+0x6e>
		trq_min = min(ecu_data->trq_sens0, ecu_data->trq_sens1);
80003890:	ef 08 00 10 	ld.sh	r8,r7[16]
80003894:	ef 09 00 12 	ld.sh	r9,r7[18]
80003898:	f0 09 0d 49 	min	r9,r8,r9
		if (trq_min > 500) {
8000389c:	e0 68 01 f4 	mov	r8,500
800038a0:	f0 09 19 00 	cp.h	r9,r8
800038a4:	e0 8a 00 17 	brle	800038d2 <fsm_ecu_state_init_launch_func+0x5e>
			if (verification_timer < SOFTWARE_TIMER_0_5_SEC) {
800038a8:	49 c8       	lddpc	r8,80003918 <fsm_ecu_state_init_launch_func+0xa4>
800038aa:	11 88       	ld.ub	r8,r8[0x0]
800038ac:	31 89       	mov	r9,24
800038ae:	f2 08 18 00 	cp.b	r8,r9
800038b2:	e0 8b 00 07 	brhi	800038c0 <fsm_ecu_state_init_launch_func+0x4c>
				verification_timer++;
800038b6:	2f f8       	sub	r8,-1
800038b8:	49 89       	lddpc	r9,80003918 <fsm_ecu_state_init_launch_func+0xa4>
800038ba:	b2 88       	st.b	r9[0x0],r8
800038bc:	30 4c       	mov	r12,4
800038be:	c1 28       	rjmp	800038e2 <fsm_ecu_state_init_launch_func+0x6e>
			} else {
				activation_timer = 0;
800038c0:	30 08       	mov	r8,0
800038c2:	49 79       	lddpc	r9,8000391c <fsm_ecu_state_init_launch_func+0xa8>
800038c4:	b2 08       	st.h	r9[0x0],r8
				verification_timer = 0;
				//Pedals has been > 500 for 0.5 sec
				verification_timer = 0;
800038c6:	49 59       	lddpc	r9,80003918 <fsm_ecu_state_init_launch_func+0xa4>
800038c8:	b2 88       	st.b	r9[0x0],r8
				ecu_can_send_launch_ready();
800038ca:	f0 1f 00 16 	mcall	80003920 <fsm_ecu_state_init_launch_func+0xac>
800038ce:	30 5c       	mov	r12,5
800038d0:	c0 98       	rjmp	800038e2 <fsm_ecu_state_init_launch_func+0x6e>
				next_state = STATE_LAUNCH_CONTROL;
			}
		} else {
			verification_timer = 0;
800038d2:	30 09       	mov	r9,0
800038d4:	49 18       	lddpc	r8,80003918 <fsm_ecu_state_init_launch_func+0xa4>
800038d6:	b0 89       	st.b	r8[0x0],r9
			activation_timer++;
800038d8:	49 18       	lddpc	r8,8000391c <fsm_ecu_state_init_launch_func+0xa8>
800038da:	90 09       	ld.sh	r9,r8[0x0]
800038dc:	2f f9       	sub	r9,-1
800038de:	b0 09       	st.h	r8[0x0],r9
800038e0:	30 4c       	mov	r12,4
		}
	}
	
	if (activation_timer == SOFTWARE_TIMER_10_SEC) {
800038e2:	48 f8       	lddpc	r8,8000391c <fsm_ecu_state_init_launch_func+0xa8>
800038e4:	90 09       	ld.sh	r9,r8[0x0]
800038e6:	e0 68 01 f4 	mov	r8,500
800038ea:	f0 09 19 00 	cp.h	r9,r8
800038ee:	c0 c1       	brne	80003906 <fsm_ecu_state_init_launch_func+0x92>
		activation_timer = 0;
800038f0:	30 08       	mov	r8,0
800038f2:	48 b9       	lddpc	r9,8000391c <fsm_ecu_state_init_launch_func+0xa8>
800038f4:	b2 08       	st.h	r9[0x0],r8
		verification_timer = 0;
800038f6:	48 99       	lddpc	r9,80003918 <fsm_ecu_state_init_launch_func+0xa4>
800038f8:	b2 88       	st.b	r9[0x0],r8
		ecu_can_send_launch_stop();
800038fa:	f0 1f 00 0b 	mcall	80003924 <fsm_ecu_state_init_launch_func+0xb0>
		ecu_data->launch_control_flag = LAUNCH_CONTROL_INACTIVE;
800038fe:	30 08       	mov	r8,0
80003900:	ef 48 00 60 	st.w	r7[96],r8
80003904:	30 6c       	mov	r12,6
		next_state = STATE_DEACTIVATE_LAUNCH;
	}
	
	return next_state;
}	
80003906:	e3 cd 80 80 	ldm	sp++,r7,pc
8000390a:	00 00       	add	r0,r0
8000390c:	80 00       	ld.sh	r0,r0[0x0]
8000390e:	42 dc       	lddsp	r12,sp[0xb4]
80003910:	80 00       	ld.sh	r0,r0[0x0]
80003912:	43 9c       	lddsp	r12,sp[0xe4]
80003914:	80 00       	ld.sh	r0,r0[0x0]
80003916:	3e dc       	mov	r12,-19
80003918:	00 00       	add	r0,r0
8000391a:	cc 04       	brge	8000389a <fsm_ecu_state_init_launch_func+0x26>
8000391c:	00 00       	add	r0,r0
8000391e:	cc 00       	breq	8000389e <fsm_ecu_state_init_launch_func+0x2a>
80003920:	80 00       	ld.sh	r0,r0[0x0]
80003922:	28 80       	sub	r0,-120
80003924:	80 00       	ld.sh	r0,r0[0x0]
80003926:	28 40       	sub	r0,-124

80003928 <fsm_ecu_state_ready_func>:
	
	return next_state;
};
	
	
fsm_ecu_state_t fsm_ecu_state_ready_func( fsm_ecu_data_t *ecu_data ) {
80003928:	eb cd 40 e0 	pushm	r5-r7,lr
8000392c:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_READY;
	int16_t kers = 0;
	
	get_new_data(ecu_data);
8000392e:	f0 1f 00 4f 	mcall	80003a68 <fsm_ecu_state_ready_func+0x140>
	get_trq_sens(ecu_data);
80003932:	0e 9c       	mov	r12,r7
80003934:	f0 1f 00 4e 	mcall	80003a6c <fsm_ecu_state_ready_func+0x144>
	get_speed_sens(ecu_data);
80003938:	0e 9c       	mov	r12,r7
8000393a:	f0 1f 00 4e 	mcall	80003a70 <fsm_ecu_state_ready_func+0x148>
	get_brake_sens(ecu_data);
8000393e:	0e 9c       	mov	r12,r7
80003940:	f0 1f 00 4d 	mcall	80003a74 <fsm_ecu_state_ready_func+0x14c>
	
	if (ecu_data->flag_drive_enable == DRIVE_DISABLE_REQUEST) {
80003944:	6f 38       	ld.w	r8,r7[0x4c]
80003946:	58 48       	cp.w	r8,4
80003948:	c0 b1       	brne	8000395e <fsm_ecu_state_ready_func+0x36>
		gpio_set_pin_low(FRG_PIN);
8000394a:	30 9c       	mov	r12,9
8000394c:	f0 1f 00 4b 	mcall	80003a78 <fsm_ecu_state_ready_func+0x150>
		ecu_data->flag_drive_enable = DRIVE_DISABLED;
80003950:	30 08       	mov	r8,0
80003952:	ef 48 00 4c 	st.w	r7[76],r8
		ecu_can_send_drive_disabled();
80003956:	f0 1f 00 4a 	mcall	80003a7c <fsm_ecu_state_ready_func+0x154>
8000395a:	30 16       	mov	r6,1
		return STATE_CHARGED;
8000395c:	c8 28       	rjmp	80003a60 <fsm_ecu_state_ready_func+0x138>
	}
	
	if (ecu_data->inverter_vdc < 50) {
8000395e:	ef 09 00 3a 	ld.sh	r9,r7[58]
80003962:	33 18       	mov	r8,49
80003964:	f0 09 19 00 	cp.h	r9,r8
80003968:	e0 8b 00 13 	brhi	8000398e <fsm_ecu_state_ready_func+0x66>
		gpio_set_pin_low(FRG_PIN);
8000396c:	30 9c       	mov	r12,9
8000396e:	f0 1f 00 43 	mcall	80003a78 <fsm_ecu_state_ready_func+0x150>
		gpio_set_pin_low(RFE_PIN);
80003972:	31 0c       	mov	r12,16
80003974:	f0 1f 00 41 	mcall	80003a78 <fsm_ecu_state_ready_func+0x150>
		gpio_set_pin_low(AIR_PLUS);
80003978:	30 4c       	mov	r12,4
8000397a:	f0 1f 00 40 	mcall	80003a78 <fsm_ecu_state_ready_func+0x150>
		ecu_can_send_drive_disabled();
8000397e:	f0 1f 00 40 	mcall	80003a7c <fsm_ecu_state_ready_func+0x154>
		ecu_data->flag_drive_enable = DRIVE_DISABLED;
80003982:	30 06       	mov	r6,0
80003984:	ef 46 00 4c 	st.w	r7[76],r6
		ecu_data->flag_start_precharge = 0;
80003988:	ef 66 00 46 	st.b	r7[70],r6

		return STATE_STARTUP;
8000398c:	c6 a8       	rjmp	80003a60 <fsm_ecu_state_ready_func+0x138>
	}
	
	if (ecu_data->launch_control_flag == LAUNCH_CONTROL_INITIATE) {
8000398e:	6f 88       	ld.w	r8,r7[0x60]
80003990:	58 18       	cp.w	r8,1
80003992:	c1 91       	brne	800039c4 <fsm_ecu_state_ready_func+0x9c>
		if ((ecu_data->trq_sens0 < 20) && (ecu_data->trq_sens1 < 20) && (ecu_data->trq_cmd == 0)) {
80003994:	ef 09 00 10 	ld.sh	r9,r7[16]
80003998:	31 38       	mov	r8,19
8000399a:	f0 09 19 00 	cp.h	r9,r8
8000399e:	e0 89 00 13 	brgt	800039c4 <fsm_ecu_state_ready_func+0x9c>
800039a2:	ef 09 00 12 	ld.sh	r9,r7[18]
800039a6:	f0 09 19 00 	cp.h	r9,r8
800039aa:	e0 89 00 0d 	brgt	800039c4 <fsm_ecu_state_ready_func+0x9c>
800039ae:	ef 09 00 16 	ld.sh	r9,r7[22]
800039b2:	30 08       	mov	r8,0
800039b4:	f0 09 19 00 	cp.h	r9,r8
800039b8:	c0 61       	brne	800039c4 <fsm_ecu_state_ready_func+0x9c>
			asm("nop");
800039ba:	d7 03       	nop
			ecu_can_confirm_activate_launch();
800039bc:	f0 1f 00 31 	mcall	80003a80 <fsm_ecu_state_ready_func+0x158>
800039c0:	30 46       	mov	r6,4
			return STATE_INIT_LAUNCH;
800039c2:	c4 f8       	rjmp	80003a60 <fsm_ecu_state_ready_func+0x138>
		} 	
	}
	
	uint8_t bspd = check_bspd();
800039c4:	f0 1f 00 30 	mcall	80003a84 <fsm_ecu_state_ready_func+0x15c>
800039c8:	18 95       	mov	r5,r12
	//uint16_t slip = (uint16_t)(calculate_slip(ecu_data)*100);
	//uint16_t max_cur = calc_max_current_allowed(ecu_data);
	uint16_t inverter_power = calc_inverter_power(ecu_data);
800039ca:	0e 9c       	mov	r12,r7
800039cc:	f0 1f 00 2f 	mcall	80003a88 <fsm_ecu_state_ready_func+0x160>
800039d0:	ed dc b0 10 	bfexts	r6,r12,0x0,0x10
	uint16_t bms_power = calc_bms_power(ecu_data);
800039d4:	0e 9c       	mov	r12,r7
800039d6:	f0 1f 00 2e 	mcall	80003a8c <fsm_ecu_state_ready_func+0x164>
	ecu_can_send_slip_current(inverter_power, bms_power); //Reuse function
800039da:	f7 dc c0 10 	bfextu	r11,r12,0x0,0x10
800039de:	f9 d6 c0 10 	bfextu	r12,r6,0x0,0x10
800039e2:	f0 1f 00 2c 	mcall	80003a90 <fsm_ecu_state_ready_func+0x168>
	
	/* First set trq_cmd to 0. Will be updated if the following tests are passed. 
	 * If not, the motor will be disabled and zero torque requested (stored in inverter?). 
	 * When transitioning from plausibility error state to ready state, the zero command
	 * stored in inverter memory will be used (it may also be zero by default) */
 	ecu_data->trq_cmd = 0;
800039e6:	30 08       	mov	r8,0
800039e8:	ef 58 00 16 	st.h	r7[22],r8
	if ( bspd == BSPD_SIGNAL_LOSS_WARNING ) {
800039ec:	34 28       	mov	r8,66
800039ee:	f0 05 18 00 	cp.b	r5,r8
800039f2:	c1 11       	brne	80003a14 <fsm_ecu_state_ready_func+0xec>
		gpio_set_pin_low(RFE_PIN);
800039f4:	31 0c       	mov	r12,16
800039f6:	f0 1f 00 21 	mcall	80003a78 <fsm_ecu_state_ready_func+0x150>
		gpio_set_pin_low(FRG_PIN);
800039fa:	30 9c       	mov	r12,9
800039fc:	f0 1f 00 1f 	mcall	80003a78 <fsm_ecu_state_ready_func+0x150>
		gpio_set_pin_low(AIR_PLUS);
80003a00:	30 4c       	mov	r12,4
80003a02:	f0 1f 00 1e 	mcall	80003a78 <fsm_ecu_state_ready_func+0x150>
		ecu_data->ecu_error |= (1 << ERR_BSPD);
80003a06:	ef 08 00 56 	ld.sh	r8,r7[86]
80003a0a:	a9 a8       	sbr	r8,0x8
80003a0c:	ef 58 00 56 	st.h	r7[86],r8
80003a10:	30 86       	mov	r6,8
80003a12:	c2 38       	rjmp	80003a58 <fsm_ecu_state_ready_func+0x130>
		next_state = STATE_ERROR;
		
 	} else if ( torque_plausibility_check(ecu_data) == false ) {
80003a14:	0e 9c       	mov	r12,r7
80003a16:	f0 1f 00 20 	mcall	80003a94 <fsm_ecu_state_ready_func+0x16c>
80003a1a:	c0 61       	brne	80003a26 <fsm_ecu_state_ready_func+0xfe>
 		/* Deviation > 10 %. Shut down power to motor */
 		gpio_set_pin_low(FRG_PIN);
80003a1c:	30 9c       	mov	r12,9
80003a1e:	f0 1f 00 17 	mcall	80003a78 <fsm_ecu_state_ready_func+0x150>
80003a22:	30 76       	mov	r6,7
80003a24:	c1 a8       	rjmp	80003a58 <fsm_ecu_state_ready_func+0x130>
 		next_state = STATE_PLAUSIBILITY_ERROR;
		 
 	} else if ((brake_plausibility_check(ecu_data) == false) || (bspd == BSPD_PLAUSIBILITY_OCCURED)) {
80003a26:	0e 9c       	mov	r12,r7
80003a28:	f0 1f 00 1c 	mcall	80003a98 <fsm_ecu_state_ready_func+0x170>
80003a2c:	c0 50       	breq	80003a36 <fsm_ecu_state_ready_func+0x10e>
80003a2e:	39 98       	mov	r8,-103
80003a30:	f0 05 18 00 	cp.b	r5,r8
80003a34:	c0 91       	brne	80003a46 <fsm_ecu_state_ready_func+0x11e>
 		gpio_set_pin_low(FRG_PIN);
80003a36:	30 9c       	mov	r12,9
80003a38:	f0 1f 00 10 	mcall	80003a78 <fsm_ecu_state_ready_func+0x150>
 		ecu_data->flag_brake_implausible = 1;
80003a3c:	30 18       	mov	r8,1
80003a3e:	ef 68 00 47 	st.b	r7[71],r8
80003a42:	30 76       	mov	r6,7
 	} else if ( torque_plausibility_check(ecu_data) == false ) {
 		/* Deviation > 10 %. Shut down power to motor */
 		gpio_set_pin_low(FRG_PIN);
 		next_state = STATE_PLAUSIBILITY_ERROR;
		 
 	} else if ((brake_plausibility_check(ecu_data) == false) || (bspd == BSPD_PLAUSIBILITY_OCCURED)) {
80003a44:	c0 a8       	rjmp	80003a58 <fsm_ecu_state_ready_func+0x130>
// 			ecu_data->trq_cmd = kers;
// 		} else {
//  			map_pedal(ecu_data);
// 			ecu_data->trq_cmd = (int16_t)ecu_data->trq_pedal;
//  		}
		map_pedal(ecu_data);
80003a46:	0e 9c       	mov	r12,r7
80003a48:	f0 1f 00 15 	mcall	80003a9c <fsm_ecu_state_ready_func+0x174>
		ecu_data->trq_cmd = (int16_t)ecu_data->trq_pedal;
80003a4c:	6e 78       	ld.w	r8,r7[0x1c]
80003a4e:	e5 ab 08 08 	cop	cp0,cr8,cr0,cr8,0x56
80003a52:	ef 58 00 16 	st.h	r7[22],r8
80003a56:	30 36       	mov	r6,3
	}
 	
 	ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
80003a58:	ef 0c 00 16 	ld.sh	r12,r7[22]
80003a5c:	f0 1f 00 11 	mcall	80003aa0 <fsm_ecu_state_ready_func+0x178>
 	
	return next_state;
};
80003a60:	0c 9c       	mov	r12,r6
80003a62:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80003a66:	00 00       	add	r0,r0
80003a68:	80 00       	ld.sh	r0,r0[0x0]
80003a6a:	42 dc       	lddsp	r12,sp[0xb4]
80003a6c:	80 00       	ld.sh	r0,r0[0x0]
80003a6e:	43 9c       	lddsp	r12,sp[0xe4]
80003a70:	80 00       	ld.sh	r0,r0[0x0]
80003a72:	44 10       	lddsp	r0,sp[0x104]
80003a74:	80 00       	ld.sh	r0,r0[0x0]
80003a76:	44 88       	lddsp	r8,sp[0x120]
80003a78:	80 00       	ld.sh	r0,r0[0x0]
80003a7a:	68 40       	ld.w	r0,r4[0x10]
80003a7c:	80 00       	ld.sh	r0,r0[0x0]
80003a7e:	29 60       	sub	r0,-106
80003a80:	80 00       	ld.sh	r0,r0[0x0]
80003a82:	28 c0       	sub	r0,-116
80003a84:	80 00       	ld.sh	r0,r0[0x0]
80003a86:	44 c8       	lddsp	r8,sp[0x130]
80003a88:	80 00       	ld.sh	r0,r0[0x0]
80003a8a:	3f 1c       	mov	r12,-15
80003a8c:	80 00       	ld.sh	r0,r0[0x0]
80003a8e:	3f 0c       	mov	r12,-16
80003a90:	80 00       	ld.sh	r0,r0[0x0]
80003a92:	28 00       	sub	r0,-128
80003a94:	80 00       	ld.sh	r0,r0[0x0]
80003a96:	3e dc       	mov	r12,-19
80003a98:	80 00       	ld.sh	r0,r0[0x0]
80003a9a:	3e 8c       	mov	r12,-24
80003a9c:	80 00       	ld.sh	r0,r0[0x0]
80003a9e:	42 58       	lddsp	r8,sp[0x94]
80003aa0:	80 00       	ld.sh	r0,r0[0x0]
80003aa2:	2b 08       	sub	r8,-80

80003aa4 <fsm_ecu_state_enable_drive_func>:
		}
	}
	return next_state;
};
	
fsm_ecu_state_t fsm_ecu_state_enable_drive_func( fsm_ecu_data_t *ecu_data ) {
80003aa4:	eb cd 40 80 	pushm	r7,lr
80003aa8:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_ENABLE_DRIVE;
	static uint8_t internal_state = 0;
	get_new_data(ecu_data);
80003aaa:	f0 1f 00 4d 	mcall	80003bdc <fsm_ecu_state_enable_drive_func+0x138>
	
	if (ecu_data->inverter_vdc < 50) {
80003aae:	ef 09 00 3a 	ld.sh	r9,r7[58]
80003ab2:	33 18       	mov	r8,49
80003ab4:	f0 09 19 00 	cp.h	r9,r8
80003ab8:	e0 8b 00 10 	brhi	80003ad8 <fsm_ecu_state_enable_drive_func+0x34>
		gpio_set_pin_low(FRG_PIN);
80003abc:	30 9c       	mov	r12,9
80003abe:	f0 1f 00 49 	mcall	80003be0 <fsm_ecu_state_enable_drive_func+0x13c>
		gpio_set_pin_low(RFE_PIN);
80003ac2:	31 0c       	mov	r12,16
80003ac4:	f0 1f 00 47 	mcall	80003be0 <fsm_ecu_state_enable_drive_func+0x13c>
		gpio_set_pin_low(AIR_PLUS);
80003ac8:	30 4c       	mov	r12,4
80003aca:	f0 1f 00 46 	mcall	80003be0 <fsm_ecu_state_enable_drive_func+0x13c>
		ecu_data->flag_start_precharge = 0;
80003ace:	30 08       	mov	r8,0
80003ad0:	ef 68 00 46 	st.b	r7[70],r8
80003ad4:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		//Reinitialize ECU here if still <90% error
		return STATE_STARTUP;
	}
	
	if (ecu_data->flag_drive_enable == DRIVE_ENABLE_RTDS_PLAYS) {
80003ad8:	6f 38       	ld.w	r8,r7[0x4c]
80003ada:	58 38       	cp.w	r8,3
80003adc:	c5 e1       	brne	80003b98 <fsm_ecu_state_enable_drive_func+0xf4>
		switch (internal_state) {
80003ade:	4c 28       	lddpc	r8,80003be4 <fsm_ecu_state_enable_drive_func+0x140>
80003ae0:	11 88       	ld.ub	r8,r8[0x0]
80003ae2:	30 19       	mov	r9,1
80003ae4:	f2 08 18 00 	cp.b	r8,r9
80003ae8:	c2 90       	breq	80003b3a <fsm_ecu_state_enable_drive_func+0x96>
80003aea:	c0 63       	brcs	80003af6 <fsm_ecu_state_enable_drive_func+0x52>
80003aec:	30 29       	mov	r9,2
80003aee:	f2 08 18 00 	cp.b	r8,r9
80003af2:	c5 31       	brne	80003b98 <fsm_ecu_state_enable_drive_func+0xf4>
80003af4:	c3 d8       	rjmp	80003b6e <fsm_ecu_state_enable_drive_func+0xca>
			case 0:
			gpio_set_pin_high(RFE_PIN);
80003af6:	31 0c       	mov	r12,16
80003af8:	f0 1f 00 3c 	mcall	80003be8 <fsm_ecu_state_enable_drive_func+0x144>
			ecu_can_inverter_enable_drive();
80003afc:	f0 1f 00 3c 	mcall	80003bec <fsm_ecu_state_enable_drive_func+0x148>
			gpio_set_pin_high(FRG_PIN);
80003b00:	30 9c       	mov	r12,9
80003b02:	f0 1f 00 3a 	mcall	80003be8 <fsm_ecu_state_enable_drive_func+0x144>
 * \return bool    \c true  if the pin is in high logical level
 *                 \c false if the pin is not in high logical level
 */
__always_inline static bool gpio_pin_is_high(uint32_t pin)
{
	return (gpio_get_pin_value(pin) != 0);
80003b06:	37 5c       	mov	r12,117
80003b08:	f0 1f 00 3a 	mcall	80003bf0 <fsm_ecu_state_enable_drive_func+0x14c>
			if (gpio_pin_is_high(INVERTER_DOUT1)) {
80003b0c:	c1 10       	breq	80003b2e <fsm_ecu_state_enable_drive_func+0x8a>
				attempts = 0;
80003b0e:	30 09       	mov	r9,0
80003b10:	4b 98       	lddpc	r8,80003bf4 <fsm_ecu_state_enable_drive_func+0x150>
80003b12:	b0 09       	st.h	r8[0x0],r9
				internal_state = 1;
80003b14:	30 19       	mov	r9,1
80003b16:	4b 48       	lddpc	r8,80003be4 <fsm_ecu_state_enable_drive_func+0x140>
80003b18:	b0 89       	st.b	r8[0x0],r9
				ecu_dio_inverter_clear_error();
80003b1a:	f0 1f 00 38 	mcall	80003bf8 <fsm_ecu_state_enable_drive_func+0x154>
				ecu_data->inverter_error = 0xDEAD;
80003b1e:	fe 78 de ad 	mov	r8,-8531
80003b22:	ef 58 00 54 	st.h	r7[84],r8
				ecu_can_inverter_read_reg(ERROR_REG);
80003b26:	e0 6c 00 8f 	mov	r12,143
80003b2a:	f0 1f 00 35 	mcall	80003bfc <fsm_ecu_state_enable_drive_func+0x158>
			}
			attempts++;
80003b2e:	4b 28       	lddpc	r8,80003bf4 <fsm_ecu_state_enable_drive_func+0x150>
80003b30:	90 09       	ld.sh	r9,r8[0x0]
80003b32:	2f f9       	sub	r9,-1
80003b34:	b0 09       	st.h	r8[0x0],r9
80003b36:	30 2c       	mov	r12,2
			break;
80003b38:	c3 18       	rjmp	80003b9a <fsm_ecu_state_enable_drive_func+0xf6>
			
			case 1:
			if (ecu_data->inverter_error != 0xDEAD) {
80003b3a:	ef 09 00 54 	ld.sh	r9,r7[84]
80003b3e:	fe 78 de ad 	mov	r8,-8531
80003b42:	f0 09 19 00 	cp.h	r9,r8
80003b46:	c0 a0       	breq	80003b5a <fsm_ecu_state_enable_drive_func+0xb6>
				internal_state = 2;
80003b48:	30 29       	mov	r9,2
80003b4a:	4a 78       	lddpc	r8,80003be4 <fsm_ecu_state_enable_drive_func+0x140>
80003b4c:	b0 89       	st.b	r8[0x0],r9
				attempts = 0;
80003b4e:	30 09       	mov	r9,0
80003b50:	4a 98       	lddpc	r8,80003bf4 <fsm_ecu_state_enable_drive_func+0x150>
80003b52:	b0 09       	st.h	r8[0x0],r9
80003b54:	30 2c       	mov	r12,2
80003b56:	e3 cd 80 80 	ldm	sp++,r7,pc
			} else {
				ecu_can_inverter_read_reg(ERROR_REG);
80003b5a:	e0 6c 00 8f 	mov	r12,143
80003b5e:	f0 1f 00 28 	mcall	80003bfc <fsm_ecu_state_enable_drive_func+0x158>
				attempts++;
80003b62:	4a 58       	lddpc	r8,80003bf4 <fsm_ecu_state_enable_drive_func+0x150>
80003b64:	90 09       	ld.sh	r9,r8[0x0]
80003b66:	2f f9       	sub	r9,-1
80003b68:	b0 09       	st.h	r8[0x0],r9
80003b6a:	30 2c       	mov	r12,2
80003b6c:	c1 78       	rjmp	80003b9a <fsm_ecu_state_enable_drive_func+0xf6>
			}
			break;
			
			case 2:
			if (check_inverter_error(ecu_data) == 0) {
80003b6e:	0e 9c       	mov	r12,r7
80003b70:	f0 1f 00 24 	mcall	80003c00 <fsm_ecu_state_enable_drive_func+0x15c>
80003b74:	c0 b1       	brne	80003b8a <fsm_ecu_state_enable_drive_func+0xe6>
				internal_state = 0; //Reset for next possible restart
80003b76:	30 09       	mov	r9,0
80003b78:	49 b8       	lddpc	r8,80003be4 <fsm_ecu_state_enable_drive_func+0x140>
80003b7a:	b0 89       	st.b	r8[0x0],r9
				ecu_can_send_ready_to_drive();
80003b7c:	f0 1f 00 22 	mcall	80003c04 <fsm_ecu_state_enable_drive_func+0x160>
				ecu_data->flag_drive_enable = DRIVE_ENABLED;
80003b80:	30 28       	mov	r8,2
80003b82:	ef 48 00 4c 	st.w	r7[76],r8
80003b86:	30 3c       	mov	r12,3
80003b88:	c0 98       	rjmp	80003b9a <fsm_ecu_state_enable_drive_func+0xf6>
				next_state = STATE_READY;
			} else {
				//set error code - return inverters error register?
				ecu_data->ecu_error |= (1 << ERR_INVERTER_INTERNAL);
80003b8a:	ef 08 00 56 	ld.sh	r8,r7[86]
80003b8e:	a3 b8       	sbr	r8,0x3
80003b90:	ef 58 00 56 	st.h	r7[86],r8
80003b94:	30 8c       	mov	r12,8
80003b96:	c0 28       	rjmp	80003b9a <fsm_ecu_state_enable_drive_func+0xf6>
80003b98:	30 2c       	mov	r12,2
			
			default:
			break;
		}
	}
	if (attempts == ATTEMPT_LIMIT) {
80003b9a:	49 78       	lddpc	r8,80003bf4 <fsm_ecu_state_enable_drive_func+0x150>
80003b9c:	90 09       	ld.sh	r9,r8[0x0]
80003b9e:	36 48       	mov	r8,100
80003ba0:	f0 09 19 00 	cp.h	r9,r8
80003ba4:	c1 a1       	brne	80003bd8 <fsm_ecu_state_enable_drive_func+0x134>
		if (internal_state == 0) {
80003ba6:	49 08       	lddpc	r8,80003be4 <fsm_ecu_state_enable_drive_func+0x140>
80003ba8:	11 88       	ld.ub	r8,r8[0x0]
80003baa:	58 08       	cp.w	r8,0
80003bac:	c0 71       	brne	80003bba <fsm_ecu_state_enable_drive_func+0x116>
			ecu_data->ecu_error |= (1 << ERR_FRG);
80003bae:	ef 08 00 56 	ld.sh	r8,r7[86]
80003bb2:	a7 a8       	sbr	r8,0x6
80003bb4:	ef 58 00 56 	st.h	r7[86],r8
80003bb8:	c0 a8       	rjmp	80003bcc <fsm_ecu_state_enable_drive_func+0x128>
		} else if (internal_state == 1) {
80003bba:	30 19       	mov	r9,1
80003bbc:	f2 08 18 00 	cp.b	r8,r9
80003bc0:	c0 61       	brne	80003bcc <fsm_ecu_state_enable_drive_func+0x128>
			ecu_data->ecu_error |= (1 << ERR_INVERTER_COM);
80003bc2:	ef 08 00 56 	ld.sh	r8,r7[86]
80003bc6:	a3 a8       	sbr	r8,0x2
80003bc8:	ef 58 00 56 	st.h	r7[86],r8
		}
		attempts = 0; //Reset
80003bcc:	30 08       	mov	r8,0
80003bce:	48 a9       	lddpc	r9,80003bf4 <fsm_ecu_state_enable_drive_func+0x150>
80003bd0:	b2 08       	st.h	r9[0x0],r8
		internal_state = 0; //Reset
80003bd2:	48 59       	lddpc	r9,80003be4 <fsm_ecu_state_enable_drive_func+0x140>
80003bd4:	b2 88       	st.b	r9[0x0],r8
80003bd6:	30 8c       	mov	r12,8
		next_state = STATE_ERROR;
	}
	
	return next_state;
};
80003bd8:	e3 cd 80 80 	ldm	sp++,r7,pc
80003bdc:	80 00       	ld.sh	r0,r0[0x0]
80003bde:	42 dc       	lddsp	r12,sp[0xb4]
80003be0:	80 00       	ld.sh	r0,r0[0x0]
80003be2:	68 40       	ld.w	r0,r4[0x10]
80003be4:	00 00       	add	r0,r0
80003be6:	cb f8       	rjmp	80003d64 <fsm_ecu_state_startup_func+0x68>
80003be8:	80 00       	ld.sh	r0,r0[0x0]
80003bea:	68 2a       	ld.w	r10,r4[0x8]
80003bec:	80 00       	ld.sh	r0,r0[0x0]
80003bee:	2b 8c       	sub	r12,-72
80003bf0:	80 00       	ld.sh	r0,r0[0x0]
80003bf2:	68 14       	ld.w	r4,r4[0x4]
80003bf4:	00 00       	add	r0,r0
80003bf6:	cc 02       	brcc	80003b76 <fsm_ecu_state_enable_drive_func+0xd2>
80003bf8:	80 00       	ld.sh	r0,r0[0x0]
80003bfa:	44 f0       	lddsp	r0,sp[0x13c]
80003bfc:	80 00       	ld.sh	r0,r0[0x0]
80003bfe:	2a d4       	sub	r4,-83
80003c00:	80 00       	ld.sh	r0,r0[0x0]
80003c02:	3f 5e       	mov	lr,-11
80003c04:	80 00       	ld.sh	r0,r0[0x0]
80003c06:	29 a0       	sub	r0,-102

80003c08 <fsm_ecu_state_charged_func>:
	return next_state;
}

	

fsm_ecu_state_t fsm_ecu_state_charged_func( fsm_ecu_data_t *ecu_data ) {
80003c08:	eb cd 40 c0 	pushm	r6-r7,lr
80003c0c:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_CHARGED;
	uint8_t no_trq_sens = 0;
	uint8_t no_speed_sens = 0;

	get_new_data(ecu_data);
80003c0e:	f0 1f 00 35 	mcall	80003ce0 <fsm_ecu_state_charged_func+0xd8>
	no_trq_sens	  = get_trq_sens(ecu_data);
80003c12:	0e 9c       	mov	r12,r7
80003c14:	f0 1f 00 34 	mcall	80003ce4 <fsm_ecu_state_charged_func+0xdc>
80003c18:	18 96       	mov	r6,r12
	no_speed_sens = get_speed_sens(ecu_data);
80003c1a:	0e 9c       	mov	r12,r7
80003c1c:	f0 1f 00 33 	mcall	80003ce8 <fsm_ecu_state_charged_func+0xe0>
	get_brake_sens(ecu_data);
80003c20:	0e 9c       	mov	r12,r7
80003c22:	f0 1f 00 33 	mcall	80003cec <fsm_ecu_state_charged_func+0xe4>
	no_speed_sens = 0;
	
	if (ecu_data->inverter_vdc < 50) {
80003c26:	ef 09 00 3a 	ld.sh	r9,r7[58]
80003c2a:	33 18       	mov	r8,49
80003c2c:	f0 09 19 00 	cp.h	r9,r8
80003c30:	e0 8b 00 10 	brhi	80003c50 <fsm_ecu_state_charged_func+0x48>
		gpio_set_pin_low(FRG_PIN);
80003c34:	30 9c       	mov	r12,9
80003c36:	f0 1f 00 2f 	mcall	80003cf0 <fsm_ecu_state_charged_func+0xe8>
		gpio_set_pin_low(RFE_PIN);
80003c3a:	31 0c       	mov	r12,16
80003c3c:	f0 1f 00 2d 	mcall	80003cf0 <fsm_ecu_state_charged_func+0xe8>
		gpio_set_pin_low(AIR_PLUS);
80003c40:	30 4c       	mov	r12,4
80003c42:	f0 1f 00 2c 	mcall	80003cf0 <fsm_ecu_state_charged_func+0xe8>
		ecu_data->flag_start_precharge = 0;
80003c46:	30 08       	mov	r8,0
80003c48:	ef 68 00 46 	st.b	r7[70],r8
80003c4c:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		//Reinitialize ECU here if still <90% error
		return STATE_STARTUP;
	}
	
	if(ecu_data->flag_drive_enable == DRIVE_ENABLE_REQUEST) {
80003c50:	6f 38       	ld.w	r8,r7[0x4c]
80003c52:	58 18       	cp.w	r8,1
80003c54:	c0 30       	breq	80003c5a <fsm_ecu_state_charged_func+0x52>
80003c56:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
 * \return bool    \c true if the pin is in low logical level
 *                 \c false if the pin is not in low logical level
 */
__always_inline static bool gpio_pin_is_low(uint32_t pin)
{
	return (gpio_get_pin_value(pin) == 0);
80003c5a:	30 4c       	mov	r12,4
80003c5c:	f0 1f 00 26 	mcall	80003cf4 <fsm_ecu_state_charged_func+0xec>
		if (gpio_pin_is_low(AIR_PLUS)) {
80003c60:	c0 30       	breq	80003c66 <fsm_ecu_state_charged_func+0x5e>
80003c62:	30 1c       	mov	r12,1
80003c64:	c0 78       	rjmp	80003c72 <fsm_ecu_state_charged_func+0x6a>
			ecu_data->ecu_error |= (1 << ERR_AIR_PLUS);
80003c66:	ef 08 00 56 	ld.sh	r8,r7[86]
80003c6a:	a7 b8       	sbr	r8,0x7
80003c6c:	ef 58 00 56 	st.h	r7[86],r8
80003c70:	30 8c       	mov	r12,8
			next_state = STATE_ERROR;
		}
		if (no_trq_sens) {
80003c72:	58 06       	cp.w	r6,0
80003c74:	c0 70       	breq	80003c82 <fsm_ecu_state_charged_func+0x7a>
			ecu_data->ecu_error |= (1 << ERR_TRQ_SENSORS);
80003c76:	ef 08 00 56 	ld.sh	r8,r7[86]
80003c7a:	a5 a8       	sbr	r8,0x4
80003c7c:	ef 58 00 56 	st.h	r7[86],r8
80003c80:	30 8c       	mov	r12,8
		}
		if (no_speed_sens) {
			ecu_data->ecu_error |= (1 << ERR_SPEED_SENSORS);
			next_state = STATE_ERROR;
		}
		if (ecu_data->brake_front == 0) {
80003c82:	ef 09 00 42 	ld.sh	r9,r7[66]
80003c86:	30 08       	mov	r8,0
80003c88:	f0 09 19 00 	cp.h	r9,r8
80003c8c:	c0 71       	brne	80003c9a <fsm_ecu_state_charged_func+0x92>
			ecu_data->ecu_error |= (1 << ERR_BRAKE_SENS_FRONT);
80003c8e:	ef 08 00 56 	ld.sh	r8,r7[86]
80003c92:	a9 b8       	sbr	r8,0x9
80003c94:	ef 58 00 56 	st.h	r7[86],r8
80003c98:	30 8c       	mov	r12,8
			next_state = STATE_ERROR;
		}
		if (ecu_data->brake_rear == 0) {
80003c9a:	ef 09 00 44 	ld.sh	r9,r7[68]
80003c9e:	30 08       	mov	r8,0
80003ca0:	f0 09 19 00 	cp.h	r9,r8
80003ca4:	c0 91       	brne	80003cb6 <fsm_ecu_state_charged_func+0xae>
			ecu_data->ecu_error |= (1 << ERR_BRAKE_SENS_REAR);
80003ca6:	ef 08 00 56 	ld.sh	r8,r7[86]
80003caa:	ab a8       	sbr	r8,0xa
80003cac:	ef 58 00 56 	st.h	r7[86],r8
80003cb0:	30 8c       	mov	r12,8
80003cb2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			next_state = STATE_ERROR;
		}
		if (next_state != STATE_ERROR) {
80003cb6:	58 8c       	cp.w	r12,8
80003cb8:	c1 10       	breq	80003cda <fsm_ecu_state_charged_func+0xd2>
			if ((ecu_data->trq_sens0 < 20) && (ecu_data->trq_sens1 < 20)) {
80003cba:	ef 09 00 10 	ld.sh	r9,r7[16]
80003cbe:	31 38       	mov	r8,19
80003cc0:	f0 09 19 00 	cp.h	r9,r8
80003cc4:	e0 89 00 0b 	brgt	80003cda <fsm_ecu_state_charged_func+0xd2>
80003cc8:	ef 09 00 12 	ld.sh	r9,r7[18]
80003ccc:	f0 09 19 00 	cp.h	r9,r8
80003cd0:	e0 89 00 05 	brgt	80003cda <fsm_ecu_state_charged_func+0xd2>
				ecu_can_send_play_rtds();
80003cd4:	f0 1f 00 09 	mcall	80003cf8 <fsm_ecu_state_charged_func+0xf0>
80003cd8:	30 2c       	mov	r12,2
				
			}
		}
	}
	return next_state;
};
80003cda:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003cde:	00 00       	add	r0,r0
80003ce0:	80 00       	ld.sh	r0,r0[0x0]
80003ce2:	42 dc       	lddsp	r12,sp[0xb4]
80003ce4:	80 00       	ld.sh	r0,r0[0x0]
80003ce6:	43 9c       	lddsp	r12,sp[0xe4]
80003ce8:	80 00       	ld.sh	r0,r0[0x0]
80003cea:	44 10       	lddsp	r0,sp[0x104]
80003cec:	80 00       	ld.sh	r0,r0[0x0]
80003cee:	44 88       	lddsp	r8,sp[0x120]
80003cf0:	80 00       	ld.sh	r0,r0[0x0]
80003cf2:	68 40       	ld.w	r0,r4[0x10]
80003cf4:	80 00       	ld.sh	r0,r0[0x0]
80003cf6:	68 14       	ld.w	r4,r4[0x4]
80003cf8:	80 00       	ld.sh	r0,r0[0x0]
80003cfa:	29 e0       	sub	r0,-98

80003cfc <fsm_ecu_state_startup_func>:

fsm_ecu_state_t fsm_ecu_run_state( fsm_ecu_state_t current_state, fsm_ecu_data_t *data) {
	return fsm_ecu_state_table[ current_state ]( data );
};

fsm_ecu_state_t fsm_ecu_state_startup_func( fsm_ecu_data_t *ecu_data ) {
80003cfc:	eb cd 40 80 	pushm	r7,lr
80003d00:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_STARTUP;
	static uint8_t internal_state = 0;
	static uint8_t precharge_timer = 0;

	get_new_data(ecu_data);
80003d02:	f0 1f 00 5a 	mcall	80003e68 <fsm_ecu_state_startup_func+0x16c>

	if (ecu_data->flag_start_precharge == 1) {
80003d06:	ef 39 00 46 	ld.ub	r9,r7[70]
80003d0a:	30 18       	mov	r8,1
80003d0c:	f0 09 18 00 	cp.b	r9,r8
80003d10:	c7 51       	brne	80003dfa <fsm_ecu_state_startup_func+0xfe>
		switch (internal_state) {
80003d12:	4d 78       	lddpc	r8,80003e6c <fsm_ecu_state_startup_func+0x170>
80003d14:	11 88       	ld.ub	r8,r8[0x0]
80003d16:	30 19       	mov	r9,1
80003d18:	f2 08 18 00 	cp.b	r8,r9
80003d1c:	c2 20       	breq	80003d60 <fsm_ecu_state_startup_func+0x64>
80003d1e:	c0 a3       	brcs	80003d32 <fsm_ecu_state_startup_func+0x36>
80003d20:	30 29       	mov	r9,2
80003d22:	f2 08 18 00 	cp.b	r8,r9
80003d26:	c3 b0       	breq	80003d9c <fsm_ecu_state_startup_func+0xa0>
80003d28:	30 39       	mov	r9,3
80003d2a:	f2 08 18 00 	cp.b	r8,r9
80003d2e:	c6 61       	brne	80003dfa <fsm_ecu_state_startup_func+0xfe>
80003d30:	c4 f8       	rjmp	80003dce <fsm_ecu_state_startup_func+0xd2>
			case 0:
			if (ecu_data->vdc_battery > 0) {
80003d32:	ef 09 00 38 	ld.sh	r9,r7[56]
80003d36:	30 08       	mov	r8,0
80003d38:	f0 09 19 00 	cp.h	r9,r8
80003d3c:	c0 c0       	breq	80003d54 <fsm_ecu_state_startup_func+0x58>
				if (ecu_data->inverter_vdc > 0) {
80003d3e:	ef 09 00 3a 	ld.sh	r9,r7[58]
80003d42:	f0 09 19 00 	cp.h	r9,r8
80003d46:	c0 70       	breq	80003d54 <fsm_ecu_state_startup_func+0x58>
					internal_state = 1;
80003d48:	30 19       	mov	r9,1
80003d4a:	4c 98       	lddpc	r8,80003e6c <fsm_ecu_state_startup_func+0x170>
80003d4c:	b0 89       	st.b	r8[0x0],r9
					attempts = 0;	
80003d4e:	30 09       	mov	r9,0
80003d50:	4c 88       	lddpc	r8,80003e70 <fsm_ecu_state_startup_func+0x174>
80003d52:	b0 09       	st.h	r8[0x0],r9
				}
			}
			attempts++;
80003d54:	4c 78       	lddpc	r8,80003e70 <fsm_ecu_state_startup_func+0x174>
80003d56:	90 09       	ld.sh	r9,r8[0x0]
80003d58:	2f f9       	sub	r9,-1
80003d5a:	b0 09       	st.h	r8[0x0],r9
80003d5c:	30 0c       	mov	r12,0
			break;
80003d5e:	c4 f8       	rjmp	80003dfc <fsm_ecu_state_startup_func+0x100>
			
			case 1:
			if (precharge_timer < 3*SOFTWARE_TIMER_1_SEC) {
80003d60:	4c 58       	lddpc	r8,80003e74 <fsm_ecu_state_startup_func+0x178>
80003d62:	11 88       	ld.ub	r8,r8[0x0]
80003d64:	39 59       	mov	r9,-107
80003d66:	f2 08 18 00 	cp.b	r8,r9
80003d6a:	e0 8b 00 07 	brhi	80003d78 <fsm_ecu_state_startup_func+0x7c>
				precharge_timer++;
80003d6e:	2f f8       	sub	r8,-1
80003d70:	4c 19       	lddpc	r9,80003e74 <fsm_ecu_state_startup_func+0x178>
80003d72:	b2 88       	st.b	r9[0x0],r8
80003d74:	30 0c       	mov	r12,0
80003d76:	c4 38       	rjmp	80003dfc <fsm_ecu_state_startup_func+0x100>
			} else {
				precharge_timer = 0;
80003d78:	30 09       	mov	r9,0
80003d7a:	4b f8       	lddpc	r8,80003e74 <fsm_ecu_state_startup_func+0x178>
80003d7c:	b0 89       	st.b	r8[0x0],r9
				ecu_dio_inverter_clear_error();
80003d7e:	f0 1f 00 3f 	mcall	80003e78 <fsm_ecu_state_startup_func+0x17c>
				ecu_data->inverter_error = 0xDEAD;
80003d82:	fe 78 de ad 	mov	r8,-8531
80003d86:	ef 58 00 54 	st.h	r7[84],r8
				ecu_can_inverter_read_reg(ERROR_REG);
80003d8a:	e0 6c 00 8f 	mov	r12,143
80003d8e:	f0 1f 00 3c 	mcall	80003e7c <fsm_ecu_state_startup_func+0x180>
				internal_state = 2;	
80003d92:	30 29       	mov	r9,2
80003d94:	4b 68       	lddpc	r8,80003e6c <fsm_ecu_state_startup_func+0x170>
80003d96:	b0 89       	st.b	r8[0x0],r9
80003d98:	30 0c       	mov	r12,0
80003d9a:	c3 18       	rjmp	80003dfc <fsm_ecu_state_startup_func+0x100>
			}
			break;
			
			case 2:
			if (ecu_data->inverter_error != 0xDEAD) {
80003d9c:	ef 09 00 54 	ld.sh	r9,r7[84]
80003da0:	fe 78 de ad 	mov	r8,-8531
80003da4:	f0 09 19 00 	cp.h	r9,r8
80003da8:	c0 90       	breq	80003dba <fsm_ecu_state_startup_func+0xbe>
				internal_state = 3;
80003daa:	30 39       	mov	r9,3
80003dac:	4b 08       	lddpc	r8,80003e6c <fsm_ecu_state_startup_func+0x170>
80003dae:	b0 89       	st.b	r8[0x0],r9
				attempts = 0;
80003db0:	30 09       	mov	r9,0
80003db2:	4b 08       	lddpc	r8,80003e70 <fsm_ecu_state_startup_func+0x174>
80003db4:	b0 09       	st.h	r8[0x0],r9
80003db6:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
			} else {
				ecu_can_inverter_read_reg(ERROR_REG);
80003dba:	e0 6c 00 8f 	mov	r12,143
80003dbe:	f0 1f 00 30 	mcall	80003e7c <fsm_ecu_state_startup_func+0x180>
				attempts++;
80003dc2:	4a c8       	lddpc	r8,80003e70 <fsm_ecu_state_startup_func+0x174>
80003dc4:	90 09       	ld.sh	r9,r8[0x0]
80003dc6:	2f f9       	sub	r9,-1
80003dc8:	b0 09       	st.h	r8[0x0],r9
80003dca:	30 0c       	mov	r12,0
80003dcc:	c1 88       	rjmp	80003dfc <fsm_ecu_state_startup_func+0x100>
			}
			break;
			
			case 3:
			if(check_inverter_error(ecu_data) == 0) {
80003dce:	0e 9c       	mov	r12,r7
80003dd0:	f0 1f 00 2c 	mcall	80003e80 <fsm_ecu_state_startup_func+0x184>
80003dd4:	c0 30       	breq	80003dda <fsm_ecu_state_startup_func+0xde>
80003dd6:	30 0c       	mov	r12,0
80003dd8:	c0 c8       	rjmp	80003df0 <fsm_ecu_state_startup_func+0xf4>
				attempts = 0; //Reset
80003dda:	30 08       	mov	r8,0
80003ddc:	4a 59       	lddpc	r9,80003e70 <fsm_ecu_state_startup_func+0x174>
80003dde:	b2 08       	st.h	r9[0x0],r8
				internal_state = 0; //Reset
80003de0:	4a 39       	lddpc	r9,80003e6c <fsm_ecu_state_startup_func+0x170>
80003de2:	b2 88       	st.b	r9[0x0],r8
				gpio_set_pin_high(AIR_PLUS);
80003de4:	30 4c       	mov	r12,4
80003de6:	f0 1f 00 28 	mcall	80003e84 <fsm_ecu_state_startup_func+0x188>
				ecu_can_send_tractive_system_active();
80003dea:	f0 1f 00 28 	mcall	80003e88 <fsm_ecu_state_startup_func+0x18c>
80003dee:	30 1c       	mov	r12,1
				next_state =  STATE_CHARGED;
			}
			attempts++;
80003df0:	4a 08       	lddpc	r8,80003e70 <fsm_ecu_state_startup_func+0x174>
80003df2:	90 09       	ld.sh	r9,r8[0x0]
80003df4:	2f f9       	sub	r9,-1
80003df6:	b0 09       	st.h	r8[0x0],r9
80003df8:	c0 28       	rjmp	80003dfc <fsm_ecu_state_startup_func+0x100>
80003dfa:	30 0c       	mov	r12,0
			break;
		}
	}
	
	
	if (attempts == ATTEMPT_LIMIT) {
80003dfc:	49 d8       	lddpc	r8,80003e70 <fsm_ecu_state_startup_func+0x174>
80003dfe:	90 09       	ld.sh	r9,r8[0x0]
80003e00:	36 48       	mov	r8,100
80003e02:	f0 09 19 00 	cp.h	r9,r8
80003e06:	c2 e1       	brne	80003e62 <fsm_ecu_state_startup_func+0x166>
		switch (internal_state) {
80003e08:	49 98       	lddpc	r8,80003e6c <fsm_ecu_state_startup_func+0x170>
80003e0a:	11 88       	ld.ub	r8,r8[0x0]
80003e0c:	30 19       	mov	r9,1
80003e0e:	f2 08 18 00 	cp.b	r8,r9
80003e12:	c1 10       	breq	80003e34 <fsm_ecu_state_startup_func+0x138>
80003e14:	c0 a3       	brcs	80003e28 <fsm_ecu_state_startup_func+0x12c>
80003e16:	30 29       	mov	r9,2
80003e18:	f2 08 18 00 	cp.b	r8,r9
80003e1c:	c1 20       	breq	80003e40 <fsm_ecu_state_startup_func+0x144>
80003e1e:	30 39       	mov	r9,3
80003e20:	f2 08 18 00 	cp.b	r8,r9
80003e24:	c1 91       	brne	80003e56 <fsm_ecu_state_startup_func+0x15a>
80003e26:	c1 38       	rjmp	80003e4c <fsm_ecu_state_startup_func+0x150>
			case 0:
			ecu_data->ecu_error |= (1 << ERR_BMS_COM);
80003e28:	ef 08 00 56 	ld.sh	r8,r7[86]
80003e2c:	a1 a8       	sbr	r8,0x0
80003e2e:	ef 58 00 56 	st.h	r7[86],r8
			break;
80003e32:	c1 28       	rjmp	80003e56 <fsm_ecu_state_startup_func+0x15a>
			case 1:
			ecu_data->ecu_error |= (1 << ERR_INVERTER_VDC_LOW);
80003e34:	ef 08 00 56 	ld.sh	r8,r7[86]
80003e38:	a1 b8       	sbr	r8,0x1
80003e3a:	ef 58 00 56 	st.h	r7[86],r8
			break;
80003e3e:	c0 c8       	rjmp	80003e56 <fsm_ecu_state_startup_func+0x15a>
			case 2:
			ecu_data->ecu_error |= (1 << ERR_INVERTER_COM);
80003e40:	ef 08 00 56 	ld.sh	r8,r7[86]
80003e44:	a3 a8       	sbr	r8,0x2
80003e46:	ef 58 00 56 	st.h	r7[86],r8
			break;
80003e4a:	c0 68       	rjmp	80003e56 <fsm_ecu_state_startup_func+0x15a>
			case 3:
			ecu_data->ecu_error |= (1 << ERR_INVERTER_INTERNAL);
80003e4c:	ef 08 00 56 	ld.sh	r8,r7[86]
80003e50:	a3 b8       	sbr	r8,0x3
80003e52:	ef 58 00 56 	st.h	r7[86],r8
			break;
		}
		attempts = 0;
80003e56:	30 08       	mov	r8,0
80003e58:	48 69       	lddpc	r9,80003e70 <fsm_ecu_state_startup_func+0x174>
80003e5a:	b2 08       	st.h	r9[0x0],r8
		internal_state = 0;
80003e5c:	48 49       	lddpc	r9,80003e6c <fsm_ecu_state_startup_func+0x170>
80003e5e:	b2 88       	st.b	r9[0x0],r8
80003e60:	30 8c       	mov	r12,8
		next_state =  STATE_ERROR;
	}
	return next_state;
}
80003e62:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e66:	00 00       	add	r0,r0
80003e68:	80 00       	ld.sh	r0,r0[0x0]
80003e6a:	42 dc       	lddsp	r12,sp[0xb4]
80003e6c:	00 00       	add	r0,r0
80003e6e:	cb fe       	rcall	80003bec <fsm_ecu_state_enable_drive_func+0x148>
80003e70:	00 00       	add	r0,r0
80003e72:	cc 02       	brcc	80003df2 <fsm_ecu_state_startup_func+0xf6>
80003e74:	00 00       	add	r0,r0
80003e76:	cb fd       	rcall	800041f4 <handle_inverter_data+0x48>
80003e78:	80 00       	ld.sh	r0,r0[0x0]
80003e7a:	44 f0       	lddsp	r0,sp[0x13c]
80003e7c:	80 00       	ld.sh	r0,r0[0x0]
80003e7e:	2a d4       	sub	r4,-83
80003e80:	80 00       	ld.sh	r0,r0[0x0]
80003e82:	3f 5e       	mov	lr,-11
80003e84:	80 00       	ld.sh	r0,r0[0x0]
80003e86:	68 2a       	ld.w	r10,r4[0x8]
80003e88:	80 00       	ld.sh	r0,r0[0x0]
80003e8a:	2a 1c       	sub	r12,-95

80003e8c <brake_plausibility_check>:
	return true;
}

bool brake_plausibility_check(fsm_ecu_data_t *ecu_data) {
	static uint8_t plausibility_timer = 0;
	int16_t trq_sens = max(ecu_data->trq_sens0, ecu_data->trq_sens1); //Changed to max 10/6-14
80003e8c:	f9 08 00 10 	ld.sh	r8,r12[16]
80003e90:	f9 09 00 12 	ld.sh	r9,r12[18]
80003e94:	f0 09 0c 49 	max	r9,r8,r9
	
	if ((trq_sens > 250) && (ecu_data->brake_front > BRAKE_TRESHOLD)) {
80003e98:	e0 68 00 fa 	mov	r8,250
80003e9c:	f0 09 19 00 	cp.h	r9,r8
80003ea0:	e0 8a 00 17 	brle	80003ece <brake_plausibility_check+0x42>
80003ea4:	f9 09 00 42 	ld.sh	r9,r12[66]
80003ea8:	e0 68 13 88 	mov	r8,5000
80003eac:	f0 09 19 00 	cp.h	r9,r8
80003eb0:	e0 88 00 0f 	brls	80003ece <brake_plausibility_check+0x42>
		plausibility_timer++;
80003eb4:	48 99       	lddpc	r9,80003ed8 <brake_plausibility_check+0x4c>
80003eb6:	13 88       	ld.ub	r8,r9[0x0]
80003eb8:	2f f8       	sub	r8,-1
80003eba:	b2 88       	st.b	r9[0x0],r8
		if (plausibility_timer == BRAKE_PLAUSIBILITY_TIME_LIMIT) {
80003ebc:	31 99       	mov	r9,25
80003ebe:	f2 08 18 00 	cp.b	r8,r9
80003ec2:	c0 20       	breq	80003ec6 <brake_plausibility_check+0x3a>
80003ec4:	5e ff       	retal	1
			plausibility_timer = 0;
80003ec6:	30 09       	mov	r9,0
80003ec8:	48 48       	lddpc	r8,80003ed8 <brake_plausibility_check+0x4c>
80003eca:	b0 89       	st.b	r8[0x0],r9
80003ecc:	5e fd       	retal	0
			return false;
		}
	} else {
		plausibility_timer = 0; //Added 10/6-14
80003ece:	30 09       	mov	r9,0
80003ed0:	48 28       	lddpc	r8,80003ed8 <brake_plausibility_check+0x4c>
80003ed2:	b0 89       	st.b	r8[0x0],r9
80003ed4:	5e ff       	retal	1
80003ed6:	00 00       	add	r0,r0
80003ed8:	00 00       	add	r0,r0
80003eda:	cc 05       	brlt	80003e5a <fsm_ecu_state_startup_func+0x15e>

80003edc <torque_plausibility_check>:
// 	return true;
}

bool torque_plausibility_check(fsm_ecu_data_t *ecu_data) {
	/* Torque sensors = <0, 1000> */
	if ( ecu_data->trq_sens0_err || ecu_data->trq_sens1_err) {
80003edc:	78 58       	ld.w	r8,r12[0x14]
80003ede:	e0 18 00 00 	andl	r8,0x0
80003ee2:	c0 30       	breq	80003ee8 <torque_plausibility_check+0xc>
		asm("nop");
80003ee4:	d7 03       	nop
80003ee6:	5e fd       	retal	0
		return false;
	} else {
		int16_t deviation = max(ecu_data->trq_sens0, ecu_data->trq_sens1) - min(ecu_data->trq_sens0,ecu_data->trq_sens1);
80003ee8:	f9 08 00 10 	ld.sh	r8,r12[16]
80003eec:	f9 09 00 12 	ld.sh	r9,r12[18]
80003ef0:	f0 09 0c 4a 	max	r10,r8,r9
80003ef4:	f0 09 0d 48 	min	r8,r8,r9
		if (deviation > 100) {
80003ef8:	f4 08 01 08 	sub	r8,r10,r8
80003efc:	36 4a       	mov	r10,100
80003efe:	f4 08 19 00 	cp.h	r8,r10
80003f02:	e0 89 00 03 	brgt	80003f08 <torque_plausibility_check+0x2c>
80003f06:	5e ff       	retal	1
			asm("nop");
80003f08:	d7 03       	nop
80003f0a:	5e fd       	retal	0

80003f0c <calc_bms_power>:
		}
		return true;
	}
}

uint16_t calc_bms_power(fsm_ecu_data_t *ecu_data) {
80003f0c:	f9 09 00 38 	ld.sh	r9,r12[56]
80003f10:	f9 08 00 8a 	ld.sh	r8,r12[138]
80003f14:	f2 08 07 8c 	mulhh.w	r12,r9:b,r8:b
	int16_t current = ecu_data->bms_current;
	int16_t voltage = ecu_data->vdc_battery;
	return (uint16_t)(voltage*current);
}
80003f18:	5c 8c       	casts.h	r12
80003f1a:	5e fc       	retal	r12

80003f1c <calc_inverter_power>:

uint16_t calc_inverter_power(fsm_ecu_data_t *ecu_data) {
80003f1c:	f9 19 00 3c 	ld.uh	r9,r12[60]
80003f20:	e0 68 02 74 	mov	r8,628
80003f24:	f2 08 02 48 	mul	r8,r9,r8
80003f28:	f9 1a 00 16 	ld.uh	r10,r12[22]
80003f2c:	e0 69 00 b4 	mov	r9,180
80003f30:	f4 09 02 49 	mul	r9,r10,r9
80003f34:	e0 6b 00 81 	mov	r11,129
80003f38:	ea 1b 80 08 	orh	r11,0x8008
80003f3c:	f2 0b 04 4a 	muls.d	r10,r9,r11
80003f40:	16 09       	add	r9,r11
80003f42:	f3 d9 c1 d0 	bfextu	r9,r9,0xe,0x10
80003f46:	b3 38       	mul	r8,r9
80003f48:	e0 6b 9f 81 	mov	r11,40833
80003f4c:	ea 1b 16 5e 	orh	r11,0x165e
80003f50:	f0 0b 04 4a 	muls.d	r10,r8,r11
80003f54:	f6 0c 14 13 	asr	r12,r11,0x13
80003f58:	bf 58       	asr	r8,0x1f
	uint16_t rpm = ecu_data->rpm;
	uint16_t trq = (uint16_t)ecu_data->trq_cmd*180/MAX_TORQUE;//180Nm
	uint32_t power = trq*rpm*628/(100*60*1000); //In kW
	return (uint16_t)power; //Such number
}
80003f5a:	10 1c       	sub	r12,r8
80003f5c:	5e fc       	retal	r12

80003f5e <check_inverter_error>:
	return temp;
}

uint8_t check_inverter_error(fsm_ecu_data_t *ecu_data) {
	uint16_t temp = ecu_data->inverter_error;
	return (uint8_t)(temp & 1 << PWR_FAULT) | (temp & 1 << RFE_FAULT) | (temp & 1 << RESOLVER_FAULT);
80003f5e:	f9 39 00 55 	ld.ub	r9,r12[85]
80003f62:	12 98       	mov	r8,r9
80003f64:	10 9c       	mov	r12,r8
80003f66:	e2 1c 00 04 	andl	r12,0x4,COH
80003f6a:	e2 19 00 02 	andl	r9,0x2,COH
80003f6e:	12 4c       	or	r12,r9
80003f70:	e2 18 00 08 	andl	r8,0x8,COH
80003f74:	10 4c       	or	r12,r8
}
80003f76:	e2 1c 00 0e 	andl	r12,0xe,COH
80003f7a:	5e fc       	retal	r12

80003f7c <convert_to_big_endian>:
	return (uint16_t)(float)((num_be + 827) / 33.2);
}

uint16_t convert_to_big_endian(uint32_t data) {
	/* Input: 0x49 D2 2A 00 Output:0x2A D2 */
	uint16_t relevant_data = (data & 0xFFFF00) >> 8;
80003f7c:	f9 dc c1 10 	bfextu	r12,r12,0x8,0x10
80003f80:	f8 08 16 08 	lsr	r8,r12,0x8
80003f84:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
	return ((relevant_data & 0xFF) << 8 | (relevant_data & 0xFF00) >> 8);
}
80003f88:	5c 8c       	casts.h	r12
80003f8a:	5e fc       	retal	r12

80003f8c <convert_num_to_vdc>:
		status++;
	}
	return status;
}

uint16_t convert_num_to_vdc(uint32_t num) {
80003f8c:	d4 01       	pushm	lr
	/* num = 33.2*vdc - 827 */
	uint32_t num_be = convert_to_big_endian(num);
80003f8e:	f0 1f 00 0c 	mcall	80003fbc <convert_num_to_vdc+0x30>
80003f92:	5c 7c       	castu.h	r12
80003f94:	f8 cc fc c5 	sub	r12,r12,-827
80003f98:	f0 1f 00 0a 	mcall	80003fc0 <convert_num_to_vdc+0x34>
80003f9c:	e0 68 99 9a 	mov	r8,39322
80003fa0:	ea 18 99 99 	orh	r8,0x9999
80003fa4:	e0 69 99 99 	mov	r9,39321
80003fa8:	ea 19 40 40 	orh	r9,0x4040
80003fac:	f0 1f 00 06 	mcall	80003fc4 <convert_num_to_vdc+0x38>
80003fb0:	f0 1f 00 06 	mcall	80003fc8 <convert_num_to_vdc+0x3c>
80003fb4:	e5 a9 0c 0c 	cop	cp0,cr12,cr0,cr12,0x52
	return (uint16_t)(float)((num_be + 827) / 33.2);
}
80003fb8:	5c 8c       	casts.h	r12
80003fba:	d8 02       	popm	pc
80003fbc:	80 00       	ld.sh	r0,r0[0x0]
80003fbe:	3f 7c       	mov	r12,-9
80003fc0:	80 00       	ld.sh	r0,r0[0x0]
80003fc2:	6f 98       	ld.w	r8,r7[0x64]
80003fc4:	80 00       	ld.sh	r0,r0[0x0]
80003fc6:	70 80       	ld.w	r0,r8[0x20]
80003fc8:	80 00       	ld.sh	r0,r0[0x0]
80003fca:	75 58       	ld.w	r8,r10[0x54]

80003fcc <handle_bms_data>:
	}
}

void handle_bms_data(fsm_ecu_data_t *ecu_data) {
	/* Max period 300 ms, contactor req, battery current input msg */
	switch (ecu_data->bms_msg.id) {
80003fcc:	78 d8       	ld.w	r8,r12[0x34]
80003fce:	e0 48 04 2a 	cp.w	r8,1066
80003fd2:	c1 b0       	breq	80004008 <handle_bms_data+0x3c>
80003fd4:	e0 8b 00 06 	brhi	80003fe0 <handle_bms_data+0x14>
80003fd8:	e0 48 04 29 	cp.w	r8,1065
80003fdc:	5e 1c       	retne	r12
80003fde:	c0 88       	rjmp	80003fee <handle_bms_data+0x22>
80003fe0:	e0 48 04 2b 	cp.w	r8,1067
80003fe4:	c1 c0       	breq	8000401c <handle_bms_data+0x50>
80003fe6:	e0 48 04 2e 	cp.w	r8,1070
80003fea:	5e 1c       	retne	r12
80003fec:	c1 38       	rjmp	80004012 <handle_bms_data+0x46>
		case (BMS_PRECHARGE_ID):
		if ((ecu_data->bms_msg.data.u8[3] & (1 << BMS_PRECHARGE_BIT)) != 0) {
80003fee:	f9 38 00 2f 	ld.ub	r8,r12[47]
80003ff2:	e2 18 00 08 	andl	r8,0x8,COH
			/* There is a hardwire contactor request */
			ecu_data->flag_start_precharge = 1;
80003ff6:	f9 b8 01 01 	movne	r8,1
80003ffa:	f9 f8 1e 46 	st.bne	r12[0x46],r8
		} else {
			ecu_data->flag_start_precharge = 0;
80003ffe:	f9 b8 00 00 	moveq	r8,0
80004002:	f9 f8 0e 46 	st.beq	r12[0x46],r8
80004006:	5e fc       	retal	r12
		}
		break;
		case (BMS_BATT_VOLT_ID):
		ecu_data->vdc_battery = ecu_data->bms_msg.data.u16[0];
80004008:	f9 08 00 2c 	ld.sh	r8,r12[44]
8000400c:	f9 58 00 38 	st.h	r12[56],r8
		break;
80004010:	5e fc       	retal	r12
		case (BMS_BATT_TEMP_ID):
		ecu_data->max_cell_temp = ecu_data->bms_msg.data.s8[4];
80004012:	f9 38 00 30 	ld.ub	r8,r12[48]
80004016:	f9 68 00 48 	st.b	r12[72],r8
		break;
8000401a:	5e fc       	retal	r12
		
		case (0x42B):
		ecu_data->bms_current = ecu_data->bms_msg.data.s16[0];
8000401c:	f9 08 00 2c 	ld.sh	r8,r12[44]
80004020:	f9 58 00 8a 	st.h	r12[138],r8
80004024:	5e fc       	retal	r12
80004026:	d7 03       	nop

80004028 <handle_dash_data>:
		default:
		break;
	}
}

void handle_dash_data(fsm_ecu_data_t *ecu_data) {
80004028:	eb cd 40 c0 	pushm	r6-r7,lr
8000402c:	18 97       	mov	r7,r12
	uint8_t rtds_plays;
	uint8_t start;
	uint8_t lc_filter_time;
	uint8_t state_of_lc = 0;
	switch (ecu_data->dash_msg.id) {
8000402e:	f9 08 00 28 	ld.sh	r8,r12[40]
80004032:	e0 69 02 63 	mov	r9,611
80004036:	f2 08 19 00 	cp.h	r8,r9
8000403a:	e0 80 00 8f 	breq	80004158 <handle_dash_data+0x130>
8000403e:	e0 8b 00 10 	brhi	8000405e <handle_dash_data+0x36>
80004042:	e0 69 02 61 	mov	r9,609
80004046:	f2 08 19 00 	cp.h	r8,r9
8000404a:	c2 40       	breq	80004092 <handle_dash_data+0x6a>
8000404c:	e0 8b 00 46 	brhi	800040d8 <handle_dash_data+0xb0>
80004050:	e0 69 02 60 	mov	r9,608
80004054:	f2 08 19 00 	cp.h	r8,r9
80004058:	e0 81 00 a0 	brne	80004198 <handle_dash_data+0x170>
8000405c:	c0 f8       	rjmp	8000407a <handle_dash_data+0x52>
8000405e:	e0 69 02 65 	mov	r9,613
80004062:	f2 08 19 00 	cp.h	r8,r9
80004066:	e0 80 00 95 	breq	80004190 <handle_dash_data+0x168>
8000406a:	c7 d3       	brcs	80004164 <handle_dash_data+0x13c>
8000406c:	e0 69 06 63 	mov	r9,1635
80004070:	f2 08 19 00 	cp.h	r8,r9
80004074:	e0 81 00 92 	brne	80004198 <handle_dash_data+0x170>
80004078:	c6 38       	rjmp	8000413e <handle_dash_data+0x116>
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID0_ID):
		rtds_plays = ecu_data->dash_msg.data.u8[0];
8000407a:	f9 39 00 20 	ld.ub	r9,r12[32]
8000407e:	30 18       	mov	r8,1
80004080:	f0 09 18 00 	cp.b	r9,r8
80004084:	e0 81 00 8a 	brne	80004198 <handle_dash_data+0x170>
		if (rtds_plays == 1) {
			ecu_data->flag_drive_enable = DRIVE_ENABLE_RTDS_PLAYS;
80004088:	30 38       	mov	r8,3
8000408a:	f9 48 00 4c 	st.w	r12[76],r8
8000408e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		break;
		
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID1_ID):
		start = ecu_data->dash_msg.data.u8[0];
80004092:	f9 36 00 20 	ld.ub	r6,r12[32]
		//uint8_t tractive = ecu_data->dash_msg.data.u8[1];
		ecu_data->kers_factor = ecu_data->dash_msg.data.u16[1];
80004096:	f9 08 00 22 	ld.sh	r8,r12[34]
8000409a:	f9 58 00 88 	st.h	r12[136],r8
		ecu_data->slip_target = ecu_data->dash_msg.data.u16[2]/100.0;
8000409e:	f9 1c 00 24 	ld.uh	r12,r12[36]
800040a2:	f0 1f 00 3f 	mcall	8000419c <handle_dash_data+0x174>
800040a6:	30 08       	mov	r8,0
800040a8:	fc 19 40 59 	movh	r9,0x4059
800040ac:	f0 1f 00 3d 	mcall	800041a0 <handle_dash_data+0x178>
800040b0:	f0 1f 00 3d 	mcall	800041a4 <handle_dash_data+0x17c>
800040b4:	ef 4c 00 74 	st.w	r7[116],r12

		if (start == 0) {
800040b8:	58 06       	cp.w	r6,0
800040ba:	c0 51       	brne	800040c4 <handle_dash_data+0x9c>
			ecu_data->flag_drive_enable = DRIVE_DISABLE_REQUEST;
800040bc:	30 48       	mov	r8,4
800040be:	ef 48 00 4c 	st.w	r7[76],r8
800040c2:	c0 88       	rjmp	800040d2 <handle_dash_data+0xaa>
		} else if (start == 1) {
800040c4:	30 18       	mov	r8,1
			ecu_data->flag_drive_enable = DRIVE_ENABLE_REQUEST;
800040c6:	f0 06 18 00 	cp.b	r6,r8
800040ca:	f9 b8 00 01 	moveq	r8,1
800040ce:	ef f8 0a 13 	st.weq	r7[0x4c],r8
		}
		asm("nop");
800040d2:	d7 03       	nop
		break;
800040d4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID2_ID):
		//PID gains
		ecu_data->Kp = ecu_data->dash_msg.data.u16[0]/10.0;
800040d8:	f9 1c 00 20 	ld.uh	r12,r12[32]
800040dc:	f0 1f 00 30 	mcall	8000419c <handle_dash_data+0x174>
800040e0:	30 08       	mov	r8,0
800040e2:	fc 19 40 24 	movh	r9,0x4024
800040e6:	f0 1f 00 2f 	mcall	800041a0 <handle_dash_data+0x178>
800040ea:	f0 1f 00 2f 	mcall	800041a4 <handle_dash_data+0x17c>
800040ee:	ef 4c 00 68 	st.w	r7[104],r12
		ecu_data->Ki = ecu_data->dash_msg.data.u16[1]/10.0;
800040f2:	ef 1c 00 22 	ld.uh	r12,r7[34]
800040f6:	f0 1f 00 2a 	mcall	8000419c <handle_dash_data+0x174>
800040fa:	30 08       	mov	r8,0
800040fc:	fc 19 40 24 	movh	r9,0x4024
80004100:	f0 1f 00 28 	mcall	800041a0 <handle_dash_data+0x178>
80004104:	f0 1f 00 28 	mcall	800041a4 <handle_dash_data+0x17c>
80004108:	ef 4c 00 6c 	st.w	r7[108],r12
		ecu_data->Kd = ecu_data->dash_msg.data.u16[2]/10.0;
8000410c:	ef 1c 00 24 	ld.uh	r12,r7[36]
80004110:	f0 1f 00 23 	mcall	8000419c <handle_dash_data+0x174>
80004114:	30 08       	mov	r8,0
80004116:	fc 19 40 24 	movh	r9,0x4024
8000411a:	f0 1f 00 22 	mcall	800041a0 <handle_dash_data+0x178>
8000411e:	f0 1f 00 22 	mcall	800041a4 <handle_dash_data+0x17c>
80004122:	ef 4c 00 70 	st.w	r7[112],r12
		ecu_data->d_filter_gain = (N_filter*Ts/(ecu_data->Kd+N_filter*Ts));
80004126:	fc 18 40 00 	movh	r8,0x4000
8000412a:	e5 a0 0b c8 	cop	cp0,cr11,cr12,cr8,0x40
8000412e:	10 9c       	mov	r12,r8
80004130:	f0 1f 00 1e 	mcall	800041a8 <handle_dash_data+0x180>
80004134:	ef 4c 00 78 	st.w	r7[120],r12
		asm("nop");
80004138:	d7 03       	nop
		break;
8000413a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		
		case (CANR_FCN_DATA_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID3_ID):
		//Only permit if ECU in error
		if (ecu_data->state == STATE_ERROR) {
8000413e:	78 08       	ld.w	r8,r12[0x0]
80004140:	58 88       	cp.w	r8,8
80004142:	c0 81       	brne	80004152 <handle_dash_data+0x12a>
			if (ecu_data->dash_msg.data.u8[1]==1) {// Message also contains the current driver
80004144:	f9 39 00 21 	ld.ub	r9,r12[33]
80004148:	30 18       	mov	r8,1
				ecu_data->reboot = 1;
8000414a:	f0 09 18 00 	cp.b	r9,r8
8000414e:	f9 f8 0e 64 	st.beq	r12[0x64],r8
			}
		}
		asm("nop");
80004152:	d7 03       	nop
		break;
80004154:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID3_ID):
		ecu_data->config_max_trq = ecu_data->dash_msg.data.u8[1];
80004158:	f9 38 00 21 	ld.ub	r8,r12[33]
8000415c:	f9 68 00 65 	st.b	r12[101],r8
		break;
80004160:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID4_ID):
		ecu_data->lc_trq_init = ecu_data->dash_msg.data.u8[0];
80004164:	f9 38 00 20 	ld.ub	r8,r12[32]
80004168:	e5 a4 08 08 	cop	cp0,cr8,cr0,cr8,0x48
8000416c:	f9 48 00 84 	st.w	r12[132],r8
		lc_filter_time = ecu_data->dash_msg.data.u8[1];
		ecu_data->lc_filter_gain = Ts/(Ts + lc_filter_time);
80004170:	f9 3b 00 21 	ld.ub	r11,r12[33]
80004174:	e5 a6 0b 0b 	cop	cp0,cr11,cr0,cr11,0x4c
80004178:	e0 6c d7 0a 	mov	r12,55050
8000417c:	ea 1c 3c a3 	orh	r12,0x3ca3
80004180:	e5 a0 0b bc 	cop	cp0,cr11,cr11,cr12,0x40
80004184:	f0 1f 00 09 	mcall	800041a8 <handle_dash_data+0x180>
80004188:	ef 4c 00 80 	st.w	r7[128],r12
		break;
8000418c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID5_ID):
		state_of_lc = ecu_data->dash_msg.data.u8[0];
		ecu_data->launch_control_flag = (launch_control_t)state_of_lc;
80004190:	f9 38 00 20 	ld.ub	r8,r12[32]
80004194:	f9 48 00 60 	st.w	r12[96],r8
80004198:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
8000419c:	80 00       	ld.sh	r0,r0[0x0]
8000419e:	6f a0       	ld.w	r0,r7[0x68]
800041a0:	80 00       	ld.sh	r0,r0[0x0]
800041a2:	70 80       	ld.w	r0,r8[0x20]
800041a4:	80 00       	ld.sh	r0,r0[0x0]
800041a6:	75 58       	ld.w	r8,r10[0x54]
800041a8:	80 00       	ld.sh	r0,r0[0x0]
800041aa:	73 98       	ld.w	r8,r9[0x64]

800041ac <handle_inverter_data>:
		default:
		break;
	}
}

void handle_inverter_data(fsm_ecu_data_t *ecu_data) {
800041ac:	eb cd 40 80 	pushm	r7,lr
800041b0:	18 97       	mov	r7,r12
	 * consist of 4 bytes etc. Refer to manual for the individual
	 * bits in state and error reg.
	 * Temp e.g.: 49d62a00 
	 */
	uint16_t temp;
	switch (ecu_data->inverter_can_msg.data.u8[0]) {
800041b2:	19 c8       	ld.ub	r8,r12[0x4]
800041b4:	34 a9       	mov	r9,74
800041b6:	f2 08 18 00 	cp.b	r8,r9
800041ba:	c1 c0       	breq	800041f2 <handle_inverter_data+0x46>
800041bc:	e0 8b 00 0b 	brhi	800041d2 <handle_inverter_data+0x26>
800041c0:	33 09       	mov	r9,48
800041c2:	f2 08 18 00 	cp.b	r8,r9
800041c6:	c2 b0       	breq	8000421c <handle_inverter_data+0x70>
800041c8:	34 99       	mov	r9,73
800041ca:	f2 08 18 00 	cp.b	r8,r9
800041ce:	c3 f1       	brne	8000424c <handle_inverter_data+0xa0>
800041d0:	c0 a8       	rjmp	800041e4 <handle_inverter_data+0x38>
800041d2:	38 f9       	mov	r9,-113
800041d4:	f2 08 18 00 	cp.b	r8,r9
800041d8:	c3 50       	breq	80004242 <handle_inverter_data+0x96>
800041da:	3e b9       	mov	r9,-21
800041dc:	f2 08 18 00 	cp.b	r8,r9
800041e0:	c3 61       	brne	8000424c <handle_inverter_data+0xa0>
800041e2:	c0 f8       	rjmp	80004200 <handle_inverter_data+0x54>
		case BTB_REG:
			break;
		case FRG_REG:
			break;
		case MOTOR_TEMP_REG:
			ecu_data->motor_temp = convert_to_big_endian(ecu_data->inverter_can_msg.data.u32[0]);
800041e4:	78 1c       	ld.w	r12,r12[0x4]
800041e6:	f0 1f 00 1b 	mcall	80004250 <handle_inverter_data+0xa4>
800041ea:	ef 5c 00 3e 	st.h	r7[62],r12
			break;
800041ee:	e3 cd 80 80 	ldm	sp++,r7,pc
		case IGBT_TEMP_REG:
			ecu_data->inverter_temp = convert_to_big_endian(ecu_data->inverter_can_msg.data.u32[0]);
800041f2:	78 1c       	ld.w	r12,r12[0x4]
800041f4:	f0 1f 00 17 	mcall	80004250 <handle_inverter_data+0xa4>
800041f8:	ef 5c 00 40 	st.h	r7[64],r12
			break;
800041fc:	e3 cd 80 80 	ldm	sp++,r7,pc
		case CURRENT_REG:
			break;
		case VDC_REG:
			/* 16 bit value */
			temp = convert_num_to_vdc(ecu_data->inverter_can_msg.data.u32[0]);
80004200:	78 1c       	ld.w	r12,r12[0x4]
80004202:	f0 1f 00 15 	mcall	80004254 <handle_inverter_data+0xa8>
			if (temp < 30) {
80004206:	31 d8       	mov	r8,29
				ecu_data->inverter_vdc = 0;	
80004208:	f0 0c 19 00 	cp.h	r12,r8
8000420c:	f9 b8 08 00 	movls	r8,0
80004210:	ef f8 8c 1d 	st.hls	r7[0x3a],r8
			} else {
				ecu_data->inverter_vdc = temp;
80004214:	ef fc bc 1d 	st.hhi	r7[0x3a],r12
80004218:	e3 cd 80 80 	ldm	sp++,r7,pc
			}	 
			break;
		case RPM_REG:
			ecu_data->rpm = (MAX_RPM * convert_to_big_endian(ecu_data->inverter_can_msg.data.u32[0])) / 32767;
8000421c:	78 1c       	ld.w	r12,r12[0x4]
8000421e:	f0 1f 00 0d 	mcall	80004250 <handle_inverter_data+0xa4>
80004222:	5c 7c       	castu.h	r12
80004224:	e0 68 13 88 	mov	r8,5000
80004228:	f8 08 02 48 	mul	r8,r12,r8
8000422c:	30 3b       	mov	r11,3
8000422e:	ea 1b 80 01 	orh	r11,0x8001
80004232:	f0 0b 04 4a 	muls.d	r10,r8,r11
80004236:	16 08       	add	r8,r11
80004238:	af 48       	asr	r8,0xe
8000423a:	ef 58 00 3c 	st.h	r7[60],r8
			break;
8000423e:	e3 cd 80 80 	ldm	sp++,r7,pc
		case ERROR_REG:
			ecu_data->inverter_error = (ecu_data->inverter_can_msg.data.u32[0] & 0x00FFFF00) >> 8;
80004242:	78 18       	ld.w	r8,r12[0x4]
80004244:	f1 d8 c1 10 	bfextu	r8,r8,0x8,0x10
80004248:	f9 58 00 54 	st.h	r12[84],r8
8000424c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004250:	80 00       	ld.sh	r0,r0[0x0]
80004252:	3f 7c       	mov	r12,-9
80004254:	80 00       	ld.sh	r0,r0[0x0]
80004256:	3f 8c       	mov	r12,-8

80004258 <map_pedal>:
		default:
			break;
	}
}

void map_pedal(fsm_ecu_data_t *ecu_data) {
80004258:	eb cd 40 c0 	pushm	r6-r7,lr
8000425c:	18 97       	mov	r7,r12
	// Torque sensors = <0,1000>
	static float pedal_filter = 0.0F;
	float config_max_trq = (float)ecu_data->config_max_trq / 100.0;
	
	int16_t trq_sens = (int16_t)min(ecu_data->trq_sens0, ecu_data->trq_sens1);
8000425e:	f9 08 00 10 	ld.sh	r8,r12[16]
80004262:	f9 09 00 12 	ld.sh	r9,r12[18]
80004266:	f0 09 0d 48 	min	r8,r8,r9
	
	// Handle values below 0
	trq_sens = max(0, trq_sens);
8000426a:	5c 88       	casts.h	r8
8000426c:	30 09       	mov	r9,0
8000426e:	f2 08 0c 48 	max	r8,r9,r8
	// Handle values above 1000
	trq_sens = min(trq_sens, 1000);
80004272:	5c 88       	casts.h	r8
80004274:	e0 66 03 e8 	mov	r6,1000
80004278:	f0 06 0d 48 	min	r8,r8,r6
	
	float pedal = (float)MAX_TORQUE*(float)trq_sens*(float)trq_sens*config_max_trq/1000000.0;
8000427c:	5c 88       	casts.h	r8
8000427e:	e5 a6 08 08 	cop	cp0,cr8,cr0,cr8,0x4c
80004282:	e0 66 f0 00 	mov	r6,61440
80004286:	ea 16 46 ff 	orh	r6,0x46ff
8000428a:	e5 a2 06 86 	cop	cp0,cr6,cr8,cr6,0x44
8000428e:	e5 a2 06 86 	cop	cp0,cr6,cr8,cr6,0x44
80004292:	f9 3c 00 65 	ld.ub	r12,r12[101]
80004296:	fc 1b 42 c8 	movh	r11,0x42c8
8000429a:	e5 a4 0c 0c 	cop	cp0,cr12,cr0,cr12,0x48
8000429e:	f0 1f 00 0e 	mcall	800042d4 <map_pedal+0x7c>
800042a2:	e0 6b 24 00 	mov	r11,9216
800042a6:	ea 1b 49 74 	orh	r11,0x4974
800042aa:	e5 a2 0c 6c 	cop	cp0,cr12,cr6,cr12,0x44
800042ae:	f0 1f 00 0a 	mcall	800042d4 <map_pedal+0x7c>
	//float pedal = (float)MAX_TORQUE*(float)trq_sens*config_max_trq/1000.0; //Linear curve
	pedal_filter = (1-PEDAL_FILTER_GAIN)*pedal_filter + PEDAL_FILTER_GAIN*pedal;
800042b2:	48 a9       	lddpc	r9,800042d8 <map_pedal+0x80>
800042b4:	72 0a       	ld.w	r10,r9[0x0]
800042b6:	30 08       	mov	r8,0
800042b8:	e1 ac 08 a8 	cop	cp0,cr8,cr10,cr8,0x18
800042bc:	93 08       	st.w	r9[0x0],r8
	ecu_data->trq_pedal = min(pedal_filter, pedal); //Selects filter when input increases, pedal when decreases
800042be:	e5 ab 08 08 	cop	cp0,cr8,cr0,cr8,0x56
800042c2:	e5 ab 0c 0c 	cop	cp0,cr12,cr0,cr12,0x56
800042c6:	f0 0c 0d 48 	min	r8,r8,r12
800042ca:	e5 a6 08 08 	cop	cp0,cr8,cr0,cr8,0x4c
800042ce:	8f 78       	st.w	r7[0x1c],r8
}
800042d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800042d4:	80 00       	ld.sh	r0,r0[0x0]
800042d6:	73 98       	ld.w	r8,r9[0x64]
800042d8:	00 00       	add	r0,r0
800042da:	cc 08       	rjmp	8000445a <get_speed_sens+0x4a>

800042dc <get_new_data>:
	gpio_set_pin_high(INVERTER_DIN1);
	delay_us(200);
	gpio_set_pin_low(INVERTER_DIN1);
}

void get_new_data(fsm_ecu_data_t *ecu_data) {
800042dc:	eb cd 40 fe 	pushm	r1-r7,lr
800042e0:	18 96       	mov	r6,r12
	uint8_t i;
	for (i=0; i<QUEUE_INVERTER_RX_LEN; i++) {
		if (xQueueReceive( queue_from_inverter, &ecu_data->inverter_can_msg, 0 ) == pdTRUE) {
800042e2:	f8 c3 ff fc 	sub	r3,r12,-4
800042e6:	30 07       	mov	r7,0
800042e8:	4a 62       	lddpc	r2,80004380 <get_new_data+0xa4>
800042ea:	0e 91       	mov	r1,r7
			handle_inverter_data(ecu_data);
			ecu_data->inverter_timeout = 0;
800042ec:	30 05       	mov	r5,0
	gpio_set_pin_low(INVERTER_DIN1);
}

void get_new_data(fsm_ecu_data_t *ecu_data) {
	uint8_t i;
	for (i=0; i<QUEUE_INVERTER_RX_LEN; i++) {
800042ee:	30 54       	mov	r4,5
		if (xQueueReceive( queue_from_inverter, &ecu_data->inverter_can_msg, 0 ) == pdTRUE) {
800042f0:	02 99       	mov	r9,r1
800042f2:	02 9a       	mov	r10,r1
800042f4:	06 9b       	mov	r11,r3
800042f6:	64 0c       	ld.w	r12,r2[0x0]
800042f8:	f0 1f 00 23 	mcall	80004384 <get_new_data+0xa8>
800042fc:	58 1c       	cp.w	r12,1
800042fe:	c0 c1       	brne	80004316 <get_new_data+0x3a>
			handle_inverter_data(ecu_data);
80004300:	0c 9c       	mov	r12,r6
80004302:	f0 1f 00 22 	mcall	80004388 <get_new_data+0xac>
			ecu_data->inverter_timeout = 0;
80004306:	ed 65 00 7c 	st.b	r6[124],r5
	gpio_set_pin_low(INVERTER_DIN1);
}

void get_new_data(fsm_ecu_data_t *ecu_data) {
	uint8_t i;
	for (i=0; i<QUEUE_INVERTER_RX_LEN; i++) {
8000430a:	2f f7       	sub	r7,-1
8000430c:	5c 57       	castu.b	r7
8000430e:	e8 07 18 00 	cp.b	r7,r4
80004312:	ce f1       	brne	800042f0 <get_new_data+0x14>
80004314:	c0 68       	rjmp	80004320 <get_new_data+0x44>
		if (xQueueReceive( queue_from_inverter, &ecu_data->inverter_can_msg, 0 ) == pdTRUE) {
			handle_inverter_data(ecu_data);
			ecu_data->inverter_timeout = 0;
		} else {
			ecu_data->inverter_timeout++;
80004316:	ed 38 00 7c 	ld.ub	r8,r6[124]
8000431a:	2f f8       	sub	r8,-1
8000431c:	ed 68 00 7c 	st.b	r6[124],r8
			break;
		}
	}
	
	for (i=0; i<QUEUE_DASH_MSG_LEN; i++) {
		if (xQueueReceive( queue_dash_msg, &ecu_data->dash_msg, 0 ) == pdTRUE) {
80004320:	ec c4 ff e0 	sub	r4,r6,-32
80004324:	30 07       	mov	r7,0
80004326:	49 a3       	lddpc	r3,8000438c <get_new_data+0xb0>
80004328:	0e 92       	mov	r2,r7
			ecu_data->inverter_timeout++;
			break;
		}
	}
	
	for (i=0; i<QUEUE_DASH_MSG_LEN; i++) {
8000432a:	30 55       	mov	r5,5
		if (xQueueReceive( queue_dash_msg, &ecu_data->dash_msg, 0 ) == pdTRUE) {
8000432c:	04 99       	mov	r9,r2
8000432e:	04 9a       	mov	r10,r2
80004330:	08 9b       	mov	r11,r4
80004332:	66 0c       	ld.w	r12,r3[0x0]
80004334:	f0 1f 00 14 	mcall	80004384 <get_new_data+0xa8>
80004338:	58 1c       	cp.w	r12,1
8000433a:	c0 80       	breq	8000434a <get_new_data+0x6e>
			break;
		}
	}
	
	for (i=0; i<QUEUE_BMS_RX_LEN; i++) {
		if (xQueueReceive( queue_bms_rx, &ecu_data->bms_msg, 0 ) == pdTRUE) {
8000433c:	ec c4 ff d4 	sub	r4,r6,-44
80004340:	30 07       	mov	r7,0
80004342:	49 43       	lddpc	r3,80004390 <get_new_data+0xb4>
80004344:	0e 92       	mov	r2,r7
		} else {
			break;
		}
	}
	
	for (i=0; i<QUEUE_BMS_RX_LEN; i++) {
80004346:	30 55       	mov	r5,5
80004348:	c0 a8       	rjmp	8000435c <get_new_data+0x80>
		}
	}
	
	for (i=0; i<QUEUE_DASH_MSG_LEN; i++) {
		if (xQueueReceive( queue_dash_msg, &ecu_data->dash_msg, 0 ) == pdTRUE) {
			handle_dash_data(ecu_data);
8000434a:	0c 9c       	mov	r12,r6
8000434c:	f0 1f 00 12 	mcall	80004394 <get_new_data+0xb8>
			ecu_data->inverter_timeout++;
			break;
		}
	}
	
	for (i=0; i<QUEUE_DASH_MSG_LEN; i++) {
80004350:	2f f7       	sub	r7,-1
80004352:	5c 57       	castu.b	r7
80004354:	ea 07 18 00 	cp.b	r7,r5
80004358:	ce a1       	brne	8000432c <get_new_data+0x50>
8000435a:	cf 1b       	rjmp	8000433c <get_new_data+0x60>
			break;
		}
	}
	
	for (i=0; i<QUEUE_BMS_RX_LEN; i++) {
		if (xQueueReceive( queue_bms_rx, &ecu_data->bms_msg, 0 ) == pdTRUE) {
8000435c:	04 99       	mov	r9,r2
8000435e:	04 9a       	mov	r10,r2
80004360:	08 9b       	mov	r11,r4
80004362:	66 0c       	ld.w	r12,r3[0x0]
80004364:	f0 1f 00 08 	mcall	80004384 <get_new_data+0xa8>
80004368:	58 1c       	cp.w	r12,1
8000436a:	c0 91       	brne	8000437c <get_new_data+0xa0>
			handle_bms_data(ecu_data);
8000436c:	0c 9c       	mov	r12,r6
8000436e:	f0 1f 00 0b 	mcall	80004398 <get_new_data+0xbc>
		} else {
			break;
		}
	}
	
	for (i=0; i<QUEUE_BMS_RX_LEN; i++) {
80004372:	2f f7       	sub	r7,-1
80004374:	5c 57       	castu.b	r7
80004376:	ea 07 18 00 	cp.b	r7,r5
8000437a:	cf 11       	brne	8000435c <get_new_data+0x80>
8000437c:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80004380:	00 00       	add	r0,r0
80004382:	cf 3c       	rcall	80004568 <launch_control+0x1c>
80004384:	80 00       	ld.sh	r0,r0[0x0]
80004386:	2d ac       	sub	r12,-38
80004388:	80 00       	ld.sh	r0,r0[0x0]
8000438a:	41 ac       	lddsp	r12,sp[0x68]
8000438c:	00 00       	add	r0,r0
8000438e:	cf 60       	breq	8000437a <get_new_data+0x9e>
80004390:	00 00       	add	r0,r0
80004392:	cf 38       	rjmp	80004578 <launch_control+0x2c>
80004394:	80 00       	ld.sh	r0,r0[0x0]
80004396:	40 28       	lddsp	r8,sp[0x8]
80004398:	80 00       	ld.sh	r0,r0[0x0]
8000439a:	3f cc       	mov	r12,-4

8000439c <get_trq_sens>:
	}
	asm("nop");
	return status;
}

uint8_t get_trq_sens(fsm_ecu_data_t *ecu_data) {
8000439c:	eb cd 40 c0 	pushm	r6-r7,lr
800043a0:	18 96       	mov	r6,r12
	uint8_t status = 0;
	if (xQueueReceive( queue_trq_sens0, &ecu_data->trq_sens0, 0 ) == pdFALSE ) {
800043a2:	30 09       	mov	r9,0
800043a4:	12 9a       	mov	r10,r9
800043a6:	f8 cb ff f0 	sub	r11,r12,-16
800043aa:	49 58       	lddpc	r8,800043fc <get_trq_sens+0x60>
800043ac:	70 0c       	ld.w	r12,r8[0x0]
800043ae:	f0 1f 00 15 	mcall	80004400 <get_trq_sens+0x64>
800043b2:	5f 07       	sreq	r7
		status++;
	}
	if (xQueueReceive( queue_trq_sens1, &ecu_data->trq_sens1, 0 ) == pdFALSE ) {
800043b4:	30 09       	mov	r9,0
800043b6:	12 9a       	mov	r10,r9
800043b8:	ec cb ff ee 	sub	r11,r6,-18
800043bc:	49 28       	lddpc	r8,80004404 <get_trq_sens+0x68>
800043be:	70 0c       	ld.w	r12,r8[0x0]
800043c0:	f0 1f 00 10 	mcall	80004400 <get_trq_sens+0x64>
800043c4:	c0 31       	brne	800043ca <get_trq_sens+0x2e>
		status++;
800043c6:	2f f7       	sub	r7,-1
800043c8:	5c 57       	castu.b	r7
	}
	if (xQueueReceive( queue_trq_sens0_err, &ecu_data->trq_sens0_err, 0 ) == pdFALSE ) {
800043ca:	30 09       	mov	r9,0
800043cc:	12 9a       	mov	r10,r9
800043ce:	ec cb ff ec 	sub	r11,r6,-20
800043d2:	48 e8       	lddpc	r8,80004408 <get_trq_sens+0x6c>
800043d4:	70 0c       	ld.w	r12,r8[0x0]
800043d6:	f0 1f 00 0b 	mcall	80004400 <get_trq_sens+0x64>
800043da:	c0 31       	brne	800043e0 <get_trq_sens+0x44>
		status++;
800043dc:	2f f7       	sub	r7,-1
800043de:	5c 57       	castu.b	r7
	}
	if (xQueueReceive( queue_trq_sens1_err, &ecu_data->trq_sens1_err, 0 ) == pdFALSE ) {
800043e0:	30 09       	mov	r9,0
800043e2:	12 9a       	mov	r10,r9
800043e4:	ec cb ff eb 	sub	r11,r6,-21
800043e8:	48 98       	lddpc	r8,8000440c <get_trq_sens+0x70>
800043ea:	70 0c       	ld.w	r12,r8[0x0]
800043ec:	f0 1f 00 05 	mcall	80004400 <get_trq_sens+0x64>
800043f0:	c0 31       	brne	800043f6 <get_trq_sens+0x5a>
		status++;
800043f2:	2f f7       	sub	r7,-1
800043f4:	5c 57       	castu.b	r7
	}
	return status;
}
800043f6:	0e 9c       	mov	r12,r7
800043f8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800043fc:	00 00       	add	r0,r0
800043fe:	cf 44       	brge	800043e6 <get_trq_sens+0x4a>
80004400:	80 00       	ld.sh	r0,r0[0x0]
80004402:	2d ac       	sub	r12,-38
80004404:	00 00       	add	r0,r0
80004406:	cf 6c       	rcall	800045f2 <launch_control+0xa6>
80004408:	00 00       	add	r0,r0
8000440a:	cf 70       	breq	800043f8 <get_trq_sens+0x5c>
8000440c:	00 00       	add	r0,r0
8000440e:	cf 58       	rjmp	800045f8 <launch_control+0xac>

80004410 <get_speed_sens>:
		status |= 1 << 1;
	}
	return status;
}

uint8_t get_speed_sens(fsm_ecu_data_t *ecu_data) {
80004410:	eb cd 40 c0 	pushm	r6-r7,lr
80004414:	18 96       	mov	r6,r12
	uint8_t status=0;
	if (xQueueReceive( queue_wheel_fl, &ecu_data->WFL_sens, 0 ) == pdFALSE) {
80004416:	30 09       	mov	r9,0
80004418:	12 9a       	mov	r10,r9
8000441a:	f8 cb ff a8 	sub	r11,r12,-88
8000441e:	49 68       	lddpc	r8,80004474 <get_speed_sens+0x64>
80004420:	70 0c       	ld.w	r12,r8[0x0]
80004422:	f0 1f 00 16 	mcall	80004478 <get_speed_sens+0x68>
80004426:	5f 07       	sreq	r7
		status++;
	}
	if (xQueueReceive( queue_wheel_fr, &ecu_data->WFR_sens, 0 ) == pdFALSE) {
80004428:	30 09       	mov	r9,0
8000442a:	12 9a       	mov	r10,r9
8000442c:	ec cb ff a6 	sub	r11,r6,-90
80004430:	49 38       	lddpc	r8,8000447c <get_speed_sens+0x6c>
80004432:	70 0c       	ld.w	r12,r8[0x0]
80004434:	f0 1f 00 11 	mcall	80004478 <get_speed_sens+0x68>
80004438:	c0 31       	brne	8000443e <get_speed_sens+0x2e>
		status++;
8000443a:	2f f7       	sub	r7,-1
8000443c:	5c 57       	castu.b	r7
	}
	if (xQueueReceive( queue_wheel_rl, &ecu_data->WRL_sens, 0 ) == pdFALSE) {
8000443e:	30 09       	mov	r9,0
80004440:	12 9a       	mov	r10,r9
80004442:	ec cb ff a4 	sub	r11,r6,-92
80004446:	48 f8       	lddpc	r8,80004480 <get_speed_sens+0x70>
80004448:	70 0c       	ld.w	r12,r8[0x0]
8000444a:	f0 1f 00 0c 	mcall	80004478 <get_speed_sens+0x68>
8000444e:	c0 31       	brne	80004454 <get_speed_sens+0x44>
		status++;
80004450:	2f f7       	sub	r7,-1
80004452:	5c 57       	castu.b	r7
	}
	if (xQueueReceive( queue_wheel_rr, &ecu_data->WRR_sens, 0 ) == pdFALSE) {
80004454:	30 09       	mov	r9,0
80004456:	12 9a       	mov	r10,r9
80004458:	ec cb ff a2 	sub	r11,r6,-94
8000445c:	48 a8       	lddpc	r8,80004484 <get_speed_sens+0x74>
8000445e:	70 0c       	ld.w	r12,r8[0x0]
80004460:	f0 1f 00 06 	mcall	80004478 <get_speed_sens+0x68>
80004464:	c0 31       	brne	8000446a <get_speed_sens+0x5a>
		status++;
80004466:	2f f7       	sub	r7,-1
80004468:	5c 57       	castu.b	r7
	}
	asm("nop");
8000446a:	d7 03       	nop
	return status;
}
8000446c:	0e 9c       	mov	r12,r7
8000446e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004472:	00 00       	add	r0,r0
80004474:	00 00       	add	r0,r0
80004476:	cf 5c       	rcall	80004660 <canif_clear_all_mob+0x1c>
80004478:	80 00       	ld.sh	r0,r0[0x0]
8000447a:	2d ac       	sub	r12,-38
8000447c:	00 00       	add	r0,r0
8000447e:	cf 54       	brge	80004468 <get_speed_sens+0x58>
80004480:	00 00       	add	r0,r0
80004482:	cf 68       	rjmp	8000466e <canif_clear_all_mob+0x2a>
80004484:	00 00       	add	r0,r0
80004486:	cf 50       	breq	80004470 <get_speed_sens+0x60>

80004488 <get_brake_sens>:
		return 1;
	}
	return 0;
}

uint8_t get_brake_sens(fsm_ecu_data_t *ecu_data) {
80004488:	eb cd 40 c0 	pushm	r6-r7,lr
8000448c:	18 96       	mov	r6,r12
	uint8_t status = 0;
	if (xQueueReceive( queue_brake_front, &ecu_data->brake_front, 0 ) == pdFALSE) {
8000448e:	30 09       	mov	r9,0
80004490:	12 9a       	mov	r10,r9
80004492:	f8 cb ff be 	sub	r11,r12,-66
80004496:	48 a8       	lddpc	r8,800044bc <get_brake_sens+0x34>
80004498:	70 0c       	ld.w	r12,r8[0x0]
8000449a:	f0 1f 00 0a 	mcall	800044c0 <get_brake_sens+0x38>
8000449e:	5f 07       	sreq	r7
		status |= 1 << 0;
	}
	if (xQueueReceive( queue_brake_rear, &ecu_data->brake_rear, 0 ) == pdFALSE) {
800044a0:	30 09       	mov	r9,0
800044a2:	12 9a       	mov	r10,r9
800044a4:	ec cb ff bc 	sub	r11,r6,-68
800044a8:	48 78       	lddpc	r8,800044c4 <get_brake_sens+0x3c>
800044aa:	70 0c       	ld.w	r12,r8[0x0]
800044ac:	f0 1f 00 05 	mcall	800044c0 <get_brake_sens+0x38>
800044b0:	c0 31       	brne	800044b6 <get_brake_sens+0x2e>
		status |= 1 << 1;
800044b2:	a1 b7       	sbr	r7,0x1
800044b4:	5c 57       	castu.b	r7
	}
	return status;
}
800044b6:	0e 9c       	mov	r12,r7
800044b8:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800044bc:	00 00       	add	r0,r0
800044be:	cf 74       	brge	800044ac <get_brake_sens+0x24>
800044c0:	80 00       	ld.sh	r0,r0[0x0]
800044c2:	2d ac       	sub	r12,-38
800044c4:	00 00       	add	r0,r0
800044c6:	cf 4c       	rcall	800046ae <canif_fixed_baudrate+0x22>

800044c8 <check_bspd>:
		return (82500 / ecu_data->vdc_battery);	
	}
	return 0;
}

uint8_t check_bspd(void) {
800044c8:	d4 01       	pushm	lr
800044ca:	20 1d       	sub	sp,4
	uint8_t temp=0;
800044cc:	fa cb ff fc 	sub	r11,sp,-4
800044d0:	30 08       	mov	r8,0
800044d2:	16 f8       	st.b	--r11,r8
	xQueueReceive(queue_bspd, &temp, 0);
800044d4:	30 09       	mov	r9,0
800044d6:	12 9a       	mov	r10,r9
800044d8:	48 48       	lddpc	r8,800044e8 <check_bspd+0x20>
800044da:	70 0c       	ld.w	r12,r8[0x0]
800044dc:	f0 1f 00 04 	mcall	800044ec <check_bspd+0x24>
	return temp;
}
800044e0:	1b bc       	ld.ub	r12,sp[0x3]
800044e2:	2f fd       	sub	sp,-4
800044e4:	d8 02       	popm	pc
800044e6:	00 00       	add	r0,r0
800044e8:	00 00       	add	r0,r0
800044ea:	cf 64       	brge	800044d6 <check_bspd+0xe>
800044ec:	80 00       	ld.sh	r0,r0[0x0]
800044ee:	2d ac       	sub	r12,-38

800044f0 <ecu_dio_inverter_clear_error>:
	/* Input: 0x49 D2 2A 00 Output:0x2A D2 */
	uint16_t relevant_data = (data & 0xFFFF00) >> 8;
	return ((relevant_data & 0xFF) << 8 | (relevant_data & 0xFF00) >> 8);
}

void ecu_dio_inverter_clear_error() {
800044f0:	eb cd 40 80 	pushm	r7,lr
	gpio_set_pin_high(INVERTER_DIN1);
800044f4:	30 5c       	mov	r12,5
800044f6:	f0 1f 00 13 	mcall	80004540 <ecu_dio_inverter_clear_error+0x50>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
800044fa:	e1 b7 00 42 	mfsr	r7,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
800044fe:	ee 78 42 40 	mov	r8,1000000
80004502:	30 09       	mov	r9,0
80004504:	e0 6a a2 3f 	mov	r10,41535
80004508:	ea 1a 3c 43 	orh	r10,0x3c43
8000450c:	30 2b       	mov	r11,2
8000450e:	f0 1f 00 0e 	mcall	80004544 <ecu_dio_inverter_clear_error+0x54>
80004512:	ee 0a 00 0a 	add	r10,r7,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80004516:	e1 b8 00 42 	mfsr	r8,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
8000451a:	14 37       	cp.w	r7,r10
8000451c:	e0 88 00 08 	brls	8000452c <ecu_dio_inverter_clear_error+0x3c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80004520:	10 37       	cp.w	r7,r8
80004522:	fe 98 ff fa 	brls	80004516 <ecu_dio_inverter_clear_error+0x26>
80004526:	10 3a       	cp.w	r10,r8
80004528:	c0 73       	brcs	80004536 <ecu_dio_inverter_clear_error+0x46>
8000452a:	cf 6b       	rjmp	80004516 <ecu_dio_inverter_clear_error+0x26>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
8000452c:	10 37       	cp.w	r7,r8
8000452e:	e0 8b 00 04 	brhi	80004536 <ecu_dio_inverter_clear_error+0x46>
80004532:	10 3a       	cp.w	r10,r8
80004534:	cf 12       	brcc	80004516 <ecu_dio_inverter_clear_error+0x26>
	delay_us(200);
	gpio_set_pin_low(INVERTER_DIN1);
80004536:	30 5c       	mov	r12,5
80004538:	f0 1f 00 04 	mcall	80004548 <ecu_dio_inverter_clear_error+0x58>
}
8000453c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004540:	80 00       	ld.sh	r0,r0[0x0]
80004542:	68 2a       	ld.w	r10,r4[0x8]
80004544:	80 00       	ld.sh	r0,r0[0x0]
80004546:	75 e2       	ld.w	r2,r10[0x78]
80004548:	80 00       	ld.sh	r0,r0[0x0]
8000454a:	68 40       	ld.w	r0,r4[0x10]

8000454c <launch_control>:
		}
	}
	ecu_data->trq_pid = Kp*e;
}

void launch_control(fsm_ecu_data_t *ecu_data) {
8000454c:	eb cd 40 fc 	pushm	r2-r7,lr
80004550:	18 97       	mov	r7,r12
	static float filter_output = 0.0F;
	static uint8_t first_run = 1;
	float filter_gain = ecu_data->lc_filter_gain;
80004552:	f8 f6 00 80 	ld.w	r6,r12[128]
	int16_t trq_min = min(ecu_data->trq_sens0, ecu_data->trq_sens1);
80004556:	f9 08 00 10 	ld.sh	r8,r12[16]
8000455a:	f9 04 00 12 	ld.sh	r4,r12[18]
8000455e:	f0 04 0d 44 	min	r4,r8,r4
80004562:	5c 84       	casts.h	r4
	
	//Because statics cannot be initialized with variables...
	if (first_run) {
80004564:	4b 28       	lddpc	r8,8000462c <launch_control+0xe0>
80004566:	11 89       	ld.ub	r9,r8[0x0]
80004568:	30 08       	mov	r8,0
8000456a:	f0 09 18 00 	cp.b	r9,r8
8000456e:	c2 e0       	breq	800045ca <launch_control+0x7e>
		first_run = 0;
80004570:	10 99       	mov	r9,r8
80004572:	4a f8       	lddpc	r8,8000462c <launch_control+0xe0>
80004574:	b0 89       	st.b	r8[0x0],r9
		filter_output = (1-filter_gain)*ecu_data->lc_trq_init + filter_gain*trq_min*(float)MAX_TORQUE/1000.0; 
80004576:	fc 1c 3f 80 	movh	r12,0x3f80
8000457a:	e5 a1 0c c6 	cop	cp0,cr12,cr12,cr6,0x42
8000457e:	ee f8 00 84 	ld.w	r8,r7[132]
80004582:	e5 a2 0c c8 	cop	cp0,cr12,cr12,cr8,0x44
80004586:	f0 1f 00 2b 	mcall	80004630 <launch_control+0xe4>
8000458a:	14 92       	mov	r2,r10
8000458c:	16 93       	mov	r3,r11
8000458e:	e5 a6 04 04 	cop	cp0,cr4,cr0,cr4,0x4c
80004592:	e5 a2 06 46 	cop	cp0,cr6,cr4,cr6,0x44
80004596:	e0 68 f0 00 	mov	r8,61440
8000459a:	ea 18 46 ff 	orh	r8,0x46ff
8000459e:	e5 a2 0c 68 	cop	cp0,cr12,cr6,cr8,0x44
800045a2:	f0 1f 00 24 	mcall	80004630 <launch_control+0xe4>
800045a6:	30 08       	mov	r8,0
800045a8:	e0 69 40 00 	mov	r9,16384
800045ac:	ea 19 40 8f 	orh	r9,0x408f
800045b0:	f0 1f 00 21 	mcall	80004634 <launch_control+0xe8>
800045b4:	14 98       	mov	r8,r10
800045b6:	16 99       	mov	r9,r11
800045b8:	04 9a       	mov	r10,r2
800045ba:	06 9b       	mov	r11,r3
800045bc:	f0 1f 00 1f 	mcall	80004638 <launch_control+0xec>
800045c0:	f0 1f 00 1f 	mcall	8000463c <launch_control+0xf0>
800045c4:	49 f8       	lddpc	r8,80004640 <launch_control+0xf4>
800045c6:	91 0c       	st.w	r8[0x0],r12
800045c8:	c2 98       	rjmp	8000461a <launch_control+0xce>
	} else {
		filter_output = (1-filter_gain)*filter_output + filter_gain*trq_min*(float)MAX_TORQUE/1000.0;	
800045ca:	49 e5       	lddpc	r5,80004640 <launch_control+0xf4>
800045cc:	fc 1c 3f 80 	movh	r12,0x3f80
800045d0:	e5 a1 0c c6 	cop	cp0,cr12,cr12,cr6,0x42
800045d4:	6a 08       	ld.w	r8,r5[0x0]
800045d6:	e5 a2 0c c8 	cop	cp0,cr12,cr12,cr8,0x44
800045da:	f0 1f 00 16 	mcall	80004630 <launch_control+0xe4>
800045de:	14 92       	mov	r2,r10
800045e0:	16 93       	mov	r3,r11
800045e2:	e5 a6 04 04 	cop	cp0,cr4,cr0,cr4,0x4c
800045e6:	e5 a2 06 46 	cop	cp0,cr6,cr4,cr6,0x44
800045ea:	e0 68 f0 00 	mov	r8,61440
800045ee:	ea 18 46 ff 	orh	r8,0x46ff
800045f2:	e5 a2 0c 68 	cop	cp0,cr12,cr6,cr8,0x44
800045f6:	f0 1f 00 0f 	mcall	80004630 <launch_control+0xe4>
800045fa:	30 08       	mov	r8,0
800045fc:	e0 69 40 00 	mov	r9,16384
80004600:	ea 19 40 8f 	orh	r9,0x408f
80004604:	f0 1f 00 0c 	mcall	80004634 <launch_control+0xe8>
80004608:	14 98       	mov	r8,r10
8000460a:	16 99       	mov	r9,r11
8000460c:	04 9a       	mov	r10,r2
8000460e:	06 9b       	mov	r11,r3
80004610:	f0 1f 00 0a 	mcall	80004638 <launch_control+0xec>
80004614:	f0 1f 00 0a 	mcall	8000463c <launch_control+0xf0>
80004618:	8b 0c       	st.w	r5[0x0],r12
	}
	
	//Add feedback from speed sensors to do slip control here (if needed)
	
	ecu_data->trq_cmd = filter_output;
8000461a:	48 a8       	lddpc	r8,80004640 <launch_control+0xf4>
8000461c:	70 08       	ld.w	r8,r8[0x0]
8000461e:	e5 ab 08 08 	cop	cp0,cr8,cr0,cr8,0x56
80004622:	ef 58 00 16 	st.h	r7[22],r8
	asm("nop");
80004626:	d7 03       	nop
}
80004628:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
8000462c:	00 00       	add	r0,r0
8000462e:	01 c4       	ld.ub	r4,r0[0x4]
80004630:	80 00       	ld.sh	r0,r0[0x0]
80004632:	74 f8       	ld.w	r8,r10[0x3c]
80004634:	80 00       	ld.sh	r0,r0[0x0]
80004636:	70 80       	ld.w	r0,r8[0x20]
80004638:	80 00       	ld.sh	r0,r0[0x0]
8000463a:	6e 88       	ld.w	r8,r7[0x20]
8000463c:	80 00       	ld.sh	r0,r0[0x0]
8000463e:	75 58       	ld.w	r8,r10[0x54]
80004640:	00 00       	add	r0,r0
80004642:	cc 0c       	rcall	800047c2 <can0_int_tx_handler+0xe>

80004644 <canif_clear_all_mob>:
#include "preprocessor.h"
#include "canif.h"

void canif_clear_all_mob(uint8_t ch,
		uint8_t nb_mob)
{
80004644:	eb cd 40 fc 	pushm	r2-r7,lr
	uint8_t mob_number;

	for (mob_number = 0; mob_number < nb_mob; mob_number++) {
80004648:	58 0b       	cp.w	r11,0
8000464a:	c1 f0       	breq	80004688 <canif_clear_all_mob+0x44>

#include "compiler.h"
#include "preprocessor.h"
#include "canif.h"

void canif_clear_all_mob(uint8_t ch,
8000464c:	f6 c3 00 01 	sub	r3,r11,1
80004650:	5c 53       	castu.b	r3
80004652:	2f f3       	sub	r3,-1
80004654:	a5 63       	lsl	r3,0x4
80004656:	30 08       	mov	r8,0
		uint8_t nb_mob)
{
	uint8_t mob_number;

	for (mob_number = 0; mob_number < nb_mob; mob_number++) {
		CANIF_clr_mob(ch,mob_number)
80004658:	fc 7a 1c 00 	mov	r10,-189440
8000465c:	a7 6c       	lsl	r12,0x6
8000465e:	f8 c9 ff ff 	sub	r9,r12,-1
80004662:	10 9b       	mov	r11,r8
80004664:	30 04       	mov	r4,0
80004666:	30 05       	mov	r5,0
80004668:	f4 09 03 3e 	ld.w	lr,r10[r9<<0x3]
8000466c:	fc 08 09 0b 	st.w	lr[r8],r11
80004670:	f4 09 03 3e 	ld.w	lr,r10[r9<<0x3]
80004674:	10 0e       	add	lr,r8
80004676:	9d 1b       	st.w	lr[0x4],r11
80004678:	f4 09 03 3e 	ld.w	lr,r10[r9<<0x3]
8000467c:	10 0e       	add	lr,r8
8000467e:	fc e5 00 08 	st.d	lr[8],r4
80004682:	2f 08       	sub	r8,-16
void canif_clear_all_mob(uint8_t ch,
		uint8_t nb_mob)
{
	uint8_t mob_number;

	for (mob_number = 0; mob_number < nb_mob; mob_number++) {
80004684:	06 38       	cp.w	r8,r3
80004686:	cf 11       	brne	80004668 <canif_clear_all_mob+0x24>
80004688:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

8000468c <canif_fixed_baudrate>:
	return MOB_NOT_COMPLETED;
}

uint8_t canif_fixed_baudrate(uint8_t ch)
{
  CANIF_conf_bt(ch);
8000468c:	a9 7c       	lsl	r12,0x9
8000468e:	e2 2c e3 f4 	sub	r12,189428
80004692:	78 08       	ld.w	r8,r12[0x0]
80004694:	e4 18 ff e7 	andh	r8,0xffe7
80004698:	99 08       	st.w	r12[0x0],r8
8000469a:	78 08       	ld.w	r8,r12[0x0]
8000469c:	b3 b8       	sbr	r8,0x13
8000469e:	99 08       	st.w	r12[0x0],r8
800046a0:	78 08       	ld.w	r8,r12[0x0]
800046a2:	e4 18 ff f8 	andh	r8,0xfff8
800046a6:	99 08       	st.w	r12[0x0],r8
800046a8:	78 08       	ld.w	r8,r12[0x0]
800046aa:	b1 b8       	sbr	r8,0x11
800046ac:	99 08       	st.w	r12[0x0],r8
800046ae:	78 08       	ld.w	r8,r12[0x0]
800046b0:	e0 18 ff c0 	andl	r8,0xffc0
800046b4:	99 08       	st.w	r12[0x0],r8
800046b6:	78 08       	ld.w	r8,r12[0x0]
800046b8:	a1 a8       	sbr	r8,0x0
800046ba:	99 08       	st.w	r12[0x0],r8
800046bc:	78 08       	ld.w	r8,r12[0x0]
800046be:	e0 18 c7 ff 	andl	r8,0xc7ff
800046c2:	99 08       	st.w	r12[0x0],r8
800046c4:	78 08       	ld.w	r8,r12[0x0]
800046c6:	ab b8       	sbr	r8,0xb
800046c8:	99 08       	st.w	r12[0x0],r8
800046ca:	78 08       	ld.w	r8,r12[0x0]
800046cc:	e0 18 f8 ff 	andl	r8,0xf8ff
800046d0:	99 08       	st.w	r12[0x0],r8
800046d2:	78 08       	ld.w	r8,r12[0x0]
800046d4:	a9 a8       	sbr	r8,0x8
800046d6:	99 08       	st.w	r12[0x0],r8
  return 1;
}
800046d8:	5e ff       	retal	1

800046da <scif_stop_gclk>:
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;
800046da:	fe 78 08 00 	mov	r8,-63488
800046de:	f8 c9 ff e7 	sub	r9,r12,-25
800046e2:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
800046e6:	a1 ca       	cbr	r10,0x0
800046e8:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
800046ec:	e0 78 86 a0 	mov	r8,100000

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800046f0:	fe 7a 08 00 	mov	r10,-63488
800046f4:	12 9c       	mov	r12,r9
800046f6:	c0 48       	rjmp	800046fe <scif_stop_gclk+0x24>
  {
    if(--timeout == 0)
800046f8:	20 18       	sub	r8,1
800046fa:	c0 21       	brne	800046fe <scif_stop_gclk+0x24>
800046fc:	5e fe       	retal	-1

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
800046fe:	f4 0c 03 29 	ld.w	r9,r10[r12<<0x2]
80004702:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004706:	cf 91       	brne	800046f8 <scif_stop_gclk+0x1e>
80004708:	5e fd       	retal	0
8000470a:	d7 03       	nop

8000470c <scif_gc_setup>:
  return PASS;
}


long int scif_gc_setup(unsigned int gclk, scif_gcctrl_oscsel_t clk_src, unsigned int diven, unsigned int divfactor)
{
8000470c:	d4 21       	pushm	r4-r7,lr
8000470e:	18 97       	mov	r7,r12
80004710:	16 95       	mov	r5,r11
80004712:	14 96       	mov	r6,r10
  bool restart_gc = false;


  // Change the division factor to conform to the equation: fgclk = fsrc/divfactor = fsrc/(2*(div+1))
  divfactor = (divfactor>>1) -1;
80004714:	a1 99       	lsr	r9,0x1
80004716:	f2 c4 00 01 	sub	r4,r9,1
      return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, disable it before changing its setup.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
8000471a:	f8 c9 ff e7 	sub	r9,r12,-25
8000471e:	fe 78 08 00 	mov	r8,-63488
80004722:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80004726:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000472a:	c0 50       	breq	80004734 <scif_gc_setup+0x28>
  {
    restart_gc = true;
    if(scif_stop_gclk(gclk) < 0)
8000472c:	f0 1f 00 18 	mcall	8000478c <scif_gc_setup+0x80>
80004730:	c1 44       	brge	80004758 <scif_gc_setup+0x4c>
80004732:	dc 2a       	popm	r4-r7,pc,r12=-1
      return -1;  // Could not stop the generic clock.
  }

  // Setup the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((divfactor << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
80004734:	a1 76       	lsl	r6,0x1
80004736:	e2 16 00 02 	andl	r6,0x2,COH
8000473a:	a9 65       	lsl	r5,0x8
8000473c:	e2 15 0f 00 	andl	r5,0xf00,COH
80004740:	0a 46       	or	r6,r5
80004742:	b1 64       	lsl	r4,0x10
80004744:	e6 14 00 ff 	andh	r4,0xff,COH
80004748:	ed e4 10 04 	or	r4,r6,r4
8000474c:	2e 77       	sub	r7,-25
8000474e:	fe 78 08 00 	mov	r8,-63488
80004752:	f0 07 09 24 	st.w	r8[r7<<0x2],r4
80004756:	d8 2a       	popm	r4-r7,pc,r12=0
80004758:	ec 09 15 01 	lsl	r9,r6,0x1
8000475c:	e2 19 00 02 	andl	r9,0x2,COH
80004760:	ea 08 15 08 	lsl	r8,r5,0x8
80004764:	e2 18 0f 00 	andl	r8,0xf00,COH
80004768:	10 49       	or	r9,r8
8000476a:	e8 08 15 10 	lsl	r8,r4,0x10
8000476e:	e6 18 00 ff 	andh	r8,0xff,COH
80004772:	10 49       	or	r9,r8
80004774:	fe 78 08 00 	mov	r8,-63488
80004778:	2e 77       	sub	r7,-25
8000477a:	f0 07 09 29 	st.w	r8[r7<<0x2],r9
                            |((diven << AVR32_SCIF_GCCTRL_DIVEN_OFFSET)&AVR32_SCIF_GCCTRL_DIVEN_MASK)
                            |((clk_src << AVR32_SCIF_GCCTRL_OSCSEL_OFFSET)&AVR32_SCIF_GCCTRL_OSCSEL_MASK);

  // Restart the gc if it previously was enabled.
  if(true == restart_gc)
    AVR32_SCIF.gcctrl[gclk] |= AVR32_SCIF_GCCTRL_CEN_MASK ;
8000477e:	f0 07 03 29 	ld.w	r9,r8[r7<<0x2]
80004782:	a1 a9       	sbr	r9,0x0
80004784:	f0 07 09 29 	st.w	r8[r7<<0x2],r9
80004788:	d8 2a       	popm	r4-r7,pc,r12=0
8000478a:	00 00       	add	r0,r0
8000478c:	80 00       	ld.sh	r0,r0[0x0]
8000478e:	46 da       	lddsp	r10,sp[0x1b4]

80004790 <scif_gc_enable>:
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, do nothing.
  if(!(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK))
80004790:	f8 c9 ff e7 	sub	r9,r12,-25
80004794:	fe 78 08 00 	mov	r8,-63488
80004798:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000479c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800047a0:	c0 91       	brne	800047b2 <scif_gc_enable+0x22>
    AVR32_SCIF.gcctrl[gclk] |= AVR32_SCIF_GCCTRL_CEN_MASK;
800047a2:	fe 78 08 00 	mov	r8,-63488
800047a6:	12 9c       	mov	r12,r9
800047a8:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
800047ac:	a1 a9       	sbr	r9,0x0
800047ae:	f0 0c 09 29 	st.w	r8[r12<<0x2],r9

  return PASS;

}
800047b2:	5e fd       	retal	0

800047b4 <can0_int_tx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_tx_handler(void)
{
800047b4:	d4 01       	pushm	lr
  U8 handle;
  handle = CANIF_mob_get_mob_txok(0);
800047b6:	fc 78 1c 00 	mov	r8,-189440
800047ba:	70 cc       	ld.w	r12,r8[0x30]
800047bc:	f9 dc c2 06 	bfextu	r12,r12,0x10,0x6
  if (handle != 0x20)
800047c0:	32 08       	mov	r8,32
800047c2:	f0 0c 18 00 	cp.b	r12,r8
800047c6:	c0 f0       	breq	800047e4 <can0_int_tx_handler+0x30>
  {
    CANIF_mob_clear_txok_status(0,handle);
800047c8:	30 19       	mov	r9,1
800047ca:	f2 0c 09 49 	lsl	r9,r9,r12
800047ce:	fc 78 1c 00 	mov	r8,-189440
800047d2:	f1 49 00 54 	st.w	r8[84],r9
    CANIF_mob_clear_status(0,handle); //   and reset MOb status
800047d6:	f8 0c 00 18 	add	r8,r12,r12<<0x1
800047da:	a3 68       	lsl	r8,0x2
800047dc:	e2 28 e3 a0 	sub	r8,189344
800047e0:	30 f9       	mov	r9,15
800047e2:	91 09       	st.w	r8[0x0],r9
  }
  can_lib_params.can_msg_callback_channel0(handle,CAN_STATUS_COMPLETED);
800047e4:	48 38       	lddpc	r8,800047f0 <can0_int_tx_handler+0x3c>
800047e6:	70 08       	ld.w	r8,r8[0x0]
800047e8:	30 0b       	mov	r11,0
800047ea:	5d 18       	icall	r8
}
800047ec:	d4 02       	popm	lr
800047ee:	d6 03       	rete
800047f0:	00 00       	add	r0,r0
800047f2:	cc 10       	breq	80004774 <scif_gc_setup+0x68>

800047f4 <can0_int_rx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_rx_handler(void)
{
800047f4:	d4 01       	pushm	lr
  U8 handle;
  handle = CANIF_mob_get_mob_rxok(0) ;
800047f6:	fc 78 1c 00 	mov	r8,-189440
800047fa:	70 cc       	ld.w	r12,r8[0x30]
800047fc:	f9 dc c1 06 	bfextu	r12,r12,0x8,0x6
  if (handle != 0x20)
80004800:	32 08       	mov	r8,32
80004802:	f0 0c 18 00 	cp.b	r12,r8
80004806:	c0 f0       	breq	80004824 <can0_int_rx_handler+0x30>
  {
    CANIF_mob_clear_rxok_status(0,handle);
80004808:	30 19       	mov	r9,1
8000480a:	f2 0c 09 49 	lsl	r9,r9,r12
8000480e:	fc 78 1c 00 	mov	r8,-189440
80004812:	f1 49 00 4c 	st.w	r8[76],r9
    CANIF_mob_clear_status(0,handle); //   and reset MOb status
80004816:	f8 0c 00 18 	add	r8,r12,r12<<0x1
8000481a:	a3 68       	lsl	r8,0x2
8000481c:	e2 28 e3 a0 	sub	r8,189344
80004820:	30 f9       	mov	r9,15
80004822:	91 09       	st.w	r8[0x0],r9
  }
  can_lib_params.can_msg_callback_channel0(handle,CAN_STATUS_COMPLETED);
80004824:	48 38       	lddpc	r8,80004830 <can0_int_rx_handler+0x3c>
80004826:	70 08       	ld.w	r8,r8[0x0]
80004828:	30 0b       	mov	r11,0
8000482a:	5d 18       	icall	r8
}
8000482c:	d4 02       	popm	lr
8000482e:	d6 03       	rete
80004830:	00 00       	add	r0,r0
80004832:	cc 10       	breq	800047b4 <can0_int_tx_handler>

80004834 <can0_int_busoff_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_busoff_handler(void)
{
80004834:	d4 01       	pushm	lr
    CANIF_clr_interrupt_status(0);
80004836:	fc 78 1c 00 	mov	r8,-189440
8000483a:	70 b9       	ld.w	r9,r8[0x2c]
8000483c:	91 a9       	st.w	r8[0x28],r9
    can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_BUSOFF);
8000483e:	48 58       	lddpc	r8,80004850 <can0_int_busoff_handler+0x1c>
80004840:	70 08       	ld.w	r8,r8[0x0]
80004842:	30 4b       	mov	r11,4
80004844:	e0 6c 00 ff 	mov	r12,255
80004848:	5d 18       	icall	r8
}
8000484a:	d4 02       	popm	lr
8000484c:	d6 03       	rete
8000484e:	00 00       	add	r0,r0
80004850:	00 00       	add	r0,r0
80004852:	cc 10       	breq	800047d4 <can0_int_tx_handler+0x20>

80004854 <can0_int_cerr_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_cerr_handler(void)
{
80004854:	d4 01       	pushm	lr
  CANIF_clr_interrupt_status(0);
80004856:	fc 78 1c 00 	mov	r8,-189440
8000485a:	70 b9       	ld.w	r9,r8[0x2c]
8000485c:	91 a9       	st.w	r8[0x28],r9
  can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_ERROR);
8000485e:	48 58       	lddpc	r8,80004870 <can0_int_cerr_handler+0x1c>
80004860:	70 08       	ld.w	r8,r8[0x0]
80004862:	30 2b       	mov	r11,2
80004864:	e0 6c 00 ff 	mov	r12,255
80004868:	5d 18       	icall	r8
}
8000486a:	d4 02       	popm	lr
8000486c:	d6 03       	rete
8000486e:	00 00       	add	r0,r0
80004870:	00 00       	add	r0,r0
80004872:	cc 10       	breq	800047f4 <can0_int_rx_handler>

80004874 <can0_int_wakeup_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_wakeup_handler(void)
{
80004874:	d4 01       	pushm	lr
  CANIF_clr_interrupt_status(0);
80004876:	fc 78 1c 00 	mov	r8,-189440
8000487a:	70 b9       	ld.w	r9,r8[0x2c]
8000487c:	91 a9       	st.w	r8[0x28],r9
  can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_WAKEUP);
8000487e:	48 58       	lddpc	r8,80004890 <can0_int_wakeup_handler+0x1c>
80004880:	70 08       	ld.w	r8,r8[0x0]
80004882:	30 3b       	mov	r11,3
80004884:	e0 6c 00 ff 	mov	r12,255
80004888:	5d 18       	icall	r8
}
8000488a:	d4 02       	popm	lr
8000488c:	d6 03       	rete
8000488e:	00 00       	add	r0,r0
80004890:	00 00       	add	r0,r0
80004892:	cc 10       	breq	80004814 <can0_int_rx_handler+0x20>

80004894 <can1_int_tx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_tx_handler(void)
{
80004894:	d4 01       	pushm	lr
  U8 handle;
  handle = CANIF_mob_get_mob_txok(1) ;
80004896:	fc 78 1c 00 	mov	r8,-189440
8000489a:	f0 fc 02 30 	ld.w	r12,r8[560]
8000489e:	f9 dc c2 06 	bfextu	r12,r12,0x10,0x6
  if (handle != 0x20)
800048a2:	32 08       	mov	r8,32
800048a4:	f0 0c 18 00 	cp.b	r12,r8
800048a8:	c0 f0       	breq	800048c6 <can1_int_tx_handler+0x32>
  {
    CANIF_mob_clear_txok_status(1,handle);
800048aa:	30 19       	mov	r9,1
800048ac:	f2 0c 09 49 	lsl	r9,r9,r12
800048b0:	fc 78 1c 00 	mov	r8,-189440
800048b4:	f1 49 02 54 	st.w	r8[596],r9
    CANIF_mob_clear_status(1,handle); //   and reset MOb status
800048b8:	f8 0c 00 18 	add	r8,r12,r12<<0x1
800048bc:	a3 68       	lsl	r8,0x2
800048be:	e2 28 e1 a0 	sub	r8,188832
800048c2:	30 f9       	mov	r9,15
800048c4:	91 09       	st.w	r8[0x0],r9
  }
  can_lib_params.can_msg_callback_channel1(handle,CAN_STATUS_COMPLETED);
800048c6:	48 48       	lddpc	r8,800048d4 <can1_int_tx_handler+0x40>
800048c8:	70 18       	ld.w	r8,r8[0x4]
800048ca:	30 0b       	mov	r11,0
800048cc:	5d 18       	icall	r8
}
800048ce:	d4 02       	popm	lr
800048d0:	d6 03       	rete
800048d2:	00 00       	add	r0,r0
800048d4:	00 00       	add	r0,r0
800048d6:	cc 10       	breq	80004858 <can0_int_cerr_handler+0x4>

800048d8 <can1_int_rx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_rx_handler(void)
{
800048d8:	d4 01       	pushm	lr
  U8 handle;
  handle = CANIF_mob_get_mob_rxok(1) ;
800048da:	fc 78 1c 00 	mov	r8,-189440
800048de:	f0 fc 02 30 	ld.w	r12,r8[560]
800048e2:	f9 dc c1 06 	bfextu	r12,r12,0x8,0x6
  if (handle != 0x20)
800048e6:	32 08       	mov	r8,32
800048e8:	f0 0c 18 00 	cp.b	r12,r8
800048ec:	c0 f0       	breq	8000490a <can1_int_rx_handler+0x32>
  {
    CANIF_mob_clear_rxok_status(1,handle);
800048ee:	30 19       	mov	r9,1
800048f0:	f2 0c 09 49 	lsl	r9,r9,r12
800048f4:	fc 78 1c 00 	mov	r8,-189440
800048f8:	f1 49 02 4c 	st.w	r8[588],r9
    CANIF_mob_clear_status(1,handle); //   and reset MOb status
800048fc:	f8 0c 00 18 	add	r8,r12,r12<<0x1
80004900:	a3 68       	lsl	r8,0x2
80004902:	e2 28 e1 a0 	sub	r8,188832
80004906:	30 f9       	mov	r9,15
80004908:	91 09       	st.w	r8[0x0],r9
  }
  can_lib_params.can_msg_callback_channel1(handle,CAN_STATUS_COMPLETED);
8000490a:	48 48       	lddpc	r8,80004918 <can1_int_rx_handler+0x40>
8000490c:	70 18       	ld.w	r8,r8[0x4]
8000490e:	30 0b       	mov	r11,0
80004910:	5d 18       	icall	r8
}
80004912:	d4 02       	popm	lr
80004914:	d6 03       	rete
80004916:	00 00       	add	r0,r0
80004918:	00 00       	add	r0,r0
8000491a:	cc 10       	breq	8000489c <can1_int_tx_handler+0x8>

8000491c <can1_int_busoff_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_busoff_handler(void)
{
8000491c:	d4 01       	pushm	lr
    CANIF_clr_interrupt_status(1);
8000491e:	fc 78 1c 00 	mov	r8,-189440
80004922:	f0 f9 02 2c 	ld.w	r9,r8[556]
80004926:	f1 49 02 28 	st.w	r8[552],r9
    can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_BUSOFF);
8000492a:	48 58       	lddpc	r8,8000493c <can1_int_busoff_handler+0x20>
8000492c:	70 18       	ld.w	r8,r8[0x4]
8000492e:	30 4b       	mov	r11,4
80004930:	e0 6c 00 ff 	mov	r12,255
80004934:	5d 18       	icall	r8
}
80004936:	d4 02       	popm	lr
80004938:	d6 03       	rete
8000493a:	00 00       	add	r0,r0
8000493c:	00 00       	add	r0,r0
8000493e:	cc 10       	breq	800048c0 <can1_int_tx_handler+0x2c>

80004940 <can1_int_cerr_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_cerr_handler(void)
{
80004940:	d4 01       	pushm	lr
  CANIF_clr_interrupt_status(1);
80004942:	fc 78 1c 00 	mov	r8,-189440
80004946:	f0 f9 02 2c 	ld.w	r9,r8[556]
8000494a:	f1 49 02 28 	st.w	r8[552],r9
  can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_ERROR);
8000494e:	48 58       	lddpc	r8,80004960 <can1_int_cerr_handler+0x20>
80004950:	70 18       	ld.w	r8,r8[0x4]
80004952:	30 2b       	mov	r11,2
80004954:	e0 6c 00 ff 	mov	r12,255
80004958:	5d 18       	icall	r8
}
8000495a:	d4 02       	popm	lr
8000495c:	d6 03       	rete
8000495e:	00 00       	add	r0,r0
80004960:	00 00       	add	r0,r0
80004962:	cc 10       	breq	800048e4 <can1_int_rx_handler+0xc>

80004964 <can1_int_wakeup_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_wakeup_handler(void)
{
80004964:	d4 01       	pushm	lr
  CANIF_clr_interrupt_status(1);
80004966:	fc 78 1c 00 	mov	r8,-189440
8000496a:	f0 f9 02 2c 	ld.w	r9,r8[556]
8000496e:	f1 49 02 28 	st.w	r8[552],r9
  can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_WAKEUP);
80004972:	48 58       	lddpc	r8,80004984 <can1_int_wakeup_handler+0x20>
80004974:	70 18       	ld.w	r8,r8[0x4]
80004976:	30 3b       	mov	r11,3
80004978:	e0 6c 00 ff 	mov	r12,255
8000497c:	5d 18       	icall	r8
}
8000497e:	d4 02       	popm	lr
80004980:	d6 03       	rete
80004982:	00 00       	add	r0,r0
80004984:	00 00       	add	r0,r0
80004986:	cc 10       	breq	80004908 <can1_int_rx_handler+0x30>

80004988 <can_tx>:
U8 can_tx( U8 ch,
           U8 handle,
           U8 dlc,
           U8 req_type,
           const can_msg_t *can_msg)
{
80004988:	eb cd 40 f8 	pushm	r3-r7,lr
    if ((ch > 1) ||
8000498c:	30 1e       	mov	lr,1
8000498e:	f8 0e 18 00 	cp.b	lr,r12
80004992:	f9 be 02 00 	movhs	lr,0
80004996:	30 17       	mov	r7,1
80004998:	30 f6       	mov	r6,15
8000499a:	f6 06 18 00 	cp.b	r6,r11
8000499e:	f9 b7 02 00 	movhs	r7,0
800049a2:	0e 96       	mov	r6,r7
800049a4:	0c 4e       	or	lr,r6
800049a6:	30 06       	mov	r6,0
800049a8:	ec 0e 18 00 	cp.b	lr,r6
800049ac:	c7 d1       	brne	80004aa6 <can_tx+0x11e>
800049ae:	30 8e       	mov	lr,8
800049b0:	fc 0a 18 00 	cp.b	r10,lr
800049b4:	e0 8b 00 79 	brhi	80004aa6 <can_tx+0x11e>
        (handle > (NB_MOB_CHANNEL-1)) ||
        (dlc > 8))
        return  CAN_CMD_REFUSED;

    if (can_msg->ide_bit){
800049b8:	70 0e       	ld.w	lr,r8[0x0]
800049ba:	e6 1e 20 00 	andh	lr,0x2000,COH
800049be:	c1 40       	breq	800049e6 <can_tx+0x5e>
             CANIF_set_ext_id(ch,
800049c0:	f6 0e 15 04 	lsl	lr,r11,0x4
800049c4:	fc 77 1c 00 	mov	r7,-189440
800049c8:	f8 06 15 06 	lsl	r6,r12,0x6
800049cc:	2f f6       	sub	r6,-1
800049ce:	ee 06 03 35 	ld.w	r5,r7[r6<<0x3]
800049d2:	70 04       	ld.w	r4,r8[0x0]
800049d4:	bd b4       	sbr	r4,0x1d
800049d6:	fc 05 09 04 	st.w	lr[r5],r4
                            handle,
                            can_msg->id);

             CANIF_set_ext_idmask(ch,
800049da:	ee 06 03 37 	ld.w	r7,r7[r6<<0x3]
800049de:	0e 0e       	add	lr,r7
800049e0:	70 17       	ld.w	r7,r8[0x4]
800049e2:	9d 17       	st.w	lr[0x4],r7
800049e4:	c1 28       	rjmp	80004a08 <can_tx+0x80>
                                handle,
                                can_msg->id_mask);
    }
    else {
             CANIF_set_std_id(ch,
800049e6:	f6 0e 15 04 	lsl	lr,r11,0x4
800049ea:	fc 77 1c 00 	mov	r7,-189440
800049ee:	f8 06 15 06 	lsl	r6,r12,0x6
800049f2:	2f f6       	sub	r6,-1
800049f4:	ee 06 03 35 	ld.w	r5,r7[r6<<0x3]
800049f8:	70 04       	ld.w	r4,r8[0x0]
800049fa:	fc 05 09 04 	st.w	lr[r5],r4
                            handle,
                            can_msg->id);
             CANIF_set_std_idmask(ch,
800049fe:	ee 06 03 37 	ld.w	r7,r7[r6<<0x3]
80004a02:	0e 0e       	add	lr,r7
80004a04:	70 17       	ld.w	r7,r8[0x4]
80004a06:	9d 17       	st.w	lr[0x4],r7
                                handle,
                                can_msg->id_mask);
    }
    CANIF_mob_clr_dlc(ch,handle);
80004a08:	16 97       	mov	r7,r11
80004a0a:	f8 0e 15 09 	lsl	lr,r12,0x9
80004a0e:	2f 8e       	sub	lr,-8
80004a10:	f6 0b 00 16 	add	r6,r11,r11<<0x1
80004a14:	fc 06 00 2e 	add	lr,lr,r6<<0x2
80004a18:	e2 2e e3 ac 	sub	lr,189356
80004a1c:	7c 06       	ld.w	r6,lr[0x0]
80004a1e:	e0 16 ff f0 	andl	r6,0xfff0
80004a22:	9d 06       	st.w	lr[0x0],r6
    CANIF_mob_set_dlc(ch,handle,dlc);
80004a24:	7c 06       	ld.w	r6,lr[0x0]
80004a26:	ed ea 10 0a 	or	r10,r6,r10
80004a2a:	9d 0a       	st.w	lr[0x0],r10
    if (req_type == CAN_REMOTE_FRAME){
80004a2c:	30 1a       	mov	r10,1
80004a2e:	f4 09 18 00 	cp.b	r9,r10
80004a32:	c1 b1       	brne	80004a68 <can_tx+0xe0>
            CANIF_set_rtr(ch,handle);
80004a34:	f6 09 15 04 	lsl	r9,r11,0x4
80004a38:	fc 7a 1c 00 	mov	r10,-189440
80004a3c:	f8 05 15 06 	lsl	r5,r12,0x6
80004a40:	2f f5       	sub	r5,-1
80004a42:	f4 05 03 34 	ld.w	r4,r10[r5<<0x3]
80004a46:	f2 04 03 03 	ld.w	r3,r9[r4]
80004a4a:	30 16       	mov	r6,1
80004a4c:	e7 d6 d3 c1 	bfins	r3,r6,0x1e,0x1
80004a50:	f2 04 09 03 	st.w	r9[r4],r3
            CANIF_set_rtrmask(ch,handle);
80004a54:	f4 05 03 3a 	ld.w	r10,r10[r5<<0x3]
80004a58:	14 09       	add	r9,r10
80004a5a:	72 1a       	ld.w	r10,r9[0x4]
80004a5c:	f5 d6 d3 c1 	bfins	r10,r6,0x1e,0x1
80004a60:	93 1a       	st.w	r9[0x4],r10
            CANIF_mob_set_automode(ch,handle);
80004a62:	7c 09       	ld.w	r9,lr[0x0]
80004a64:	a5 b9       	sbr	r9,0x5
80004a66:	9d 09       	st.w	lr[0x0],r9
    }
    CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
80004a68:	fc 79 1c 00 	mov	r9,-189440
80004a6c:	f8 0a 15 06 	lsl	r10,r12,0x6
80004a70:	2f fa       	sub	r10,-1
80004a72:	f2 0a 03 3a 	ld.w	r10,r9[r10<<0x3]
80004a76:	a5 6b       	lsl	r11,0x4
80004a78:	14 0b       	add	r11,r10
80004a7a:	f0 e4 00 08 	ld.d	r4,r8[8]
80004a7e:	f6 e5 00 08 	st.d	r11[8],r4
    CANIF_config_tx(ch,handle);
80004a82:	7c 08       	ld.w	r8,lr[0x0]
80004a84:	a5 a8       	sbr	r8,0x4
80004a86:	9d 08       	st.w	lr[0x0],r8
    CANIF_mob_enable(ch,handle);
80004a88:	30 18       	mov	r8,1
80004a8a:	f0 07 09 48 	lsl	r8,r8,r7
80004a8e:	f8 0a 15 09 	lsl	r10,r12,0x9
80004a92:	f2 0a 00 0a 	add	r10,r9,r10
80004a96:	2c ca       	sub	r10,-52
80004a98:	95 08       	st.w	r10[0x0],r8
#ifdef CAN_LIB_UNDER_INTERRUPT
    CANIF_mob_enable_interrupt(ch,handle);
80004a9a:	a9 7c       	lsl	r12,0x9
80004a9c:	2c 0c       	sub	r12,-64
80004a9e:	18 09       	add	r9,r12
80004aa0:	93 08       	st.w	r9[0x0],r8
80004aa2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
#endif
    return CAN_CMD_ACCEPTED;
80004aa6:	e0 6c 00 ff 	mov	r12,255
}
80004aaa:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

80004aae <can_rx>:

U8 can_rx( U8 ch,
           U8 handle,
           U8 req_type,
           const can_msg_t *can_msg)
{
80004aae:	eb cd 40 e0 	pushm	r5-r7,lr
    if ((ch > 1) ||
80004ab2:	30 18       	mov	r8,1
80004ab4:	f8 08 18 00 	cp.b	r8,r12
80004ab8:	f9 b8 02 00 	movhs	r8,0
80004abc:	30 1e       	mov	lr,1
80004abe:	30 f7       	mov	r7,15
80004ac0:	f6 07 18 00 	cp.b	r7,r11
80004ac4:	f9 be 02 00 	movhs	lr,0
80004ac8:	1c 48       	or	r8,lr
80004aca:	30 07       	mov	r7,0
80004acc:	ee 08 18 00 	cp.b	r8,r7
80004ad0:	c0 50       	breq	80004ada <can_rx+0x2c>
80004ad2:	e0 6c 00 ff 	mov	r12,255
80004ad6:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        (handle > (NB_MOB_CHANNEL-1)))
        return  CAN_CMD_REFUSED;
    if (can_msg->ide_bit){
80004ada:	72 08       	ld.w	r8,r9[0x0]
80004adc:	e6 18 20 00 	andh	r8,0x2000,COH
80004ae0:	c1 40       	breq	80004b08 <can_rx+0x5a>
    	CANIF_set_ext_id(ch,
80004ae2:	f6 08 15 04 	lsl	r8,r11,0x4
80004ae6:	fc 7e 1c 00 	mov	lr,-189440
80004aea:	f8 07 15 06 	lsl	r7,r12,0x6
80004aee:	2f f7       	sub	r7,-1
80004af0:	fc 07 03 36 	ld.w	r6,lr[r7<<0x3]
80004af4:	72 05       	ld.w	r5,r9[0x0]
80004af6:	bd b5       	sbr	r5,0x1d
80004af8:	f0 06 09 05 	st.w	r8[r6],r5
                      handle,
                      can_msg->id);
        CANIF_set_ext_idmask(ch,
80004afc:	fc 07 03 3e 	ld.w	lr,lr[r7<<0x3]
80004b00:	1c 08       	add	r8,lr
80004b02:	72 1e       	ld.w	lr,r9[0x4]
80004b04:	91 1e       	st.w	r8[0x4],lr
80004b06:	c1 28       	rjmp	80004b2a <can_rx+0x7c>
                          handle,
                          can_msg->id_mask);
    }
    else {
    	CANIF_set_std_id(ch,
80004b08:	f6 08 15 04 	lsl	r8,r11,0x4
80004b0c:	fc 7e 1c 00 	mov	lr,-189440
80004b10:	f8 07 15 06 	lsl	r7,r12,0x6
80004b14:	2f f7       	sub	r7,-1
80004b16:	fc 07 03 36 	ld.w	r6,lr[r7<<0x3]
80004b1a:	72 05       	ld.w	r5,r9[0x0]
80004b1c:	f0 06 09 05 	st.w	r8[r6],r5
                      handle,
                      can_msg->id);
        CANIF_set_std_idmask(ch,
80004b20:	fc 07 03 3e 	ld.w	lr,lr[r7<<0x3]
80004b24:	1c 08       	add	r8,lr
80004b26:	72 1e       	ld.w	lr,r9[0x4]
80004b28:	91 1e       	st.w	r8[0x4],lr
                          handle,
                          can_msg->id_mask);
    }
    if (req_type == CAN_REMOTE_FRAME){
80004b2a:	30 18       	mov	r8,1
80004b2c:	f0 0a 18 00 	cp.b	r10,r8
80004b30:	c2 a1       	brne	80004b84 <can_rx+0xd6>
            CANIF_set_rtr(ch,handle);
80004b32:	f6 08 15 04 	lsl	r8,r11,0x4
80004b36:	fc 7e 1c 00 	mov	lr,-189440
80004b3a:	f8 0a 15 06 	lsl	r10,r12,0x6
80004b3e:	2f fa       	sub	r10,-1
80004b40:	fc 0a 03 37 	ld.w	r7,lr[r10<<0x3]
80004b44:	f0 07 03 06 	ld.w	r6,r8[r7]
80004b48:	30 15       	mov	r5,1
80004b4a:	ed d5 d3 c1 	bfins	r6,r5,0x1e,0x1
80004b4e:	f0 07 09 06 	st.w	r8[r7],r6
            CANIF_set_rtrmask(ch,handle);
80004b52:	fc 0a 03 37 	ld.w	r7,lr[r10<<0x3]
80004b56:	f0 07 00 07 	add	r7,r8,r7
80004b5a:	6e 16       	ld.w	r6,r7[0x4]
80004b5c:	ed d5 d3 c1 	bfins	r6,r5,0x1e,0x1
80004b60:	8f 16       	st.w	r7[0x4],r6
            CANIF_mob_set_automode(ch,handle);
80004b62:	f6 0b 00 17 	add	r7,r11,r11<<0x1
80004b66:	a3 67       	lsl	r7,0x2
80004b68:	ee 0a 00 37 	add	r7,r7,r10<<0x3
80004b6c:	e2 27 e3 ac 	sub	r7,189356
80004b70:	6e 06       	ld.w	r6,r7[0x0]
80004b72:	a5 b6       	sbr	r6,0x5
80004b74:	8f 06       	st.w	r7[0x0],r6
            CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
80004b76:	fc 0a 03 3a 	ld.w	r10,lr[r10<<0x3]
80004b7a:	14 08       	add	r8,r10
80004b7c:	f2 e6 00 08 	ld.d	r6,r9[8]
80004b80:	f0 e7 00 08 	st.d	r8[8],r6
    }
    CANIF_config_rx(ch,handle);
80004b84:	f8 08 15 09 	lsl	r8,r12,0x9
80004b88:	2f 88       	sub	r8,-8
80004b8a:	f6 0b 00 19 	add	r9,r11,r11<<0x1
80004b8e:	f0 09 00 28 	add	r8,r8,r9<<0x2
80004b92:	e2 28 e3 ac 	sub	r8,189356
80004b96:	70 09       	ld.w	r9,r8[0x0]
80004b98:	a5 c9       	cbr	r9,0x4
80004b9a:	91 09       	st.w	r8[0x0],r9
    CANIF_mob_enable(ch,handle);
80004b9c:	30 18       	mov	r8,1
80004b9e:	f0 0b 09 4b 	lsl	r11,r8,r11
80004ba2:	f8 08 15 09 	lsl	r8,r12,0x9
80004ba6:	e2 28 e3 cc 	sub	r8,189388
80004baa:	91 0b       	st.w	r8[0x0],r11
#ifdef CAN_LIB_UNDER_INTERRUPT
    CANIF_mob_enable_interrupt(ch,handle);
80004bac:	a9 7c       	lsl	r12,0x9
80004bae:	e2 2c e3 c0 	sub	r12,189376
80004bb2:	99 0b       	st.w	r12[0x0],r11
80004bb4:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0

80004bb8 <can_get_mob_data>:
}

Union64 can_get_mob_data( U8 ch ,
                           U8 handle)
{
    return ((CANIF_mob_get_ptr_data(ch,handle)->data));
80004bb8:	a7 6c       	lsl	r12,0x6
80004bba:	2f fc       	sub	r12,-1
80004bbc:	fc 78 1c 00 	mov	r8,-189440
80004bc0:	f0 0c 03 38 	ld.w	r8,r8[r12<<0x3]
80004bc4:	a5 6b       	lsl	r11,0x4
80004bc6:	f6 08 00 08 	add	r8,r11,r8
}
80004bca:	70 2b       	ld.w	r11,r8[0x8]
80004bcc:	70 3a       	ld.w	r10,r8[0xc]
80004bce:	5e fc       	retal	r12

80004bd0 <can_get_mob_dlc>:

U8 can_get_mob_dlc( U8 ch ,
                    U8 handle)
{
    return (CANIF_mob_get_dlc(ch,handle));
80004bd0:	a9 7c       	lsl	r12,0x9
80004bd2:	2f 8c       	sub	r12,-8
80004bd4:	f6 0b 00 1b 	add	r11,r11,r11<<0x1
80004bd8:	f8 0b 00 2c 	add	r12,r12,r11<<0x2
80004bdc:	e2 2c e3 ac 	sub	r12,189356
80004be0:	78 0c       	ld.w	r12,r12[0x0]
}
80004be2:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
80004be6:	5e fc       	retal	r12

80004be8 <can_get_mob_id>:

U32 can_get_mob_id( U8 ch ,
                    U8 handle)
{
    return (CANIF_get_ext_id(ch,handle));
80004be8:	a7 6c       	lsl	r12,0x6
80004bea:	2f fc       	sub	r12,-1
80004bec:	fc 78 1c 00 	mov	r8,-189440
80004bf0:	f0 0c 03 38 	ld.w	r8,r8[r12<<0x3]
80004bf4:	a5 6b       	lsl	r11,0x4
80004bf6:	f6 08 03 0c 	ld.w	r12,r11[r8]
}
80004bfa:	f9 dc c0 1d 	bfextu	r12,r12,0x0,0x1d
80004bfe:	5e fc       	retal	r12

80004c00 <can_enable_interrupt>:
  CANIF_clr_interrupt_status(1);
  can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_WAKEUP);
}

U8 can_enable_interrupt(U8 ch)
{
80004c00:	d4 01       	pushm	lr
  if ((ch > 1))
80004c02:	30 18       	mov	r8,1
80004c04:	f0 0c 18 00 	cp.b	r12,r8
80004c08:	e0 88 00 05 	brls	80004c12 <can_enable_interrupt+0x12>
80004c0c:	e0 6c 00 ff 	mov	r12,255
80004c10:	d8 02       	popm	pc
        return  CAN_CMD_REFUSED;

  if (ch==0)
80004c12:	58 0c       	cp.w	r12,0
80004c14:	c2 51       	brne	80004c5e <can_enable_interrupt+0x5e>
  {
    INTC_register_interrupt(&can0_int_tx_handler, AVR32_CANIF_TXOK_IRQ_0, CAN0_INT_TX_LEVEL);
80004c16:	30 0a       	mov	r10,0
80004c18:	e0 6b 01 23 	mov	r11,291
80004c1c:	4a 6c       	lddpc	r12,80004cb4 <can_enable_interrupt+0xb4>
80004c1e:	f0 1f 00 27 	mcall	80004cb8 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can0_int_rx_handler, AVR32_CANIF_RXOK_IRQ_0, CAN0_INT_RX_LEVEL);
80004c22:	30 0a       	mov	r10,0
80004c24:	e0 6b 01 22 	mov	r11,290
80004c28:	4a 5c       	lddpc	r12,80004cbc <can_enable_interrupt+0xbc>
80004c2a:	f0 1f 00 24 	mcall	80004cb8 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can0_int_busoff_handler, AVR32_CANIF_BUS_OFF_IRQ_0, CAN0_INT_BOFF_LEVEL);
80004c2e:	30 0a       	mov	r10,0
80004c30:	e0 6b 01 20 	mov	r11,288
80004c34:	4a 3c       	lddpc	r12,80004cc0 <can_enable_interrupt+0xc0>
80004c36:	f0 1f 00 21 	mcall	80004cb8 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can0_int_cerr_handler, AVR32_CANIF_ERROR_IRQ_0, CAN0_INT_ERR_LEVEL);
80004c3a:	30 0a       	mov	r10,0
80004c3c:	e0 6b 01 21 	mov	r11,289
80004c40:	4a 1c       	lddpc	r12,80004cc4 <can_enable_interrupt+0xc4>
80004c42:	f0 1f 00 1e 	mcall	80004cb8 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can0_int_wakeup_handler, AVR32_CANIF_WAKE_UP_IRQ_0, CAN0_INT_WAKE_UP_LEVEL);
80004c46:	30 0a       	mov	r10,0
80004c48:	e0 6b 01 24 	mov	r11,292
80004c4c:	49 fc       	lddpc	r12,80004cc8 <can_enable_interrupt+0xc8>
80004c4e:	f0 1f 00 1b 	mcall	80004cb8 <can_enable_interrupt+0xb8>
    CANIF_enable_interrupt(ch);
80004c52:	e0 69 01 c9 	mov	r9,457
80004c56:	fc 78 1c 00 	mov	r8,-189440
80004c5a:	91 79       	st.w	r8[0x1c],r9
80004c5c:	d8 0a       	popm	pc,r12=0
  }
  else if (ch == 1)
80004c5e:	30 18       	mov	r8,1
80004c60:	f0 0c 18 00 	cp.b	r12,r8
80004c64:	c0 20       	breq	80004c68 <can_enable_interrupt+0x68>
80004c66:	d8 0a       	popm	pc,r12=0
  {
    INTC_register_interrupt(&can1_int_tx_handler, AVR32_CANIF_TXOK_IRQ_1, CAN1_INT_TX_LEVEL);
80004c68:	30 0a       	mov	r10,0
80004c6a:	e0 6b 01 28 	mov	r11,296
80004c6e:	49 8c       	lddpc	r12,80004ccc <can_enable_interrupt+0xcc>
80004c70:	f0 1f 00 12 	mcall	80004cb8 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can1_int_rx_handler, AVR32_CANIF_RXOK_IRQ_1, CAN1_INT_RX_LEVEL);
80004c74:	30 0a       	mov	r10,0
80004c76:	e0 6b 01 27 	mov	r11,295
80004c7a:	49 6c       	lddpc	r12,80004cd0 <can_enable_interrupt+0xd0>
80004c7c:	f0 1f 00 0f 	mcall	80004cb8 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can1_int_busoff_handler, AVR32_CANIF_BUS_OFF_IRQ_1, CAN1_INT_BOFF_LEVEL);
80004c80:	30 0a       	mov	r10,0
80004c82:	e0 6b 01 25 	mov	r11,293
80004c86:	49 4c       	lddpc	r12,80004cd4 <can_enable_interrupt+0xd4>
80004c88:	f0 1f 00 0c 	mcall	80004cb8 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can1_int_cerr_handler, AVR32_CANIF_ERROR_IRQ_1, CAN1_INT_ERR_LEVEL);
80004c8c:	30 0a       	mov	r10,0
80004c8e:	e0 6b 01 26 	mov	r11,294
80004c92:	49 2c       	lddpc	r12,80004cd8 <can_enable_interrupt+0xd8>
80004c94:	f0 1f 00 09 	mcall	80004cb8 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can1_int_wakeup_handler, AVR32_CANIF_WAKE_UP_IRQ_1, CAN1_INT_WAKE_UP_LEVEL);
80004c98:	30 0a       	mov	r10,0
80004c9a:	e0 6b 01 29 	mov	r11,297
80004c9e:	49 0c       	lddpc	r12,80004cdc <can_enable_interrupt+0xdc>
80004ca0:	f0 1f 00 06 	mcall	80004cb8 <can_enable_interrupt+0xb8>
    CANIF_enable_interrupt(ch);
80004ca4:	e0 69 01 c9 	mov	r9,457
80004ca8:	fc 78 1c 00 	mov	r8,-189440
80004cac:	f1 49 02 1c 	st.w	r8[540],r9
80004cb0:	d8 0a       	popm	pc,r12=0
80004cb2:	00 00       	add	r0,r0
80004cb4:	80 00       	ld.sh	r0,r0[0x0]
80004cb6:	47 b4       	lddsp	r4,sp[0x1ec]
80004cb8:	80 00       	ld.sh	r0,r0[0x0]
80004cba:	68 70       	ld.w	r0,r4[0x1c]
80004cbc:	80 00       	ld.sh	r0,r0[0x0]
80004cbe:	47 f4       	lddsp	r4,sp[0x1fc]
80004cc0:	80 00       	ld.sh	r0,r0[0x0]
80004cc2:	48 34       	lddpc	r4,80004ccc <can_enable_interrupt+0xcc>
80004cc4:	80 00       	ld.sh	r0,r0[0x0]
80004cc6:	48 54       	lddpc	r4,80004cd8 <can_enable_interrupt+0xd8>
80004cc8:	80 00       	ld.sh	r0,r0[0x0]
80004cca:	48 74       	lddpc	r4,80004ce4 <can_init+0x4>
80004ccc:	80 00       	ld.sh	r0,r0[0x0]
80004cce:	48 94       	lddpc	r4,80004cf0 <can_init+0x10>
80004cd0:	80 00       	ld.sh	r0,r0[0x0]
80004cd2:	48 d8       	lddpc	r8,80004d04 <can_init+0x24>
80004cd4:	80 00       	ld.sh	r0,r0[0x0]
80004cd6:	49 1c       	lddpc	r12,80004d18 <can_init+0x38>
80004cd8:	80 00       	ld.sh	r0,r0[0x0]
80004cda:	49 40       	lddpc	r0,80004d28 <can_init+0x48>
80004cdc:	80 00       	ld.sh	r0,r0[0x0]
80004cde:	49 64       	lddpc	r4,80004d34 <can_init+0x54>

80004ce0 <can_init>:

U8 can_init(U8 ch,
            U32 can_msg_ram_add,
            U8 operating_mode,
            void (*can_msg_callback_channel) (U8 handle, U8 event))
{
80004ce0:	d4 21       	pushm	r4-r7,lr
80004ce2:	18 96       	mov	r6,r12
80004ce4:	14 95       	mov	r5,r10
80004ce6:	12 94       	mov	r4,r9
   if ( ch > 1)
80004ce8:	30 18       	mov	r8,1
80004cea:	f0 0c 18 00 	cp.b	r12,r8
80004cee:	e0 8b 00 91 	brhi	80004e10 <can_init+0x130>
         return  CAN_CMD_REFUSED;

   // Initialize CAN channel
   CANIF_set_reset(ch);
80004cf2:	18 97       	mov	r7,r12
80004cf4:	f8 08 15 09 	lsl	r8,r12,0x9
80004cf8:	e2 28 e3 f0 	sub	r8,189424
80004cfc:	30 19       	mov	r9,1
80004cfe:	91 09       	st.w	r8[0x0],r9
   while(CANIF_channel_enable_status(ch));
80004d00:	f8 09 15 09 	lsl	r9,r12,0x9
80004d04:	e2 29 e3 ec 	sub	r9,189420
80004d08:	72 08       	ld.w	r8,r9[0x0]
80004d0a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004d0e:	cf d1       	brne	80004d08 <can_init+0x28>
   CANIF_clr_reset(ch);
80004d10:	ee 08 15 09 	lsl	r8,r7,0x9
80004d14:	e2 28 e3 f0 	sub	r8,189424
80004d18:	30 09       	mov	r9,0
80004d1a:	91 09       	st.w	r8[0x0],r9

   CANIF_set_ram_add(ch,(unsigned long) can_msg_ram_add);
80004d1c:	ee 09 15 06 	lsl	r9,r7,0x6
80004d20:	2f f9       	sub	r9,-1
80004d22:	fc 78 1c 00 	mov	r8,-189440
80004d26:	f0 09 09 3b 	st.w	r8[r9<<0x3],r11
   if ((CANIF_bit_timing(ch))==0) return (0);
80004d2a:	0e 9c       	mov	r12,r7
80004d2c:	f0 1f 00 3f 	mcall	80004e28 <can_init+0x148>
80004d30:	c7 20       	breq	80004e14 <can_init+0x134>
   switch(operating_mode)
80004d32:	30 18       	mov	r8,1
80004d34:	f0 05 18 00 	cp.b	r5,r8
80004d38:	c1 50       	breq	80004d62 <can_init+0x82>
80004d3a:	c0 63       	brcs	80004d46 <can_init+0x66>
80004d3c:	30 28       	mov	r8,2
80004d3e:	f0 05 18 00 	cp.b	r5,r8
80004d42:	c2 d1       	brne	80004d9c <can_init+0xbc>
80004d44:	c1 e8       	rjmp	80004d80 <can_init+0xa0>
   {
    case CANIF_CHANNEL_MODE_NORMAL:
      CANIF_set_channel_mode(ch,0);
80004d46:	ee 08 15 09 	lsl	r8,r7,0x9
80004d4a:	e2 28 e3 f4 	sub	r8,189428
80004d4e:	70 09       	ld.w	r9,r8[0x0]
80004d50:	e4 19 fc ff 	andh	r9,0xfcff
80004d54:	91 09       	st.w	r8[0x0],r9
80004d56:	70 09       	ld.w	r9,r8[0x0]
80004d58:	91 09       	st.w	r8[0x0],r9
      CANIF_clr_overrun_mode(ch);
80004d5a:	70 09       	ld.w	r9,r8[0x0]
80004d5c:	bb c9       	cbr	r9,0x1a
80004d5e:	91 09       	st.w	r8[0x0],r9
      break;
80004d60:	c1 e8       	rjmp	80004d9c <can_init+0xbc>
    case CANIF_CHANNEL_MODE_LISTENING:
      CANIF_set_channel_mode(ch,1);
80004d62:	ee 08 15 09 	lsl	r8,r7,0x9
80004d66:	e2 28 e3 f4 	sub	r8,189428
80004d6a:	70 09       	ld.w	r9,r8[0x0]
80004d6c:	e4 19 fc ff 	andh	r9,0xfcff
80004d70:	91 09       	st.w	r8[0x0],r9
80004d72:	70 09       	ld.w	r9,r8[0x0]
80004d74:	b9 a9       	sbr	r9,0x18
80004d76:	91 09       	st.w	r8[0x0],r9
      CANIF_set_overrun_mode(ch);
80004d78:	70 09       	ld.w	r9,r8[0x0]
80004d7a:	bb a9       	sbr	r9,0x1a
80004d7c:	91 09       	st.w	r8[0x0],r9
      break;
80004d7e:	c0 f8       	rjmp	80004d9c <can_init+0xbc>
    case CANIF_CHANNEL_MODE_LOOPBACK:
      CANIF_set_channel_mode(ch,2);
80004d80:	ee 08 15 09 	lsl	r8,r7,0x9
80004d84:	e2 28 e3 f4 	sub	r8,189428
80004d88:	70 09       	ld.w	r9,r8[0x0]
80004d8a:	e4 19 fc ff 	andh	r9,0xfcff
80004d8e:	91 09       	st.w	r8[0x0],r9
80004d90:	70 09       	ld.w	r9,r8[0x0]
80004d92:	b9 b9       	sbr	r9,0x19
80004d94:	91 09       	st.w	r8[0x0],r9
      CANIF_clr_overrun_mode(ch);
80004d96:	70 09       	ld.w	r9,r8[0x0]
80004d98:	bb c9       	cbr	r9,0x1a
80004d9a:	91 09       	st.w	r8[0x0],r9
      break;
   }
   canif_clear_all_mob(ch,NB_MOB_CHANNEL);
80004d9c:	31 0b       	mov	r11,16
80004d9e:	0e 9c       	mov	r12,r7
80004da0:	f0 1f 00 23 	mcall	80004e2c <can_init+0x14c>
   CANIF_enable(ch);
80004da4:	ee 08 15 09 	lsl	r8,r7,0x9
80004da8:	e2 28 e3 f0 	sub	r8,189424
80004dac:	70 09       	ld.w	r9,r8[0x0]
80004dae:	a1 b9       	sbr	r9,0x1
80004db0:	91 09       	st.w	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80004db2:	ee 78 42 40 	mov	r8,1000000
80004db6:	30 09       	mov	r9,0
80004db8:	e0 6a be 3f 	mov	r10,48703
80004dbc:	ea 1a 93 76 	orh	r10,0x9376
80004dc0:	30 1b       	mov	r11,1
80004dc2:	f0 1f 00 1c 	mcall	80004e30 <can_init+0x150>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80004dc6:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80004dca:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80004dce:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80004dd2:	14 38       	cp.w	r8,r10
80004dd4:	e0 88 00 08 	brls	80004de4 <can_init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80004dd8:	12 38       	cp.w	r8,r9
80004dda:	fe 98 ff fa 	brls	80004dce <can_init+0xee>
80004dde:	12 3a       	cp.w	r10,r9
80004de0:	c1 b3       	brcs	80004e16 <can_init+0x136>
80004de2:	cf 6b       	rjmp	80004dce <can_init+0xee>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80004de4:	12 38       	cp.w	r8,r9
80004de6:	e0 8b 00 18 	brhi	80004e16 <can_init+0x136>
80004dea:	12 3a       	cp.w	r10,r9
80004dec:	c1 53       	brcs	80004e16 <can_init+0x136>
80004dee:	cf 0b       	rjmp	80004dce <can_init+0xee>
            return CAN_CMD_REFUSED;
   }
#endif

#ifdef CAN_LIB_UNDER_INTERRUPT
   switch(ch)
80004df0:	58 06       	cp.w	r6,0
80004df2:	c0 60       	breq	80004dfe <can_init+0x11e>
80004df4:	30 18       	mov	r8,1
80004df6:	f0 06 18 00 	cp.b	r6,r8
80004dfa:	c0 71       	brne	80004e08 <can_init+0x128>
80004dfc:	c0 48       	rjmp	80004e04 <can_init+0x124>
   {
    case 0:
        can_lib_params.can_msg_callback_channel0     = can_msg_callback_channel;
80004dfe:	48 e8       	lddpc	r8,80004e34 <can_init+0x154>
80004e00:	91 04       	st.w	r8[0x0],r4
        break;
80004e02:	c0 38       	rjmp	80004e08 <can_init+0x128>
    case 1:
        can_lib_params.can_msg_callback_channel1     = can_msg_callback_channel;
80004e04:	48 c8       	lddpc	r8,80004e34 <can_init+0x154>
80004e06:	91 14       	st.w	r8[0x4],r4
        break;
   }
    can_enable_interrupt(ch);
80004e08:	0e 9c       	mov	r12,r7
80004e0a:	f0 1f 00 0c 	mcall	80004e38 <can_init+0x158>
80004e0e:	d8 2a       	popm	r4-r7,pc,r12=0
#endif

   return CAN_CMD_ACCEPTED;
80004e10:	e0 6c 00 ff 	mov	r12,255
}
80004e14:	d8 22       	popm	r4-r7,pc
 * - 3x bits of interframe.
 */
#define DELAY_HZ         (BAUDRATE_HZ/141.0)   /*Compute Maximum delay time*/
#define DELAY            (1000000 / DELAY_HZ)  /*Compute Delay in s*/
   delay_us(DELAY);
   if(!CANIF_channel_enable_status(ch)) {
80004e16:	ee 08 15 09 	lsl	r8,r7,0x9
80004e1a:	e2 28 e3 ec 	sub	r8,189420
80004e1e:	70 08       	ld.w	r8,r8[0x0]
80004e20:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e24:	ce 61       	brne	80004df0 <can_init+0x110>
80004e26:	cf 5b       	rjmp	80004e10 <can_init+0x130>
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	46 8c       	lddsp	r12,sp[0x1a0]
80004e2c:	80 00       	ld.sh	r0,r0[0x0]
80004e2e:	46 44       	lddsp	r4,sp[0x190]
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	75 e2       	ld.w	r2,r10[0x78]
80004e34:	00 00       	add	r0,r0
80004e36:	cc 10       	breq	80004db8 <can_init+0xd8>
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	4c 00       	lddpc	r0,80004f38 <can_out_callback_channel1+0xfc>

80004e3c <can_out_callback_channel1>:
		mob_rx_bspd.can_msg);
	} 
}

/* Call Back called by can_drv, channel 1 */
void can_out_callback_channel1(U8 handle, U8 event){
80004e3c:	d4 21       	pushm	r4-r7,lr
80004e3e:	20 6d       	sub	sp,24
80004e40:	16 94       	mov	r4,r11
	if (handle == mob_rx_speed_sens_fl.handle) {
80004e42:	fe f8 03 66 	ld.w	r8,pc[870]
80004e46:	11 87       	ld.ub	r7,r8[0x0]
80004e48:	f8 07 18 00 	cp.b	r7,r12
80004e4c:	c2 f1       	brne	80004eaa <can_out_callback_channel1+0x6e>
		mob_rx_speed_sens_fl.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80004e4e:	fe f5 03 5a 	ld.w	r5,pc[858]
80004e52:	6a 16       	ld.w	r6,r5[0x4]
80004e54:	0e 9b       	mov	r11,r7
80004e56:	30 1c       	mov	r12,1
80004e58:	f0 1f 00 d5 	mcall	800051ac <can_out_callback_channel1+0x370>
80004e5c:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_speed_sens_fl.can_msg->id		= can_get_mob_id(CAN_BUS_1, handle);
80004e60:	6a 16       	ld.w	r6,r5[0x4]
80004e62:	0e 9b       	mov	r11,r7
80004e64:	30 1c       	mov	r12,1
80004e66:	f0 1f 00 d3 	mcall	800051b0 <can_out_callback_channel1+0x374>
80004e6a:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_speed_sens_fl.dlc				= can_get_mob_dlc(CAN_BUS_1, handle);
80004e6c:	0e 9b       	mov	r11,r7
80004e6e:	30 1c       	mov	r12,1
80004e70:	f0 1f 00 d1 	mcall	800051b4 <can_out_callback_channel1+0x378>
80004e74:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_speed_sens_fl.status				= event;
80004e78:	eb 64 00 0a 	st.b	r5[10],r4
		
		xQueueOverwriteFromISR(queue_wheel_fl, &mob_rx_speed_sens_fl.can_msg->data.u16[0], NULL);
80004e7c:	6a 1b       	ld.w	r11,r5[0x4]
80004e7e:	30 29       	mov	r9,2
80004e80:	30 0a       	mov	r10,0
80004e82:	2f 8b       	sub	r11,-8
80004e84:	fe f8 03 34 	ld.w	r8,pc[820]
80004e88:	70 0c       	ld.w	r12,r8[0x0]
80004e8a:	f0 1f 00 cd 	mcall	800051bc <can_out_callback_channel1+0x380>
		/* Empty message field */
		mob_rx_speed_sens_fl.can_msg->data.u64 = 0x0LL;
80004e8e:	6a 18       	ld.w	r8,r5[0x4]
80004e90:	30 0a       	mov	r10,0
80004e92:	30 0b       	mov	r11,0
80004e94:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
80004e98:	6a 19       	ld.w	r9,r5[0x4]
80004e9a:	eb 3a 00 09 	ld.ub	r10,r5[9]
80004e9e:	0b 8b       	ld.ub	r11,r5[0x0]
80004ea0:	30 1c       	mov	r12,1
80004ea2:	f0 1f 00 c8 	mcall	800051c0 <can_out_callback_channel1+0x384>
80004ea6:	e0 8f 01 7f 	bral	800051a4 <can_out_callback_channel1+0x368>
		mob_rx_speed_sens_fl.handle,
		mob_rx_speed_sens_fl.req_type,
		mob_rx_speed_sens_fl.can_msg);
		
	} else if (handle == mob_rx_speed_sens_fr.handle) {
80004eaa:	fe f8 03 1a 	ld.w	r8,pc[794]
80004eae:	11 87       	ld.ub	r7,r8[0x0]
80004eb0:	f8 07 18 00 	cp.b	r7,r12
80004eb4:	c2 f1       	brne	80004f12 <can_out_callback_channel1+0xd6>
		mob_rx_speed_sens_fr.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80004eb6:	fe f5 03 0e 	ld.w	r5,pc[782]
80004eba:	6a 16       	ld.w	r6,r5[0x4]
80004ebc:	0e 9b       	mov	r11,r7
80004ebe:	30 1c       	mov	r12,1
80004ec0:	f0 1f 00 bb 	mcall	800051ac <can_out_callback_channel1+0x370>
80004ec4:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_speed_sens_fr.can_msg->id		= can_get_mob_id(CAN_BUS_1, handle);
80004ec8:	6a 16       	ld.w	r6,r5[0x4]
80004eca:	0e 9b       	mov	r11,r7
80004ecc:	30 1c       	mov	r12,1
80004ece:	f0 1f 00 b9 	mcall	800051b0 <can_out_callback_channel1+0x374>
80004ed2:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_speed_sens_fr.dlc				= can_get_mob_dlc(CAN_BUS_1, handle);
80004ed4:	0e 9b       	mov	r11,r7
80004ed6:	30 1c       	mov	r12,1
80004ed8:	f0 1f 00 b7 	mcall	800051b4 <can_out_callback_channel1+0x378>
80004edc:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_speed_sens_fr.status				= event;
80004ee0:	eb 64 00 0a 	st.b	r5[10],r4
		
		xQueueOverwriteFromISR(queue_wheel_fr, &mob_rx_speed_sens_fr.can_msg->data.u16[0], NULL);
80004ee4:	6a 1b       	ld.w	r11,r5[0x4]
80004ee6:	30 29       	mov	r9,2
80004ee8:	30 0a       	mov	r10,0
80004eea:	2f 8b       	sub	r11,-8
80004eec:	fe f8 02 dc 	ld.w	r8,pc[732]
80004ef0:	70 0c       	ld.w	r12,r8[0x0]
80004ef2:	f0 1f 00 b3 	mcall	800051bc <can_out_callback_channel1+0x380>
		/* Empty message field */
		mob_rx_speed_sens_fr.can_msg->data.u64 = 0x0LL;
80004ef6:	6a 18       	ld.w	r8,r5[0x4]
80004ef8:	30 0a       	mov	r10,0
80004efa:	30 0b       	mov	r11,0
80004efc:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
80004f00:	6a 19       	ld.w	r9,r5[0x4]
80004f02:	eb 3a 00 09 	ld.ub	r10,r5[9]
80004f06:	0b 8b       	ld.ub	r11,r5[0x0]
80004f08:	30 1c       	mov	r12,1
80004f0a:	f0 1f 00 ae 	mcall	800051c0 <can_out_callback_channel1+0x384>
80004f0e:	e0 8f 01 4b 	bral	800051a4 <can_out_callback_channel1+0x368>
		mob_rx_speed_sens_fr.handle,
		mob_rx_speed_sens_fr.req_type,
		mob_rx_speed_sens_fr.can_msg);
	} else if (handle == mob_rx_speed_sens_rl.handle) {
80004f12:	fe f8 02 ba 	ld.w	r8,pc[698]
80004f16:	11 87       	ld.ub	r7,r8[0x0]
80004f18:	f8 07 18 00 	cp.b	r7,r12
80004f1c:	c2 e1       	brne	80004f78 <can_out_callback_channel1+0x13c>
		mob_rx_speed_sens_rl.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80004f1e:	fe f5 02 ae 	ld.w	r5,pc[686]
80004f22:	6a 16       	ld.w	r6,r5[0x4]
80004f24:	0e 9b       	mov	r11,r7
80004f26:	30 1c       	mov	r12,1
80004f28:	f0 1f 00 a1 	mcall	800051ac <can_out_callback_channel1+0x370>
80004f2c:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_speed_sens_rl.can_msg->id			= can_get_mob_id(CAN_BUS_1, handle);
80004f30:	6a 16       	ld.w	r6,r5[0x4]
80004f32:	0e 9b       	mov	r11,r7
80004f34:	30 1c       	mov	r12,1
80004f36:	f0 1f 00 9f 	mcall	800051b0 <can_out_callback_channel1+0x374>
80004f3a:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_speed_sens_rl.dlc					= can_get_mob_dlc(CAN_BUS_1, handle);
80004f3c:	0e 9b       	mov	r11,r7
80004f3e:	30 1c       	mov	r12,1
80004f40:	f0 1f 00 9d 	mcall	800051b4 <can_out_callback_channel1+0x378>
80004f44:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_speed_sens_rl.status				= event;
80004f48:	eb 64 00 0a 	st.b	r5[10],r4

		xQueueOverwriteFromISR(queue_wheel_rl, &mob_rx_speed_sens_rl.can_msg->data.u16[0], NULL);
80004f4c:	6a 1b       	ld.w	r11,r5[0x4]
80004f4e:	30 29       	mov	r9,2
80004f50:	30 0a       	mov	r10,0
80004f52:	2f 8b       	sub	r11,-8
80004f54:	fe f8 02 7c 	ld.w	r8,pc[636]
80004f58:	70 0c       	ld.w	r12,r8[0x0]
80004f5a:	f0 1f 00 99 	mcall	800051bc <can_out_callback_channel1+0x380>
	
		/* Empty message field */
		mob_rx_speed_sens_rl.can_msg->data.u64 = 0x0LL;
80004f5e:	6a 18       	ld.w	r8,r5[0x4]
80004f60:	30 0a       	mov	r10,0
80004f62:	30 0b       	mov	r11,0
80004f64:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_1, 
80004f68:	6a 19       	ld.w	r9,r5[0x4]
80004f6a:	eb 3a 00 09 	ld.ub	r10,r5[9]
80004f6e:	0b 8b       	ld.ub	r11,r5[0x0]
80004f70:	30 1c       	mov	r12,1
80004f72:	f0 1f 00 94 	mcall	800051c0 <can_out_callback_channel1+0x384>
80004f76:	c1 79       	rjmp	800051a4 <can_out_callback_channel1+0x368>
		mob_rx_speed_sens_rl.handle,
		mob_rx_speed_sens_rl.req_type,
		mob_rx_speed_sens_rl.can_msg);
		
	} else if (handle == mob_rx_speed_sens_rr.handle) {
80004f78:	fe f8 02 5c 	ld.w	r8,pc[604]
80004f7c:	11 87       	ld.ub	r7,r8[0x0]
80004f7e:	f8 07 18 00 	cp.b	r7,r12
80004f82:	c2 e1       	brne	80004fde <can_out_callback_channel1+0x1a2>
		mob_rx_speed_sens_rr.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80004f84:	fe f5 02 50 	ld.w	r5,pc[592]
80004f88:	6a 16       	ld.w	r6,r5[0x4]
80004f8a:	0e 9b       	mov	r11,r7
80004f8c:	30 1c       	mov	r12,1
80004f8e:	f0 1f 00 88 	mcall	800051ac <can_out_callback_channel1+0x370>
80004f92:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_speed_sens_rr.can_msg->id		= can_get_mob_id(CAN_BUS_1, handle);
80004f96:	6a 16       	ld.w	r6,r5[0x4]
80004f98:	0e 9b       	mov	r11,r7
80004f9a:	30 1c       	mov	r12,1
80004f9c:	f0 1f 00 85 	mcall	800051b0 <can_out_callback_channel1+0x374>
80004fa0:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_speed_sens_rr.dlc				= can_get_mob_dlc(CAN_BUS_1, handle);
80004fa2:	0e 9b       	mov	r11,r7
80004fa4:	30 1c       	mov	r12,1
80004fa6:	f0 1f 00 84 	mcall	800051b4 <can_out_callback_channel1+0x378>
80004faa:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_speed_sens_rr.status				= event;
80004fae:	eb 64 00 0a 	st.b	r5[10],r4

		xQueueOverwriteFromISR(queue_wheel_rr, &mob_rx_speed_sens_rr.can_msg->data.u16[0], NULL);
80004fb2:	6a 1b       	ld.w	r11,r5[0x4]
80004fb4:	30 29       	mov	r9,2
80004fb6:	30 0a       	mov	r10,0
80004fb8:	2f 8b       	sub	r11,-8
80004fba:	fe f8 02 1e 	ld.w	r8,pc[542]
80004fbe:	70 0c       	ld.w	r12,r8[0x0]
80004fc0:	f0 1f 00 7f 	mcall	800051bc <can_out_callback_channel1+0x380>
		
		/* Empty message field */
		mob_rx_speed_sens_rr.can_msg->data.u64 = 0x0LL;
80004fc4:	6a 18       	ld.w	r8,r5[0x4]
80004fc6:	30 0a       	mov	r10,0
80004fc8:	30 0b       	mov	r11,0
80004fca:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
80004fce:	6a 19       	ld.w	r9,r5[0x4]
80004fd0:	eb 3a 00 09 	ld.ub	r10,r5[9]
80004fd4:	0b 8b       	ld.ub	r11,r5[0x0]
80004fd6:	30 1c       	mov	r12,1
80004fd8:	f0 1f 00 7a 	mcall	800051c0 <can_out_callback_channel1+0x384>
80004fdc:	ce 48       	rjmp	800051a4 <can_out_callback_channel1+0x368>
		mob_rx_speed_sens_rr.handle,
		mob_rx_speed_sens_rr.req_type,
		mob_rx_speed_sens_rr.can_msg);
	
	}	else if (handle == mob_rx_trq_sens1.handle) {
80004fde:	fe f8 01 fe 	ld.w	r8,pc[510]
80004fe2:	11 87       	ld.ub	r7,r8[0x0]
80004fe4:	f8 07 18 00 	cp.b	r7,r12
80004fe8:	c3 51       	brne	80005052 <can_out_callback_channel1+0x216>
		mob_rx_trq_sens1.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80004fea:	4f d5       	lddpc	r5,800051dc <can_out_callback_channel1+0x3a0>
80004fec:	6a 16       	ld.w	r6,r5[0x4]
80004fee:	0e 9b       	mov	r11,r7
80004ff0:	30 1c       	mov	r12,1
80004ff2:	f0 1f 00 6f 	mcall	800051ac <can_out_callback_channel1+0x370>
80004ff6:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_trq_sens1.can_msg->id			= can_get_mob_id(CAN_BUS_1, handle);
80004ffa:	6a 16       	ld.w	r6,r5[0x4]
80004ffc:	0e 9b       	mov	r11,r7
80004ffe:	30 1c       	mov	r12,1
80005000:	f0 1f 00 6c 	mcall	800051b0 <can_out_callback_channel1+0x374>
80005004:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_trq_sens1.dlc					= can_get_mob_dlc(CAN_BUS_1, handle);
80005006:	0e 9b       	mov	r11,r7
80005008:	30 1c       	mov	r12,1
8000500a:	f0 1f 00 6b 	mcall	800051b4 <can_out_callback_channel1+0x378>
8000500e:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_trq_sens1.status					= event;
80005012:	eb 64 00 0a 	st.b	r5[10],r4
		
		xQueueOverwriteFromISR(queue_trq_sens1, &mob_rx_trq_sens1.can_msg->data.s16[0], NULL);
80005016:	6a 1b       	ld.w	r11,r5[0x4]
80005018:	30 29       	mov	r9,2
8000501a:	30 0a       	mov	r10,0
8000501c:	2f 8b       	sub	r11,-8
8000501e:	4f 18       	lddpc	r8,800051e0 <can_out_callback_channel1+0x3a4>
80005020:	70 0c       	ld.w	r12,r8[0x0]
80005022:	f0 1f 00 67 	mcall	800051bc <can_out_callback_channel1+0x380>
		xQueueOverwriteFromISR(queue_trq_sens1_err, &mob_rx_trq_sens1.can_msg->data.u8[2], NULL);
80005026:	6a 1b       	ld.w	r11,r5[0x4]
80005028:	30 29       	mov	r9,2
8000502a:	30 0a       	mov	r10,0
8000502c:	2f 6b       	sub	r11,-10
8000502e:	4e e8       	lddpc	r8,800051e4 <can_out_callback_channel1+0x3a8>
80005030:	70 0c       	ld.w	r12,r8[0x0]
80005032:	f0 1f 00 63 	mcall	800051bc <can_out_callback_channel1+0x380>
		asm("nop");
80005036:	d7 03       	nop
		/* Empty message field */
		mob_rx_trq_sens1.can_msg->data.u64 = 0x0LL;
80005038:	6a 18       	ld.w	r8,r5[0x4]
8000503a:	30 0a       	mov	r10,0
8000503c:	30 0b       	mov	r11,0
8000503e:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_1, 
80005042:	6a 19       	ld.w	r9,r5[0x4]
80005044:	eb 3a 00 09 	ld.ub	r10,r5[9]
80005048:	0b 8b       	ld.ub	r11,r5[0x0]
8000504a:	30 1c       	mov	r12,1
8000504c:	f0 1f 00 5d 	mcall	800051c0 <can_out_callback_channel1+0x384>
80005050:	ca a8       	rjmp	800051a4 <can_out_callback_channel1+0x368>
		mob_rx_trq_sens1.handle,
		mob_rx_trq_sens1.req_type,
		mob_rx_trq_sens1.can_msg);
	
	} else if (handle == mob_rx_bms_precharge.handle) {
80005052:	4e 68       	lddpc	r8,800051e8 <can_out_callback_channel1+0x3ac>
80005054:	11 87       	ld.ub	r7,r8[0x0]
80005056:	f8 07 18 00 	cp.b	r7,r12
8000505a:	c3 31       	brne	800050c0 <can_out_callback_channel1+0x284>
		mob_rx_bms_precharge.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
8000505c:	4e 35       	lddpc	r5,800051e8 <can_out_callback_channel1+0x3ac>
8000505e:	6a 16       	ld.w	r6,r5[0x4]
80005060:	0e 9b       	mov	r11,r7
80005062:	30 1c       	mov	r12,1
80005064:	f0 1f 00 52 	mcall	800051ac <can_out_callback_channel1+0x370>
80005068:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_bms_precharge.can_msg->id		= can_get_mob_id(CAN_BUS_1, handle);
8000506c:	6a 16       	ld.w	r6,r5[0x4]
8000506e:	0e 9b       	mov	r11,r7
80005070:	30 1c       	mov	r12,1
80005072:	f0 1f 00 50 	mcall	800051b0 <can_out_callback_channel1+0x374>
80005076:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_bms_precharge.dlc				= can_get_mob_dlc(CAN_BUS_1, handle);
80005078:	0e 9b       	mov	r11,r7
8000507a:	30 1c       	mov	r12,1
8000507c:	f0 1f 00 4e 	mcall	800051b4 <can_out_callback_channel1+0x378>
80005080:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_bms_precharge.status				= event;
80005084:	eb 64 00 0a 	st.b	r5[10],r4
		
		bms_can_msg_t bms_can_msg;
		bms_can_msg.data.u64 = mob_rx_bms_precharge.can_msg->data.u64;
80005088:	6a 18       	ld.w	r8,r5[0x4]
8000508a:	f0 ea 00 08 	ld.d	r10,r8[8]
8000508e:	fa eb 00 0c 	st.d	sp[12],r10
		bms_can_msg.id = mob_rx_bms_precharge.can_msg->id;
80005092:	70 08       	ld.w	r8,r8[0x0]
80005094:	50 58       	stdsp	sp[0x14],r8
		xQueueSendToBackFromISR(queue_bms_rx, &bms_can_msg, NULL);
80005096:	30 09       	mov	r9,0
80005098:	12 9a       	mov	r10,r9
8000509a:	fa cb ff f4 	sub	r11,sp,-12
8000509e:	4d 48       	lddpc	r8,800051ec <can_out_callback_channel1+0x3b0>
800050a0:	70 0c       	ld.w	r12,r8[0x0]
800050a2:	f0 1f 00 47 	mcall	800051bc <can_out_callback_channel1+0x380>
		/* Empty message field */
		mob_rx_bms_precharge.can_msg->data.u64 = 0x0LL;
800050a6:	6a 18       	ld.w	r8,r5[0x4]
800050a8:	30 0a       	mov	r10,0
800050aa:	30 0b       	mov	r11,0
800050ac:	f0 eb 00 08 	st.d	r8[8],r10
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
800050b0:	6a 19       	ld.w	r9,r5[0x4]
800050b2:	eb 3a 00 09 	ld.ub	r10,r5[9]
800050b6:	0b 8b       	ld.ub	r11,r5[0x0]
800050b8:	30 1c       	mov	r12,1
800050ba:	f0 1f 00 42 	mcall	800051c0 <can_out_callback_channel1+0x384>
800050be:	c7 38       	rjmp	800051a4 <can_out_callback_channel1+0x368>
		mob_rx_bms_precharge.handle,
		mob_rx_bms_precharge.req_type,
		mob_rx_bms_precharge.can_msg);
		
	} else if (handle == mob_rx_bms_battvolt.handle) {
800050c0:	4c c8       	lddpc	r8,800051f0 <can_out_callback_channel1+0x3b4>
800050c2:	11 87       	ld.ub	r7,r8[0x0]
800050c4:	f8 07 18 00 	cp.b	r7,r12
800050c8:	c3 21       	brne	8000512c <can_out_callback_channel1+0x2f0>
		mob_rx_bms_battvolt.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
800050ca:	4c a5       	lddpc	r5,800051f0 <can_out_callback_channel1+0x3b4>
800050cc:	6a 16       	ld.w	r6,r5[0x4]
800050ce:	0e 9b       	mov	r11,r7
800050d0:	30 1c       	mov	r12,1
800050d2:	f0 1f 00 37 	mcall	800051ac <can_out_callback_channel1+0x370>
800050d6:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_bms_battvolt.can_msg->id			= can_get_mob_id(CAN_BUS_1, handle);
800050da:	6a 16       	ld.w	r6,r5[0x4]
800050dc:	0e 9b       	mov	r11,r7
800050de:	30 1c       	mov	r12,1
800050e0:	f0 1f 00 34 	mcall	800051b0 <can_out_callback_channel1+0x374>
800050e4:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_bms_battvolt.dlc					= can_get_mob_dlc(CAN_BUS_1, handle);
800050e6:	0e 9b       	mov	r11,r7
800050e8:	30 1c       	mov	r12,1
800050ea:	f0 1f 00 33 	mcall	800051b4 <can_out_callback_channel1+0x378>
800050ee:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_bms_battvolt.status				= event;
800050f2:	eb 64 00 0a 	st.b	r5[10],r4
		
		bms_can_msg_t bms_can_msg;
		bms_can_msg.data.u64 = mob_rx_bms_battvolt.can_msg->data.u64;
800050f6:	6a 18       	ld.w	r8,r5[0x4]
800050f8:	f0 ea 00 08 	ld.d	r10,r8[8]
800050fc:	fa eb 00 00 	st.d	sp[0],r10
		bms_can_msg.id = mob_rx_bms_battvolt.can_msg->id;
80005100:	70 08       	ld.w	r8,r8[0x0]
80005102:	50 28       	stdsp	sp[0x8],r8
		
		xQueueSendToBackFromISR(queue_bms_rx, &bms_can_msg, NULL);
80005104:	30 09       	mov	r9,0
80005106:	12 9a       	mov	r10,r9
80005108:	1a 9b       	mov	r11,sp
8000510a:	4b 98       	lddpc	r8,800051ec <can_out_callback_channel1+0x3b0>
8000510c:	70 0c       	ld.w	r12,r8[0x0]
8000510e:	f0 1f 00 2c 	mcall	800051bc <can_out_callback_channel1+0x380>
		/* Empty message field */
		mob_rx_bms_battvolt.can_msg->data.u64 = 0x0LL;
80005112:	6a 18       	ld.w	r8,r5[0x4]
80005114:	30 0a       	mov	r10,0
80005116:	30 0b       	mov	r11,0
80005118:	f0 eb 00 08 	st.d	r8[8],r10
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
8000511c:	6a 19       	ld.w	r9,r5[0x4]
8000511e:	eb 3a 00 09 	ld.ub	r10,r5[9]
80005122:	0b 8b       	ld.ub	r11,r5[0x0]
80005124:	30 1c       	mov	r12,1
80005126:	f0 1f 00 27 	mcall	800051c0 <can_out_callback_channel1+0x384>
8000512a:	c3 d8       	rjmp	800051a4 <can_out_callback_channel1+0x368>
		mob_rx_bms_battvolt.handle,
		mob_rx_bms_battvolt.req_type,
		mob_rx_bms_battvolt.can_msg);	
	} else if (handle == mob_brk.handle) {
8000512c:	4b 28       	lddpc	r8,800051f4 <can_out_callback_channel1+0x3b8>
8000512e:	11 87       	ld.ub	r7,r8[0x0]
80005130:	f8 07 18 00 	cp.b	r7,r12
80005134:	c3 81       	brne	800051a4 <can_out_callback_channel1+0x368>
		mob_brk.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80005136:	4b 05       	lddpc	r5,800051f4 <can_out_callback_channel1+0x3b8>
80005138:	6a 16       	ld.w	r6,r5[0x4]
8000513a:	0e 9b       	mov	r11,r7
8000513c:	30 1c       	mov	r12,1
8000513e:	f0 1f 00 1c 	mcall	800051ac <can_out_callback_channel1+0x370>
80005142:	ec eb 00 08 	st.d	r6[8],r10
		mob_brk.can_msg->id			= can_get_mob_id(CAN_BUS_1, handle);
80005146:	6a 16       	ld.w	r6,r5[0x4]
80005148:	0e 9b       	mov	r11,r7
8000514a:	30 1c       	mov	r12,1
8000514c:	f0 1f 00 19 	mcall	800051b0 <can_out_callback_channel1+0x374>
80005150:	8d 0c       	st.w	r6[0x0],r12
		mob_brk.dlc					= can_get_mob_dlc(CAN_BUS_1, handle);
80005152:	0e 9b       	mov	r11,r7
80005154:	30 1c       	mov	r12,1
80005156:	f0 1f 00 18 	mcall	800051b4 <can_out_callback_channel1+0x378>
8000515a:	eb 6c 00 08 	st.b	r5[8],r12
		mob_brk.status				= event;
8000515e:	eb 64 00 0a 	st.b	r5[10],r4
		
		if (mob_brk.can_msg->id == (CANR_FCN_DATA_ID | CANR_GRP_SENS_BRK_ID | CANR_MODULE_ID0_ID)) {
80005162:	6a 1b       	ld.w	r11,r5[0x4]
80005164:	76 08       	ld.w	r8,r11[0x0]
80005166:	e0 48 06 18 	cp.w	r8,1560
8000516a:	c0 91       	brne	8000517c <can_out_callback_channel1+0x340>
			xQueueSendToBackFromISR( queue_brake_front, &mob_brk.can_msg->data.u16[0], NULL );
8000516c:	30 09       	mov	r9,0
8000516e:	12 9a       	mov	r10,r9
80005170:	2f 8b       	sub	r11,-8
80005172:	4a 28       	lddpc	r8,800051f8 <can_out_callback_channel1+0x3bc>
80005174:	70 0c       	ld.w	r12,r8[0x0]
80005176:	f0 1f 00 12 	mcall	800051bc <can_out_callback_channel1+0x380>
8000517a:	c0 88       	rjmp	8000518a <can_out_callback_channel1+0x34e>
		} else {
			xQueueSendToBackFromISR( queue_brake_rear, &mob_brk.can_msg->data.u16[0], NULL );
8000517c:	30 09       	mov	r9,0
8000517e:	12 9a       	mov	r10,r9
80005180:	2f 8b       	sub	r11,-8
80005182:	49 f8       	lddpc	r8,800051fc <can_out_callback_channel1+0x3c0>
80005184:	70 0c       	ld.w	r12,r8[0x0]
80005186:	f0 1f 00 0e 	mcall	800051bc <can_out_callback_channel1+0x380>
		}
		/* Empty message field */
		mob_brk.can_msg->data.u64 = 0x0LL;
8000518a:	49 b8       	lddpc	r8,800051f4 <can_out_callback_channel1+0x3b8>
8000518c:	70 19       	ld.w	r9,r8[0x4]
8000518e:	30 0a       	mov	r10,0
80005190:	30 0b       	mov	r11,0
80005192:	f2 eb 00 08 	st.d	r9[8],r10
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
80005196:	70 19       	ld.w	r9,r8[0x4]
80005198:	f1 3a 00 09 	ld.ub	r10,r8[9]
8000519c:	11 8b       	ld.ub	r11,r8[0x0]
8000519e:	30 1c       	mov	r12,1
800051a0:	f0 1f 00 08 	mcall	800051c0 <can_out_callback_channel1+0x384>
		mob_brk.handle,
		mob_brk.req_type,
		mob_brk.can_msg);
	}
}
800051a4:	2f ad       	sub	sp,-24
800051a6:	d8 22       	popm	r4-r7,pc
800051a8:	00 00       	add	r0,r0
800051aa:	00 20       	rsub	r0,r0
800051ac:	80 00       	ld.sh	r0,r0[0x0]
800051ae:	4b b8       	lddpc	r8,80005298 <can_out_callback_channel0+0x98>
800051b0:	80 00       	ld.sh	r0,r0[0x0]
800051b2:	4b e8       	lddpc	r8,800052a8 <can_out_callback_channel0+0xa8>
800051b4:	80 00       	ld.sh	r0,r0[0x0]
800051b6:	4b d0       	lddpc	r0,800052a8 <can_out_callback_channel0+0xa8>
800051b8:	00 00       	add	r0,r0
800051ba:	cf 5c       	rcall	800053a4 <can_out_callback_channel0+0x1a4>
800051bc:	80 00       	ld.sh	r0,r0[0x0]
800051be:	2c ac       	sub	r12,-54
800051c0:	80 00       	ld.sh	r0,r0[0x0]
800051c2:	4a ae       	lddpc	lr,80005268 <can_out_callback_channel0+0x68>
800051c4:	00 00       	add	r0,r0
800051c6:	01 a0       	ld.ub	r0,r0[0x2]
800051c8:	00 00       	add	r0,r0
800051ca:	cf 54       	brge	800051b4 <can_out_callback_channel1+0x378>
800051cc:	00 00       	add	r0,r0
800051ce:	00 14       	sub	r4,r0
800051d0:	00 00       	add	r0,r0
800051d2:	cf 68       	rjmp	800053be <can_out_callback_channel0+0x1be>
800051d4:	00 00       	add	r0,r0
800051d6:	00 38       	cp.w	r8,r0
800051d8:	00 00       	add	r0,r0
800051da:	cf 50       	breq	800051c4 <can_out_callback_channel1+0x388>
800051dc:	00 00       	add	r0,r0
800051de:	01 b8       	ld.ub	r8,r0[0x3]
800051e0:	00 00       	add	r0,r0
800051e2:	cf 6c       	rcall	800053ce <can_out_callback_channel0+0x1ce>
800051e4:	00 00       	add	r0,r0
800051e6:	cf 58       	rjmp	800053d0 <can_out_callback_channel0+0x1d0>
800051e8:	00 00       	add	r0,r0
800051ea:	00 ac       	st.w	r0++,r12
800051ec:	00 00       	add	r0,r0
800051ee:	cf 38       	rjmp	800053d4 <can_out_callback_channel0+0x1d4>
800051f0:	00 00       	add	r0,r0
800051f2:	01 34       	ld.ub	r4,r0++
800051f4:	00 00       	add	r0,r0
800051f6:	01 58       	ld.sh	r8,--r0
800051f8:	00 00       	add	r0,r0
800051fa:	cf 74       	brge	800051e8 <can_out_callback_channel1+0x3ac>
800051fc:	00 00       	add	r0,r0
800051fe:	cf 4c       	rcall	800053e6 <can_out_callback_channel0+0x1e6>

80005200 <can_out_callback_channel0>:
		, mob_rx_bspd.can_msg
	);
	asm("nop");
}

void can_out_callback_channel0(U8 handle, U8 event){
80005200:	d4 21       	pushm	r4-r7,lr
80005202:	20 6d       	sub	sp,24
80005204:	16 94       	mov	r4,r11
	if (handle == mob_rx_dash_pri.handle) {
80005206:	4e d8       	lddpc	r8,800053b8 <can_out_callback_channel0+0x1b8>
80005208:	11 87       	ld.ub	r7,r8[0x0]
8000520a:	f8 07 18 00 	cp.b	r7,r12
8000520e:	c3 41       	brne	80005276 <can_out_callback_channel0+0x76>
		mob_rx_dash_pri.can_msg->data.u64	= can_get_mob_data(CAN_BUS_0, handle).u64;
80005210:	4e a5       	lddpc	r5,800053b8 <can_out_callback_channel0+0x1b8>
80005212:	6a 16       	ld.w	r6,r5[0x4]
80005214:	0e 9b       	mov	r11,r7
80005216:	30 0c       	mov	r12,0
80005218:	f0 1f 00 69 	mcall	800053bc <can_out_callback_channel0+0x1bc>
8000521c:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_dash_pri.can_msg->id			= can_get_mob_id(CAN_BUS_0, handle);
80005220:	6a 16       	ld.w	r6,r5[0x4]
80005222:	0e 9b       	mov	r11,r7
80005224:	30 0c       	mov	r12,0
80005226:	f0 1f 00 67 	mcall	800053c0 <can_out_callback_channel0+0x1c0>
8000522a:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_dash_pri.dlc					= can_get_mob_dlc(CAN_BUS_0, handle);
8000522c:	0e 9b       	mov	r11,r7
8000522e:	30 0c       	mov	r12,0
80005230:	f0 1f 00 65 	mcall	800053c4 <can_out_callback_channel0+0x1c4>
80005234:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_dash_pri.status				= event;
80005238:	eb 64 00 0a 	st.b	r5[10],r4
		
		dash_can_msg_t dash_can_msg;
		
		dash_can_msg.data.u64 = mob_rx_dash_pri.can_msg->data.u64;
8000523c:	6a 18       	ld.w	r8,r5[0x4]
8000523e:	f0 ea 00 08 	ld.d	r10,r8[8]
80005242:	fa eb 00 0c 	st.d	sp[12],r10
		dash_can_msg.id = mob_rx_dash_pri.can_msg->id;
80005246:	70 08       	ld.w	r8,r8[0x0]
80005248:	fb 58 00 14 	st.h	sp[20],r8
		xQueueSendToBackFromISR(queue_dash_msg, &dash_can_msg, NULL);
8000524c:	30 09       	mov	r9,0
8000524e:	12 9a       	mov	r10,r9
80005250:	fa cb ff f4 	sub	r11,sp,-12
80005254:	4d d8       	lddpc	r8,800053c8 <can_out_callback_channel0+0x1c8>
80005256:	70 0c       	ld.w	r12,r8[0x0]
80005258:	f0 1f 00 5d 	mcall	800053cc <can_out_callback_channel0+0x1cc>
		/* Empty message field */
		mob_rx_dash_pri.can_msg->data.u64 = 0x0LL;
8000525c:	6a 18       	ld.w	r8,r5[0x4]
8000525e:	30 0a       	mov	r10,0
80005260:	30 0b       	mov	r11,0
80005262:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_0,
80005266:	6a 19       	ld.w	r9,r5[0x4]
80005268:	eb 3a 00 09 	ld.ub	r10,r5[9]
8000526c:	0b 8b       	ld.ub	r11,r5[0x0]
8000526e:	30 0c       	mov	r12,0
80005270:	f0 1f 00 58 	mcall	800053d0 <can_out_callback_channel0+0x1d0>
80005274:	c9 f8       	rjmp	800053b2 <can_out_callback_channel0+0x1b2>
		mob_rx_dash_pri.handle,
		mob_rx_dash_pri.req_type,
		mob_rx_dash_pri.can_msg);
		
	} else if (handle == mob_rx_dash_data.handle) {
80005276:	4d 88       	lddpc	r8,800053d4 <can_out_callback_channel0+0x1d4>
80005278:	11 87       	ld.ub	r7,r8[0x0]
8000527a:	f8 07 18 00 	cp.b	r7,r12
8000527e:	c3 21       	brne	800052e2 <can_out_callback_channel0+0xe2>
		mob_rx_dash_data.can_msg->data.u64	= can_get_mob_data(CAN_BUS_0, handle).u64;
80005280:	4d 55       	lddpc	r5,800053d4 <can_out_callback_channel0+0x1d4>
80005282:	6a 16       	ld.w	r6,r5[0x4]
80005284:	0e 9b       	mov	r11,r7
80005286:	30 0c       	mov	r12,0
80005288:	f0 1f 00 4d 	mcall	800053bc <can_out_callback_channel0+0x1bc>
8000528c:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_dash_data.can_msg->id			= can_get_mob_id(CAN_BUS_0, handle);
80005290:	6a 16       	ld.w	r6,r5[0x4]
80005292:	0e 9b       	mov	r11,r7
80005294:	30 0c       	mov	r12,0
80005296:	f0 1f 00 4b 	mcall	800053c0 <can_out_callback_channel0+0x1c0>
8000529a:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_dash_data.dlc					= can_get_mob_dlc(CAN_BUS_0, handle);
8000529c:	0e 9b       	mov	r11,r7
8000529e:	30 0c       	mov	r12,0
800052a0:	f0 1f 00 49 	mcall	800053c4 <can_out_callback_channel0+0x1c4>
800052a4:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_dash_data.status				= event;
800052a8:	eb 64 00 0a 	st.b	r5[10],r4
		
		dash_can_msg_t dash_can_msg;
		
		dash_can_msg.data.u64 = mob_rx_dash_data.can_msg->data.u64;
800052ac:	6a 18       	ld.w	r8,r5[0x4]
800052ae:	f0 ea 00 08 	ld.d	r10,r8[8]
800052b2:	fa eb 00 00 	st.d	sp[0],r10
		dash_can_msg.id = mob_rx_dash_data.can_msg->id;
800052b6:	70 08       	ld.w	r8,r8[0x0]
800052b8:	ba 48       	st.h	sp[0x8],r8
		xQueueSendToBackFromISR(queue_dash_msg, &dash_can_msg, NULL);
800052ba:	30 09       	mov	r9,0
800052bc:	12 9a       	mov	r10,r9
800052be:	1a 9b       	mov	r11,sp
800052c0:	4c 28       	lddpc	r8,800053c8 <can_out_callback_channel0+0x1c8>
800052c2:	70 0c       	ld.w	r12,r8[0x0]
800052c4:	f0 1f 00 42 	mcall	800053cc <can_out_callback_channel0+0x1cc>
		/* Empty message field */
		mob_rx_dash_data.can_msg->data.u64 = 0x0LL;
800052c8:	6a 18       	ld.w	r8,r5[0x4]
800052ca:	30 0a       	mov	r10,0
800052cc:	30 0b       	mov	r11,0
800052ce:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_0, 
800052d2:	6a 19       	ld.w	r9,r5[0x4]
800052d4:	eb 3a 00 09 	ld.ub	r10,r5[9]
800052d8:	0b 8b       	ld.ub	r11,r5[0x0]
800052da:	30 0c       	mov	r12,0
800052dc:	f0 1f 00 3d 	mcall	800053d0 <can_out_callback_channel0+0x1d0>
800052e0:	c6 98       	rjmp	800053b2 <can_out_callback_channel0+0x1b2>
		mob_rx_dash_data.handle,
		mob_rx_dash_data.req_type,
		mob_rx_dash_data.can_msg);
		
	} else if (handle == mob_rx_trq_sens0.handle) {
800052e2:	4b e8       	lddpc	r8,800053d8 <can_out_callback_channel0+0x1d8>
800052e4:	11 87       	ld.ub	r7,r8[0x0]
800052e6:	f8 07 18 00 	cp.b	r7,r12
800052ea:	c3 51       	brne	80005354 <can_out_callback_channel0+0x154>
		mob_rx_trq_sens0.can_msg->data.u64	= can_get_mob_data(CAN_BUS_0, handle).u64;
800052ec:	4b b5       	lddpc	r5,800053d8 <can_out_callback_channel0+0x1d8>
800052ee:	6a 16       	ld.w	r6,r5[0x4]
800052f0:	0e 9b       	mov	r11,r7
800052f2:	30 0c       	mov	r12,0
800052f4:	f0 1f 00 32 	mcall	800053bc <can_out_callback_channel0+0x1bc>
800052f8:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_trq_sens0.can_msg->id		= can_get_mob_id(CAN_BUS_0, handle);
800052fc:	6a 16       	ld.w	r6,r5[0x4]
800052fe:	0e 9b       	mov	r11,r7
80005300:	30 0c       	mov	r12,0
80005302:	f0 1f 00 30 	mcall	800053c0 <can_out_callback_channel0+0x1c0>
80005306:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_trq_sens0.dlc				= can_get_mob_dlc(CAN_BUS_0, handle);
80005308:	0e 9b       	mov	r11,r7
8000530a:	30 0c       	mov	r12,0
8000530c:	f0 1f 00 2e 	mcall	800053c4 <can_out_callback_channel0+0x1c4>
80005310:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_trq_sens0.status				= event;
80005314:	eb 64 00 0a 	st.b	r5[10],r4
	
		xQueueOverwriteFromISR(queue_trq_sens0, &mob_rx_trq_sens0.can_msg->data.s16[0], NULL);
80005318:	6a 1b       	ld.w	r11,r5[0x4]
8000531a:	30 29       	mov	r9,2
8000531c:	30 0a       	mov	r10,0
8000531e:	2f 8b       	sub	r11,-8
80005320:	4a f8       	lddpc	r8,800053dc <can_out_callback_channel0+0x1dc>
80005322:	70 0c       	ld.w	r12,r8[0x0]
80005324:	f0 1f 00 2a 	mcall	800053cc <can_out_callback_channel0+0x1cc>
		xQueueOverwriteFromISR(queue_trq_sens0_err, &mob_rx_trq_sens0.can_msg->data.u8[2], NULL);
80005328:	6a 1b       	ld.w	r11,r5[0x4]
8000532a:	30 29       	mov	r9,2
8000532c:	30 0a       	mov	r10,0
8000532e:	2f 6b       	sub	r11,-10
80005330:	4a c8       	lddpc	r8,800053e0 <can_out_callback_channel0+0x1e0>
80005332:	70 0c       	ld.w	r12,r8[0x0]
80005334:	f0 1f 00 26 	mcall	800053cc <can_out_callback_channel0+0x1cc>
		asm("nop");
80005338:	d7 03       	nop
		/* Empty message field */
		mob_rx_trq_sens0.can_msg->data.u64 = 0x0LL;
8000533a:	6a 18       	ld.w	r8,r5[0x4]
8000533c:	30 0a       	mov	r10,0
8000533e:	30 0b       	mov	r11,0
80005340:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_0, 
80005344:	6a 19       	ld.w	r9,r5[0x4]
80005346:	eb 3a 00 09 	ld.ub	r10,r5[9]
8000534a:	0b 8b       	ld.ub	r11,r5[0x0]
8000534c:	30 0c       	mov	r12,0
8000534e:	f0 1f 00 21 	mcall	800053d0 <can_out_callback_channel0+0x1d0>
80005352:	c3 08       	rjmp	800053b2 <can_out_callback_channel0+0x1b2>
		mob_rx_trq_sens0.handle,
		mob_rx_trq_sens0.req_type,
		mob_rx_trq_sens0.can_msg);
		
	}	else if (handle == mob_rx_bspd.handle) {
80005354:	4a 48       	lddpc	r8,800053e4 <can_out_callback_channel0+0x1e4>
80005356:	11 87       	ld.ub	r7,r8[0x0]
80005358:	f8 07 18 00 	cp.b	r7,r12
8000535c:	c2 b1       	brne	800053b2 <can_out_callback_channel0+0x1b2>
		mob_rx_bspd.can_msg->data.u64	= can_get_mob_data(CAN_BUS_0, handle).u64;
8000535e:	4a 25       	lddpc	r5,800053e4 <can_out_callback_channel0+0x1e4>
80005360:	6a 16       	ld.w	r6,r5[0x4]
80005362:	0e 9b       	mov	r11,r7
80005364:	30 0c       	mov	r12,0
80005366:	f0 1f 00 16 	mcall	800053bc <can_out_callback_channel0+0x1bc>
8000536a:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_bspd.can_msg->id			= can_get_mob_id(CAN_BUS_0, handle);
8000536e:	6a 16       	ld.w	r6,r5[0x4]
80005370:	0e 9b       	mov	r11,r7
80005372:	30 0c       	mov	r12,0
80005374:	f0 1f 00 13 	mcall	800053c0 <can_out_callback_channel0+0x1c0>
80005378:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_bspd.dlc					= can_get_mob_dlc(CAN_BUS_0, handle);
8000537a:	0e 9b       	mov	r11,r7
8000537c:	30 0c       	mov	r12,0
8000537e:	f0 1f 00 12 	mcall	800053c4 <can_out_callback_channel0+0x1c4>
80005382:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_bspd.status				= event;
80005386:	eb 64 00 0a 	st.b	r5[10],r4
		
		xQueueOverwriteFromISR( queue_bspd, &mob_rx_bspd.can_msg->data.u8[0], NULL );
8000538a:	6a 1b       	ld.w	r11,r5[0x4]
8000538c:	30 29       	mov	r9,2
8000538e:	30 0a       	mov	r10,0
80005390:	2f 8b       	sub	r11,-8
80005392:	49 68       	lddpc	r8,800053e8 <can_out_callback_channel0+0x1e8>
80005394:	70 0c       	ld.w	r12,r8[0x0]
80005396:	f0 1f 00 0e 	mcall	800053cc <can_out_callback_channel0+0x1cc>
		/* Empty message field */
		mob_rx_bspd.can_msg->data.u64 = 0x0LL;
8000539a:	6a 18       	ld.w	r8,r5[0x4]
8000539c:	30 0a       	mov	r10,0
8000539e:	30 0b       	mov	r11,0
800053a0:	f0 eb 00 08 	st.d	r8[8],r10
		/* Prepare message reception */
		can_rx(CAN_BUS_0,
800053a4:	6a 19       	ld.w	r9,r5[0x4]
800053a6:	eb 3a 00 09 	ld.ub	r10,r5[9]
800053aa:	0b 8b       	ld.ub	r11,r5[0x0]
800053ac:	30 0c       	mov	r12,0
800053ae:	f0 1f 00 09 	mcall	800053d0 <can_out_callback_channel0+0x1d0>
		mob_rx_bspd.handle,
		mob_rx_bspd.req_type,
		mob_rx_bspd.can_msg);
	} 
}
800053b2:	2f ad       	sub	sp,-24
800053b4:	d8 22       	popm	r4-r7,pc
800053b6:	00 00       	add	r0,r0
800053b8:	00 00       	add	r0,r0
800053ba:	01 4c       	ld.w	r12,--r0
800053bc:	80 00       	ld.sh	r0,r0[0x0]
800053be:	4b b8       	lddpc	r8,800054a8 <ecu_can_init+0xbc>
800053c0:	80 00       	ld.sh	r0,r0[0x0]
800053c2:	4b e8       	lddpc	r8,800054b8 <ecu_can_init+0xcc>
800053c4:	80 00       	ld.sh	r0,r0[0x0]
800053c6:	4b d0       	lddpc	r0,800054b8 <ecu_can_init+0xcc>
800053c8:	00 00       	add	r0,r0
800053ca:	cf 60       	breq	800053b6 <can_out_callback_channel0+0x1b6>
800053cc:	80 00       	ld.sh	r0,r0[0x0]
800053ce:	2c ac       	sub	r12,-54
800053d0:	80 00       	ld.sh	r0,r0[0x0]
800053d2:	4a ae       	lddpc	lr,80005478 <ecu_can_init+0x8c>
800053d4:	00 00       	add	r0,r0
800053d6:	01 84       	ld.ub	r4,r0[0x0]
800053d8:	00 00       	add	r0,r0
800053da:	01 ac       	ld.ub	r12,r0[0x2]
800053dc:	00 00       	add	r0,r0
800053de:	cf 44       	brge	800053c6 <can_out_callback_channel0+0x1c6>
800053e0:	00 00       	add	r0,r0
800053e2:	cf 70       	breq	800053d0 <can_out_callback_channel0+0x1d0>
800053e4:	00 00       	add	r0,r0
800053e6:	00 2c       	rsub	r12,r0
800053e8:	00 00       	add	r0,r0
800053ea:	cf 64       	brge	800053d6 <can_out_callback_channel0+0x1d6>

800053ec <ecu_can_init>:
/* Allocate CAN mobs */
volatile can_msg_t mob_ram_ch0[NB_MOB_CHANNEL] __attribute__ ((section (".hsb_ram_loc")));
volatile can_msg_t mob_ram_ch1[NB_MOB_CHANNEL] __attribute__ ((section (".hsb_ram_loc")));


void ecu_can_init(void) {
800053ec:	d4 31       	pushm	r0-r7,lr
	/* Setup the generic clock for CAN output */
	scif_gc_setup(
800053ee:	30 09       	mov	r9,0
800053f0:	12 9a       	mov	r10,r9
800053f2:	30 3b       	mov	r11,3
800053f4:	30 1c       	mov	r12,1
800053f6:	f0 1f 00 53 	mcall	80005540 <ecu_can_init+0x154>
		SCIF_GCCTRL_OSC0,
		AVR32_SCIF_GC_NO_DIV_CLOCK,
		0
	);
	/* Now enable the generic clock input for the CAN module */
	scif_gc_enable(AVR32_SCIF_GCLK_CANIF);
800053fa:	30 1c       	mov	r12,1
800053fc:	f0 1f 00 52 	mcall	80005544 <ecu_can_init+0x158>
		{CAN1_RX_PIN, CAN1_RX_FUNCTION},
		{CAN1_TX_PIN, CAN1_TX_FUNCTION}
	};
	
	/* Assign GPIO to CAN. */
	gpio_enable_module(CAN_GPIO_MAP, sizeof(CAN_GPIO_MAP) / sizeof(CAN_GPIO_MAP[0]));
80005400:	30 4b       	mov	r11,4
80005402:	4d 2c       	lddpc	r12,80005548 <ecu_can_init+0x15c>
80005404:	f0 1f 00 52 	mcall	8000554c <ecu_can_init+0x160>
	

	/* Initialize interrupt vectors. */
	INTC_init_interrupts();
80005408:	f0 1f 00 52 	mcall	80005550 <ecu_can_init+0x164>
	
	/* Allocate channel message box */
	mob_rx_speed_sens_fl.handle	= 0;
8000540c:	4d 27       	lddpc	r7,80005554 <ecu_can_init+0x168>
8000540e:	30 08       	mov	r8,0
80005410:	ae 88       	st.b	r7[0x0],r8
	mob_rx_speed_sens_fr.handle	= 1;
80005412:	4d 25       	lddpc	r5,80005558 <ecu_can_init+0x16c>
80005414:	30 18       	mov	r8,1
80005416:	aa 88       	st.b	r5[0x0],r8
	mob_rx_speed_sens_rl.handle	= 2;
80005418:	4d 14       	lddpc	r4,8000555c <ecu_can_init+0x170>
8000541a:	30 28       	mov	r8,2
8000541c:	a8 88       	st.b	r4[0x0],r8
	mob_rx_speed_sens_rr.handle	= 3;
8000541e:	4d 13       	lddpc	r3,80005560 <ecu_can_init+0x174>
80005420:	30 38       	mov	r8,3
80005422:	a6 88       	st.b	r3[0x0],r8
	mob_rx_dash_pri.handle		= 4;
80005424:	4d 02       	lddpc	r2,80005564 <ecu_can_init+0x178>
80005426:	30 48       	mov	r8,4
80005428:	a4 88       	st.b	r2[0x0],r8
	mob_tx_dash.handle			= 5;
8000542a:	30 59       	mov	r9,5
8000542c:	4c f8       	lddpc	r8,80005568 <ecu_can_init+0x17c>
8000542e:	b0 89       	st.b	r8[0x0],r9
	mob_rx_trq_sens0.handle		= 6;
80005430:	4c f0       	lddpc	r0,8000556c <ecu_can_init+0x180>
80005432:	30 68       	mov	r8,6
80005434:	a0 88       	st.b	r0[0x0],r8
	mob_rx_trq_sens1.handle     = 7;
80005436:	30 78       	mov	r8,7
80005438:	4c e9       	lddpc	r9,80005570 <ecu_can_init+0x184>
8000543a:	b2 88       	st.b	r9[0x0],r8
	mob_ecu_slow_data.handle	= 8;
8000543c:	30 89       	mov	r9,8
8000543e:	4c e8       	lddpc	r8,80005574 <ecu_can_init+0x188>
80005440:	b0 89       	st.b	r8[0x0],r9
	mob_rx_bms_precharge.handle	= 9;
80005442:	30 98       	mov	r8,9
80005444:	4c d9       	lddpc	r9,80005578 <ecu_can_init+0x18c>
80005446:	b2 88       	st.b	r9[0x0],r8
	mob_brk.handle				= 10;
80005448:	30 a8       	mov	r8,10
8000544a:	4c d9       	lddpc	r9,8000557c <ecu_can_init+0x190>
8000544c:	b2 88       	st.b	r9[0x0],r8
	mob_ecu_fast_data.handle	= 11;
8000544e:	30 b9       	mov	r9,11
80005450:	4c c8       	lddpc	r8,80005580 <ecu_can_init+0x194>
80005452:	b0 89       	st.b	r8[0x0],r9
	mob_rx_bms_battvolt.handle  = 12;
80005454:	30 c8       	mov	r8,12
80005456:	4c c9       	lddpc	r9,80005584 <ecu_can_init+0x198>
80005458:	b2 88       	st.b	r9[0x0],r8
	mob_rx_bspd.handle			= 13;
8000545a:	30 d8       	mov	r8,13
8000545c:	4c b9       	lddpc	r9,80005588 <ecu_can_init+0x19c>
8000545e:	b2 88       	st.b	r9[0x0],r8
	mob_rx_dash_data.handle		= 14;
80005460:	4c b1       	lddpc	r1,8000558c <ecu_can_init+0x1a0>
80005462:	30 e8       	mov	r8,14
80005464:	a2 88       	st.b	r1[0x0],r8
	mob_slip_current.handle     = 15;
80005466:	30 f9       	mov	r9,15
80005468:	4c a8       	lddpc	r8,80005590 <ecu_can_init+0x1a4>
8000546a:	b0 89       	st.b	r8[0x0],r9


	/* Initialize CAN channels */
	can_init(CAN_BUS_0, ((uint32_t)&mob_ram_ch0[0]), CANIF_CHANNEL_MODE_NORMAL,	can_out_callback_channel0);
8000546c:	4c a6       	lddpc	r6,80005594 <ecu_can_init+0x1a8>
8000546e:	4c b9       	lddpc	r9,80005598 <ecu_can_init+0x1ac>
80005470:	30 0a       	mov	r10,0
80005472:	0c 9b       	mov	r11,r6
80005474:	14 9c       	mov	r12,r10
80005476:	f0 1f 00 4a 	mcall	8000559c <ecu_can_init+0x1b0>
	can_init(CAN_BUS_1, ((uint32_t)&mob_ram_ch1[0]), CANIF_CHANNEL_MODE_NORMAL,	can_out_callback_channel1);
8000547a:	4c a9       	lddpc	r9,800055a0 <ecu_can_init+0x1b4>
8000547c:	30 0a       	mov	r10,0
8000547e:	ec cb ff 00 	sub	r11,r6,-256
80005482:	30 1c       	mov	r12,1
80005484:	f0 1f 00 46 	mcall	8000559c <ecu_can_init+0x1b0>
	
	
	/* Prepare for message reception */	
	can_rx(
80005488:	6e 19       	ld.w	r9,r7[0x4]
8000548a:	ef 3a 00 09 	ld.ub	r10,r7[9]
8000548e:	0f 8b       	ld.ub	r11,r7[0x0]
80005490:	30 1c       	mov	r12,1
80005492:	f0 1f 00 45 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_rx_speed_sens_fl.handle
		, mob_rx_speed_sens_fl.req_type
		, mob_rx_speed_sens_fl.can_msg
	);
	
	can_rx(
80005496:	6a 19       	ld.w	r9,r5[0x4]
80005498:	eb 3a 00 09 	ld.ub	r10,r5[9]
8000549c:	0b 8b       	ld.ub	r11,r5[0x0]
8000549e:	30 1c       	mov	r12,1
800054a0:	f0 1f 00 41 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_rx_speed_sens_fr.req_type
		, mob_rx_speed_sens_fr.can_msg
	);
	
	
	can_rx(
800054a4:	68 19       	ld.w	r9,r4[0x4]
800054a6:	e9 3a 00 09 	ld.ub	r10,r4[9]
800054aa:	09 8b       	ld.ub	r11,r4[0x0]
800054ac:	30 1c       	mov	r12,1
800054ae:	f0 1f 00 3e 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_rx_speed_sens_rl.handle
		, mob_rx_speed_sens_rl.req_type
		, mob_rx_speed_sens_rl.can_msg
	);
	
	can_rx(
800054b2:	66 19       	ld.w	r9,r3[0x4]
800054b4:	e7 3a 00 09 	ld.ub	r10,r3[9]
800054b8:	07 8b       	ld.ub	r11,r3[0x0]
800054ba:	30 1c       	mov	r12,1
800054bc:	f0 1f 00 3a 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_rx_speed_sens_rr.handle
		, mob_rx_speed_sens_rr.req_type
		, mob_rx_speed_sens_rr.can_msg
	);
	
	can_rx(
800054c0:	64 19       	ld.w	r9,r2[0x4]
800054c2:	e5 3a 00 09 	ld.ub	r10,r2[9]
800054c6:	05 8b       	ld.ub	r11,r2[0x0]
800054c8:	30 0c       	mov	r12,0
800054ca:	f0 1f 00 37 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_rx_dash_pri.handle
		, mob_rx_dash_pri.req_type
		, mob_rx_dash_pri.can_msg
	);
	
	can_rx(
800054ce:	62 19       	ld.w	r9,r1[0x4]
800054d0:	e3 3a 00 09 	ld.ub	r10,r1[9]
800054d4:	03 8b       	ld.ub	r11,r1[0x0]
800054d6:	30 0c       	mov	r12,0
800054d8:	f0 1f 00 33 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_rx_dash_data.handle
		, mob_rx_dash_data.req_type
		, mob_rx_dash_data.can_msg
	);
	
	can_rx(
800054dc:	60 19       	ld.w	r9,r0[0x4]
800054de:	e1 3a 00 09 	ld.ub	r10,r0[9]
800054e2:	01 8b       	ld.ub	r11,r0[0x0]
800054e4:	30 0c       	mov	r12,0
800054e6:	f0 1f 00 30 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_rx_trq_sens0.handle
		, mob_rx_trq_sens0.req_type
		, mob_rx_trq_sens0.can_msg
	);

	can_rx(
800054ea:	4a 28       	lddpc	r8,80005570 <ecu_can_init+0x184>
800054ec:	70 19       	ld.w	r9,r8[0x4]
800054ee:	f1 3a 00 09 	ld.ub	r10,r8[9]
800054f2:	11 8b       	ld.ub	r11,r8[0x0]
800054f4:	30 1c       	mov	r12,1
800054f6:	f0 1f 00 2c 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_rx_trq_sens1.req_type
		, mob_rx_trq_sens1.can_msg
	);

	
	can_rx(
800054fa:	4a 08       	lddpc	r8,80005578 <ecu_can_init+0x18c>
800054fc:	70 19       	ld.w	r9,r8[0x4]
800054fe:	f1 3a 00 09 	ld.ub	r10,r8[9]
80005502:	11 8b       	ld.ub	r11,r8[0x0]
80005504:	30 1c       	mov	r12,1
80005506:	f0 1f 00 28 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_rx_bms_precharge.handle
		, mob_rx_bms_precharge.req_type
		, mob_rx_bms_precharge.can_msg
	);
	
	can_rx(
8000550a:	49 f8       	lddpc	r8,80005584 <ecu_can_init+0x198>
8000550c:	70 19       	ld.w	r9,r8[0x4]
8000550e:	f1 3a 00 09 	ld.ub	r10,r8[9]
80005512:	11 8b       	ld.ub	r11,r8[0x0]
80005514:	30 1c       	mov	r12,1
80005516:	f0 1f 00 24 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_rx_bms_battvolt.handle
		, mob_rx_bms_battvolt.req_type
		, mob_rx_bms_battvolt.can_msg
	);
	
	can_rx(
8000551a:	49 98       	lddpc	r8,8000557c <ecu_can_init+0x190>
8000551c:	70 19       	ld.w	r9,r8[0x4]
8000551e:	f1 3a 00 09 	ld.ub	r10,r8[9]
80005522:	11 8b       	ld.ub	r11,r8[0x0]
80005524:	30 1c       	mov	r12,1
80005526:	f0 1f 00 20 	mcall	800055a4 <ecu_can_init+0x1b8>
		, mob_brk.handle
		, mob_brk.req_type
		, mob_brk.can_msg
	);
	
	can_rx(
8000552a:	49 88       	lddpc	r8,80005588 <ecu_can_init+0x19c>
8000552c:	70 19       	ld.w	r9,r8[0x4]
8000552e:	f1 3a 00 09 	ld.ub	r10,r8[9]
80005532:	11 8b       	ld.ub	r11,r8[0x0]
80005534:	30 0c       	mov	r12,0
80005536:	f0 1f 00 1c 	mcall	800055a4 <ecu_can_init+0x1b8>
		CAN_BUS_0
		, mob_rx_bspd.handle
		, mob_rx_bspd.req_type
		, mob_rx_bspd.can_msg
	);
	asm("nop");
8000553a:	d7 03       	nop
}
8000553c:	d8 32       	popm	r0-r7,pc
8000553e:	00 00       	add	r0,r0
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	47 0c       	lddsp	r12,sp[0x1c0]
80005544:	80 00       	ld.sh	r0,r0[0x0]
80005546:	47 90       	lddsp	r0,sp[0x1e4]
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	7c 50       	ld.w	r0,lr[0x14]
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	66 b4       	ld.w	r4,r3[0x2c]
80005550:	80 00       	ld.sh	r0,r0[0x0]
80005552:	68 f0       	ld.w	r0,r4[0x3c]
80005554:	00 00       	add	r0,r0
80005556:	00 20       	rsub	r0,r0
80005558:	00 00       	add	r0,r0
8000555a:	01 a0       	ld.ub	r0,r0[0x2]
8000555c:	00 00       	add	r0,r0
8000555e:	00 14       	sub	r4,r0
80005560:	00 00       	add	r0,r0
80005562:	00 38       	cp.w	r8,r0
80005564:	00 00       	add	r0,r0
80005566:	01 4c       	ld.w	r12,--r0
80005568:	00 00       	add	r0,r0
8000556a:	00 a0       	st.w	r0++,r0
8000556c:	00 00       	add	r0,r0
8000556e:	01 ac       	ld.ub	r12,r0[0x2]
80005570:	00 00       	add	r0,r0
80005572:	01 b8       	ld.ub	r8,r0[0x3]
80005574:	00 00       	add	r0,r0
80005576:	01 40       	ld.w	r0,--r0
80005578:	00 00       	add	r0,r0
8000557a:	00 ac       	st.w	r0++,r12
8000557c:	00 00       	add	r0,r0
8000557e:	01 58       	ld.sh	r8,--r0
80005580:	00 00       	add	r0,r0
80005582:	00 64       	and	r4,r0
80005584:	00 00       	add	r0,r0
80005586:	01 34       	ld.ub	r4,r0++
80005588:	00 00       	add	r0,r0
8000558a:	00 2c       	rsub	r12,r0
8000558c:	00 00       	add	r0,r0
8000558e:	01 84       	ld.ub	r4,r0[0x0]
80005590:	00 00       	add	r0,r0
80005592:	00 e8       	st.h	--r0,r8
80005594:	00 00       	add	r0,r0
80005596:	01 ec       	ld.ub	r12,r0[0x6]
80005598:	80 00       	ld.sh	r0,r0[0x0]
8000559a:	52 00       	stdsp	sp[0x80],r0
8000559c:	80 00       	ld.sh	r0,r0[0x0]
8000559e:	4c e0       	lddpc	r0,800056d4 <vPortEnterCritical+0x8>
800055a0:	80 00       	ld.sh	r0,r0[0x0]
800055a2:	4e 3c       	lddpc	r12,8000572c <xPortStartScheduler+0x50>
800055a4:	80 00       	ld.sh	r0,r0[0x0]
800055a6:	4a ae       	lddpc	lr,8000564c <pxPortInitialiseStack+0x14>

800055a8 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
800055a8:	f8 c8 ff f8 	sub	r8,r12,-8
800055ac:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
800055ae:	3f f9       	mov	r9,-1
800055b0:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
800055b2:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
800055b4:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
800055b6:	30 08       	mov	r8,0
800055b8:	99 08       	st.w	r12[0x0],r8
}
800055ba:	5e fc       	retal	r12

800055bc <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
800055bc:	30 08       	mov	r8,0
800055be:	99 48       	st.w	r12[0x10],r8
}
800055c0:	5e fc       	retal	r12

800055c2 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
800055c2:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
800055c4:	70 19       	ld.w	r9,r8[0x4]
800055c6:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
800055c8:	78 19       	ld.w	r9,r12[0x4]
800055ca:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
800055cc:	70 19       	ld.w	r9,r8[0x4]
800055ce:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
800055d0:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
800055d2:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
800055d4:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
800055d6:	78 08       	ld.w	r8,r12[0x0]
800055d8:	2f f8       	sub	r8,-1
800055da:	99 08       	st.w	r12[0x0],r8
}
800055dc:	5e fc       	retal	r12

800055de <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
800055de:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
800055e0:	5b fa       	cp.w	r10,-1
800055e2:	c0 31       	brne	800055e8 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
800055e4:	78 48       	ld.w	r8,r12[0x10]
800055e6:	c0 c8       	rjmp	800055fe <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
800055e8:	f8 c8 ff f8 	sub	r8,r12,-8
800055ec:	70 19       	ld.w	r9,r8[0x4]
800055ee:	72 09       	ld.w	r9,r9[0x0]
800055f0:	12 3a       	cp.w	r10,r9
800055f2:	c0 63       	brcs	800055fe <vListInsert+0x20>
800055f4:	70 18       	ld.w	r8,r8[0x4]
800055f6:	70 19       	ld.w	r9,r8[0x4]
800055f8:	72 09       	ld.w	r9,r9[0x0]
800055fa:	12 3a       	cp.w	r10,r9
800055fc:	cf c2       	brcc	800055f4 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
800055fe:	70 19       	ld.w	r9,r8[0x4]
80005600:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005602:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005604:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005606:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005608:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
8000560a:	78 08       	ld.w	r8,r12[0x0]
8000560c:	2f f8       	sub	r8,-1
8000560e:	99 08       	st.w	r12[0x0],r8
}
80005610:	5e fc       	retal	r12

80005612 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80005612:	78 18       	ld.w	r8,r12[0x4]
80005614:	78 29       	ld.w	r9,r12[0x8]
80005616:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005618:	78 28       	ld.w	r8,r12[0x8]
8000561a:	78 19       	ld.w	r9,r12[0x4]
8000561c:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000561e:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80005620:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
80005622:	18 39       	cp.w	r9,r12
80005624:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
80005628:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
8000562c:	30 09       	mov	r9,0
8000562e:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
80005630:	70 09       	ld.w	r9,r8[0x0]
80005632:	20 19       	sub	r9,1
80005634:	91 09       	st.w	r8[0x0],r9
}
80005636:	5e fc       	retal	r12

80005638 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
80005638:	e0 68 08 08 	mov	r8,2056
8000563c:	ea 18 08 08 	orh	r8,0x808
80005640:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
80005642:	e0 68 09 09 	mov	r8,2313
80005646:	ea 18 09 09 	orh	r8,0x909
8000564a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
8000564c:	e0 68 0a 0a 	mov	r8,2570
80005650:	ea 18 0a 0a 	orh	r8,0xa0a
80005654:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
80005656:	e0 68 0b 0b 	mov	r8,2827
8000565a:	ea 18 0b 0b 	orh	r8,0xb0b
8000565e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
80005660:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
80005662:	e0 68 be ef 	mov	r8,48879
80005666:	ea 18 de ad 	orh	r8,0xdead
8000566a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
8000566c:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
8000566e:	fc 18 00 40 	movh	r8,0x40
80005672:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
80005674:	e0 68 00 ff 	mov	r8,255
80005678:	ea 18 ff 00 	orh	r8,0xff00
8000567c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
8000567e:	e0 68 01 01 	mov	r8,257
80005682:	ea 18 01 01 	orh	r8,0x101
80005686:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005688:	e0 68 02 02 	mov	r8,514
8000568c:	ea 18 02 02 	orh	r8,0x202
80005690:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
80005692:	e0 68 03 03 	mov	r8,771
80005696:	ea 18 03 03 	orh	r8,0x303
8000569a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
8000569c:	e0 68 04 04 	mov	r8,1028
800056a0:	ea 18 04 04 	orh	r8,0x404
800056a4:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
800056a6:	e0 68 05 05 	mov	r8,1285
800056aa:	ea 18 05 05 	orh	r8,0x505
800056ae:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
800056b0:	e0 68 06 06 	mov	r8,1542
800056b4:	ea 18 06 06 	orh	r8,0x606
800056b8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
800056ba:	e0 68 07 07 	mov	r8,1799
800056be:	ea 18 07 07 	orh	r8,0x707
800056c2:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
800056c4:	30 08       	mov	r8,0
800056c6:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
800056c8:	5e fc       	retal	r12
800056ca:	d7 03       	nop

800056cc <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
800056cc:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
800056ce:	48 38       	lddpc	r8,800056d8 <vPortEnterCritical+0xc>
800056d0:	70 09       	ld.w	r9,r8[0x0]
800056d2:	2f f9       	sub	r9,-1
800056d4:	91 09       	st.w	r8[0x0],r9
}
800056d6:	5e fc       	retal	r12
800056d8:	00 00       	add	r0,r0
800056da:	01 c8       	ld.ub	r8,r0[0x4]

800056dc <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
800056dc:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
800056de:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
800056e0:	30 0a       	mov	r10,0
800056e2:	14 9b       	mov	r11,r10
800056e4:	49 2c       	lddpc	r12,8000572c <xPortStartScheduler+0x50>
800056e6:	f0 1f 00 13 	mcall	80005730 <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
800056ea:	e0 68 bb 80 	mov	r8,48000
800056ee:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
800056f2:	30 08       	mov	r8,0
800056f4:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
800056f8:	e0 68 cc e8 	mov	r8,52456
800056fc:	ea 18 00 00 	orh	r8,0x0
80005700:	70 00       	ld.w	r0,r8[0x0]
80005702:	60 0d       	ld.w	sp,r0[0x0]
80005704:	1b 00       	ld.w	r0,sp++
80005706:	e0 68 01 c8 	mov	r8,456
8000570a:	ea 18 00 00 	orh	r8,0x0
8000570e:	91 00       	st.w	r8[0x0],r0
80005710:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005714:	2f ed       	sub	sp,-8
80005716:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
8000571a:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000571e:	e3 b0 00 00 	mtsr	0x0,r0
80005722:	fa f0 ff dc 	ld.w	r0,sp[-36]
80005726:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
8000572a:	d8 0a       	popm	pc,r12=0
8000572c:	80 00       	ld.sh	r0,r0[0x0]
8000572e:	57 f8       	stdsp	sp[0x1fc],r8
80005730:	80 00       	ld.sh	r0,r0[0x0]
80005732:	68 70       	ld.w	r0,r4[0x1c]

80005734 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
80005734:	20 6d       	sub	sp,24
80005736:	eb cd 00 ff 	pushm	r0-r7
8000573a:	fa c7 ff c0 	sub	r7,sp,-64
8000573e:	ee f0 ff f8 	ld.w	r0,r7[-8]
80005742:	ef 40 ff e0 	st.w	r7[-32],r0
80005746:	ee f0 ff fc 	ld.w	r0,r7[-4]
8000574a:	ef 40 ff e4 	st.w	r7[-28],r0
8000574e:	eb c7 5f 00 	stm	--r7,r8-r12,lr
80005752:	e0 68 01 c8 	mov	r8,456
80005756:	ea 18 00 00 	orh	r8,0x0
8000575a:	70 00       	ld.w	r0,r8[0x0]
8000575c:	1a d0       	st.w	--sp,r0
8000575e:	f0 1f 00 1a 	mcall	800057c4 <LABEL_RET_SCALL_260+0x14>
80005762:	e0 68 cc e8 	mov	r8,52456
80005766:	ea 18 00 00 	orh	r8,0x0
8000576a:	70 00       	ld.w	r0,r8[0x0]
8000576c:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
8000576e:	f0 1f 00 17 	mcall	800057c8 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
80005772:	e0 68 cc e8 	mov	r8,52456
80005776:	ea 18 00 00 	orh	r8,0x0
8000577a:	70 00       	ld.w	r0,r8[0x0]
8000577c:	60 0d       	ld.w	sp,r0[0x0]
8000577e:	1b 00       	ld.w	r0,sp++
80005780:	e0 68 01 c8 	mov	r8,456
80005784:	ea 18 00 00 	orh	r8,0x0
80005788:	91 00       	st.w	r8[0x0],r0
8000578a:	fa c7 ff d8 	sub	r7,sp,-40
8000578e:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
80005792:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005796:	e0 61 01 c8 	mov	r1,456
8000579a:	ea 11 00 00 	orh	r1,0x0
8000579e:	62 02       	ld.w	r2,r1[0x0]
800057a0:	58 02       	cp.w	r2,0
800057a2:	c0 70       	breq	800057b0 <LABEL_RET_SCALL_260>
800057a4:	e4 c2 00 01 	sub	r2,r2,1
800057a8:	83 02       	st.w	r1[0x0],r2
800057aa:	58 02       	cp.w	r2,0
800057ac:	c0 21       	brne	800057b0 <LABEL_RET_SCALL_260>
800057ae:	b1 c0       	cbr	r0,0x10

800057b0 <LABEL_RET_SCALL_260>:
800057b0:	ef 40 ff f8 	st.w	r7[-8],r0
800057b4:	ee f0 ff e4 	ld.w	r0,r7[-28]
800057b8:	ef 40 ff fc 	st.w	r7[-4],r0
800057bc:	e3 cd 00 ff 	ldm	sp++,r0-r7
800057c0:	2f ad       	sub	sp,-24
800057c2:	d6 13       	rets
800057c4:	80 00       	ld.sh	r0,r0[0x0]
800057c6:	56 cc       	stdsp	sp[0x1b0],r12
800057c8:	80 00       	ld.sh	r0,r0[0x0]
800057ca:	58 8c       	cp.w	r12,8

800057cc <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
800057cc:	e1 b8 00 43 	mfsr	r8,0x10c
800057d0:	e3 b8 00 43 	mtsr	0x10c,r8
	}
800057d4:	5e fc       	retal	r12
800057d6:	d7 03       	nop

800057d8 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
800057d8:	48 78       	lddpc	r8,800057f4 <vPortExitCritical+0x1c>
800057da:	70 08       	ld.w	r8,r8[0x0]
800057dc:	58 08       	cp.w	r8,0
800057de:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
800057e0:	48 58       	lddpc	r8,800057f4 <vPortExitCritical+0x1c>
800057e2:	70 09       	ld.w	r9,r8[0x0]
800057e4:	20 19       	sub	r9,1
800057e6:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
800057e8:	70 08       	ld.w	r8,r8[0x0]
800057ea:	58 08       	cp.w	r8,0
800057ec:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
800057ee:	d5 03       	csrf	0x10
800057f0:	5e fc       	retal	r12
800057f2:	00 00       	add	r0,r0
800057f4:	00 00       	add	r0,r0
800057f6:	01 c8       	ld.ub	r8,r0[0x4]

800057f8 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
800057f8:	eb cd 00 ff 	pushm	r0-r7
800057fc:	e0 68 01 c8 	mov	r8,456
80005800:	ea 18 00 00 	orh	r8,0x0
80005804:	70 00       	ld.w	r0,r8[0x0]
80005806:	1a d0       	st.w	--sp,r0
80005808:	7a 90       	ld.w	r0,sp[0x24]
8000580a:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000580e:	58 10       	cp.w	r0,1
80005810:	e0 8b 00 08 	brhi	80005820 <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80005814:	e0 68 cc e8 	mov	r8,52456
80005818:	ea 18 00 00 	orh	r8,0x0
8000581c:	70 00       	ld.w	r0,r8[0x0]
8000581e:	81 0d       	st.w	r0[0x0],sp

80005820 <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
80005820:	f0 1f 00 12 	mcall	80005868 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
80005824:	f0 1f 00 12 	mcall	8000586c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
80005828:	f0 1f 00 12 	mcall	80005870 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
8000582c:	f0 1f 00 12 	mcall	80005874 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
80005830:	7a 90       	ld.w	r0,sp[0x24]
80005832:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
80005836:	58 10       	cp.w	r0,1
80005838:	e0 8b 00 0e 	brhi	80005854 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
8000583c:	f0 1f 00 0c 	mcall	8000586c <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
80005840:	f0 1f 00 0e 	mcall	80005878 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
80005844:	f0 1f 00 0c 	mcall	80005874 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
80005848:	e0 68 cc e8 	mov	r8,52456
8000584c:	ea 18 00 00 	orh	r8,0x0
80005850:	70 00       	ld.w	r0,r8[0x0]
80005852:	60 0d       	ld.w	sp,r0[0x0]

80005854 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
80005854:	1b 00       	ld.w	r0,sp++
80005856:	e0 68 01 c8 	mov	r8,456
8000585a:	ea 18 00 00 	orh	r8,0x0
8000585e:	91 00       	st.w	r8[0x0],r0
80005860:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005864:	d6 03       	rete
80005866:	00 00       	add	r0,r0
80005868:	80 00       	ld.sh	r0,r0[0x0]
8000586a:	57 cc       	stdsp	sp[0x1f0],r12
8000586c:	80 00       	ld.sh	r0,r0[0x0]
8000586e:	56 cc       	stdsp	sp[0x1b0],r12
80005870:	80 00       	ld.sh	r0,r0[0x0]
80005872:	5a 40       	cp.w	r0,-28
80005874:	80 00       	ld.sh	r0,r0[0x0]
80005876:	57 d8       	stdsp	sp[0x1f4],r8
80005878:	80 00       	ld.sh	r0,r0[0x0]
8000587a:	58 8c       	cp.w	r12,8

8000587c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
8000587c:	48 38       	lddpc	r8,80005888 <vTaskSuspendAll+0xc>
8000587e:	70 09       	ld.w	r9,r8[0x0]
80005880:	2f f9       	sub	r9,-1
80005882:	91 09       	st.w	r8[0x0],r9
}
80005884:	5e fc       	retal	r12
80005886:	00 00       	add	r0,r0
80005888:	00 00       	add	r0,r0
8000588a:	cd 18       	rjmp	80005a2c <xTaskRemoveFromEventList+0x6c>

8000588c <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
8000588c:	49 a8       	lddpc	r8,800058f4 <vTaskSwitchContext+0x68>
8000588e:	70 08       	ld.w	r8,r8[0x0]
80005890:	58 08       	cp.w	r8,0
80005892:	c0 b1       	brne	800058a8 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005894:	49 98       	lddpc	r8,800058f8 <vTaskSwitchContext+0x6c>
80005896:	70 08       	ld.w	r8,r8[0x0]
80005898:	f0 08 00 28 	add	r8,r8,r8<<0x2
8000589c:	49 89       	lddpc	r9,800058fc <vTaskSwitchContext+0x70>
8000589e:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
800058a2:	58 08       	cp.w	r8,0
800058a4:	c0 60       	breq	800058b0 <vTaskSwitchContext+0x24>
800058a6:	c1 18       	rjmp	800058c8 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
800058a8:	30 19       	mov	r9,1
800058aa:	49 68       	lddpc	r8,80005900 <vTaskSwitchContext+0x74>
800058ac:	91 09       	st.w	r8[0x0],r9
800058ae:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800058b0:	49 28       	lddpc	r8,800058f8 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800058b2:	49 3a       	lddpc	r10,800058fc <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
800058b4:	70 09       	ld.w	r9,r8[0x0]
800058b6:	20 19       	sub	r9,1
800058b8:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
800058ba:	70 09       	ld.w	r9,r8[0x0]
800058bc:	f2 09 00 29 	add	r9,r9,r9<<0x2
800058c0:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
800058c4:	58 09       	cp.w	r9,0
800058c6:	cf 70       	breq	800058b4 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
800058c8:	48 c8       	lddpc	r8,800058f8 <vTaskSwitchContext+0x6c>
800058ca:	70 08       	ld.w	r8,r8[0x0]
800058cc:	f0 08 00 28 	add	r8,r8,r8<<0x2
800058d0:	48 b9       	lddpc	r9,800058fc <vTaskSwitchContext+0x70>
800058d2:	f2 08 00 28 	add	r8,r9,r8<<0x2
800058d6:	70 19       	ld.w	r9,r8[0x4]
800058d8:	72 19       	ld.w	r9,r9[0x4]
800058da:	91 19       	st.w	r8[0x4],r9
800058dc:	f0 ca ff f8 	sub	r10,r8,-8
800058e0:	14 39       	cp.w	r9,r10
800058e2:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
800058e6:	f1 f9 0a 01 	st.weq	r8[0x4],r9
800058ea:	70 18       	ld.w	r8,r8[0x4]
800058ec:	70 39       	ld.w	r9,r8[0xc]
800058ee:	48 68       	lddpc	r8,80005904 <vTaskSwitchContext+0x78>
800058f0:	91 09       	st.w	r8[0x0],r9
800058f2:	5e fc       	retal	r12
800058f4:	00 00       	add	r0,r0
800058f6:	cd 18       	rjmp	80005a98 <vTaskIncrementTick+0x58>
800058f8:	00 00       	add	r0,r0
800058fa:	cd 50       	breq	800058a4 <vTaskSwitchContext+0x18>
800058fc:	00 00       	add	r0,r0
800058fe:	cc 34       	brge	80005884 <vTaskSuspendAll+0x8>
80005900:	00 00       	add	r0,r0
80005902:	cd 38       	rjmp	80005aa8 <vTaskIncrementTick+0x68>
80005904:	00 00       	add	r0,r0
80005906:	cc e8       	rjmp	80005aa2 <vTaskIncrementTick+0x62>

80005908 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005908:	48 48       	lddpc	r8,80005918 <vTaskSetTimeOutState+0x10>
8000590a:	70 08       	ld.w	r8,r8[0x0]
8000590c:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
8000590e:	48 48       	lddpc	r8,8000591c <vTaskSetTimeOutState+0x14>
80005910:	70 08       	ld.w	r8,r8[0x0]
80005912:	99 18       	st.w	r12[0x4],r8
}
80005914:	5e fc       	retal	r12
80005916:	00 00       	add	r0,r0
80005918:	00 00       	add	r0,r0
8000591a:	cc 2c       	rcall	80005a9e <vTaskIncrementTick+0x5e>
8000591c:	00 00       	add	r0,r0
8000591e:	cd 14       	brge	800058c0 <vTaskSwitchContext+0x34>

80005920 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005920:	30 19       	mov	r9,1
80005922:	48 28       	lddpc	r8,80005928 <vTaskMissedYield+0x8>
80005924:	91 09       	st.w	r8[0x0],r9
}
80005926:	5e fc       	retal	r12
80005928:	00 00       	add	r0,r0
8000592a:	cd 38       	rjmp	80005ad0 <vTaskIncrementTick+0x90>

8000592c <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
8000592c:	eb cd 40 c0 	pushm	r6-r7,lr
80005930:	18 97       	mov	r7,r12
80005932:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005934:	f0 1f 00 15 	mcall	80005988 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005938:	6c 08       	ld.w	r8,r6[0x0]
8000593a:	5b f8       	cp.w	r8,-1
8000593c:	c0 31       	brne	80005942 <xTaskCheckForTimeOut+0x16>
8000593e:	30 07       	mov	r7,0
80005940:	c1 f8       	rjmp	8000597e <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005942:	49 39       	lddpc	r9,8000598c <xTaskCheckForTimeOut+0x60>
80005944:	72 09       	ld.w	r9,r9[0x0]
80005946:	6e 0a       	ld.w	r10,r7[0x0]
80005948:	12 3a       	cp.w	r10,r9
8000594a:	c0 70       	breq	80005958 <xTaskCheckForTimeOut+0x2c>
8000594c:	49 19       	lddpc	r9,80005990 <xTaskCheckForTimeOut+0x64>
8000594e:	72 09       	ld.w	r9,r9[0x0]
80005950:	6e 1a       	ld.w	r10,r7[0x4]
80005952:	12 3a       	cp.w	r10,r9
80005954:	e0 88 00 14 	brls	8000597c <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005958:	48 e9       	lddpc	r9,80005990 <xTaskCheckForTimeOut+0x64>
8000595a:	72 0a       	ld.w	r10,r9[0x0]
8000595c:	6e 19       	ld.w	r9,r7[0x4]
8000595e:	12 1a       	sub	r10,r9
80005960:	14 38       	cp.w	r8,r10
80005962:	e0 88 00 0d 	brls	8000597c <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005966:	48 ba       	lddpc	r10,80005990 <xTaskCheckForTimeOut+0x64>
80005968:	74 0a       	ld.w	r10,r10[0x0]
8000596a:	14 19       	sub	r9,r10
8000596c:	f2 08 00 08 	add	r8,r9,r8
80005970:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005972:	0e 9c       	mov	r12,r7
80005974:	f0 1f 00 08 	mcall	80005994 <xTaskCheckForTimeOut+0x68>
80005978:	30 07       	mov	r7,0
8000597a:	c0 28       	rjmp	8000597e <xTaskCheckForTimeOut+0x52>
8000597c:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
8000597e:	f0 1f 00 07 	mcall	80005998 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005982:	0e 9c       	mov	r12,r7
80005984:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005988:	80 00       	ld.sh	r0,r0[0x0]
8000598a:	56 cc       	stdsp	sp[0x1b0],r12
8000598c:	00 00       	add	r0,r0
8000598e:	cc 2c       	rcall	80005b12 <vTaskIncrementTick+0xd2>
80005990:	00 00       	add	r0,r0
80005992:	cd 14       	brge	80005934 <xTaskCheckForTimeOut+0x8>
80005994:	80 00       	ld.sh	r0,r0[0x0]
80005996:	59 08       	cp.w	r8,16
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	57 d8       	stdsp	sp[0x1f4],r8

8000599c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
8000599c:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
800059a0:	f0 1f 00 05 	mcall	800059b4 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
800059a4:	48 58       	lddpc	r8,800059b8 <xTaskGetTickCount+0x1c>
800059a6:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
800059a8:	f0 1f 00 05 	mcall	800059bc <xTaskGetTickCount+0x20>

	return xTicks;
}
800059ac:	0e 9c       	mov	r12,r7
800059ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800059b2:	00 00       	add	r0,r0
800059b4:	80 00       	ld.sh	r0,r0[0x0]
800059b6:	56 cc       	stdsp	sp[0x1b0],r12
800059b8:	00 00       	add	r0,r0
800059ba:	cd 14       	brge	8000595c <xTaskCheckForTimeOut+0x30>
800059bc:	80 00       	ld.sh	r0,r0[0x0]
800059be:	57 d8       	stdsp	sp[0x1f4],r8

800059c0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
800059c0:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
800059c4:	78 38       	ld.w	r8,r12[0xc]
800059c6:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
800059c8:	ee c6 ff e8 	sub	r6,r7,-24
800059cc:	0c 9c       	mov	r12,r6
800059ce:	f0 1f 00 16 	mcall	80005a24 <xTaskRemoveFromEventList+0x64>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
800059d2:	49 68       	lddpc	r8,80005a28 <xTaskRemoveFromEventList+0x68>
800059d4:	70 08       	ld.w	r8,r8[0x0]
800059d6:	58 08       	cp.w	r8,0
800059d8:	c1 71       	brne	80005a06 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
800059da:	ee c6 ff fc 	sub	r6,r7,-4
800059de:	0c 9c       	mov	r12,r6
800059e0:	f0 1f 00 11 	mcall	80005a24 <xTaskRemoveFromEventList+0x64>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
800059e4:	6e bc       	ld.w	r12,r7[0x2c]
800059e6:	49 28       	lddpc	r8,80005a2c <xTaskRemoveFromEventList+0x6c>
800059e8:	70 08       	ld.w	r8,r8[0x0]
800059ea:	10 3c       	cp.w	r12,r8
800059ec:	e0 88 00 04 	brls	800059f4 <xTaskRemoveFromEventList+0x34>
800059f0:	48 f8       	lddpc	r8,80005a2c <xTaskRemoveFromEventList+0x6c>
800059f2:	91 0c       	st.w	r8[0x0],r12
800059f4:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800059f8:	0c 9b       	mov	r11,r6
800059fa:	48 e8       	lddpc	r8,80005a30 <xTaskRemoveFromEventList+0x70>
800059fc:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005a00:	f0 1f 00 0d 	mcall	80005a34 <xTaskRemoveFromEventList+0x74>
80005a04:	c0 58       	rjmp	80005a0e <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005a06:	0c 9b       	mov	r11,r6
80005a08:	48 cc       	lddpc	r12,80005a38 <xTaskRemoveFromEventList+0x78>
80005a0a:	f0 1f 00 0b 	mcall	80005a34 <xTaskRemoveFromEventList+0x74>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005a0e:	48 c8       	lddpc	r8,80005a3c <xTaskRemoveFromEventList+0x7c>
80005a10:	70 08       	ld.w	r8,r8[0x0]
80005a12:	6e bc       	ld.w	r12,r7[0x2c]
80005a14:	70 b8       	ld.w	r8,r8[0x2c]
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005a16:	10 3c       	cp.w	r12,r8
80005a18:	f9 bc 02 01 	movhs	r12,1
80005a1c:	f9 bc 03 00 	movlo	r12,0
80005a20:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005a24:	80 00       	ld.sh	r0,r0[0x0]
80005a26:	56 12       	stdsp	sp[0x184],r2
80005a28:	00 00       	add	r0,r0
80005a2a:	cd 18       	rjmp	80005bcc <xTaskResumeAll+0x78>
80005a2c:	00 00       	add	r0,r0
80005a2e:	cd 50       	breq	800059d8 <xTaskRemoveFromEventList+0x18>
80005a30:	00 00       	add	r0,r0
80005a32:	cc 34       	brge	800059b8 <xTaskGetTickCount+0x1c>
80005a34:	80 00       	ld.sh	r0,r0[0x0]
80005a36:	55 c2       	stdsp	sp[0x170],r2
80005a38:	00 00       	add	r0,r0
80005a3a:	cc ec       	rcall	80005bd6 <xTaskResumeAll+0x82>
80005a3c:	00 00       	add	r0,r0
80005a3e:	cc e8       	rjmp	80005bda <xTaskResumeAll+0x86>

80005a40 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005a40:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005a44:	4b 98       	lddpc	r8,80005b28 <vTaskIncrementTick+0xe8>
80005a46:	70 08       	ld.w	r8,r8[0x0]
80005a48:	58 08       	cp.w	r8,0
80005a4a:	c6 91       	brne	80005b1c <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005a4c:	4b 88       	lddpc	r8,80005b2c <vTaskIncrementTick+0xec>
80005a4e:	70 09       	ld.w	r9,r8[0x0]
80005a50:	2f f9       	sub	r9,-1
80005a52:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005a54:	70 08       	ld.w	r8,r8[0x0]
80005a56:	58 08       	cp.w	r8,0
80005a58:	c1 a1       	brne	80005a8c <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005a5a:	4b 68       	lddpc	r8,80005b30 <vTaskIncrementTick+0xf0>
80005a5c:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005a5e:	4b 69       	lddpc	r9,80005b34 <vTaskIncrementTick+0xf4>
80005a60:	72 0b       	ld.w	r11,r9[0x0]
80005a62:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005a64:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005a66:	4b 59       	lddpc	r9,80005b38 <vTaskIncrementTick+0xf8>
80005a68:	72 0a       	ld.w	r10,r9[0x0]
80005a6a:	2f fa       	sub	r10,-1
80005a6c:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005a6e:	70 08       	ld.w	r8,r8[0x0]
80005a70:	70 08       	ld.w	r8,r8[0x0]
80005a72:	58 08       	cp.w	r8,0
80005a74:	c0 51       	brne	80005a7e <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005a76:	3f f9       	mov	r9,-1
80005a78:	4b 18       	lddpc	r8,80005b3c <vTaskIncrementTick+0xfc>
80005a7a:	91 09       	st.w	r8[0x0],r9
80005a7c:	c0 88       	rjmp	80005a8c <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005a7e:	4a d8       	lddpc	r8,80005b30 <vTaskIncrementTick+0xf0>
80005a80:	70 08       	ld.w	r8,r8[0x0]
80005a82:	70 38       	ld.w	r8,r8[0xc]
80005a84:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005a86:	70 19       	ld.w	r9,r8[0x4]
80005a88:	4a d8       	lddpc	r8,80005b3c <vTaskIncrementTick+0xfc>
80005a8a:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005a8c:	4a 88       	lddpc	r8,80005b2c <vTaskIncrementTick+0xec>
80005a8e:	70 09       	ld.w	r9,r8[0x0]
80005a90:	4a b8       	lddpc	r8,80005b3c <vTaskIncrementTick+0xfc>
80005a92:	70 08       	ld.w	r8,r8[0x0]
80005a94:	10 39       	cp.w	r9,r8
80005a96:	c4 73       	brcs	80005b24 <vTaskIncrementTick+0xe4>
80005a98:	4a 68       	lddpc	r8,80005b30 <vTaskIncrementTick+0xf0>
80005a9a:	70 08       	ld.w	r8,r8[0x0]
80005a9c:	70 08       	ld.w	r8,r8[0x0]
80005a9e:	58 08       	cp.w	r8,0
80005aa0:	c0 c0       	breq	80005ab8 <vTaskIncrementTick+0x78>
80005aa2:	4a 48       	lddpc	r8,80005b30 <vTaskIncrementTick+0xf0>
80005aa4:	70 08       	ld.w	r8,r8[0x0]
80005aa6:	70 38       	ld.w	r8,r8[0xc]
80005aa8:	70 37       	ld.w	r7,r8[0xc]
80005aaa:	6e 18       	ld.w	r8,r7[0x4]
80005aac:	4a 09       	lddpc	r9,80005b2c <vTaskIncrementTick+0xec>
80005aae:	72 09       	ld.w	r9,r9[0x0]
80005ab0:	12 38       	cp.w	r8,r9
80005ab2:	e0 88 00 14 	brls	80005ada <vTaskIncrementTick+0x9a>
80005ab6:	c0 e8       	rjmp	80005ad2 <vTaskIncrementTick+0x92>
80005ab8:	3f f9       	mov	r9,-1
80005aba:	4a 18       	lddpc	r8,80005b3c <vTaskIncrementTick+0xfc>
80005abc:	91 09       	st.w	r8[0x0],r9
80005abe:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005ac2:	6a 08       	ld.w	r8,r5[0x0]
80005ac4:	70 38       	ld.w	r8,r8[0xc]
80005ac6:	70 37       	ld.w	r7,r8[0xc]
80005ac8:	6e 18       	ld.w	r8,r7[0x4]
80005aca:	64 09       	ld.w	r9,r2[0x0]
80005acc:	12 38       	cp.w	r8,r9
80005ace:	e0 88 00 0a 	brls	80005ae2 <vTaskIncrementTick+0xa2>
80005ad2:	49 b9       	lddpc	r9,80005b3c <vTaskIncrementTick+0xfc>
80005ad4:	93 08       	st.w	r9[0x0],r8
80005ad6:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005ada:	49 a4       	lddpc	r4,80005b40 <vTaskIncrementTick+0x100>
80005adc:	49 a3       	lddpc	r3,80005b44 <vTaskIncrementTick+0x104>
80005ade:	49 55       	lddpc	r5,80005b30 <vTaskIncrementTick+0xf0>
80005ae0:	49 32       	lddpc	r2,80005b2c <vTaskIncrementTick+0xec>
80005ae2:	ee c6 ff fc 	sub	r6,r7,-4
80005ae6:	0c 9c       	mov	r12,r6
80005ae8:	f0 1f 00 18 	mcall	80005b48 <vTaskIncrementTick+0x108>
80005aec:	6e a8       	ld.w	r8,r7[0x28]
80005aee:	58 08       	cp.w	r8,0
80005af0:	c0 50       	breq	80005afa <vTaskIncrementTick+0xba>
80005af2:	ee cc ff e8 	sub	r12,r7,-24
80005af6:	f0 1f 00 15 	mcall	80005b48 <vTaskIncrementTick+0x108>
80005afa:	6e bc       	ld.w	r12,r7[0x2c]
80005afc:	68 08       	ld.w	r8,r4[0x0]
80005afe:	10 3c       	cp.w	r12,r8
80005b00:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005b04:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005b08:	0c 9b       	mov	r11,r6
80005b0a:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005b0e:	f0 1f 00 10 	mcall	80005b4c <vTaskIncrementTick+0x10c>
80005b12:	6a 08       	ld.w	r8,r5[0x0]
80005b14:	70 08       	ld.w	r8,r8[0x0]
80005b16:	58 08       	cp.w	r8,0
80005b18:	cd 51       	brne	80005ac2 <vTaskIncrementTick+0x82>
80005b1a:	cc fb       	rjmp	80005ab8 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005b1c:	48 d8       	lddpc	r8,80005b50 <vTaskIncrementTick+0x110>
80005b1e:	70 09       	ld.w	r9,r8[0x0]
80005b20:	2f f9       	sub	r9,-1
80005b22:	91 09       	st.w	r8[0x0],r9
80005b24:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005b28:	00 00       	add	r0,r0
80005b2a:	cd 18       	rjmp	80005ccc <vTaskDelayUntil+0x34>
80005b2c:	00 00       	add	r0,r0
80005b2e:	cd 14       	brge	80005ad0 <vTaskIncrementTick+0x90>
80005b30:	00 00       	add	r0,r0
80005b32:	cc 20       	breq	80005ab6 <vTaskIncrementTick+0x76>
80005b34:	00 00       	add	r0,r0
80005b36:	cc 30       	breq	80005abc <vTaskIncrementTick+0x7c>
80005b38:	00 00       	add	r0,r0
80005b3a:	cc 2c       	rcall	80005cbe <vTaskDelayUntil+0x26>
80005b3c:	00 00       	add	r0,r0
80005b3e:	01 cc       	ld.ub	r12,r0[0x4]
80005b40:	00 00       	add	r0,r0
80005b42:	cd 50       	breq	80005aec <vTaskIncrementTick+0xac>
80005b44:	00 00       	add	r0,r0
80005b46:	cc 34       	brge	80005acc <vTaskIncrementTick+0x8c>
80005b48:	80 00       	ld.sh	r0,r0[0x0]
80005b4a:	56 12       	stdsp	sp[0x184],r2
80005b4c:	80 00       	ld.sh	r0,r0[0x0]
80005b4e:	55 c2       	stdsp	sp[0x170],r2
80005b50:	00 00       	add	r0,r0
80005b52:	cc 18       	rjmp	80005cd4 <vTaskDelayUntil+0x3c>

80005b54 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005b54:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005b58:	f0 1f 00 2c 	mcall	80005c08 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005b5c:	4a c8       	lddpc	r8,80005c0c <xTaskResumeAll+0xb8>
80005b5e:	70 09       	ld.w	r9,r8[0x0]
80005b60:	20 19       	sub	r9,1
80005b62:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005b64:	70 08       	ld.w	r8,r8[0x0]
80005b66:	58 08       	cp.w	r8,0
80005b68:	c4 91       	brne	80005bfa <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005b6a:	4a a8       	lddpc	r8,80005c10 <xTaskResumeAll+0xbc>
80005b6c:	70 08       	ld.w	r8,r8[0x0]
80005b6e:	58 08       	cp.w	r8,0
80005b70:	c4 50       	breq	80005bfa <xTaskResumeAll+0xa6>
80005b72:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005b74:	4a 85       	lddpc	r5,80005c14 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005b76:	4a 93       	lddpc	r3,80005c18 <xTaskResumeAll+0xc4>
80005b78:	4a 92       	lddpc	r2,80005c1c <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005b7a:	4a a1       	lddpc	r1,80005c20 <xTaskResumeAll+0xcc>
80005b7c:	c1 e8       	rjmp	80005bb8 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005b7e:	6a 38       	ld.w	r8,r5[0xc]
80005b80:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005b82:	ee cc ff e8 	sub	r12,r7,-24
80005b86:	f0 1f 00 28 	mcall	80005c24 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005b8a:	ee c6 ff fc 	sub	r6,r7,-4
80005b8e:	0c 9c       	mov	r12,r6
80005b90:	f0 1f 00 25 	mcall	80005c24 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005b94:	6e bc       	ld.w	r12,r7[0x2c]
80005b96:	66 08       	ld.w	r8,r3[0x0]
80005b98:	10 3c       	cp.w	r12,r8
80005b9a:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005b9e:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005ba2:	0c 9b       	mov	r11,r6
80005ba4:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005ba8:	f0 1f 00 20 	mcall	80005c28 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005bac:	62 08       	ld.w	r8,r1[0x0]
80005bae:	6e b9       	ld.w	r9,r7[0x2c]
80005bb0:	70 b8       	ld.w	r8,r8[0x2c]
80005bb2:	10 39       	cp.w	r9,r8
80005bb4:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005bb8:	6a 08       	ld.w	r8,r5[0x0]
80005bba:	58 08       	cp.w	r8,0
80005bbc:	ce 11       	brne	80005b7e <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005bbe:	49 c8       	lddpc	r8,80005c2c <xTaskResumeAll+0xd8>
80005bc0:	70 08       	ld.w	r8,r8[0x0]
80005bc2:	58 08       	cp.w	r8,0
80005bc4:	c0 f0       	breq	80005be2 <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005bc6:	49 a8       	lddpc	r8,80005c2c <xTaskResumeAll+0xd8>
80005bc8:	70 08       	ld.w	r8,r8[0x0]
80005bca:	58 08       	cp.w	r8,0
80005bcc:	c1 10       	breq	80005bee <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005bce:	49 87       	lddpc	r7,80005c2c <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005bd0:	f0 1f 00 18 	mcall	80005c30 <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005bd4:	6e 08       	ld.w	r8,r7[0x0]
80005bd6:	20 18       	sub	r8,1
80005bd8:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005bda:	6e 08       	ld.w	r8,r7[0x0]
80005bdc:	58 08       	cp.w	r8,0
80005bde:	cf 91       	brne	80005bd0 <xTaskResumeAll+0x7c>
80005be0:	c0 78       	rjmp	80005bee <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005be2:	58 14       	cp.w	r4,1
80005be4:	c0 50       	breq	80005bee <xTaskResumeAll+0x9a>
80005be6:	49 48       	lddpc	r8,80005c34 <xTaskResumeAll+0xe0>
80005be8:	70 08       	ld.w	r8,r8[0x0]
80005bea:	58 18       	cp.w	r8,1
80005bec:	c0 71       	brne	80005bfa <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005bee:	30 09       	mov	r9,0
80005bf0:	49 18       	lddpc	r8,80005c34 <xTaskResumeAll+0xe0>
80005bf2:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005bf4:	d7 33       	scall
80005bf6:	30 17       	mov	r7,1
80005bf8:	c0 28       	rjmp	80005bfc <xTaskResumeAll+0xa8>
80005bfa:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005bfc:	f0 1f 00 0f 	mcall	80005c38 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005c00:	0e 9c       	mov	r12,r7
80005c02:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005c06:	00 00       	add	r0,r0
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	56 cc       	stdsp	sp[0x1b0],r12
80005c0c:	00 00       	add	r0,r0
80005c0e:	cd 18       	rjmp	80005db0 <prvIdleTask+0x40>
80005c10:	00 00       	add	r0,r0
80005c12:	cd 34       	brge	80005bb8 <xTaskResumeAll+0x64>
80005c14:	00 00       	add	r0,r0
80005c16:	cc ec       	rcall	80005db2 <prvIdleTask+0x42>
80005c18:	00 00       	add	r0,r0
80005c1a:	cd 50       	breq	80005bc4 <xTaskResumeAll+0x70>
80005c1c:	00 00       	add	r0,r0
80005c1e:	cc 34       	brge	80005ba4 <xTaskResumeAll+0x50>
80005c20:	00 00       	add	r0,r0
80005c22:	cc e8       	rjmp	80005dbe <prvIdleTask+0x4e>
80005c24:	80 00       	ld.sh	r0,r0[0x0]
80005c26:	56 12       	stdsp	sp[0x184],r2
80005c28:	80 00       	ld.sh	r0,r0[0x0]
80005c2a:	55 c2       	stdsp	sp[0x170],r2
80005c2c:	00 00       	add	r0,r0
80005c2e:	cc 18       	rjmp	80005db0 <prvIdleTask+0x40>
80005c30:	80 00       	ld.sh	r0,r0[0x0]
80005c32:	5a 40       	cp.w	r0,-28
80005c34:	00 00       	add	r0,r0
80005c36:	cd 38       	rjmp	80005ddc <prvIdleTask+0x6c>
80005c38:	80 00       	ld.sh	r0,r0[0x0]
80005c3a:	57 d8       	stdsp	sp[0x1f4],r8

80005c3c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005c3c:	eb cd 40 80 	pushm	r7,lr
80005c40:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005c42:	49 08       	lddpc	r8,80005c80 <prvAddCurrentTaskToDelayedList+0x44>
80005c44:	70 08       	ld.w	r8,r8[0x0]
80005c46:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005c48:	48 f8       	lddpc	r8,80005c84 <prvAddCurrentTaskToDelayedList+0x48>
80005c4a:	70 08       	ld.w	r8,r8[0x0]
80005c4c:	10 3c       	cp.w	r12,r8
80005c4e:	c0 a2       	brcc	80005c62 <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005c50:	48 c8       	lddpc	r8,80005c80 <prvAddCurrentTaskToDelayedList+0x44>
80005c52:	70 0b       	ld.w	r11,r8[0x0]
80005c54:	48 d8       	lddpc	r8,80005c88 <prvAddCurrentTaskToDelayedList+0x4c>
80005c56:	70 0c       	ld.w	r12,r8[0x0]
80005c58:	2f cb       	sub	r11,-4
80005c5a:	f0 1f 00 0d 	mcall	80005c8c <prvAddCurrentTaskToDelayedList+0x50>
80005c5e:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005c62:	48 88       	lddpc	r8,80005c80 <prvAddCurrentTaskToDelayedList+0x44>
80005c64:	70 0b       	ld.w	r11,r8[0x0]
80005c66:	48 b8       	lddpc	r8,80005c90 <prvAddCurrentTaskToDelayedList+0x54>
80005c68:	70 0c       	ld.w	r12,r8[0x0]
80005c6a:	2f cb       	sub	r11,-4
80005c6c:	f0 1f 00 08 	mcall	80005c8c <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005c70:	48 98       	lddpc	r8,80005c94 <prvAddCurrentTaskToDelayedList+0x58>
80005c72:	70 08       	ld.w	r8,r8[0x0]
80005c74:	10 37       	cp.w	r7,r8
80005c76:	c0 32       	brcc	80005c7c <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005c78:	48 78       	lddpc	r8,80005c94 <prvAddCurrentTaskToDelayedList+0x58>
80005c7a:	91 07       	st.w	r8[0x0],r7
80005c7c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c80:	00 00       	add	r0,r0
80005c82:	cc e8       	rjmp	80005e1e <xTaskGenericCreate+0x2e>
80005c84:	00 00       	add	r0,r0
80005c86:	cd 14       	brge	80005c28 <xTaskResumeAll+0xd4>
80005c88:	00 00       	add	r0,r0
80005c8a:	cc 30       	breq	80005c10 <xTaskResumeAll+0xbc>
80005c8c:	80 00       	ld.sh	r0,r0[0x0]
80005c8e:	55 de       	stdsp	sp[0x174],lr
80005c90:	00 00       	add	r0,r0
80005c92:	cc 20       	breq	80005c16 <xTaskResumeAll+0xc2>
80005c94:	00 00       	add	r0,r0
80005c96:	01 cc       	ld.ub	r12,r0[0x4]

80005c98 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005c98:	eb cd 40 c0 	pushm	r6-r7,lr
80005c9c:	18 96       	mov	r6,r12
80005c9e:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005ca0:	f0 1f 00 18 	mcall	80005d00 <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005ca4:	6c 08       	ld.w	r8,r6[0x0]
80005ca6:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005ca8:	49 79       	lddpc	r9,80005d04 <vTaskDelayUntil+0x6c>
80005caa:	72 09       	ld.w	r9,r9[0x0]
80005cac:	12 38       	cp.w	r8,r9
80005cae:	e0 88 00 0c 	brls	80005cc6 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005cb2:	0e 38       	cp.w	r8,r7
80005cb4:	e0 88 00 22 	brls	80005cf8 <vTaskDelayUntil+0x60>
80005cb8:	49 38       	lddpc	r8,80005d04 <vTaskDelayUntil+0x6c>
80005cba:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005cbc:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005cbe:	10 37       	cp.w	r7,r8
80005cc0:	e0 88 00 14 	brls	80005ce8 <vTaskDelayUntil+0x50>
80005cc4:	c0 a8       	rjmp	80005cd8 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005cc6:	0e 38       	cp.w	r8,r7
80005cc8:	e0 8b 00 16 	brhi	80005cf4 <vTaskDelayUntil+0x5c>
80005ccc:	48 e8       	lddpc	r8,80005d04 <vTaskDelayUntil+0x6c>
80005cce:	70 08       	ld.w	r8,r8[0x0]
80005cd0:	10 37       	cp.w	r7,r8
80005cd2:	e0 8b 00 11 	brhi	80005cf4 <vTaskDelayUntil+0x5c>
80005cd6:	c1 18       	rjmp	80005cf8 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005cd8:	48 c8       	lddpc	r8,80005d08 <vTaskDelayUntil+0x70>
80005cda:	70 0c       	ld.w	r12,r8[0x0]
80005cdc:	2f cc       	sub	r12,-4
80005cde:	f0 1f 00 0c 	mcall	80005d0c <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005ce2:	0e 9c       	mov	r12,r7
80005ce4:	f0 1f 00 0b 	mcall	80005d10 <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005ce8:	f0 1f 00 0b 	mcall	80005d14 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005cec:	c0 81       	brne	80005cfc <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005cee:	d7 33       	scall
80005cf0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005cf4:	8d 07       	st.w	r6[0x0],r7
80005cf6:	cf 1b       	rjmp	80005cd8 <vTaskDelayUntil+0x40>
80005cf8:	8d 07       	st.w	r6[0x0],r7
80005cfa:	cf 7b       	rjmp	80005ce8 <vTaskDelayUntil+0x50>
80005cfc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d00:	80 00       	ld.sh	r0,r0[0x0]
80005d02:	58 7c       	cp.w	r12,7
80005d04:	00 00       	add	r0,r0
80005d06:	cd 14       	brge	80005ca8 <vTaskDelayUntil+0x10>
80005d08:	00 00       	add	r0,r0
80005d0a:	cc e8       	rjmp	80005ea6 <xTaskGenericCreate+0xb6>
80005d0c:	80 00       	ld.sh	r0,r0[0x0]
80005d0e:	56 12       	stdsp	sp[0x184],r2
80005d10:	80 00       	ld.sh	r0,r0[0x0]
80005d12:	5c 3c       	neg	r12
80005d14:	80 00       	ld.sh	r0,r0[0x0]
80005d16:	5b 54       	cp.w	r4,-11

80005d18 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005d18:	eb cd 40 c0 	pushm	r6-r7,lr
80005d1c:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005d1e:	48 e7       	lddpc	r7,80005d54 <vTaskPlaceOnEventList+0x3c>
80005d20:	6e 0b       	ld.w	r11,r7[0x0]
80005d22:	2e 8b       	sub	r11,-24
80005d24:	f0 1f 00 0d 	mcall	80005d58 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d28:	6e 0c       	ld.w	r12,r7[0x0]
80005d2a:	2f cc       	sub	r12,-4
80005d2c:	f0 1f 00 0c 	mcall	80005d5c <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005d30:	5b f6       	cp.w	r6,-1
80005d32:	c0 81       	brne	80005d42 <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005d34:	6e 0b       	ld.w	r11,r7[0x0]
80005d36:	2f cb       	sub	r11,-4
80005d38:	48 ac       	lddpc	r12,80005d60 <vTaskPlaceOnEventList+0x48>
80005d3a:	f0 1f 00 0b 	mcall	80005d64 <vTaskPlaceOnEventList+0x4c>
80005d3e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005d42:	48 a8       	lddpc	r8,80005d68 <vTaskPlaceOnEventList+0x50>
80005d44:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005d46:	ec 0c 00 0c 	add	r12,r6,r12
80005d4a:	f0 1f 00 09 	mcall	80005d6c <vTaskPlaceOnEventList+0x54>
80005d4e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005d52:	00 00       	add	r0,r0
80005d54:	00 00       	add	r0,r0
80005d56:	cc e8       	rjmp	80005ef2 <xTaskGenericCreate+0x102>
80005d58:	80 00       	ld.sh	r0,r0[0x0]
80005d5a:	55 de       	stdsp	sp[0x174],lr
80005d5c:	80 00       	ld.sh	r0,r0[0x0]
80005d5e:	56 12       	stdsp	sp[0x184],r2
80005d60:	00 00       	add	r0,r0
80005d62:	cd 3c       	rcall	80005f08 <xTaskGenericCreate+0x118>
80005d64:	80 00       	ld.sh	r0,r0[0x0]
80005d66:	55 c2       	stdsp	sp[0x170],r2
80005d68:	00 00       	add	r0,r0
80005d6a:	cd 14       	brge	80005d0c <vTaskDelayUntil+0x74>
80005d6c:	80 00       	ld.sh	r0,r0[0x0]
80005d6e:	5c 3c       	neg	r12

80005d70 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005d70:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005d74:	49 57       	lddpc	r7,80005dc8 <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005d76:	49 64       	lddpc	r4,80005dcc <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005d78:	49 63       	lddpc	r3,80005dd0 <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005d7a:	49 75       	lddpc	r5,80005dd4 <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005d7c:	6e 08       	ld.w	r8,r7[0x0]
80005d7e:	58 08       	cp.w	r8,0
80005d80:	c1 e0       	breq	80005dbc <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005d82:	f0 1f 00 16 	mcall	80005dd8 <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005d86:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005d88:	f0 1f 00 15 	mcall	80005ddc <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
80005d8c:	58 06       	cp.w	r6,0
80005d8e:	c1 70       	breq	80005dbc <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005d90:	f0 1f 00 14 	mcall	80005de0 <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005d94:	68 38       	ld.w	r8,r4[0xc]
80005d96:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005d98:	ec cc ff fc 	sub	r12,r6,-4
80005d9c:	f0 1f 00 12 	mcall	80005de4 <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
80005da0:	66 08       	ld.w	r8,r3[0x0]
80005da2:	20 18       	sub	r8,1
80005da4:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005da6:	6e 08       	ld.w	r8,r7[0x0]
80005da8:	20 18       	sub	r8,1
80005daa:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005dac:	f0 1f 00 0f 	mcall	80005de8 <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005db0:	6c cc       	ld.w	r12,r6[0x30]
80005db2:	f0 1f 00 0f 	mcall	80005dec <prvIdleTask+0x7c>
		vPortFree( pxTCB );
80005db6:	0c 9c       	mov	r12,r6
80005db8:	f0 1f 00 0d 	mcall	80005dec <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005dbc:	6a 08       	ld.w	r8,r5[0x0]
80005dbe:	58 18       	cp.w	r8,1
80005dc0:	fe 98 ff de 	brls	80005d7c <prvIdleTask+0xc>
			{
				taskYIELD();
80005dc4:	d7 33       	scall
80005dc6:	cd bb       	rjmp	80005d7c <prvIdleTask+0xc>
80005dc8:	00 00       	add	r0,r0
80005dca:	cc 28       	rjmp	80005f4e <xTaskGenericCreate+0x15e>
80005dcc:	00 00       	add	r0,r0
80005dce:	cc d4       	brge	80005d68 <vTaskPlaceOnEventList+0x50>
80005dd0:	00 00       	add	r0,r0
80005dd2:	cd 34       	brge	80005d78 <prvIdleTask+0x8>
80005dd4:	00 00       	add	r0,r0
80005dd6:	cc 34       	brge	80005d5c <vTaskPlaceOnEventList+0x44>
80005dd8:	80 00       	ld.sh	r0,r0[0x0]
80005dda:	58 7c       	cp.w	r12,7
80005ddc:	80 00       	ld.sh	r0,r0[0x0]
80005dde:	5b 54       	cp.w	r4,-11
80005de0:	80 00       	ld.sh	r0,r0[0x0]
80005de2:	56 cc       	stdsp	sp[0x1b0],r12
80005de4:	80 00       	ld.sh	r0,r0[0x0]
80005de6:	56 12       	stdsp	sp[0x184],r2
80005de8:	80 00       	ld.sh	r0,r0[0x0]
80005dea:	57 d8       	stdsp	sp[0x1f4],r8
80005dec:	80 00       	ld.sh	r0,r0[0x0]
80005dee:	2b 9c       	sub	r12,-71

80005df0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005df0:	d4 31       	pushm	r0-r7,lr
80005df2:	20 1d       	sub	sp,4
80005df4:	fa c4 ff d8 	sub	r4,sp,-40
80005df8:	50 0c       	stdsp	sp[0x0],r12
80005dfa:	16 91       	mov	r1,r11
80005dfc:	14 97       	mov	r7,r10
80005dfe:	12 90       	mov	r0,r9
80005e00:	10 93       	mov	r3,r8
80005e02:	68 02       	ld.w	r2,r4[0x0]
80005e04:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005e06:	34 4c       	mov	r12,68
80005e08:	f0 1f 00 5b 	mcall	80005f74 <xTaskGenericCreate+0x184>
80005e0c:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005e0e:	c0 31       	brne	80005e14 <xTaskGenericCreate+0x24>
80005e10:	3f fc       	mov	r12,-1
80005e12:	ca d8       	rjmp	80005f6c <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005e14:	58 06       	cp.w	r6,0
80005e16:	e0 81 00 ad 	brne	80005f70 <xTaskGenericCreate+0x180>
80005e1a:	0e 9c       	mov	r12,r7
80005e1c:	5c 7c       	castu.h	r12
80005e1e:	a3 6c       	lsl	r12,0x2
80005e20:	f0 1f 00 55 	mcall	80005f74 <xTaskGenericCreate+0x184>
80005e24:	18 96       	mov	r6,r12
80005e26:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005e28:	c0 61       	brne	80005e34 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005e2a:	0a 9c       	mov	r12,r5
80005e2c:	f0 1f 00 53 	mcall	80005f78 <xTaskGenericCreate+0x188>
80005e30:	3f fc       	mov	r12,-1
80005e32:	c9 d8       	rjmp	80005f6c <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005e34:	5c 77       	castu.h	r7
80005e36:	ee 0a 15 02 	lsl	r10,r7,0x2
80005e3a:	e0 6b 00 a5 	mov	r11,165
80005e3e:	0c 9c       	mov	r12,r6
80005e40:	f0 1f 00 4f 	mcall	80005f7c <xTaskGenericCreate+0x18c>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005e44:	ee c6 00 01 	sub	r6,r7,1
80005e48:	6a c8       	ld.w	r8,r5[0x30]
80005e4a:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005e4e:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005e52:	31 0a       	mov	r10,16
80005e54:	02 9b       	mov	r11,r1
80005e56:	ea cc ff cc 	sub	r12,r5,-52
80005e5a:	f0 1f 00 4a 	mcall	80005f80 <xTaskGenericCreate+0x190>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005e5e:	30 08       	mov	r8,0
80005e60:	eb 68 00 43 	st.b	r5[67],r8
80005e64:	58 73       	cp.w	r3,7
80005e66:	e6 07 17 80 	movls	r7,r3
80005e6a:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005e6e:	8b b7       	st.w	r5[0x2c],r7
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005e70:	ea c4 ff fc 	sub	r4,r5,-4
80005e74:	08 9c       	mov	r12,r4
80005e76:	f0 1f 00 44 	mcall	80005f84 <xTaskGenericCreate+0x194>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005e7a:	ea cc ff e8 	sub	r12,r5,-24
80005e7e:	f0 1f 00 42 	mcall	80005f84 <xTaskGenericCreate+0x194>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005e82:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80005e84:	ee 07 11 08 	rsub	r7,r7,8
80005e88:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80005e8a:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80005e8c:	00 9a       	mov	r10,r0
80005e8e:	40 0b       	lddsp	r11,sp[0x0]
80005e90:	0c 9c       	mov	r12,r6
80005e92:	f0 1f 00 3e 	mcall	80005f88 <xTaskGenericCreate+0x198>
80005e96:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80005e98:	58 02       	cp.w	r2,0
80005e9a:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
80005e9e:	f0 1f 00 3c 	mcall	80005f8c <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
80005ea2:	4b c8       	lddpc	r8,80005f90 <xTaskGenericCreate+0x1a0>
80005ea4:	70 09       	ld.w	r9,r8[0x0]
80005ea6:	2f f9       	sub	r9,-1
80005ea8:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80005eaa:	4b b8       	lddpc	r8,80005f94 <xTaskGenericCreate+0x1a4>
80005eac:	70 08       	ld.w	r8,r8[0x0]
80005eae:	58 08       	cp.w	r8,0
80005eb0:	c2 61       	brne	80005efc <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
80005eb2:	4b 98       	lddpc	r8,80005f94 <xTaskGenericCreate+0x1a4>
80005eb4:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80005eb6:	4b 78       	lddpc	r8,80005f90 <xTaskGenericCreate+0x1a0>
80005eb8:	70 08       	ld.w	r8,r8[0x0]
80005eba:	58 18       	cp.w	r8,1
80005ebc:	c2 b1       	brne	80005f12 <xTaskGenericCreate+0x122>
80005ebe:	4b 77       	lddpc	r7,80005f98 <xTaskGenericCreate+0x1a8>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
80005ec0:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80005ec4:	0e 9c       	mov	r12,r7
80005ec6:	f0 1f 00 36 	mcall	80005f9c <xTaskGenericCreate+0x1ac>
80005eca:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80005ecc:	0c 37       	cp.w	r7,r6
80005ece:	cf b1       	brne	80005ec4 <xTaskGenericCreate+0xd4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
80005ed0:	4b 47       	lddpc	r7,80005fa0 <xTaskGenericCreate+0x1b0>
80005ed2:	0e 9c       	mov	r12,r7
80005ed4:	f0 1f 00 32 	mcall	80005f9c <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80005ed8:	4b 36       	lddpc	r6,80005fa4 <xTaskGenericCreate+0x1b4>
80005eda:	0c 9c       	mov	r12,r6
80005edc:	f0 1f 00 30 	mcall	80005f9c <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xPendingReadyList );
80005ee0:	4b 2c       	lddpc	r12,80005fa8 <xTaskGenericCreate+0x1b8>
80005ee2:	f0 1f 00 2f 	mcall	80005f9c <xTaskGenericCreate+0x1ac>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80005ee6:	4b 2c       	lddpc	r12,80005fac <xTaskGenericCreate+0x1bc>
80005ee8:	f0 1f 00 2d 	mcall	80005f9c <xTaskGenericCreate+0x1ac>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80005eec:	4b 1c       	lddpc	r12,80005fb0 <xTaskGenericCreate+0x1c0>
80005eee:	f0 1f 00 2c 	mcall	80005f9c <xTaskGenericCreate+0x1ac>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80005ef2:	4b 18       	lddpc	r8,80005fb4 <xTaskGenericCreate+0x1c4>
80005ef4:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80005ef6:	4b 18       	lddpc	r8,80005fb8 <xTaskGenericCreate+0x1c8>
80005ef8:	91 06       	st.w	r8[0x0],r6
80005efa:	c0 c8       	rjmp	80005f12 <xTaskGenericCreate+0x122>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80005efc:	4b 08       	lddpc	r8,80005fbc <xTaskGenericCreate+0x1cc>
80005efe:	70 08       	ld.w	r8,r8[0x0]
80005f00:	58 08       	cp.w	r8,0
80005f02:	c0 81       	brne	80005f12 <xTaskGenericCreate+0x122>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80005f04:	4a 48       	lddpc	r8,80005f94 <xTaskGenericCreate+0x1a4>
80005f06:	70 08       	ld.w	r8,r8[0x0]
80005f08:	70 b8       	ld.w	r8,r8[0x2c]
80005f0a:	10 33       	cp.w	r3,r8
80005f0c:	c0 33       	brcs	80005f12 <xTaskGenericCreate+0x122>
					{
						pxCurrentTCB = pxNewTCB;
80005f0e:	4a 28       	lddpc	r8,80005f94 <xTaskGenericCreate+0x1a4>
80005f10:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
80005f12:	6a b8       	ld.w	r8,r5[0x2c]
80005f14:	4a b9       	lddpc	r9,80005fc0 <xTaskGenericCreate+0x1d0>
80005f16:	72 09       	ld.w	r9,r9[0x0]
80005f18:	12 38       	cp.w	r8,r9
80005f1a:	e0 88 00 04 	brls	80005f22 <xTaskGenericCreate+0x132>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
80005f1e:	4a 99       	lddpc	r9,80005fc0 <xTaskGenericCreate+0x1d0>
80005f20:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
80005f22:	4a 98       	lddpc	r8,80005fc4 <xTaskGenericCreate+0x1d4>
80005f24:	70 09       	ld.w	r9,r8[0x0]
80005f26:	2f f9       	sub	r9,-1
80005f28:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
80005f2a:	6a b8       	ld.w	r8,r5[0x2c]
80005f2c:	4a 79       	lddpc	r9,80005fc8 <xTaskGenericCreate+0x1d8>
80005f2e:	72 09       	ld.w	r9,r9[0x0]
80005f30:	12 38       	cp.w	r8,r9
80005f32:	e0 88 00 04 	brls	80005f3a <xTaskGenericCreate+0x14a>
80005f36:	4a 59       	lddpc	r9,80005fc8 <xTaskGenericCreate+0x1d8>
80005f38:	93 08       	st.w	r9[0x0],r8
80005f3a:	6a bc       	ld.w	r12,r5[0x2c]
80005f3c:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005f40:	08 9b       	mov	r11,r4
80005f42:	49 68       	lddpc	r8,80005f98 <xTaskGenericCreate+0x1a8>
80005f44:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005f48:	f0 1f 00 21 	mcall	80005fcc <xTaskGenericCreate+0x1dc>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
80005f4c:	f0 1f 00 21 	mcall	80005fd0 <xTaskGenericCreate+0x1e0>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
80005f50:	49 b8       	lddpc	r8,80005fbc <xTaskGenericCreate+0x1cc>
80005f52:	70 08       	ld.w	r8,r8[0x0]
80005f54:	58 08       	cp.w	r8,0
80005f56:	c0 a0       	breq	80005f6a <xTaskGenericCreate+0x17a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
80005f58:	48 f8       	lddpc	r8,80005f94 <xTaskGenericCreate+0x1a4>
80005f5a:	70 08       	ld.w	r8,r8[0x0]
80005f5c:	70 b8       	ld.w	r8,r8[0x2c]
80005f5e:	10 33       	cp.w	r3,r8
80005f60:	e0 88 00 05 	brls	80005f6a <xTaskGenericCreate+0x17a>
			{
				portYIELD_WITHIN_API();
80005f64:	d7 33       	scall
80005f66:	30 1c       	mov	r12,1
80005f68:	c0 28       	rjmp	80005f6c <xTaskGenericCreate+0x17c>
80005f6a:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
80005f6c:	2f fd       	sub	sp,-4
80005f6e:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005f70:	99 c6       	st.w	r12[0x30],r6
80005f72:	c6 1b       	rjmp	80005e34 <xTaskGenericCreate+0x44>
80005f74:	80 00       	ld.sh	r0,r0[0x0]
80005f76:	2b a0       	sub	r0,-70
80005f78:	80 00       	ld.sh	r0,r0[0x0]
80005f7a:	2b 9c       	sub	r12,-71
80005f7c:	80 00       	ld.sh	r0,r0[0x0]
80005f7e:	79 8e       	ld.w	lr,r12[0x60]
80005f80:	80 00       	ld.sh	r0,r0[0x0]
80005f82:	79 9c       	ld.w	r12,r12[0x64]
80005f84:	80 00       	ld.sh	r0,r0[0x0]
80005f86:	55 bc       	stdsp	sp[0x16c],r12
80005f88:	80 00       	ld.sh	r0,r0[0x0]
80005f8a:	56 38       	stdsp	sp[0x18c],r8
80005f8c:	80 00       	ld.sh	r0,r0[0x0]
80005f8e:	56 cc       	stdsp	sp[0x1b0],r12
80005f90:	00 00       	add	r0,r0
80005f92:	cd 34       	brge	80005f38 <xTaskGenericCreate+0x148>
80005f94:	00 00       	add	r0,r0
80005f96:	cc e8       	rjmp	80006132 <wdt_scheduler+0x22>
80005f98:	00 00       	add	r0,r0
80005f9a:	cc 34       	brge	80005f20 <xTaskGenericCreate+0x130>
80005f9c:	80 00       	ld.sh	r0,r0[0x0]
80005f9e:	55 a8       	stdsp	sp[0x168],r8
80005fa0:	00 00       	add	r0,r0
80005fa2:	cd 00       	breq	80005f42 <xTaskGenericCreate+0x152>
80005fa4:	00 00       	add	r0,r0
80005fa6:	cd 1c       	rcall	80006148 <wdt_scheduler+0x38>
80005fa8:	00 00       	add	r0,r0
80005faa:	cc ec       	rcall	80006146 <wdt_scheduler+0x36>
80005fac:	00 00       	add	r0,r0
80005fae:	cc d4       	brge	80005f48 <xTaskGenericCreate+0x158>
80005fb0:	00 00       	add	r0,r0
80005fb2:	cd 3c       	rcall	80006158 <wdt_scheduler+0x48>
80005fb4:	00 00       	add	r0,r0
80005fb6:	cc 20       	breq	80005f3a <xTaskGenericCreate+0x14a>
80005fb8:	00 00       	add	r0,r0
80005fba:	cc 30       	breq	80005f40 <xTaskGenericCreate+0x150>
80005fbc:	00 00       	add	r0,r0
80005fbe:	cc 24       	brge	80005f42 <xTaskGenericCreate+0x152>
80005fc0:	00 00       	add	r0,r0
80005fc2:	cc 1c       	rcall	80006144 <wdt_scheduler+0x34>
80005fc4:	00 00       	add	r0,r0
80005fc6:	cd 30       	breq	80005f6c <xTaskGenericCreate+0x17c>
80005fc8:	00 00       	add	r0,r0
80005fca:	cd 50       	breq	80005f74 <xTaskGenericCreate+0x184>
80005fcc:	80 00       	ld.sh	r0,r0[0x0]
80005fce:	55 c2       	stdsp	sp[0x170],r2
80005fd0:	80 00       	ld.sh	r0,r0[0x0]
80005fd2:	57 d8       	stdsp	sp[0x1f4],r8

80005fd4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80005fd4:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80005fd6:	30 09       	mov	r9,0
80005fd8:	1a d9       	st.w	--sp,r9
80005fda:	1a d9       	st.w	--sp,r9
80005fdc:	1a d9       	st.w	--sp,r9
80005fde:	12 98       	mov	r8,r9
80005fe0:	e0 6a 01 00 	mov	r10,256
80005fe4:	48 9b       	lddpc	r11,80006008 <vTaskStartScheduler+0x34>
80005fe6:	48 ac       	lddpc	r12,8000600c <vTaskStartScheduler+0x38>
80005fe8:	f0 1f 00 0a 	mcall	80006010 <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80005fec:	2f dd       	sub	sp,-12
80005fee:	58 1c       	cp.w	r12,1
80005ff0:	c0 a1       	brne	80006004 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
80005ff2:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80005ff4:	30 19       	mov	r9,1
80005ff6:	48 88       	lddpc	r8,80006014 <vTaskStartScheduler+0x40>
80005ff8:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80005ffa:	30 09       	mov	r9,0
80005ffc:	48 78       	lddpc	r8,80006018 <vTaskStartScheduler+0x44>
80005ffe:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
80006000:	f0 1f 00 07 	mcall	8000601c <vTaskStartScheduler+0x48>
80006004:	d8 02       	popm	pc
80006006:	00 00       	add	r0,r0
80006008:	80 00       	ld.sh	r0,r0[0x0]
8000600a:	7c 70       	ld.w	r0,lr[0x1c]
8000600c:	80 00       	ld.sh	r0,r0[0x0]
8000600e:	5d 70       	*unknown*
80006010:	80 00       	ld.sh	r0,r0[0x0]
80006012:	5d f0       	*unknown*
80006014:	00 00       	add	r0,r0
80006016:	cc 24       	brge	80005f9a <xTaskGenericCreate+0x1aa>
80006018:	00 00       	add	r0,r0
8000601a:	cd 14       	brge	80005fbc <xTaskGenericCreate+0x1cc>
8000601c:	80 00       	ld.sh	r0,r0[0x0]
8000601e:	56 dc       	stdsp	sp[0x1b4],r12

80006020 <get_and_send_periodic_data>:
		fsm_ecu_init(&ecu_data);
		wdt_enable(&opt);
	}
}

uint16_t get_and_send_periodic_data(fsm_ecu_data_t *ecu_data, uint16_t data_timer) {
80006020:	eb cd 40 c0 	pushm	r6-r7,lr
80006024:	18 96       	mov	r6,r12
80006026:	16 97       	mov	r7,r11
	if ((data_timer % TIMER_10_HZ) == 0) {
80006028:	16 98       	mov	r8,r11
8000602a:	5c 78       	castu.h	r8
8000602c:	e0 6b cc cd 	mov	r11,52429
80006030:	ea 1b cc cc 	orh	r11,0xcccc
80006034:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80006038:	f6 09 16 02 	lsr	r9,r11,0x2
8000603c:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006040:	12 18       	sub	r8,r9
80006042:	30 0a       	mov	r10,0
80006044:	f4 08 19 00 	cp.h	r8,r10
80006048:	c1 21       	brne	8000606c <get_and_send_periodic_data+0x4c>
		ecu_can_inverter_read_reg(VDC_REG);
8000604a:	e0 6c 00 eb 	mov	r12,235
8000604e:	f0 1f 00 2b 	mcall	800060f8 <get_and_send_periodic_data+0xd8>
		ecu_can_inverter_read_reg(RPM_REG);
80006052:	33 0c       	mov	r12,48
80006054:	f0 1f 00 29 	mcall	800060f8 <get_and_send_periodic_data+0xd8>
		ecu_can_send_fast_data(ecu_data->inverter_vdc, ecu_data->ecu_error, ecu_data->rpm, ecu_data->trq_cmd);
80006058:	ed 09 00 16 	ld.sh	r9,r6[22]
8000605c:	ed 1a 00 3c 	ld.uh	r10,r6[60]
80006060:	ed 1b 00 56 	ld.uh	r11,r6[86]
80006064:	ed 1c 00 3a 	ld.uh	r12,r6[58]
80006068:	f0 1f 00 25 	mcall	800060fc <get_and_send_periodic_data+0xdc>
	}
	
	if ((data_timer % TIMER_2_HZ) == 0) {
8000606c:	0e 98       	mov	r8,r7
8000606e:	5c 78       	castu.h	r8
80006070:	e0 6b 85 1f 	mov	r11,34079
80006074:	ea 1b 51 eb 	orh	r11,0x51eb
80006078:	f0 0b 06 4a 	mulu.d	r10,r8,r11
8000607c:	f6 09 16 03 	lsr	r9,r11,0x3
80006080:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006084:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006088:	12 18       	sub	r8,r9
8000608a:	30 0a       	mov	r10,0
8000608c:	f4 08 19 00 	cp.h	r8,r10
80006090:	c0 b1       	brne	800060a6 <get_and_send_periodic_data+0x86>
		if (ecu_data->state == STATE_ERROR) {
80006092:	6c 08       	ld.w	r8,r6[0x0]
80006094:	58 88       	cp.w	r8,8
80006096:	c0 51       	brne	800060a0 <get_and_send_periodic_data+0x80>
			ecu_can_send_alive(1);
80006098:	30 1c       	mov	r12,1
8000609a:	f0 1f 00 1a 	mcall	80006100 <get_and_send_periodic_data+0xe0>
8000609e:	c0 48       	rjmp	800060a6 <get_and_send_periodic_data+0x86>
			} else {
			ecu_can_send_alive(0);
800060a0:	30 0c       	mov	r12,0
800060a2:	f0 1f 00 18 	mcall	80006100 <get_and_send_periodic_data+0xe0>
		}
	}
	
	if ((data_timer % TIMER_1_HZ) == 0) {
800060a6:	0e 98       	mov	r8,r7
800060a8:	5c 78       	castu.h	r8
800060aa:	e0 6b 85 1f 	mov	r11,34079
800060ae:	ea 1b 51 eb 	orh	r11,0x51eb
800060b2:	f0 0b 06 4a 	mulu.d	r10,r8,r11
800060b6:	f6 09 16 04 	lsr	r9,r11,0x4
800060ba:	f2 09 10 32 	mul	r9,r9,50
800060be:	12 18       	sub	r8,r9
800060c0:	30 09       	mov	r9,0
800060c2:	f2 08 19 00 	cp.h	r8,r9
800060c6:	c1 51       	brne	800060f0 <get_and_send_periodic_data+0xd0>
		ecu_can_inverter_read_reg(MOTOR_TEMP_REG);
800060c8:	34 9c       	mov	r12,73
800060ca:	f0 1f 00 0c 	mcall	800060f8 <get_and_send_periodic_data+0xd8>
		ecu_can_inverter_read_reg(IGBT_TEMP_REG);
800060ce:	34 ac       	mov	r12,74
800060d0:	f0 1f 00 0a 	mcall	800060f8 <get_and_send_periodic_data+0xd8>
		ecu_can_send_slow_data(ecu_data->motor_temp, ecu_data->inverter_temp, ecu_data->config_max_trq);
800060d4:	ed 3a 00 65 	ld.ub	r10,r6[101]
800060d8:	ed 1b 00 40 	ld.uh	r11,r6[64]
800060dc:	ed 1c 00 3e 	ld.uh	r12,r6[62]
800060e0:	f0 1f 00 09 	mcall	80006104 <get_and_send_periodic_data+0xe4>
		save_state(&mcp2515_spiModule, ecu_data);
800060e4:	0c 9b       	mov	r11,r6
800060e6:	48 9c       	lddpc	r12,80006108 <get_and_send_periodic_data+0xe8>
800060e8:	f0 1f 00 09 	mcall	8000610c <get_and_send_periodic_data+0xec>
		data_timer = 0;
		asm("nop");
800060ec:	d7 03       	nop
800060ee:	30 07       	mov	r7,0
	}
	return data_timer;
800060f0:	0e 9c       	mov	r12,r7
800060f2:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060f6:	00 00       	add	r0,r0
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	2a d4       	sub	r4,-83
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	2a 98       	sub	r8,-87
80006100:	80 00       	ld.sh	r0,r0[0x0]
80006102:	29 00       	sub	r0,-112
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	2a 5c       	sub	r12,-91
80006108:	00 00       	add	r0,r0
8000610a:	d0 04       	*unknown*
8000610c:	80 00       	ld.sh	r0,r0[0x0]
8000610e:	31 f8       	mov	r8,31

80006110 <wdt_scheduler>:
		portEXIT_CRITICAL();
	}
}


void wdt_scheduler(void) {
80006110:	d4 01       	pushm	lr
	// Watchdog reset
	if(AVR32_PM.RCAUSE.wdt) {
80006112:	fe 78 04 00 	mov	r8,-64512
80006116:	f0 f8 01 80 	ld.w	r8,r8[384]
8000611a:	e2 18 00 08 	andl	r8,0x8,COH
8000611e:	c0 b0       	breq	80006134 <wdt_scheduler+0x24>
		power_on_reset = 0;
80006120:	30 09       	mov	r9,0
80006122:	49 38       	lddpc	r8,8000616c <wdt_scheduler+0x5c>
80006124:	b0 89       	st.b	r8[0x0],r9
		load_state(&mcp2515_spiModule, &ecu_data);
80006126:	49 3b       	lddpc	r11,80006170 <wdt_scheduler+0x60>
80006128:	49 3c       	lddpc	r12,80006174 <wdt_scheduler+0x64>
8000612a:	f0 1f 00 14 	mcall	80006178 <wdt_scheduler+0x68>
		wdt_reenable();
8000612e:	f0 1f 00 14 	mcall	8000617c <wdt_scheduler+0x6c>
80006132:	d8 02       	popm	pc
	} else if (AVR32_PM.RCAUSE.por) {
80006134:	fe 78 04 00 	mov	r8,-64512
80006138:	f0 f8 01 80 	ld.w	r8,r8[384]
8000613c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006140:	c0 b0       	breq	80006156 <wdt_scheduler+0x46>
		power_on_reset = 1;
80006142:	30 19       	mov	r9,1
80006144:	48 a8       	lddpc	r8,8000616c <wdt_scheduler+0x5c>
80006146:	b0 89       	st.b	r8[0x0],r9
		fsm_ecu_init(&ecu_data);
80006148:	48 ac       	lddpc	r12,80006170 <wdt_scheduler+0x60>
8000614a:	f0 1f 00 0e 	mcall	80006180 <wdt_scheduler+0x70>
		wdt_enable(&opt);
8000614e:	48 ec       	lddpc	r12,80006184 <wdt_scheduler+0x74>
80006150:	f0 1f 00 0e 	mcall	80006188 <wdt_scheduler+0x78>
80006154:	d8 02       	popm	pc
	} else {
		power_on_reset = 0;
80006156:	30 09       	mov	r9,0
80006158:	48 58       	lddpc	r8,8000616c <wdt_scheduler+0x5c>
8000615a:	b0 89       	st.b	r8[0x0],r9
		fsm_ecu_init(&ecu_data);
8000615c:	48 5c       	lddpc	r12,80006170 <wdt_scheduler+0x60>
8000615e:	f0 1f 00 09 	mcall	80006180 <wdt_scheduler+0x70>
		wdt_enable(&opt);
80006162:	48 9c       	lddpc	r12,80006184 <wdt_scheduler+0x74>
80006164:	f0 1f 00 09 	mcall	80006188 <wdt_scheduler+0x78>
80006168:	d8 02       	popm	pc
8000616a:	00 00       	add	r0,r0
8000616c:	00 00       	add	r0,r0
8000616e:	cd 5c       	rcall	80006318 <main+0x18c>
80006170:	00 00       	add	r0,r0
80006172:	cf 78       	rjmp	80006360 <task_watchdog+0x14>
80006174:	00 00       	add	r0,r0
80006176:	d0 04       	*unknown*
80006178:	80 00       	ld.sh	r0,r0[0x0]
8000617a:	30 ec       	mov	r12,14
8000617c:	80 00       	ld.sh	r0,r0[0x0]
8000617e:	21 e8       	sub	r8,30
80006180:	80 00       	ld.sh	r0,r0[0x0]
80006182:	35 68       	mov	r8,86
80006184:	00 00       	add	r0,r0
80006186:	01 d4       	ld.ub	r4,r0[0x5]
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	22 28       	sub	r8,34

8000618c <main>:
struct spi_device spi_init_module(void);
void wdt_scheduler(void);
uint16_t get_and_send_periodic_data(fsm_ecu_data_t *ecu_data, uint16_t data_timer);


int main(void){	
8000618c:	eb cd 40 e0 	pushm	r5-r7,lr
	board_init();
80006190:	f0 1f 00 50 	mcall	800062d0 <main+0x144>
	spi_init_pins();
80006194:	f0 1f 00 50 	mcall	800062d4 <main+0x148>
	mcp2515_spiModule = spi_init_module();
80006198:	f0 1f 00 50 	mcall	800062d8 <main+0x14c>
8000619c:	4d 08       	lddpc	r8,800062dc <main+0x150>
8000619e:	b0 8c       	st.b	r8[0x0],r12
	queue_from_inverter	= xQueueCreate(QUEUE_INVERTER_RX_LEN, sizeof(inverter_can_msg_t));
800061a0:	30 0a       	mov	r10,0
800061a2:	30 cb       	mov	r11,12
800061a4:	30 5c       	mov	r12,5
800061a6:	f0 1f 00 4f 	mcall	800062e0 <main+0x154>
800061aa:	4c f8       	lddpc	r8,800062e4 <main+0x158>
800061ac:	91 0c       	st.w	r8[0x0],r12
	queue_to_inverter	= xQueueCreate(QUEUE_INVERTER_RX_LEN+5, sizeof(inverter_can_msg_t));
800061ae:	30 0a       	mov	r10,0
800061b0:	30 cb       	mov	r11,12
800061b2:	30 ac       	mov	r12,10
800061b4:	f0 1f 00 4b 	mcall	800062e0 <main+0x154>
800061b8:	4c c8       	lddpc	r8,800062e8 <main+0x15c>
800061ba:	91 0c       	st.w	r8[0x0],r12
	queue_wheel_fl		= xQueueCreate(1, sizeof(uint16_t));	
800061bc:	30 0a       	mov	r10,0
800061be:	30 2b       	mov	r11,2
800061c0:	30 1c       	mov	r12,1
800061c2:	f0 1f 00 48 	mcall	800062e0 <main+0x154>
800061c6:	4c a8       	lddpc	r8,800062ec <main+0x160>
800061c8:	91 0c       	st.w	r8[0x0],r12
	queue_wheel_fr		= xQueueCreate(1, sizeof(uint16_t));	
800061ca:	30 0a       	mov	r10,0
800061cc:	30 2b       	mov	r11,2
800061ce:	30 1c       	mov	r12,1
800061d0:	f0 1f 00 44 	mcall	800062e0 <main+0x154>
800061d4:	4c 78       	lddpc	r8,800062f0 <main+0x164>
800061d6:	91 0c       	st.w	r8[0x0],r12
	queue_wheel_rl		= xQueueCreate(1, sizeof(uint16_t));	
800061d8:	30 0a       	mov	r10,0
800061da:	30 2b       	mov	r11,2
800061dc:	30 1c       	mov	r12,1
800061de:	f0 1f 00 41 	mcall	800062e0 <main+0x154>
800061e2:	4c 58       	lddpc	r8,800062f4 <main+0x168>
800061e4:	91 0c       	st.w	r8[0x0],r12
	queue_wheel_rr		= xQueueCreate(1, sizeof(uint16_t));
800061e6:	30 0a       	mov	r10,0
800061e8:	30 2b       	mov	r11,2
800061ea:	30 1c       	mov	r12,1
800061ec:	f0 1f 00 3d 	mcall	800062e0 <main+0x154>
800061f0:	4c 28       	lddpc	r8,800062f8 <main+0x16c>
800061f2:	91 0c       	st.w	r8[0x0],r12
	//queue_traction_control = xQueueCreate(1, sizeof(int16_t));
	queue_dash_msg		= xQueueCreate(QUEUE_DASH_MSG_LEN, sizeof(dash_can_msg_t));	
800061f4:	30 0a       	mov	r10,0
800061f6:	30 cb       	mov	r11,12
800061f8:	30 5c       	mov	r12,5
800061fa:	f0 1f 00 3a 	mcall	800062e0 <main+0x154>
800061fe:	4c 08       	lddpc	r8,800062fc <main+0x170>
80006200:	91 0c       	st.w	r8[0x0],r12
	queue_trq_sens0		= xQueueCreate(1, sizeof(int16_t));
80006202:	30 0a       	mov	r10,0
80006204:	30 2b       	mov	r11,2
80006206:	30 1c       	mov	r12,1
80006208:	f0 1f 00 36 	mcall	800062e0 <main+0x154>
8000620c:	4b d8       	lddpc	r8,80006300 <main+0x174>
8000620e:	91 0c       	st.w	r8[0x0],r12
	queue_trq_sens1		= xQueueCreate(1, sizeof(int16_t));
80006210:	30 0a       	mov	r10,0
80006212:	30 2b       	mov	r11,2
80006214:	30 1c       	mov	r12,1
80006216:	f0 1f 00 33 	mcall	800062e0 <main+0x154>
8000621a:	4b b8       	lddpc	r8,80006304 <main+0x178>
8000621c:	91 0c       	st.w	r8[0x0],r12
	queue_bms_rx		= xQueueCreate(QUEUE_BMS_RX_LEN, sizeof(bms_can_msg_t));
8000621e:	30 0a       	mov	r10,0
80006220:	30 cb       	mov	r11,12
80006222:	30 5c       	mov	r12,5
80006224:	f0 1f 00 2f 	mcall	800062e0 <main+0x154>
80006228:	4b 88       	lddpc	r8,80006308 <main+0x17c>
8000622a:	91 0c       	st.w	r8[0x0],r12
	queue_brake_front	= xQueueCreate(2, sizeof(uint16_t));
8000622c:	30 0a       	mov	r10,0
8000622e:	30 2b       	mov	r11,2
80006230:	16 9c       	mov	r12,r11
80006232:	f0 1f 00 2c 	mcall	800062e0 <main+0x154>
80006236:	4b 68       	lddpc	r8,8000630c <main+0x180>
80006238:	91 0c       	st.w	r8[0x0],r12
	queue_brake_rear	= xQueueCreate(2, sizeof(uint16_t));
8000623a:	30 0a       	mov	r10,0
8000623c:	30 2b       	mov	r11,2
8000623e:	16 9c       	mov	r12,r11
80006240:	f0 1f 00 28 	mcall	800062e0 <main+0x154>
80006244:	4b 38       	lddpc	r8,80006310 <main+0x184>
80006246:	91 0c       	st.w	r8[0x0],r12
	queue_bspd			= xQueueCreate(1, sizeof(uint8_t));
80006248:	30 0a       	mov	r10,0
8000624a:	30 1b       	mov	r11,1
8000624c:	16 9c       	mov	r12,r11
8000624e:	f0 1f 00 25 	mcall	800062e0 <main+0x154>
80006252:	4b 18       	lddpc	r8,80006314 <main+0x188>
80006254:	91 0c       	st.w	r8[0x0],r12
	queue_trq_sens0_err = xQueueCreate(1, sizeof(uint8_t));
80006256:	30 0a       	mov	r10,0
80006258:	30 1b       	mov	r11,1
8000625a:	16 9c       	mov	r12,r11
8000625c:	f0 1f 00 21 	mcall	800062e0 <main+0x154>
80006260:	4a e8       	lddpc	r8,80006318 <main+0x18c>
80006262:	91 0c       	st.w	r8[0x0],r12
	queue_trq_sens1_err = xQueueCreate(1, sizeof(uint8_t));
80006264:	30 0a       	mov	r10,0
80006266:	30 1b       	mov	r11,1
80006268:	16 9c       	mov	r12,r11
8000626a:	f0 1f 00 1e 	mcall	800062e0 <main+0x154>
8000626e:	4a c8       	lddpc	r8,8000631c <main+0x190>
80006270:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
80006272:	4a c5       	lddpc	r5,80006320 <main+0x194>
80006274:	30 07       	mov	r7,0
80006276:	1a d7       	st.w	--sp,r7
80006278:	1a d7       	st.w	--sp,r7
8000627a:	4a b6       	lddpc	r6,80006324 <main+0x198>
8000627c:	1a d6       	st.w	--sp,r6
8000627e:	30 18       	mov	r8,1
80006280:	0a 99       	mov	r9,r5
80006282:	e0 6a 01 00 	mov	r10,256
80006286:	4a 9b       	lddpc	r11,80006328 <main+0x19c>
80006288:	4a 9c       	lddpc	r12,8000632c <main+0x1a0>
8000628a:	f0 1f 00 2a 	mcall	80006330 <main+0x1a4>
		, (void *) &task_check_alive[0]
		, TASK_MAIN_PRIORITY
		, (xTaskHandle *) &task_handles[0]
	);
	
 	xTaskCreate(
8000628e:	1a d7       	st.w	--sp,r7
80006290:	1a d7       	st.w	--sp,r7
80006292:	2f c6       	sub	r6,-4
80006294:	1a d6       	st.w	--sp,r6
80006296:	30 18       	mov	r8,1
80006298:	ea c9 ff fc 	sub	r9,r5,-4
8000629c:	e0 6a 01 00 	mov	r10,256
800062a0:	4a 5b       	lddpc	r11,80006334 <main+0x1a8>
800062a2:	4a 6c       	lddpc	r12,80006338 <main+0x1ac>
800062a4:	f0 1f 00 23 	mcall	80006330 <main+0x1a4>
 		, (void *) &task_check_alive[1]
 		, TASK_SPI_CAN_PRIORITY
 		, (xTaskHandle *) &task_handles[1]
 	);
	 	 
	xTaskCreate(
800062a8:	1a d7       	st.w	--sp,r7
800062aa:	1a d7       	st.w	--sp,r7
800062ac:	1a d7       	st.w	--sp,r7
800062ae:	30 28       	mov	r8,2
800062b0:	0e 99       	mov	r9,r7
800062b2:	e0 6a 01 00 	mov	r10,256
800062b6:	4a 2b       	lddpc	r11,8000633c <main+0x1b0>
800062b8:	4a 2c       	lddpc	r12,80006340 <main+0x1b4>
800062ba:	f0 1f 00 1e 	mcall	80006330 <main+0x1a4>
	 	, TASK_WATCHDOG_PRIORITY
	 	, NULL
	);
		
	#ifdef USE_WDT
		wdt_scheduler();
800062be:	2f 7d       	sub	sp,-36
800062c0:	f0 1f 00 21 	mcall	80006344 <main+0x1b8>
	#else
		fsm_ecu_init(&ecu_data);
	#endif
	vTaskStartScheduler();
800062c4:	f0 1f 00 21 	mcall	80006348 <main+0x1bc>
}
800062c8:	0e 9c       	mov	r12,r7
800062ca:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800062ce:	00 00       	add	r0,r0
800062d0:	80 00       	ld.sh	r0,r0[0x0]
800062d2:	6c 44       	ld.w	r4,r6[0x10]
800062d4:	80 00       	ld.sh	r0,r0[0x0]
800062d6:	35 54       	mov	r4,85
800062d8:	80 00       	ld.sh	r0,r0[0x0]
800062da:	34 cc       	mov	r12,76
800062dc:	00 00       	add	r0,r0
800062de:	d0 04       	*unknown*
800062e0:	80 00       	ld.sh	r0,r0[0x0]
800062e2:	30 44       	mov	r4,4
800062e4:	00 00       	add	r0,r0
800062e6:	cf 3c       	rcall	800064cc <task_spi_can+0xc8>
800062e8:	00 00       	add	r0,r0
800062ea:	cf 48       	rjmp	800064d2 <task_spi_can+0xce>
800062ec:	00 00       	add	r0,r0
800062ee:	cf 5c       	rcall	800064d8 <task_spi_can+0xd4>
800062f0:	00 00       	add	r0,r0
800062f2:	cf 54       	brge	800062dc <main+0x150>
800062f4:	00 00       	add	r0,r0
800062f6:	cf 68       	rjmp	800064e2 <task_spi_can+0xde>
800062f8:	00 00       	add	r0,r0
800062fa:	cf 50       	breq	800062e4 <main+0x158>
800062fc:	00 00       	add	r0,r0
800062fe:	cf 60       	breq	800062ea <main+0x15e>
80006300:	00 00       	add	r0,r0
80006302:	cf 44       	brge	800062ea <main+0x15e>
80006304:	00 00       	add	r0,r0
80006306:	cf 6c       	rcall	800064f2 <task_spi_can+0xee>
80006308:	00 00       	add	r0,r0
8000630a:	cf 38       	rjmp	800064f0 <task_spi_can+0xec>
8000630c:	00 00       	add	r0,r0
8000630e:	cf 74       	brge	800062fc <main+0x170>
80006310:	00 00       	add	r0,r0
80006312:	cf 4c       	rcall	800064fa <task_spi_can+0xf6>
80006314:	00 00       	add	r0,r0
80006316:	cf 64       	brge	80006302 <main+0x176>
80006318:	00 00       	add	r0,r0
8000631a:	cf 70       	breq	80006308 <main+0x17c>
8000631c:	00 00       	add	r0,r0
8000631e:	cf 58       	rjmp	80006508 <task_spi_can+0x104>
80006320:	00 00       	add	r0,r0
80006322:	cd 60       	breq	800062ce <main+0x142>
80006324:	00 00       	add	r0,r0
80006326:	cd 54       	brge	800062d0 <main+0x144>
80006328:	80 00       	ld.sh	r0,r0[0x0]
8000632a:	7c 78       	ld.w	r8,lr[0x1c]
8000632c:	80 00       	ld.sh	r0,r0[0x0]
8000632e:	65 6c       	ld.w	r12,r2[0x58]
80006330:	80 00       	ld.sh	r0,r0[0x0]
80006332:	5d f0       	*unknown*
80006334:	80 00       	ld.sh	r0,r0[0x0]
80006336:	7c 84       	ld.w	r4,lr[0x20]
80006338:	80 00       	ld.sh	r0,r0[0x0]
8000633a:	64 04       	ld.w	r4,r2[0x0]
8000633c:	80 00       	ld.sh	r0,r0[0x0]
8000633e:	7c 90       	ld.w	r0,lr[0x24]
80006340:	80 00       	ld.sh	r0,r0[0x0]
80006342:	63 4c       	ld.w	r12,r1[0x50]
80006344:	80 00       	ld.sh	r0,r0[0x0]
80006346:	61 10       	ld.w	r0,r0[0x44]
80006348:	80 00       	ld.sh	r0,r0[0x0]
8000634a:	5f d4       	srvc	r4

8000634c <task_watchdog>:


static portTASK_FUNCTION(task_watchdog, pvParameters) {
8000634c:	d4 31       	pushm	r0-r7,lr
8000634e:	20 1d       	sub	sp,4
	portTickType first_run = xTaskGetTickCount();
80006350:	f0 1f 00 22 	mcall	800063d8 <task_watchdog+0x8c>
80006354:	fa c2 ff fc 	sub	r2,sp,-4
80006358:	04 dc       	st.w	--r2,r12
	short task;
	static uint8_t seppuku = 0;
	static uint8_t por_timer = 0;
	while (1) {
		vTaskDelayUntil(&first_run, TASK_WATCHDOG_PERIOD);
8000635a:	33 c1       	mov	r1,60
		 * Check if tasks update their flags. If not, restart ECU by not
		 * clearing the watchdog timer.
		 */
		portENTER_CRITICAL();
		for (task = 0; task < NUMBER_OF_TASKS-1; task++) {
			if (task_check_alive[task] == pdFALSE) {
8000635c:	4a 07       	lddpc	r7,800063dc <task_watchdog+0x90>
				seppuku++;
8000635e:	4a 16       	lddpc	r6,800063e0 <task_watchdog+0x94>
				gpio_set_pin_high(LED1);	
			}
			/* Task has well-behaved. Reset flag and wait for next round. */
			task_check_alive[task] = pdFALSE;
80006360:	30 05       	mov	r5,0
		}
		
		if (power_on_reset == 1) {
80006362:	4a 10       	lddpc	r0,800063e4 <task_watchdog+0x98>
80006364:	30 13       	mov	r3,1
		} else {
			por_timer = 0;
		}
		
		if (por_timer < 10) {
			if (!seppuku) {
80006366:	30 04       	mov	r4,0
	portTickType first_run = xTaskGetTickCount();
	short task;
	static uint8_t seppuku = 0;
	static uint8_t por_timer = 0;
	while (1) {
		vTaskDelayUntil(&first_run, TASK_WATCHDOG_PERIOD);
80006368:	02 9b       	mov	r11,r1
8000636a:	1a 9c       	mov	r12,sp
8000636c:	f0 1f 00 1f 	mcall	800063e8 <task_watchdog+0x9c>
		/* Perform routine work.
		 * Check if tasks update their flags. If not, restart ECU by not
		 * clearing the watchdog timer.
		 */
		portENTER_CRITICAL();
80006370:	f0 1f 00 1f 	mcall	800063ec <task_watchdog+0xa0>
		for (task = 0; task < NUMBER_OF_TASKS-1; task++) {
			if (task_check_alive[task] == pdFALSE) {
80006374:	6e 08       	ld.w	r8,r7[0x0]
80006376:	58 08       	cp.w	r8,0
80006378:	c0 71       	brne	80006386 <task_watchdog+0x3a>
				seppuku++;
8000637a:	0d 88       	ld.ub	r8,r6[0x0]
8000637c:	2f f8       	sub	r8,-1
8000637e:	ac 88       	st.b	r6[0x0],r8
				gpio_set_pin_high(LED1);	
80006380:	35 3c       	mov	r12,83
80006382:	f0 1f 00 1c 	mcall	800063f0 <task_watchdog+0xa4>
			}
			/* Task has well-behaved. Reset flag and wait for next round. */
			task_check_alive[task] = pdFALSE;
80006386:	8f 05       	st.w	r7[0x0],r5
		 * Check if tasks update their flags. If not, restart ECU by not
		 * clearing the watchdog timer.
		 */
		portENTER_CRITICAL();
		for (task = 0; task < NUMBER_OF_TASKS-1; task++) {
			if (task_check_alive[task] == pdFALSE) {
80006388:	6e 18       	ld.w	r8,r7[0x4]
8000638a:	58 08       	cp.w	r8,0
8000638c:	c0 71       	brne	8000639a <task_watchdog+0x4e>
				seppuku++;
8000638e:	0d 88       	ld.ub	r8,r6[0x0]
80006390:	2f f8       	sub	r8,-1
80006392:	ac 88       	st.b	r6[0x0],r8
				gpio_set_pin_high(LED1);	
80006394:	35 3c       	mov	r12,83
80006396:	f0 1f 00 17 	mcall	800063f0 <task_watchdog+0xa4>
			}
			/* Task has well-behaved. Reset flag and wait for next round. */
			task_check_alive[task] = pdFALSE;
8000639a:	8f 15       	st.w	r7[0x4],r5
		}
		
		if (power_on_reset == 1) {
8000639c:	01 88       	ld.ub	r8,r0[0x0]
8000639e:	e6 08 18 00 	cp.b	r8,r3
800063a2:	c0 b1       	brne	800063b8 <task_watchdog+0x6c>
			por_timer++;
800063a4:	49 49       	lddpc	r9,800063f4 <task_watchdog+0xa8>
800063a6:	13 88       	ld.ub	r8,r9[0x0]
800063a8:	2f f8       	sub	r8,-1
800063aa:	b2 88       	st.b	r9[0x0],r8
		} else {
			por_timer = 0;
		}
		
		if (por_timer < 10) {
800063ac:	30 99       	mov	r9,9
800063ae:	f2 08 18 00 	cp.b	r8,r9
800063b2:	e0 8b 00 0d 	brhi	800063cc <task_watchdog+0x80>
800063b6:	c0 38       	rjmp	800063bc <task_watchdog+0x70>
		}
		
		if (power_on_reset == 1) {
			por_timer++;
		} else {
			por_timer = 0;
800063b8:	48 f8       	lddpc	r8,800063f4 <task_watchdog+0xa8>
800063ba:	b0 84       	st.b	r8[0x0],r4
		}
		
		if (por_timer < 10) {
			if (!seppuku) {
800063bc:	0d 88       	ld.ub	r8,r6[0x0]
800063be:	e8 08 18 00 	cp.b	r8,r4
800063c2:	c0 41       	brne	800063ca <task_watchdog+0x7e>
				/* Clear watchdog timer */
				wdt_clear();
800063c4:	f0 1f 00 0d 	mcall	800063f8 <task_watchdog+0xac>
800063c8:	c0 28       	rjmp	800063cc <task_watchdog+0x80>
			} else {
				asm("nop");
800063ca:	d7 03       	nop
			}
		}
		portEXIT_CRITICAL();
800063cc:	f0 1f 00 0c 	mcall	800063fc <task_watchdog+0xb0>
		gpio_toggle_pin(LED2);
800063d0:	35 2c       	mov	r12,82
800063d2:	f0 1f 00 0c 	mcall	80006400 <task_watchdog+0xb4>
	}
800063d6:	cc 9b       	rjmp	80006368 <task_watchdog+0x1c>
800063d8:	80 00       	ld.sh	r0,r0[0x0]
800063da:	59 9c       	cp.w	r12,25
800063dc:	00 00       	add	r0,r0
800063de:	cd 60       	breq	8000638a <task_watchdog+0x3e>
800063e0:	00 00       	add	r0,r0
800063e2:	cd 5d       	rcall	8000678c <gpio_configure_pin+0xa8>
800063e4:	00 00       	add	r0,r0
800063e6:	cd 5c       	rcall	80006590 <task_main+0x24>
800063e8:	80 00       	ld.sh	r0,r0[0x0]
800063ea:	5c 98       	brev	r8
800063ec:	80 00       	ld.sh	r0,r0[0x0]
800063ee:	56 cc       	stdsp	sp[0x1b0],r12
800063f0:	80 00       	ld.sh	r0,r0[0x0]
800063f2:	68 2a       	ld.w	r10,r4[0x8]
800063f4:	00 00       	add	r0,r0
800063f6:	cd 68       	rjmp	800065a2 <task_main+0x36>
800063f8:	80 00       	ld.sh	r0,r0[0x0]
800063fa:	22 04       	sub	r4,32
800063fc:	80 00       	ld.sh	r0,r0[0x0]
800063fe:	57 d8       	stdsp	sp[0x1f4],r8
80006400:	80 00       	ld.sh	r0,r0[0x0]
80006402:	68 56       	ld.w	r6,r4[0x14]

80006404 <task_spi_can>:
		portEXIT_CRITICAL();	
		gpio_toggle_pin(LED4);
	}
}
	
static portTASK_FUNCTION(task_spi_can, pvParameters) {
80006404:	d4 31       	pushm	r0-r7,lr
80006406:	20 4d       	sub	sp,16
80006408:	18 92       	mov	r2,r12
	volatile signed portBASE_TYPE *pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
	portTickType first_run = xTaskGetTickCount();
8000640a:	f0 1f 00 4a 	mcall	80006530 <task_spi_can+0x12c>
8000640e:	fa c3 ff f0 	sub	r3,sp,-16
80006412:	06 dc       	st.w	--r3,r12
	inverter_can_msg_t inverter_can_msg;
	mcp2515_init (&mcp2515_spiModule);
80006414:	4c 8c       	lddpc	r12,80006534 <task_spi_can+0x130>
80006416:	f0 1f 00 49 	mcall	80006538 <task_spi_can+0x134>
	
	while(1) {
		vTaskDelayUntil(&first_run, TASK_SPI_CAN_PERIOD);
8000641a:	30 51       	mov	r1,5
8000641c:	36 e0       	mov	r0,110
		if (gpio_pin_is_low(INT1)) { // Data has been received. Start reception of data
			//portENTER_CRITICAL(); // unsure if this is necessary?
			
			uint8_t canintfRegister;
			canintfRegister = mcp2515_readRegister(&mcp2515_spiModule,CANINTF); // read the interrupt register
8000641e:	4c 67       	lddpc	r7,80006534 <task_spi_can+0x130>
				
			}
			
			if ( messageReceivedOnBuffer1){
				inverter_can_msg.data.u64 = 0x00L;
				inverter_can_msg.dlc = mcp2515_getReceivedMessage(&mcp2515_spiModule,1,inverter_can_msg.data.u8,6);
80006420:	30 14       	mov	r4,1
	portTickType first_run = xTaskGetTickCount();
	inverter_can_msg_t inverter_can_msg;
	mcp2515_init (&mcp2515_spiModule);
	
	while(1) {
		vTaskDelayUntil(&first_run, TASK_SPI_CAN_PERIOD);
80006422:	02 9b       	mov	r11,r1
80006424:	06 9c       	mov	r12,r3
80006426:	f0 1f 00 46 	mcall	8000653c <task_spi_can+0x138>
8000642a:	00 9c       	mov	r12,r0
8000642c:	f0 1f 00 45 	mcall	80006540 <task_spi_can+0x13c>
		if (gpio_pin_is_low(INT1)) { // Data has been received. Start reception of data
80006430:	c3 31       	brne	80006496 <task_spi_can+0x92>
			//portENTER_CRITICAL(); // unsure if this is necessary?
			
			uint8_t canintfRegister;
			canintfRegister = mcp2515_readRegister(&mcp2515_spiModule,CANINTF); // read the interrupt register
80006432:	32 cb       	mov	r11,44
80006434:	0e 9c       	mov	r12,r7
80006436:	f0 1f 00 44 	mcall	80006544 <task_spi_can+0x140>
			
			bool messageReceivedOnBuffer0 = canintfRegister & ( 1 << RX0IF);	// determine where messages have come from
8000643a:	18 96       	mov	r6,r12
			bool messageReceivedOnBuffer1 = canintfRegister & ( 1 << RX1IF);
			
			if ( messageReceivedOnBuffer0){
8000643c:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
80006440:	c1 60       	breq	8000646c <task_spi_can+0x68>
				gpio_toggle_pin(LED3);
80006442:	35 1c       	mov	r12,81
80006444:	f0 1f 00 41 	mcall	80006548 <task_spi_can+0x144>
				inverter_can_msg.data.u64 = 0x00L;
80006448:	30 08       	mov	r8,0
8000644a:	30 09       	mov	r9,0
8000644c:	fa e9 00 00 	st.d	sp[0],r8
				inverter_can_msg.dlc = mcp2515_getReceivedMessage(&mcp2515_spiModule,0,inverter_can_msg.data.u8,6);
80006450:	30 69       	mov	r9,6
80006452:	1a 9a       	mov	r10,sp
80006454:	30 0b       	mov	r11,0
80006456:	0e 9c       	mov	r12,r7
80006458:	f0 1f 00 3d 	mcall	8000654c <task_spi_can+0x148>
8000645c:	50 2c       	stdsp	sp[0x8],r12
				xQueueSendToBack( queue_from_inverter, &inverter_can_msg, 0 );
8000645e:	30 09       	mov	r9,0
80006460:	12 9a       	mov	r10,r9
80006462:	1a 9b       	mov	r11,sp
80006464:	4b b8       	lddpc	r8,80006550 <task_spi_can+0x14c>
80006466:	70 0c       	ld.w	r12,r8[0x0]
80006468:	f0 1f 00 3b 	mcall	80006554 <task_spi_can+0x150>
				
			}
			
			if ( messageReceivedOnBuffer1){
8000646c:	e2 16 00 02 	andl	r6,0x2,COH
80006470:	c1 30       	breq	80006496 <task_spi_can+0x92>
				inverter_can_msg.data.u64 = 0x00L;
80006472:	30 08       	mov	r8,0
80006474:	30 09       	mov	r9,0
80006476:	fa e9 00 00 	st.d	sp[0],r8
				inverter_can_msg.dlc = mcp2515_getReceivedMessage(&mcp2515_spiModule,1,inverter_can_msg.data.u8,6);
8000647a:	30 69       	mov	r9,6
8000647c:	1a 9a       	mov	r10,sp
8000647e:	08 9b       	mov	r11,r4
80006480:	0e 9c       	mov	r12,r7
80006482:	f0 1f 00 33 	mcall	8000654c <task_spi_can+0x148>
80006486:	50 2c       	stdsp	sp[0x8],r12
				xQueueSendToBack( queue_from_inverter, &inverter_can_msg, 0 );
80006488:	30 09       	mov	r9,0
8000648a:	12 9a       	mov	r10,r9
8000648c:	1a 9b       	mov	r11,sp
8000648e:	4b 18       	lddpc	r8,80006550 <task_spi_can+0x14c>
80006490:	70 0c       	ld.w	r12,r8[0x0]
80006492:	f0 1f 00 31 	mcall	80006554 <task_spi_can+0x150>
			
			//portEXIT_CRITICAL();
		}
		

		uint8_t TXBuffer0controlReg = mcp2515_readRegister(&mcp2515_spiModule, TXB0CTRL);	//check if transmit register 0 is ready to receive new data
80006496:	33 0b       	mov	r11,48
80006498:	0e 9c       	mov	r12,r7
8000649a:	f0 1f 00 2b 	mcall	80006544 <task_spi_can+0x140>
8000649e:	18 95       	mov	r5,r12
		bool TXbuffer0Empty = !(TXBuffer0controlReg & (1 << TXREQ));
		uint8_t TXBuffer1controlReg = mcp2515_readRegister(&mcp2515_spiModule, TXB1CTRL); //check if transmit register 1 is ready to receive new data
800064a0:	34 0b       	mov	r11,64
800064a2:	0e 9c       	mov	r12,r7
800064a4:	f0 1f 00 28 	mcall	80006544 <task_spi_can+0x140>
800064a8:	18 96       	mov	r6,r12
		bool TXbuffer1Empty = !(TXBuffer1controlReg & ( 1 << TXREQ));
		
		bool messageSent = false;	
				
		if ( TXbuffer0Empty && !messageSent){
800064aa:	e2 15 00 08 	andl	r5,0x8,COH
800064ae:	c1 a1       	brne	800064e2 <task_spi_can+0xde>
			inverter_can_msg.dlc = 0;
800064b0:	30 0a       	mov	r10,0
800064b2:	50 2a       	stdsp	sp[0x8],r10
			inverter_can_msg.data.u64 = 0x00L;
800064b4:	30 08       	mov	r8,0
800064b6:	30 09       	mov	r9,0
800064b8:	fa e9 00 00 	st.d	sp[0],r8
			
			if ( xQueueReceive(queue_to_inverter, &inverter_can_msg,0) == pdTRUE){
800064bc:	14 99       	mov	r9,r10
800064be:	1a 9b       	mov	r11,sp
800064c0:	4a 68       	lddpc	r8,80006558 <task_spi_can+0x154>
800064c2:	70 0c       	ld.w	r12,r8[0x0]
800064c4:	f0 1f 00 26 	mcall	8000655c <task_spi_can+0x158>
800064c8:	58 1c       	cp.w	r12,1
800064ca:	c0 c1       	brne	800064e2 <task_spi_can+0xde>
				mcp2515_sendCanMessage(&mcp2515_spiModule,inverter_can_msg.dlc,inverter_can_msg.data.u8,INVERTER_ADDR_RX,0);
800064cc:	30 08       	mov	r8,0
800064ce:	e0 69 01 00 	mov	r9,256
800064d2:	1a 9a       	mov	r10,sp
800064d4:	fb 3b 00 0b 	ld.ub	r11,sp[11]
800064d8:	0e 9c       	mov	r12,r7
800064da:	f0 1f 00 22 	mcall	80006560 <task_spi_can+0x15c>
800064de:	08 98       	mov	r8,r4
800064e0:	c0 28       	rjmp	800064e4 <task_spi_can+0xe0>
800064e2:	30 08       	mov	r8,0
				messageSent = true;
			}
		}
		
		if ( TXbuffer1Empty && !messageSent){
800064e4:	e2 16 00 08 	andl	r6,0x8,COH
800064e8:	c1 a1       	brne	8000651c <task_spi_can+0x118>
800064ea:	58 08       	cp.w	r8,0
800064ec:	c1 81       	brne	8000651c <task_spi_can+0x118>
			inverter_can_msg.dlc = 0;
800064ee:	30 0a       	mov	r10,0
800064f0:	50 2a       	stdsp	sp[0x8],r10
			inverter_can_msg.data.u64 = 0x00L;
800064f2:	30 08       	mov	r8,0
800064f4:	30 09       	mov	r9,0
800064f6:	fa e9 00 00 	st.d	sp[0],r8
			
			if (xQueueReceive(queue_to_inverter, & inverter_can_msg,0) == pdTRUE){
800064fa:	14 99       	mov	r9,r10
800064fc:	1a 9b       	mov	r11,sp
800064fe:	49 78       	lddpc	r8,80006558 <task_spi_can+0x154>
80006500:	70 0c       	ld.w	r12,r8[0x0]
80006502:	f0 1f 00 17 	mcall	8000655c <task_spi_can+0x158>
80006506:	58 1c       	cp.w	r12,1
80006508:	c0 a1       	brne	8000651c <task_spi_can+0x118>
				mcp2515_sendCanMessage(&mcp2515_spiModule,inverter_can_msg.dlc,inverter_can_msg.data.u8,INVERTER_ADDR_RX,1);
8000650a:	08 98       	mov	r8,r4
8000650c:	e0 69 01 00 	mov	r9,256
80006510:	1a 9a       	mov	r10,sp
80006512:	fb 3b 00 0b 	ld.ub	r11,sp[11]
80006516:	0e 9c       	mov	r12,r7
80006518:	f0 1f 00 12 	mcall	80006560 <task_spi_can+0x15c>
				messageSent = true;
			}
		}
		gpio_toggle_pin(LED3);
8000651c:	35 1c       	mov	r12,81
8000651e:	f0 1f 00 0b 	mcall	80006548 <task_spi_can+0x144>
		portENTER_CRITICAL();
80006522:	f0 1f 00 11 	mcall	80006564 <task_spi_can+0x160>
		*pxTaskHasExecuted = pdTRUE;
80006526:	85 04       	st.w	r2[0x0],r4
		portEXIT_CRITICAL();
80006528:	f0 1f 00 10 	mcall	80006568 <task_spi_can+0x164>
	}
8000652c:	c7 bb       	rjmp	80006422 <task_spi_can+0x1e>
8000652e:	00 00       	add	r0,r0
80006530:	80 00       	ld.sh	r0,r0[0x0]
80006532:	59 9c       	cp.w	r12,25
80006534:	00 00       	add	r0,r0
80006536:	d0 04       	*unknown*
80006538:	80 00       	ld.sh	r0,r0[0x0]
8000653a:	33 6c       	mov	r12,54
8000653c:	80 00       	ld.sh	r0,r0[0x0]
8000653e:	5c 98       	brev	r8
80006540:	80 00       	ld.sh	r0,r0[0x0]
80006542:	68 14       	ld.w	r4,r4[0x4]
80006544:	80 00       	ld.sh	r0,r0[0x0]
80006546:	32 88       	mov	r8,40
80006548:	80 00       	ld.sh	r0,r0[0x0]
8000654a:	68 56       	ld.w	r6,r4[0x14]
8000654c:	80 00       	ld.sh	r0,r0[0x0]
8000654e:	33 e8       	mov	r8,62
80006550:	00 00       	add	r0,r0
80006552:	cf 3c       	rcall	80006738 <gpio_configure_pin+0x54>
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	2e c8       	sub	r8,-20
80006558:	00 00       	add	r0,r0
8000655a:	cf 48       	rjmp	80006742 <gpio_configure_pin+0x5e>
8000655c:	80 00       	ld.sh	r0,r0[0x0]
8000655e:	2d ac       	sub	r12,-38
80006560:	80 00       	ld.sh	r0,r0[0x0]
80006562:	34 40       	mov	r0,68
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	56 cc       	stdsp	sp[0x1b0],r12
80006568:	80 00       	ld.sh	r0,r0[0x0]
8000656a:	57 d8       	stdsp	sp[0x1f4],r8

8000656c <task_main>:
		gpio_toggle_pin(LED2);
	}
}


static portTASK_FUNCTION( task_main, pvParameters ) {	
8000656c:	eb cd 40 fe 	pushm	r1-r7,lr
80006570:	20 1d       	sub	sp,4
80006572:	18 94       	mov	r4,r12
	volatile signed portBASE_TYPE *pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
	ecu_can_inverter_disable_drive();
80006574:	f0 1f 00 14 	mcall	800065c4 <task_main+0x58>
	portTickType first_run = xTaskGetTickCount();
80006578:	f0 1f 00 14 	mcall	800065c8 <task_main+0x5c>
8000657c:	fa c5 ff fc 	sub	r5,sp,-4
80006580:	0a dc       	st.w	--r5,r12
	while(1) {
		vTaskDelayUntil(&first_run, TASK_MAIN_PERIOD);
80006582:	31 43       	mov	r3,20
		/* Run state machine */
		ecu_data.state = fsm_ecu_run_state(ecu_data.state, &ecu_data);
80006584:	49 26       	lddpc	r6,800065cc <task_main+0x60>
		data_timer = get_and_send_periodic_data(&ecu_data, data_timer);
80006586:	49 37       	lddpc	r7,800065d0 <task_main+0x64>
	
		portENTER_CRITICAL();
		data_timer++;
		*pxTaskHasExecuted = pdTRUE;
80006588:	30 12       	mov	r2,1
		portEXIT_CRITICAL();	
		gpio_toggle_pin(LED4);
8000658a:	35 01       	mov	r1,80
static portTASK_FUNCTION( task_main, pvParameters ) {	
	volatile signed portBASE_TYPE *pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
	ecu_can_inverter_disable_drive();
	portTickType first_run = xTaskGetTickCount();
	while(1) {
		vTaskDelayUntil(&first_run, TASK_MAIN_PERIOD);
8000658c:	06 9b       	mov	r11,r3
8000658e:	1a 9c       	mov	r12,sp
80006590:	f0 1f 00 11 	mcall	800065d4 <task_main+0x68>
		/* Run state machine */
		ecu_data.state = fsm_ecu_run_state(ecu_data.state, &ecu_data);
80006594:	0c 9b       	mov	r11,r6
80006596:	6c 0c       	ld.w	r12,r6[0x0]
80006598:	f0 1f 00 10 	mcall	800065d8 <task_main+0x6c>
8000659c:	8d 0c       	st.w	r6[0x0],r12
		data_timer = get_and_send_periodic_data(&ecu_data, data_timer);
8000659e:	8e 0b       	ld.sh	r11,r7[0x0]
800065a0:	5c 7b       	castu.h	r11
800065a2:	0c 9c       	mov	r12,r6
800065a4:	f0 1f 00 0e 	mcall	800065dc <task_main+0x70>
800065a8:	ae 0c       	st.h	r7[0x0],r12
	
		portENTER_CRITICAL();
800065aa:	f0 1f 00 0e 	mcall	800065e0 <task_main+0x74>
		data_timer++;
800065ae:	8e 08       	ld.sh	r8,r7[0x0]
800065b0:	2f f8       	sub	r8,-1
800065b2:	ae 08       	st.h	r7[0x0],r8
		*pxTaskHasExecuted = pdTRUE;
800065b4:	89 02       	st.w	r4[0x0],r2
		portEXIT_CRITICAL();	
800065b6:	f0 1f 00 0c 	mcall	800065e4 <task_main+0x78>
		gpio_toggle_pin(LED4);
800065ba:	02 9c       	mov	r12,r1
800065bc:	f0 1f 00 0b 	mcall	800065e8 <task_main+0x7c>
800065c0:	ce 6b       	rjmp	8000658c <task_main+0x20>
800065c2:	00 00       	add	r0,r0
800065c4:	80 00       	ld.sh	r0,r0[0x0]
800065c6:	2b 78       	sub	r8,-73
800065c8:	80 00       	ld.sh	r0,r0[0x0]
800065ca:	59 9c       	cp.w	r12,25
800065cc:	00 00       	add	r0,r0
800065ce:	cf 78       	rjmp	800067bc <gpio_configure_pin+0xd8>
800065d0:	00 00       	add	r0,r0
800065d2:	01 d0       	ld.ub	r0,r0[0x5]
800065d4:	80 00       	ld.sh	r0,r0[0x0]
800065d6:	5c 98       	brev	r8
800065d8:	80 00       	ld.sh	r0,r0[0x0]
800065da:	36 48       	mov	r8,100
800065dc:	80 00       	ld.sh	r0,r0[0x0]
800065de:	60 20       	ld.w	r0,r0[0x8]
800065e0:	80 00       	ld.sh	r0,r0[0x0]
800065e2:	56 cc       	stdsp	sp[0x1b0],r12
800065e4:	80 00       	ld.sh	r0,r0[0x0]
800065e6:	57 d8       	stdsp	sp[0x1f4],r8
800065e8:	80 00       	ld.sh	r0,r0[0x0]
800065ea:	68 56       	ld.w	r6,r4[0x14]

800065ec <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800065ec:	fe 68 00 00 	mov	r8,-131072
800065f0:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800065f2:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800065f6:	91 09       	st.w	r8[0x0],r9
}
800065f8:	5e fc       	retal	r12
800065fa:	d7 03       	nop

800065fc <flashc_set_bus_freq>:


void flashc_set_bus_freq(unsigned int cpu_f_hz)
{
800065fc:	d4 01       	pushm	lr
	if (cpu_f_hz >= AVR32_FLASHC_FWS_0_MAX_FREQ) {
800065fe:	e0 68 8a 3f 	mov	r8,35391
80006602:	ea 18 01 f7 	orh	r8,0x1f7
80006606:	10 3c       	cp.w	r12,r8
80006608:	e0 88 00 06 	brls	80006614 <flashc_set_bus_freq+0x18>
		// Set 1 WS.
		flashc_set_wait_state(1);
8000660c:	30 1c       	mov	r12,1
8000660e:	f0 1f 00 04 	mcall	8000661c <flashc_set_bus_freq+0x20>
80006612:	d8 02       	popm	pc
	} else {
		// Set 0 WS.
		flashc_set_wait_state(0);
80006614:	30 0c       	mov	r12,0
80006616:	f0 1f 00 02 	mcall	8000661c <flashc_set_bus_freq+0x20>
8000661a:	d8 02       	popm	pc
8000661c:	80 00       	ld.sh	r0,r0[0x0]
8000661e:	65 ec       	ld.w	r12,r2[0x78]

80006620 <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006620:	f8 08 16 05 	lsr	r8,r12,0x5
80006624:	a9 78       	lsl	r8,0x9
80006626:	e0 28 e0 00 	sub	r8,57344

	/* Enable the correct function. */
	switch (function) {
8000662a:	58 7b       	cp.w	r11,7
8000662c:	e0 8b 00 05 	brhi	80006636 <gpio_enable_module_pin+0x16>
80006630:	4a 09       	lddpc	r9,800066b0 <gpio_enable_module_pin+0x90>
80006632:	f2 0b 03 2f 	ld.w	pc,r9[r11<<0x2]
80006636:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006638:	30 19       	mov	r9,1
8000663a:	f2 0c 09 49 	lsl	r9,r9,r12
8000663e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006640:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80006642:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80006644:	c3 18       	rjmp	800066a6 <gpio_enable_module_pin+0x86>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006646:	30 19       	mov	r9,1
80006648:	f2 0c 09 49 	lsl	r9,r9,r12
8000664c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
8000664e:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
80006650:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80006652:	c2 a8       	rjmp	800066a6 <gpio_enable_module_pin+0x86>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006654:	30 19       	mov	r9,1
80006656:	f2 0c 09 49 	lsl	r9,r9,r12
8000665a:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000665c:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
8000665e:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
80006660:	c2 38       	rjmp	800066a6 <gpio_enable_module_pin+0x86>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006662:	30 19       	mov	r9,1
80006664:	f2 0c 09 49 	lsl	r9,r9,r12
80006668:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000666a:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
8000666c:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
8000666e:	c1 c8       	rjmp	800066a6 <gpio_enable_module_pin+0x86>

#if (AVR32_GPIO_H_VERSION >= 210)
	case 4: /* E function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006670:	30 19       	mov	r9,1
80006672:	f2 0c 09 49 	lsl	r9,r9,r12
80006676:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006678:	91 a9       	st.w	r8[0x28],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
8000667a:	91 d9       	st.w	r8[0x34],r9
		break;
8000667c:	c1 58       	rjmp	800066a6 <gpio_enable_module_pin+0x86>

	case 5: /* F function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000667e:	30 19       	mov	r9,1
80006680:	f2 0c 09 49 	lsl	r9,r9,r12
80006684:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006686:	91 a9       	st.w	r8[0x28],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80006688:	91 d9       	st.w	r8[0x34],r9
		break;
8000668a:	c0 e8       	rjmp	800066a6 <gpio_enable_module_pin+0x86>

	case 6: /* G function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
8000668c:	30 19       	mov	r9,1
8000668e:	f2 0c 09 49 	lsl	r9,r9,r12
80006692:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006694:	91 99       	st.w	r8[0x24],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80006696:	91 d9       	st.w	r8[0x34],r9
		break;
80006698:	c0 78       	rjmp	800066a6 <gpio_enable_module_pin+0x86>

	case 7: /* H function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
8000669a:	30 19       	mov	r9,1
8000669c:	f2 0c 09 49 	lsl	r9,r9,r12
800066a0:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800066a2:	91 99       	st.w	r8[0x24],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
800066a4:	91 d9       	st.w	r8[0x34],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
800066a6:	30 19       	mov	r9,1
800066a8:	f2 0c 09 4c 	lsl	r12,r9,r12
800066ac:	91 2c       	st.w	r8[0x8],r12
800066ae:	5e fd       	retal	0
800066b0:	80 00       	ld.sh	r0,r0[0x0]
800066b2:	7c 9c       	ld.w	r12,lr[0x24]

800066b4 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
800066b4:	d4 21       	pushm	r4-r7,lr
800066b6:	18 97       	mov	r7,r12
800066b8:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800066ba:	58 0b       	cp.w	r11,0
800066bc:	c0 31       	brne	800066c2 <gpio_enable_module+0xe>
800066be:	30 05       	mov	r5,0
800066c0:	c0 d8       	rjmp	800066da <gpio_enable_module+0x26>
800066c2:	30 06       	mov	r6,0
800066c4:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
800066c6:	6e 1b       	ld.w	r11,r7[0x4]
800066c8:	6e 0c       	ld.w	r12,r7[0x0]
800066ca:	f0 1f 00 06 	mcall	800066e0 <gpio_enable_module+0x2c>
800066ce:	18 45       	or	r5,r12
		gpiomap++;
800066d0:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
800066d2:	2f f6       	sub	r6,-1
800066d4:	0c 34       	cp.w	r4,r6
800066d6:	fe 9b ff f8 	brhi	800066c6 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
800066da:	0a 9c       	mov	r12,r5
800066dc:	d8 22       	popm	r4-r7,pc
800066de:	00 00       	add	r0,r0
800066e0:	80 00       	ld.sh	r0,r0[0x0]
800066e2:	66 20       	ld.w	r0,r3[0x8]

800066e4 <gpio_configure_pin>:
 * \param pin The pin number.
 * \param flags The configuration.
 */
void gpio_configure_pin(uint32_t pin, uint32_t flags)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800066e4:	f8 08 16 05 	lsr	r8,r12,0x5
800066e8:	a9 78       	lsl	r8,0x9
800066ea:	e0 28 e0 00 	sub	r8,57344

	/* Both pull-up and pull-down set means buskeeper */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	if (flags & GPIO_PULL_DOWN) {
800066ee:	16 99       	mov	r9,r11
800066f0:	e2 19 00 08 	andl	r9,0x8,COH
800066f4:	c0 70       	breq	80006702 <gpio_configure_pin+0x1e>
		gpio_port->pders = 1 << (pin & 0x1F);
800066f6:	30 19       	mov	r9,1
800066f8:	f2 0c 09 49 	lsl	r9,r9,r12
800066fc:	f1 49 00 84 	st.w	r8[132],r9
80006700:	c0 68       	rjmp	8000670c <gpio_configure_pin+0x28>
	} else {
		gpio_port->pderc = 1 << (pin & 0x1F);
80006702:	30 19       	mov	r9,1
80006704:	f2 0c 09 49 	lsl	r9,r9,r12
80006708:	f1 49 00 88 	st.w	r8[136],r9
	}

#endif
	if (flags & GPIO_PULL_UP) {
8000670c:	16 99       	mov	r9,r11
8000670e:	e2 19 00 04 	andl	r9,0x4,COH
80006712:	c0 70       	breq	80006720 <gpio_configure_pin+0x3c>
		gpio_port->puers = 1 << (pin & 0x1F);
80006714:	30 19       	mov	r9,1
80006716:	f2 0c 09 49 	lsl	r9,r9,r12
8000671a:	f1 49 00 74 	st.w	r8[116],r9
8000671e:	c0 68       	rjmp	8000672a <gpio_configure_pin+0x46>
	} else {
		gpio_port->puerc = 1 << (pin & 0x1F);
80006720:	30 19       	mov	r9,1
80006722:	f2 0c 09 49 	lsl	r9,r9,r12
80006726:	f1 49 00 78 	st.w	r8[120],r9
	}

	/* Enable open-drain mode if requested */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	if (flags & GPIO_OPEN_DRAIN) {
8000672a:	16 99       	mov	r9,r11
8000672c:	e2 19 00 40 	andl	r9,0x40,COH
80006730:	c0 70       	breq	8000673e <gpio_configure_pin+0x5a>
		gpio_port->odmers = 1 << (pin & 0x1F);
80006732:	30 19       	mov	r9,1
80006734:	f2 0c 09 49 	lsl	r9,r9,r12
80006738:	f1 49 00 e4 	st.w	r8[228],r9
8000673c:	c0 68       	rjmp	80006748 <gpio_configure_pin+0x64>
	} else {
		gpio_port->odmerc = 1 << (pin & 0x1F);
8000673e:	30 19       	mov	r9,1
80006740:	f2 0c 09 49 	lsl	r9,r9,r12
80006744:	f1 49 00 e8 	st.w	r8[232],r9
#endif

#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	/* Select drive strength */
	if (flags & GPIO_DRIVE_LOW) {
80006748:	16 99       	mov	r9,r11
8000674a:	e2 19 00 10 	andl	r9,0x10,COH
8000674e:	c0 70       	breq	8000675c <gpio_configure_pin+0x78>
		gpio_port->odcr0s = 1 << (pin & 0x1F);
80006750:	30 19       	mov	r9,1
80006752:	f2 0c 09 49 	lsl	r9,r9,r12
80006756:	f1 49 01 04 	st.w	r8[260],r9
8000675a:	c0 68       	rjmp	80006766 <gpio_configure_pin+0x82>
	} else {
		gpio_port->odcr0c = 1 << (pin & 0x1F);
8000675c:	30 19       	mov	r9,1
8000675e:	f2 0c 09 49 	lsl	r9,r9,r12
80006762:	f1 49 01 08 	st.w	r8[264],r9
	}

	if (flags & GPIO_DRIVE_HIGH) {
80006766:	16 99       	mov	r9,r11
80006768:	e2 19 00 20 	andl	r9,0x20,COH
8000676c:	c0 70       	breq	8000677a <gpio_configure_pin+0x96>
		gpio_port->odcr1s = 1 << (pin & 0x1F);
8000676e:	30 19       	mov	r9,1
80006770:	f2 0c 09 49 	lsl	r9,r9,r12
80006774:	f1 49 01 14 	st.w	r8[276],r9
80006778:	c0 68       	rjmp	80006784 <gpio_configure_pin+0xa0>
	} else {
		gpio_port->odcr1c = 1 << (pin & 0x1F);
8000677a:	30 19       	mov	r9,1
8000677c:	f2 0c 09 49 	lsl	r9,r9,r12
80006780:	f1 49 01 18 	st.w	r8[280],r9
	}

#endif

	/* Select interrupt level for group */
	if (flags & GPIO_INTERRUPT) {
80006784:	16 99       	mov	r9,r11
80006786:	e2 19 00 80 	andl	r9,0x80,COH
8000678a:	c2 40       	breq	800067d2 <gpio_configure_pin+0xee>
		if (flags & GPIO_BOTHEDGES) {
8000678c:	16 99       	mov	r9,r11
8000678e:	e2 19 01 80 	andl	r9,0x180,COH
80006792:	c0 90       	breq	800067a4 <gpio_configure_pin+0xc0>
			gpio_port->imr0c = 1 << (pin & 0x1F);
80006794:	30 19       	mov	r9,1
80006796:	f2 0c 09 49 	lsl	r9,r9,r12
8000679a:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
8000679e:	f1 49 00 b8 	st.w	r8[184],r9
800067a2:	c1 88       	rjmp	800067d2 <gpio_configure_pin+0xee>
		} else if (flags & GPIO_RISING) {
800067a4:	16 99       	mov	r9,r11
800067a6:	e2 19 02 80 	andl	r9,0x280,COH
800067aa:	c0 90       	breq	800067bc <gpio_configure_pin+0xd8>
			gpio_port->imr0s = 1 << (pin & 0x1F);
800067ac:	30 19       	mov	r9,1
800067ae:	f2 0c 09 49 	lsl	r9,r9,r12
800067b2:	f1 49 00 a4 	st.w	r8[164],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
800067b6:	f1 49 00 b8 	st.w	r8[184],r9
800067ba:	c0 c8       	rjmp	800067d2 <gpio_configure_pin+0xee>
		} else if (flags & GPIO_FALLING) {
800067bc:	16 99       	mov	r9,r11
800067be:	e2 19 03 80 	andl	r9,0x380,COH
800067c2:	c0 80       	breq	800067d2 <gpio_configure_pin+0xee>
			gpio_port->imr0c = 1 << (pin & 0x1F);
800067c4:	30 19       	mov	r9,1
800067c6:	f2 0c 09 49 	lsl	r9,r9,r12
800067ca:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1s = 1 << (pin & 0x1F);
800067ce:	f1 49 00 b4 	st.w	r8[180],r9
		}
	}

	/* Select direction and initial pin state */
	if (flags & GPIO_DIR_OUTPUT) {
800067d2:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
800067d6:	c1 50       	breq	80006800 <gpio_configure_pin+0x11c>
		if (flags & GPIO_INIT_HIGH) {
800067d8:	e2 1b 00 02 	andl	r11,0x2,COH
800067dc:	c0 70       	breq	800067ea <gpio_configure_pin+0x106>
			gpio_port->ovrs = 1 << (pin & 0x1F);
800067de:	30 19       	mov	r9,1
800067e0:	f2 0c 09 49 	lsl	r9,r9,r12
800067e4:	f1 49 00 54 	st.w	r8[84],r9
800067e8:	c0 68       	rjmp	800067f4 <gpio_configure_pin+0x110>
		} else {
			gpio_port->ovrc = 1 << (pin & 0x1F);
800067ea:	30 19       	mov	r9,1
800067ec:	f2 0c 09 49 	lsl	r9,r9,r12
800067f0:	f1 49 00 58 	st.w	r8[88],r9
		}

		gpio_port->oders = 1 << (pin & 0x1F);
800067f4:	30 19       	mov	r9,1
800067f6:	f2 0c 09 49 	lsl	r9,r9,r12
800067fa:	f1 49 00 44 	st.w	r8[68],r9
800067fe:	c0 68       	rjmp	8000680a <gpio_configure_pin+0x126>
	} else {
		gpio_port->oderc = 1 << (pin & 0x1F);
80006800:	30 19       	mov	r9,1
80006802:	f2 0c 09 49 	lsl	r9,r9,r12
80006806:	f1 49 00 48 	st.w	r8[72],r9
	}

	/* Enable GPIO */
	gpio_port->gpers = 1 << (pin & 0x1F);
8000680a:	30 19       	mov	r9,1
8000680c:	f2 0c 09 4c 	lsl	r12,r9,r12
80006810:	91 1c       	st.w	r8[0x4],r12
}
80006812:	5e fc       	retal	r12

80006814 <gpio_get_pin_value>:
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006814:	f8 08 16 05 	lsr	r8,r12,0x5
80006818:	a9 78       	lsl	r8,0x9
8000681a:	e0 28 e0 00 	sub	r8,57344
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
8000681e:	71 88       	ld.w	r8,r8[0x60]
80006820:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
80006824:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
80006828:	5e fc       	retal	r12

8000682a <gpio_set_pin_high>:
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_set_pin_high(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000682a:	f8 08 16 05 	lsr	r8,r12,0x5
8000682e:	a9 78       	lsl	r8,0x9
80006830:	e0 28 e0 00 	sub	r8,57344
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
80006834:	30 19       	mov	r9,1
80006836:	f2 0c 09 4c 	lsl	r12,r9,r12
8000683a:	f1 4c 00 54 	st.w	r8[84],r12
}
8000683e:	5e fc       	retal	r12

80006840 <gpio_set_pin_low>:
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_set_pin_low(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006840:	f8 08 16 05 	lsr	r8,r12,0x5
80006844:	a9 78       	lsl	r8,0x9
80006846:	e0 28 e0 00 	sub	r8,57344
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
8000684a:	30 19       	mov	r9,1
8000684c:	f2 0c 09 4c 	lsl	r12,r9,r12
80006850:	f1 4c 00 58 	st.w	r8[88],r12
}
80006854:	5e fc       	retal	r12

80006856 <gpio_toggle_pin>:
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_toggle_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006856:	f8 08 16 05 	lsr	r8,r12,0x5
8000685a:	a9 78       	lsl	r8,0x9
8000685c:	e0 28 e0 00 	sub	r8,57344
	
	/* Toggle the I/O line. */
	gpio_port->ovrt  = 1 << (pin & 0x1F);
80006860:	30 19       	mov	r9,1
80006862:	f2 0c 09 4c 	lsl	r12,r9,r12
80006866:	f1 4c 00 5c 	st.w	r8[92],r12
}
8000686a:	5e fc       	retal	r12

8000686c <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
8000686c:	c0 08       	rjmp	8000686c <_unhandled_interrupt>
8000686e:	d7 03       	nop

80006870 <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80006870:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80006874:	49 99       	lddpc	r9,800068d8 <INTC_register_interrupt+0x68>
80006876:	f2 08 00 39 	add	r9,r9,r8<<0x3
8000687a:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
8000687e:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80006880:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80006884:	58 0a       	cp.w	r10,0
80006886:	c0 91       	brne	80006898 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006888:	49 59       	lddpc	r9,800068dc <INTC_register_interrupt+0x6c>
8000688a:	49 6a       	lddpc	r10,800068e0 <INTC_register_interrupt+0x70>
8000688c:	12 1a       	sub	r10,r9
8000688e:	fe 79 00 00 	mov	r9,-65536
80006892:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006896:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80006898:	58 1a       	cp.w	r10,1
8000689a:	c0 a1       	brne	800068ae <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
8000689c:	49 09       	lddpc	r9,800068dc <INTC_register_interrupt+0x6c>
8000689e:	49 2a       	lddpc	r10,800068e4 <INTC_register_interrupt+0x74>
800068a0:	12 1a       	sub	r10,r9
800068a2:	bf aa       	sbr	r10,0x1e
800068a4:	fe 79 00 00 	mov	r9,-65536
800068a8:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800068ac:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
800068ae:	58 2a       	cp.w	r10,2
800068b0:	c0 a1       	brne	800068c4 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
800068b2:	48 b9       	lddpc	r9,800068dc <INTC_register_interrupt+0x6c>
800068b4:	48 da       	lddpc	r10,800068e8 <INTC_register_interrupt+0x78>
800068b6:	12 1a       	sub	r10,r9
800068b8:	bf ba       	sbr	r10,0x1f
800068ba:	fe 79 00 00 	mov	r9,-65536
800068be:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800068c2:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
800068c4:	48 69       	lddpc	r9,800068dc <INTC_register_interrupt+0x6c>
800068c6:	48 aa       	lddpc	r10,800068ec <INTC_register_interrupt+0x7c>
800068c8:	12 1a       	sub	r10,r9
800068ca:	ea 1a c0 00 	orh	r10,0xc000
800068ce:	fe 79 00 00 	mov	r9,-65536
800068d2:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
800068d6:	5e fc       	retal	r12
800068d8:	80 00       	ld.sh	r0,r0[0x0]
800068da:	7c bc       	ld.w	r12,lr[0x2c]
800068dc:	80 00       	ld.sh	r0,r0[0x0]
800068de:	7a 00       	ld.w	r0,sp[0x0]
800068e0:	80 00       	ld.sh	r0,r0[0x0]
800068e2:	7b 04       	ld.w	r4,sp[0x40]
800068e4:	80 00       	ld.sh	r0,r0[0x0]
800068e6:	7b 12       	ld.w	r2,sp[0x44]
800068e8:	80 00       	ld.sh	r0,r0[0x0]
800068ea:	7b 20       	ld.w	r0,sp[0x48]
800068ec:	80 00       	ld.sh	r0,r0[0x0]
800068ee:	7b 2e       	ld.w	lr,sp[0x48]

800068f0 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
800068f0:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
800068f2:	49 18       	lddpc	r8,80006934 <INTC_init_interrupts+0x44>
800068f4:	e3 b8 00 01 	mtsr	0x4,r8
800068f8:	49 0e       	lddpc	lr,80006938 <INTC_init_interrupts+0x48>
800068fa:	30 07       	mov	r7,0
800068fc:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
800068fe:	49 0c       	lddpc	r12,8000693c <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006900:	49 05       	lddpc	r5,80006940 <INTC_init_interrupts+0x50>
80006902:	10 15       	sub	r5,r8
80006904:	fe 76 00 00 	mov	r6,-65536
80006908:	c1 18       	rjmp	8000692a <INTC_init_interrupts+0x3a>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
8000690a:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
8000690c:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000690e:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80006910:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80006914:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006916:	10 3a       	cp.w	r10,r8
80006918:	fe 9b ff fc 	brhi	80006910 <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
8000691c:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80006920:	2f f7       	sub	r7,-1
80006922:	2f 8e       	sub	lr,-8
80006924:	e0 47 00 2f 	cp.w	r7,47
80006928:	c0 50       	breq	80006932 <INTC_init_interrupts+0x42>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
8000692a:	7c 08       	ld.w	r8,lr[0x0]
8000692c:	58 08       	cp.w	r8,0
8000692e:	ce e1       	brne	8000690a <INTC_init_interrupts+0x1a>
80006930:	cf 6b       	rjmp	8000691c <INTC_init_interrupts+0x2c>
80006932:	d8 22       	popm	r4-r7,pc
80006934:	80 00       	ld.sh	r0,r0[0x0]
80006936:	7a 00       	ld.w	r0,sp[0x0]
80006938:	80 00       	ld.sh	r0,r0[0x0]
8000693a:	7c bc       	ld.w	r12,lr[0x2c]
8000693c:	80 00       	ld.sh	r0,r0[0x0]
8000693e:	68 6c       	ld.w	r12,r4[0x18]
80006940:	80 00       	ld.sh	r0,r0[0x0]
80006942:	7b 04       	ld.w	r4,sp[0x40]

80006944 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80006944:	fe 78 00 00 	mov	r8,-65536
80006948:	e0 69 00 83 	mov	r9,131
8000694c:	f2 0c 01 0c 	sub	r12,r9,r12
80006950:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80006954:	f2 ca ff c0 	sub	r10,r9,-64
80006958:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
8000695c:	58 08       	cp.w	r8,0
8000695e:	c0 21       	brne	80006962 <_get_interrupt_handler+0x1e>
80006960:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80006962:	f0 08 12 00 	clz	r8,r8
80006966:	48 5a       	lddpc	r10,80006978 <_get_interrupt_handler+0x34>
80006968:	f4 09 00 39 	add	r9,r10,r9<<0x3
8000696c:	f0 08 11 1f 	rsub	r8,r8,31
80006970:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80006972:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80006976:	5e fc       	retal	r12
80006978:	80 00       	ld.sh	r0,r0[0x0]
8000697a:	7c bc       	ld.w	r12,lr[0x2c]

8000697c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
8000697c:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006980:	fe c0 ef 80 	sub	r0,pc,-4224

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006984:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006988:	d5 53       	csrf	0x15
  cp      r0, r1
8000698a:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
8000698c:	e0 61 03 f0 	mov	r1,1008
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006990:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006992:	c0 72       	brcc	800069a0 <idata_load_loop_end>
  cp      r0, r1
80006994:	fe c2 eb 5c 	sub	r2,pc,-5284

80006998 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006998:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
8000699a:	a1 24       	st.d	r0++,r4
  cp      r0, r1
8000699c:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
8000699e:	cf d3       	brcs	80006998 <idata_load_loop>

800069a0 <idata_load_loop_end>:
  mov     r2, 0
800069a0:	e0 60 03 f0 	mov	r0,1008
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
800069a4:	e0 61 d0 08 	mov	r1,53256
  cp      r0, r1
  brlo    udata_clear_loop
800069a8:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
800069aa:	c0 62       	brcc	800069b6 <udata_clear_loop_end>
800069ac:	30 02       	mov	r2,0
800069ae:	30 03       	mov	r3,0

800069b0 <udata_clear_loop>:
800069b0:	a1 22       	st.d	r0++,r2
800069b2:	02 30       	cp.w	r0,r1
800069b4:	cf e3       	brcs	800069b0 <udata_clear_loop>

800069b6 <udata_clear_loop_end>:
800069b6:	fe cf 08 2a 	sub	pc,pc,2090
800069ba:	d7 03       	nop

800069bc <osc_priv_enable_rc120m>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800069bc:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800069c0:	d3 03       	ssrf	0x10
void osc_priv_enable_rc120m(void)
{
	irqflags_t flags;

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_RC120MCR;
800069c2:	fe 78 08 00 	mov	r8,-63488
800069c6:	35 8a       	mov	r10,88
800069c8:	ea 1a aa 00 	orh	r10,0xaa00
800069cc:	91 6a       	st.w	r8[0x18],r10
	AVR32_SCIF.rc120mcr = 1U << AVR32_SCIF_RC120MCR_EN;
800069ce:	30 1a       	mov	r10,1
800069d0:	f1 4a 00 58 	st.w	r8[88],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800069d4:	12 98       	mov	r8,r9
800069d6:	e6 18 00 01 	andh	r8,0x1,COH
800069da:	c0 21       	brne	800069de <osc_priv_enable_rc120m+0x22>
      cpu_irq_enable();
800069dc:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
800069de:	5e fc       	retal	r12

800069e0 <osc_priv_enable_rc8m>:
{
	irqflags_t flags;
	uint32_t   rccr8;
    uint32_t* calibration_bits = (uint32_t*)0x80800200;
	/* Wait for the CALIB field to be updated from fuses after reset */
	while (!(AVR32_SCIF.rccr8 & AVR32_SCIF_RCCR8_FCD_MASK)) {
800069e0:	fe 79 08 00 	mov	r9,-63488
800069e4:	73 28       	ld.w	r8,r9[0x48]
800069e6:	e6 18 00 01 	andh	r8,0x1,COH
800069ea:	cf d0       	breq	800069e4 <osc_priv_enable_rc8m+0x4>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800069ec:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
800069f0:	d3 03       	ssrf	0x10
		/* Do nothing */
	}

	/* Enable the oscillator without touching the CALIB and FCD fields */
	flags = cpu_irq_save();
	rccr8 = AVR32_SCIF.rccr8;
800069f2:	fe 78 08 00 	mov	r8,-63488
800069f6:	71 2b       	ld.w	r11,r8[0x48]
	rccr8 &= AVR32_SCIF_RCCR8_FCD_MASK | ((*calibration_bits)&AVR32_SCIF_RCCR8_CALIB_MASK);
800069f8:	e0 6a 02 00 	mov	r10,512
800069fc:	ea 1a 80 80 	orh	r10,0x8080
80006a00:	15 ba       	ld.ub	r10,r10[0x3]
80006a02:	b1 aa       	sbr	r10,0x10
80006a04:	16 6a       	and	r10,r11
	rccr8 |= 1U << AVR32_SCIF_RCOSC8_EN;
80006a06:	b9 aa       	sbr	r10,0x18
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_RCCR8;
80006a08:	34 8b       	mov	r11,72
80006a0a:	ea 1b aa 00 	orh	r11,0xaa00
80006a0e:	91 6b       	st.w	r8[0x18],r11
	AVR32_SCIF.rccr8 = rccr8;
80006a10:	f1 4a 00 48 	st.w	r8[72],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006a14:	12 98       	mov	r8,r9
80006a16:	e6 18 00 01 	andh	r8,0x1,COH
80006a1a:	c0 21       	brne	80006a1e <osc_priv_enable_rc8m+0x3e>
      cpu_irq_enable();
80006a1c:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
80006a1e:	5e fc       	retal	r12

80006a20 <osc_priv_enable_osc32>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006a20:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006a24:	d3 03       	ssrf	0x10
void osc_priv_enable_osc32(void)
{
	irqflags_t flags;

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_OSCCTRL32;
80006a26:	fe 78 08 00 	mov	r8,-63488
80006a2a:	34 ca       	mov	r10,76
80006a2c:	ea 1a aa 00 	orh	r10,0xaa00
80006a30:	91 6a       	st.w	r8[0x18],r10
	AVR32_SCIF.oscctrl32 =
80006a32:	e2 6a 01 01 	mov	r10,131329
80006a36:	f1 4a 00 4c 	st.w	r8[76],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006a3a:	12 98       	mov	r8,r9
80006a3c:	e6 18 00 01 	andh	r8,0x1,COH
80006a40:	c0 21       	brne	80006a44 <osc_priv_enable_osc32+0x24>
      cpu_irq_enable();
80006a42:	d5 03       	csrf	0x10
			(OSC32_STARTUP_VALUE << AVR32_SCIF_OSCCTRL32_STARTUP)
			| (OSC32_MODE_VALUE << AVR32_SCIF_OSCCTRL32_MODE)
			| (1U << AVR32_SCIF_OSCCTRL32_OSC32EN);
	cpu_irq_restore(flags);
}
80006a44:	5e fc       	retal	r12

80006a46 <osc_priv_enable_osc0>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006a46:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006a4a:	d3 03       	ssrf	0x10
void osc_priv_enable_osc0(void)
{
	irqflags_t flags;

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_OSCCTRL;
80006a4c:	fe 78 08 00 	mov	r8,-63488
80006a50:	32 4a       	mov	r10,36
80006a52:	ea 1a aa 00 	orh	r10,0xaa00
80006a56:	91 6a       	st.w	r8[0x18],r10
	AVR32_SCIF.oscctrl[0] =
80006a58:	e0 7a 0c 07 	mov	r10,68615
80006a5c:	91 9a       	st.w	r8[0x24],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006a5e:	12 98       	mov	r8,r9
80006a60:	e6 18 00 01 	andh	r8,0x1,COH
80006a64:	c0 21       	brne	80006a68 <osc_priv_enable_osc0+0x22>
      cpu_irq_enable();
80006a66:	d5 03       	csrf	0x10
			(OSC0_STARTUP_VALUE << AVR32_SCIF_OSCCTRL_STARTUP)
			| (OSC0_GAIN_VALUE << AVR32_SCIF_OSCCTRL_GAIN)
			| (OSC0_MODE_VALUE << AVR32_SCIF_OSCCTRL_MODE)
			| (1U << AVR32_SCIF_OSCCTRL_OSCEN);
	cpu_irq_restore(flags);
}
80006a68:	5e fc       	retal	r12

80006a6a <pll_enable>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006a6a:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006a6e:	d3 03       	ssrf	0x10
	irqflags_t flags;

	Assert(pll_id < NR_PLLS);

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | (AVR32_SCIF_PLL + (4 * pll_id));
80006a70:	2f 9b       	sub	r11,-7
80006a72:	f6 0a 15 02 	lsl	r10,r11,0x2
80006a76:	ea 1a aa 00 	orh	r10,0xaa00
80006a7a:	fe 78 08 00 	mov	r8,-63488
80006a7e:	91 6a       	st.w	r8[0x18],r10
	AVR32_SCIF.pll[pll_id] = cfg->ctrl | (1U << AVR32_SCIF_PLLEN);
80006a80:	78 0a       	ld.w	r10,r12[0x0]
80006a82:	a1 aa       	sbr	r10,0x0
80006a84:	f0 0b 09 2a 	st.w	r8[r11<<0x2],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006a88:	12 98       	mov	r8,r9
80006a8a:	e6 18 00 01 	andh	r8,0x1,COH
80006a8e:	c0 21       	brne	80006a92 <pll_enable+0x28>
      cpu_irq_enable();
80006a90:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
80006a92:	5e fc       	retal	r12

80006a94 <osc_enable>:
extern void osc_priv_enable_rc120m(void);
extern void osc_priv_disable_rc120m(void);
extern bool osc_priv_rc120m_is_ready(void);

static inline void osc_enable(uint8_t id)
{
80006a94:	d4 01       	pushm	lr
	switch (id) {
80006a96:	30 28       	mov	r8,2
80006a98:	f0 0c 18 00 	cp.b	r12,r8
80006a9c:	c1 50       	breq	80006ac6 <osc_enable+0x32>
80006a9e:	e0 8b 00 05 	brhi	80006aa8 <osc_enable+0x14>
80006aa2:	58 0c       	cp.w	r12,0
80006aa4:	c1 61       	brne	80006ad0 <osc_enable+0x3c>
80006aa6:	c0 a8       	rjmp	80006aba <osc_enable+0x26>
80006aa8:	30 38       	mov	r8,3
80006aaa:	f0 0c 18 00 	cp.b	r12,r8
80006aae:	c0 90       	breq	80006ac0 <osc_enable+0x2c>
80006ab0:	30 48       	mov	r8,4
80006ab2:	f0 0c 18 00 	cp.b	r12,r8
80006ab6:	c0 d1       	brne	80006ad0 <osc_enable+0x3c>
80006ab8:	c0 a8       	rjmp	80006acc <osc_enable+0x38>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		osc_priv_enable_osc0();
80006aba:	f0 1f 00 07 	mcall	80006ad4 <osc_enable+0x40>
		break;
80006abe:	d8 02       	popm	pc
		break;
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		osc_priv_enable_osc32();
80006ac0:	f0 1f 00 06 	mcall	80006ad8 <osc_enable+0x44>
		break;
80006ac4:	d8 02       	popm	pc
#endif

	case OSC_ID_RC8M:
		osc_priv_enable_rc8m();
80006ac6:	f0 1f 00 06 	mcall	80006adc <osc_enable+0x48>
		break;
80006aca:	d8 02       	popm	pc

	case OSC_ID_RC120M:
		osc_priv_enable_rc120m();
80006acc:	f0 1f 00 05 	mcall	80006ae0 <osc_enable+0x4c>
80006ad0:	d8 02       	popm	pc
80006ad2:	00 00       	add	r0,r0
80006ad4:	80 00       	ld.sh	r0,r0[0x0]
80006ad6:	6a 46       	ld.w	r6,r5[0x10]
80006ad8:	80 00       	ld.sh	r0,r0[0x0]
80006ada:	6a 20       	ld.w	r0,r5[0x8]
80006adc:	80 00       	ld.sh	r0,r0[0x0]
80006ade:	69 e0       	ld.w	r0,r4[0x78]
80006ae0:	80 00       	ld.sh	r0,r0[0x0]
80006ae2:	69 bc       	ld.w	r12,r4[0x6c]

80006ae4 <sysclk_set_source>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006ae4:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006ae8:	d3 03       	ssrf	0x10
	irqflags_t flags;

	Assert(src <= SYSCLK_SRC_RC120M);

	flags = cpu_irq_save();
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_MCCTRL;
80006aea:	fe 78 04 00 	mov	r8,-64512
80006aee:	fc 1a aa 00 	movh	r10,0xaa00
80006af2:	f1 4a 00 58 	st.w	r8[88],r10
	AVR32_PM.mcctrl = src;
80006af6:	91 0c       	st.w	r8[0x0],r12
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006af8:	12 98       	mov	r8,r9
80006afa:	e6 18 00 01 	andh	r8,0x1,COH
80006afe:	c0 21       	brne	80006b02 <sysclk_set_source+0x1e>
      cpu_irq_enable();
80006b00:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
80006b02:	5e fc       	retal	r12

80006b04 <sysclk_set_prescalers>:
 * \param pbc_shift The PBC clock will be divided by \f$2^{pbc\_shift}\f$
 */
void sysclk_set_prescalers(unsigned int cpu_shift,
		unsigned int pba_shift, unsigned int pbb_shift,
		unsigned int pbc_shift)
{
80006b04:	eb cd 40 80 	pushm	r7,lr
	uint32_t   pbc_cksel = 0;

	Assert(cpu_shift <= pba_shift);
	Assert(cpu_shift <= pbb_shift);

	if (cpu_shift > 0)
80006b08:	58 0c       	cp.w	r12,0
80006b0a:	c0 30       	breq	80006b10 <sysclk_set_prescalers+0xc>
		cpu_cksel = ((cpu_shift - 1) << AVR32_PM_CPUSEL_CPUSEL)
80006b0c:	20 1c       	sub	r12,1
80006b0e:	a7 bc       	sbr	r12,0x7
				| (1U << AVR32_PM_CPUDIV);

	if (pba_shift > 0)
80006b10:	58 0b       	cp.w	r11,0
80006b12:	c0 30       	breq	80006b18 <sysclk_set_prescalers+0x14>
		pba_cksel = ((pba_shift - 1) << AVR32_PM_PBASEL_PBSEL)
80006b14:	20 1b       	sub	r11,1
80006b16:	a7 bb       	sbr	r11,0x7
				| (1U << AVR32_PM_PBADIV);

	if (pbb_shift > 0)
80006b18:	58 0a       	cp.w	r10,0
80006b1a:	c0 30       	breq	80006b20 <sysclk_set_prescalers+0x1c>
		pbb_cksel = ((pbb_shift - 1) << AVR32_PM_PBBSEL_PBSEL)
80006b1c:	20 1a       	sub	r10,1
80006b1e:	a7 ba       	sbr	r10,0x7
				| (1U << AVR32_PM_PBBDIV);

	if (pbc_shift > 0)
80006b20:	58 09       	cp.w	r9,0
80006b22:	c0 30       	breq	80006b28 <sysclk_set_prescalers+0x24>
		pbc_cksel = ((pbc_shift - 1) << AVR32_PM_PBCSEL_PBSEL)
80006b24:	20 19       	sub	r9,1
80006b26:	a7 b9       	sbr	r9,0x7

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006b28:	e1 be 00 00 	mfsr	lr,0x0
	cpu_irq_disable();
80006b2c:	d3 03       	ssrf	0x10
				| (1U << AVR32_PM_PBCDIV);

	flags = cpu_irq_save();
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_CPUSEL;
80006b2e:	fe 78 04 00 	mov	r8,-64512
80006b32:	30 47       	mov	r7,4
80006b34:	ea 17 aa 00 	orh	r7,0xaa00
80006b38:	f1 47 00 58 	st.w	r8[88],r7
	AVR32_PM.cpusel = cpu_cksel;
80006b3c:	91 1c       	st.w	r8[0x4],r12
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_PBASEL;
80006b3e:	30 cc       	mov	r12,12
80006b40:	ea 1c aa 00 	orh	r12,0xaa00
80006b44:	f1 4c 00 58 	st.w	r8[88],r12
	AVR32_PM.pbasel = pba_cksel;
80006b48:	91 3b       	st.w	r8[0xc],r11
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_PBBSEL;
80006b4a:	31 0b       	mov	r11,16
80006b4c:	ea 1b aa 00 	orh	r11,0xaa00
80006b50:	f1 4b 00 58 	st.w	r8[88],r11
	AVR32_PM.pbbsel = pbb_cksel;
80006b54:	91 4a       	st.w	r8[0x10],r10
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_PBCSEL;
80006b56:	31 4a       	mov	r10,20
80006b58:	ea 1a aa 00 	orh	r10,0xaa00
80006b5c:	f1 4a 00 58 	st.w	r8[88],r10
	AVR32_PM.pbcsel = pbc_cksel;
80006b60:	91 59       	st.w	r8[0x14],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006b62:	1c 98       	mov	r8,lr
80006b64:	e6 18 00 01 	andh	r8,0x1,COH
80006b68:	c0 21       	brne	80006b6c <sysclk_set_prescalers+0x68>
      cpu_irq_enable();
80006b6a:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
80006b6c:	e3 cd 80 80 	ldm	sp++,r7,pc

80006b70 <sysclk_priv_enable_module>:
 * \param bus_id Bus index, given by the \c AVR32_PM_CLK_GRP_xxx definitions.
 * \param module_index Index of the module to be enabled. This is the
 * bit number in the corresponding xxxMASK register.
 */
void sysclk_priv_enable_module(unsigned int bus_id, unsigned int module_index)
{
80006b70:	d4 01       	pushm	lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006b72:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006b76:	d3 03       	ssrf	0x10
	uint32_t   mask;

	flags = cpu_irq_save();

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80006b78:	a3 6c       	lsl	r12,0x2
80006b7a:	fe 7a 04 20 	mov	r10,-64480
80006b7e:	f8 0a 00 08 	add	r8,r12,r10
80006b82:	70 0a       	ld.w	r10,r8[0x0]
	mask |= 1U << module_index;
80006b84:	30 1e       	mov	lr,1
80006b86:	fc 0b 09 4b 	lsl	r11,lr,r11
80006b8a:	14 4b       	or	r11,r10
	AVR32_PM.unlock = 0xaa000020 + (4 * bus_id);
80006b8c:	32 0a       	mov	r10,32
80006b8e:	ea 1a aa 00 	orh	r10,0xaa00
80006b92:	14 0c       	add	r12,r10
80006b94:	fe 7a 04 00 	mov	r10,-64512
80006b98:	f5 4c 00 58 	st.w	r10[88],r12
	*(&AVR32_PM.cpumask + bus_id) = mask;
80006b9c:	91 0b       	st.w	r8[0x0],r11
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006b9e:	12 98       	mov	r8,r9
80006ba0:	e6 18 00 01 	andh	r8,0x1,COH
80006ba4:	c0 21       	brne	80006ba8 <sysclk_priv_enable_module+0x38>
      cpu_irq_enable();
80006ba6:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80006ba8:	d8 02       	popm	pc
80006baa:	d7 03       	nop

80006bac <sysclk_init>:
}
#endif // CONFIG_USBCLK_SOURCE


void sysclk_init(void)
{
80006bac:	d4 01       	pushm	lr
80006bae:	20 1d       	sub	sp,4
	/* Set up system clock dividers if different from defaults */
	if ((CONFIG_SYSCLK_CPU_DIV > 0) || (CONFIG_SYSCLK_PBA_DIV > 0) ||
			(CONFIG_SYSCLK_PBB_DIV > 0) || (CONFIG_SYSCLK_PBC_DIV > 0)) {
		sysclk_set_prescalers(CONFIG_SYSCLK_CPU_DIV,
80006bb0:	30 19       	mov	r9,1
80006bb2:	12 9a       	mov	r10,r9
80006bb4:	12 9b       	mov	r11,r9
80006bb6:	30 0c       	mov	r12,0
80006bb8:	f0 1f 00 1e 	mcall	80006c30 <sysclk_init+0x84>

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_SCIF.pclksr & (1U << (AVR32_SCIF_PLL0_LOCK + pll_id)));
80006bbc:	fe 78 08 00 	mov	r8,-63488
80006bc0:	70 58       	ld.w	r8,r8[0x14]

static inline void pll_enable_config_defaults(unsigned int pll_id)
{
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
80006bc2:	e2 18 00 10 	andl	r8,0x10,COH
80006bc6:	c2 91       	brne	80006c18 <sysclk_init+0x6c>
static inline bool osc_is_ready(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_SCIF.pclksr & (1 << AVR32_SCIF_OSC0RDY));
80006bc8:	fe 78 08 00 	mov	r8,-63488
80006bcc:	70 58       	ld.w	r8,r8[0x14]

static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
80006bce:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006bd2:	c0 a1       	brne	80006be6 <sysclk_init+0x3a>
			osc_enable(OSC_ID_OSC0);
80006bd4:	30 0c       	mov	r12,0
80006bd6:	f0 1f 00 18 	mcall	80006c34 <sysclk_init+0x88>
80006bda:	fe 79 08 00 	mov	r9,-63488
80006bde:	72 58       	ld.w	r8,r9[0x14]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
80006be0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006be4:	cf d0       	breq	80006bde <sysclk_init+0x32>
static inline void pll_config_set_option(struct pll_config *cfg,
		unsigned int option)
{
	Assert(option < PLL_NR_OPTIONS);

	cfg->ctrl |= 1U << (AVR32_SCIF_PLLOPT + option);
80006be6:	31 08       	mov	r8,16
80006be8:	a3 b8       	sbr	r8,0x3
80006bea:	50 08       	stdsp	sp[0x0],r8
		pll_config_set_option(cfg, PLL_OPT_VCO_RANGE_LOW);

	Assert(mul > 2 && mul <= 16);
	Assert(div > 0 && div <= 15);

	cfg->ctrl |= ((mul - 1) << AVR32_SCIF_PLLMUL)
80006bec:	10 99       	mov	r9,r8
80006bee:	ea 19 3f 00 	orh	r9,0x3f00
80006bf2:	e8 19 01 00 	orl	r9,0x100
80006bf6:	30 68       	mov	r8,6
80006bf8:	20 18       	sub	r8,1
80006bfa:	f3 e8 11 08 	or	r8,r9,r8<<0x10
80006bfe:	fa cc ff fc 	sub	r12,sp,-4
80006c02:	18 d8       	st.w	--r12,r8
#endif
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
80006c04:	30 0b       	mov	r11,0
80006c06:	1a 9c       	mov	r12,sp
80006c08:	f0 1f 00 0c 	mcall	80006c38 <sysclk_init+0x8c>

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_SCIF.pclksr & (1U << (AVR32_SCIF_PLL0_LOCK + pll_id)));
80006c0c:	fe 79 08 00 	mov	r9,-63488
80006c10:	72 58       	ld.w	r8,r9[0x14]
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
80006c12:	e2 18 00 10 	andl	r8,0x10,COH
80006c16:	cf d0       	breq	80006c10 <sysclk_init+0x64>

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0: {
		pll_enable_config_defaults(0);
		// Set a flash wait state depending on the new cpu frequency.
		flash_set_bus_freq(sysclk_get_cpu_hz());
80006c18:	e0 6c 6c 00 	mov	r12,27648
80006c1c:	ea 1c 02 dc 	orh	r12,0x2dc
80006c20:	f0 1f 00 07 	mcall	80006c3c <sysclk_init+0x90>
		sysclk_set_source(SYSCLK_SRC_PLL0);
80006c24:	30 3c       	mov	r12,3
80006c26:	f0 1f 00 07 	mcall	80006c40 <sysclk_init+0x94>

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = true;
#endif
}
80006c2a:	2f fd       	sub	sp,-4
80006c2c:	d8 02       	popm	pc
80006c2e:	00 00       	add	r0,r0
80006c30:	80 00       	ld.sh	r0,r0[0x0]
80006c32:	6b 04       	ld.w	r4,r5[0x40]
80006c34:	80 00       	ld.sh	r0,r0[0x0]
80006c36:	6a 94       	ld.w	r4,r5[0x24]
80006c38:	80 00       	ld.sh	r0,r0[0x0]
80006c3a:	6a 6a       	ld.w	r10,r5[0x18]
80006c3c:	80 00       	ld.sh	r0,r0[0x0]
80006c3e:	65 fc       	ld.w	r12,r2[0x7c]
80006c40:	80 00       	ld.sh	r0,r0[0x0]
80006c42:	6a e4       	ld.w	r4,r5[0x38]

80006c44 <board_init>:
#include <conf_board.h>
#include "ecu_can.h"
#include "mcp2515.h"

void board_init(void)
{
80006c44:	d4 01       	pushm	lr
	/* This function is meant to contain board-specific initialization code
	 * for, e.g., the I/O pins. The initialization can rely on application-
	 * specific board configuration, found in conf_board.h.
	 */
	#ifdef USE_WDT
		wdt_disable();
80006c46:	f0 1f 00 25 	mcall	80006cd8 <board_init+0x94>
	#endif
	/* Disable all interrupts. */
	Disable_global_interrupt();
80006c4a:	d3 03       	ssrf	0x10
	sysclk_init();
80006c4c:	f0 1f 00 24 	mcall	80006cdc <board_init+0x98>
	delay_init(sysclk_get_cpu_hz());
	
	gpio_configure_pin(LED1,  GPIO_INIT_HIGH|GPIO_DIR_OUTPUT);
80006c50:	30 3b       	mov	r11,3
80006c52:	35 3c       	mov	r12,83
80006c54:	f0 1f 00 23 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(LED2,  GPIO_INIT_HIGH|GPIO_DIR_OUTPUT);
80006c58:	30 3b       	mov	r11,3
80006c5a:	35 2c       	mov	r12,82
80006c5c:	f0 1f 00 21 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(LED3,  GPIO_INIT_HIGH|GPIO_DIR_OUTPUT);
80006c60:	30 3b       	mov	r11,3
80006c62:	35 1c       	mov	r12,81
80006c64:	f0 1f 00 1f 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(LED4,  GPIO_INIT_HIGH|GPIO_DIR_OUTPUT);
80006c68:	30 3b       	mov	r11,3
80006c6a:	35 0c       	mov	r12,80
80006c6c:	f0 1f 00 1d 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(AIR_PLUS,GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006c70:	30 1b       	mov	r11,1
80006c72:	30 4c       	mov	r12,4
80006c74:	f0 1f 00 1b 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(FRG_PIN,GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006c78:	30 1b       	mov	r11,1
80006c7a:	30 9c       	mov	r12,9
80006c7c:	f0 1f 00 19 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(RFE_PIN,GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006c80:	30 1b       	mov	r11,1
80006c82:	31 0c       	mov	r12,16
80006c84:	f0 1f 00 17 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(INVERTER_BTB,GPIO_PULL_DOWN|GPIO_DIR_INPUT);
80006c88:	30 8b       	mov	r11,8
80006c8a:	37 dc       	mov	r12,125
80006c8c:	f0 1f 00 15 	mcall	80006ce0 <board_init+0x9c>
	
	
	gpio_configure_pin(INVERTER_DIN1, GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006c90:	30 1b       	mov	r11,1
80006c92:	30 5c       	mov	r12,5
80006c94:	f0 1f 00 13 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(INVERTER_DIN2, GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006c98:	30 1b       	mov	r11,1
80006c9a:	30 6c       	mov	r12,6
80006c9c:	f0 1f 00 11 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(INVERTER_DOUT1,GPIO_PULL_DOWN|GPIO_DIR_INPUT);
80006ca0:	30 8b       	mov	r11,8
80006ca2:	37 5c       	mov	r12,117
80006ca4:	f0 1f 00 0f 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(INVERTER_DOUT2,GPIO_PULL_DOWN|GPIO_DIR_INPUT);
80006ca8:	30 8b       	mov	r11,8
80006caa:	37 bc       	mov	r12,123
80006cac:	f0 1f 00 0d 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(INVERTER_DOUT3,GPIO_PULL_DOWN|GPIO_DIR_INPUT);
80006cb0:	30 8b       	mov	r11,8
80006cb2:	37 cc       	mov	r12,124
80006cb4:	f0 1f 00 0b 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(END1, GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006cb8:	30 1b       	mov	r11,1
80006cba:	30 7c       	mov	r12,7
80006cbc:	f0 1f 00 09 	mcall	80006ce0 <board_init+0x9c>
	gpio_configure_pin(END2, GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006cc0:	30 1b       	mov	r11,1
80006cc2:	30 8c       	mov	r12,8
80006cc4:	f0 1f 00 07 	mcall	80006ce0 <board_init+0x9c>
	
	gpio_configure_pin(INT1, GPIO_DIR_INPUT| GPIO_PULL_UP); 
80006cc8:	30 4b       	mov	r11,4
80006cca:	36 ec       	mov	r12,110
80006ccc:	f0 1f 00 05 	mcall	80006ce0 <board_init+0x9c>
	
	ecu_can_init();
80006cd0:	f0 1f 00 05 	mcall	80006ce4 <board_init+0xa0>
	
	Enable_global_interrupt();
80006cd4:	d5 03       	csrf	0x10
	
}
80006cd6:	d8 02       	popm	pc
80006cd8:	80 00       	ld.sh	r0,r0[0x0]
80006cda:	21 d4       	sub	r4,29
80006cdc:	80 00       	ld.sh	r0,r0[0x0]
80006cde:	6b ac       	ld.w	r12,r5[0x68]
80006ce0:	80 00       	ld.sh	r0,r0[0x0]
80006ce2:	66 e4       	ld.w	r4,r3[0x38]
80006ce4:	80 00       	ld.sh	r0,r0[0x0]
80006ce6:	53 ec       	stdsp	sp[0xf8],r12

80006ce8 <__avr32_f64_sub_from_add>:
80006ce8:	ee 19 80 00 	eorh	r9,0x8000

80006cec <__avr32_f64_sub>:
80006cec:	f7 e9 20 0c 	eor	r12,r11,r9
80006cf0:	e0 86 00 ca 	brmi	80006e84 <__avr32_f64_add_from_sub>
80006cf4:	eb cd 40 e0 	pushm	r5-r7,lr
80006cf8:	16 9c       	mov	r12,r11
80006cfa:	e6 1c 80 00 	andh	r12,0x8000,COH
80006cfe:	bf db       	cbr	r11,0x1f
80006d00:	bf d9       	cbr	r9,0x1f
80006d02:	10 3a       	cp.w	r10,r8
80006d04:	f2 0b 13 00 	cpc	r11,r9
80006d08:	c0 92       	brcc	80006d1a <__avr32_f64_sub+0x2e>
80006d0a:	16 97       	mov	r7,r11
80006d0c:	12 9b       	mov	r11,r9
80006d0e:	0e 99       	mov	r9,r7
80006d10:	14 97       	mov	r7,r10
80006d12:	10 9a       	mov	r10,r8
80006d14:	0e 98       	mov	r8,r7
80006d16:	ee 1c 80 00 	eorh	r12,0x8000
80006d1a:	f6 07 16 14 	lsr	r7,r11,0x14
80006d1e:	ab 7b       	lsl	r11,0xb
80006d20:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80006d24:	ab 7a       	lsl	r10,0xb
80006d26:	bf bb       	sbr	r11,0x1f
80006d28:	f2 06 16 14 	lsr	r6,r9,0x14
80006d2c:	c4 40       	breq	80006db4 <__avr32_f64_sub_opL_subnormal>
80006d2e:	ab 79       	lsl	r9,0xb
80006d30:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80006d34:	ab 78       	lsl	r8,0xb
80006d36:	bf b9       	sbr	r9,0x1f

80006d38 <__avr32_f64_sub_opL_subnormal_done>:
80006d38:	e0 47 07 ff 	cp.w	r7,2047
80006d3c:	c4 f0       	breq	80006dda <__avr32_f64_sub_opH_nan_or_inf>
80006d3e:	0e 26       	rsub	r6,r7
80006d40:	c1 20       	breq	80006d64 <__avr32_f64_sub_shift_done>
80006d42:	ec 05 11 20 	rsub	r5,r6,32
80006d46:	e0 46 00 20 	cp.w	r6,32
80006d4a:	c7 c2       	brcc	80006e42 <__avr32_f64_sub_longshift>
80006d4c:	f0 05 09 4e 	lsl	lr,r8,r5
80006d50:	f2 05 09 45 	lsl	r5,r9,r5
80006d54:	f0 06 0a 48 	lsr	r8,r8,r6
80006d58:	f2 06 0a 49 	lsr	r9,r9,r6
80006d5c:	0a 48       	or	r8,r5
80006d5e:	58 0e       	cp.w	lr,0
80006d60:	5f 1e       	srne	lr
80006d62:	1c 48       	or	r8,lr

80006d64 <__avr32_f64_sub_shift_done>:
80006d64:	10 1a       	sub	r10,r8
80006d66:	f6 09 01 4b 	sbc	r11,r11,r9
80006d6a:	f6 06 12 00 	clz	r6,r11
80006d6e:	c0 e0       	breq	80006d8a <__avr32_f64_sub_longnormalize_done>
80006d70:	c7 83       	brcs	80006e60 <__avr32_f64_sub_longnormalize>
80006d72:	ec 0e 11 20 	rsub	lr,r6,32
80006d76:	f6 06 09 4b 	lsl	r11,r11,r6
80006d7a:	f4 0e 0a 4e 	lsr	lr,r10,lr
80006d7e:	1c 4b       	or	r11,lr
80006d80:	f4 06 09 4a 	lsl	r10,r10,r6
80006d84:	0c 17       	sub	r7,r6
80006d86:	e0 8a 00 39 	brle	80006df8 <__avr32_f64_sub_subnormal_result>

80006d8a <__avr32_f64_sub_longnormalize_done>:
80006d8a:	f4 09 15 15 	lsl	r9,r10,0x15
80006d8e:	ab 9a       	lsr	r10,0xb
80006d90:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80006d94:	ab 9b       	lsr	r11,0xb
80006d96:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80006d9a:	18 4b       	or	r11,r12

80006d9c <__avr32_f64_sub_round>:
80006d9c:	fc 17 80 00 	movh	r7,0x8000
80006da0:	ed ba 00 00 	bld	r10,0x0
80006da4:	f7 b7 01 ff 	subne	r7,-1
80006da8:	0e 39       	cp.w	r9,r7
80006daa:	5f 29       	srhs	r9
80006dac:	12 0a       	add	r10,r9
80006dae:	5c 0b       	acr	r11
80006db0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80006db4 <__avr32_f64_sub_opL_subnormal>:
80006db4:	ab 79       	lsl	r9,0xb
80006db6:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80006dba:	ab 78       	lsl	r8,0xb
80006dbc:	f3 e8 10 0e 	or	lr,r9,r8
80006dc0:	f9 b6 01 01 	movne	r6,1
80006dc4:	ee 0e 11 00 	rsub	lr,r7,0
80006dc8:	f9 b7 00 01 	moveq	r7,1
80006dcc:	ef bb 00 1f 	bst	r11,0x1f
80006dd0:	f7 ea 10 0e 	or	lr,r11,r10
80006dd4:	f9 b7 00 00 	moveq	r7,0
80006dd8:	cb 0b       	rjmp	80006d38 <__avr32_f64_sub_opL_subnormal_done>

80006dda <__avr32_f64_sub_opH_nan_or_inf>:
80006dda:	bf db       	cbr	r11,0x1f
80006ddc:	f7 ea 10 0e 	or	lr,r11,r10
80006de0:	c0 81       	brne	80006df0 <__avr32_f64_sub_return_nan>
80006de2:	e0 46 07 ff 	cp.w	r6,2047
80006de6:	c0 50       	breq	80006df0 <__avr32_f64_sub_return_nan>
80006de8:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
80006dec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80006df0 <__avr32_f64_sub_return_nan>:
80006df0:	3f fa       	mov	r10,-1
80006df2:	3f fb       	mov	r11,-1
80006df4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80006df8 <__avr32_f64_sub_subnormal_result>:
80006df8:	5c 37       	neg	r7
80006dfa:	2f f7       	sub	r7,-1
80006dfc:	f1 b7 04 c0 	satu	r7,0x6
80006e00:	e0 47 00 20 	cp.w	r7,32
80006e04:	c1 14       	brge	80006e26 <__avr32_f64_sub_subnormal_result+0x2e>
80006e06:	ee 08 11 20 	rsub	r8,r7,32
80006e0a:	f4 08 09 49 	lsl	r9,r10,r8
80006e0e:	5f 16       	srne	r6
80006e10:	f4 07 0a 4a 	lsr	r10,r10,r7
80006e14:	0c 4a       	or	r10,r6
80006e16:	f6 08 09 49 	lsl	r9,r11,r8
80006e1a:	f5 e9 10 0a 	or	r10,r10,r9
80006e1e:	f4 07 0a 4b 	lsr	r11,r10,r7
80006e22:	30 07       	mov	r7,0
80006e24:	cb 3b       	rjmp	80006d8a <__avr32_f64_sub_longnormalize_done>
80006e26:	ee 08 11 40 	rsub	r8,r7,64
80006e2a:	f6 08 09 49 	lsl	r9,r11,r8
80006e2e:	14 49       	or	r9,r10
80006e30:	5f 16       	srne	r6
80006e32:	f6 07 0a 4a 	lsr	r10,r11,r7
80006e36:	0c 4a       	or	r10,r6
80006e38:	30 0b       	mov	r11,0
80006e3a:	30 07       	mov	r7,0
80006e3c:	ca 7b       	rjmp	80006d8a <__avr32_f64_sub_longnormalize_done>
80006e3e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80006e42 <__avr32_f64_sub_longshift>:
80006e42:	f1 b6 04 c0 	satu	r6,0x6
80006e46:	f0 0e 17 00 	moveq	lr,r8
80006e4a:	c0 40       	breq	80006e52 <__avr32_f64_sub_longshift+0x10>
80006e4c:	f2 05 09 4e 	lsl	lr,r9,r5
80006e50:	10 4e       	or	lr,r8
80006e52:	f2 06 0a 48 	lsr	r8,r9,r6
80006e56:	30 09       	mov	r9,0
80006e58:	58 0e       	cp.w	lr,0
80006e5a:	5f 1e       	srne	lr
80006e5c:	1c 48       	or	r8,lr
80006e5e:	c8 3b       	rjmp	80006d64 <__avr32_f64_sub_shift_done>

80006e60 <__avr32_f64_sub_longnormalize>:
80006e60:	f4 06 12 00 	clz	r6,r10
80006e64:	f9 b7 03 00 	movlo	r7,0
80006e68:	f9 b6 03 00 	movlo	r6,0
80006e6c:	f9 bc 03 00 	movlo	r12,0
80006e70:	f7 b6 02 e0 	subhs	r6,-32
80006e74:	f4 06 09 4b 	lsl	r11,r10,r6
80006e78:	30 0a       	mov	r10,0
80006e7a:	0c 17       	sub	r7,r6
80006e7c:	fe 9a ff be 	brle	80006df8 <__avr32_f64_sub_subnormal_result>
80006e80:	c8 5b       	rjmp	80006d8a <__avr32_f64_sub_longnormalize_done>
80006e82:	d7 03       	nop

80006e84 <__avr32_f64_add_from_sub>:
80006e84:	ee 19 80 00 	eorh	r9,0x8000

80006e88 <__avr32_f64_add>:
80006e88:	f7 e9 20 0c 	eor	r12,r11,r9
80006e8c:	fe 96 ff 2e 	brmi	80006ce8 <__avr32_f64_sub_from_add>
80006e90:	eb cd 40 e0 	pushm	r5-r7,lr
80006e94:	16 9c       	mov	r12,r11
80006e96:	e6 1c 80 00 	andh	r12,0x8000,COH
80006e9a:	bf db       	cbr	r11,0x1f
80006e9c:	bf d9       	cbr	r9,0x1f
80006e9e:	12 3b       	cp.w	r11,r9
80006ea0:	c0 72       	brcc	80006eae <__avr32_f64_add+0x26>
80006ea2:	16 97       	mov	r7,r11
80006ea4:	12 9b       	mov	r11,r9
80006ea6:	0e 99       	mov	r9,r7
80006ea8:	14 97       	mov	r7,r10
80006eaa:	10 9a       	mov	r10,r8
80006eac:	0e 98       	mov	r8,r7
80006eae:	30 0e       	mov	lr,0
80006eb0:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80006eb4:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
80006eb8:	b5 ab       	sbr	r11,0x14
80006eba:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80006ebe:	c6 20       	breq	80006f82 <__avr32_f64_add_op2_subnormal>
80006ec0:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
80006ec4:	b5 a9       	sbr	r9,0x14
80006ec6:	e0 47 07 ff 	cp.w	r7,2047
80006eca:	c2 80       	breq	80006f1a <__avr32_f64_add_opH_nan_or_inf>
80006ecc:	0e 26       	rsub	r6,r7
80006ece:	c1 20       	breq	80006ef2 <__avr32_f64_add_shift_done>
80006ed0:	e0 46 00 36 	cp.w	r6,54
80006ed4:	c1 52       	brcc	80006efe <__avr32_f64_add_res_of_done>
80006ed6:	ec 05 11 20 	rsub	r5,r6,32
80006eda:	e0 46 00 20 	cp.w	r6,32
80006ede:	c3 52       	brcc	80006f48 <__avr32_f64_add_longshift>
80006ee0:	f0 05 09 4e 	lsl	lr,r8,r5
80006ee4:	f2 05 09 45 	lsl	r5,r9,r5
80006ee8:	f0 06 0a 48 	lsr	r8,r8,r6
80006eec:	f2 06 0a 49 	lsr	r9,r9,r6
80006ef0:	0a 48       	or	r8,r5

80006ef2 <__avr32_f64_add_shift_done>:
80006ef2:	10 0a       	add	r10,r8
80006ef4:	f6 09 00 4b 	adc	r11,r11,r9
80006ef8:	ed bb 00 15 	bld	r11,0x15
80006efc:	c3 40       	breq	80006f64 <__avr32_f64_add_res_of>

80006efe <__avr32_f64_add_res_of_done>:
80006efe:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80006f02:	18 4b       	or	r11,r12

80006f04 <__avr32_f64_add_round>:
80006f04:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
80006f08:	18 4e       	or	lr,r12
80006f0a:	ee 1e 80 00 	eorh	lr,0x8000
80006f0e:	f1 be 04 20 	satu	lr,0x1
80006f12:	1c 0a       	add	r10,lr
80006f14:	5c 0b       	acr	r11
80006f16:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80006f1a <__avr32_f64_add_opH_nan_or_inf>:
80006f1a:	b5 cb       	cbr	r11,0x14
80006f1c:	f7 ea 10 0e 	or	lr,r11,r10
80006f20:	c1 01       	brne	80006f40 <__avr32_f64_add_return_nan>
80006f22:	e0 46 07 ff 	cp.w	r6,2047
80006f26:	c0 30       	breq	80006f2c <__avr32_f64_add_opL_nan_or_inf>
80006f28:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80006f2c <__avr32_f64_add_opL_nan_or_inf>:
80006f2c:	b5 c9       	cbr	r9,0x14
80006f2e:	f3 e8 10 0e 	or	lr,r9,r8
80006f32:	c0 71       	brne	80006f40 <__avr32_f64_add_return_nan>
80006f34:	30 0a       	mov	r10,0
80006f36:	fc 1b 7f f0 	movh	r11,0x7ff0
80006f3a:	18 4b       	or	r11,r12
80006f3c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80006f40 <__avr32_f64_add_return_nan>:
80006f40:	3f fa       	mov	r10,-1
80006f42:	3f fb       	mov	r11,-1
80006f44:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80006f48 <__avr32_f64_add_longshift>:
80006f48:	f1 b6 04 c0 	satu	r6,0x6
80006f4c:	f0 0e 17 00 	moveq	lr,r8
80006f50:	c0 60       	breq	80006f5c <__avr32_f64_add_longshift+0x14>
80006f52:	f2 05 09 4e 	lsl	lr,r9,r5
80006f56:	58 08       	cp.w	r8,0
80006f58:	5f 18       	srne	r8
80006f5a:	10 4e       	or	lr,r8
80006f5c:	f2 06 0a 48 	lsr	r8,r9,r6
80006f60:	30 09       	mov	r9,0
80006f62:	cc 8b       	rjmp	80006ef2 <__avr32_f64_add_shift_done>

80006f64 <__avr32_f64_add_res_of>:
80006f64:	fd ee 10 1e 	or	lr,lr,lr<<0x1
80006f68:	a1 9b       	lsr	r11,0x1
80006f6a:	5d 0a       	ror	r10
80006f6c:	5d 0e       	ror	lr
80006f6e:	2f f7       	sub	r7,-1
80006f70:	e0 47 07 ff 	cp.w	r7,2047
80006f74:	f9 ba 00 00 	moveq	r10,0
80006f78:	f9 bb 00 00 	moveq	r11,0
80006f7c:	f9 be 00 00 	moveq	lr,0
80006f80:	cb fb       	rjmp	80006efe <__avr32_f64_add_res_of_done>

80006f82 <__avr32_f64_add_op2_subnormal>:
80006f82:	30 16       	mov	r6,1
80006f84:	58 07       	cp.w	r7,0
80006f86:	ca 01       	brne	80006ec6 <__avr32_f64_add+0x3e>
80006f88:	b5 cb       	cbr	r11,0x14
80006f8a:	10 0a       	add	r10,r8
80006f8c:	f6 09 00 4b 	adc	r11,r11,r9
80006f90:	18 4b       	or	r11,r12
80006f92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80006f96:	d7 03       	nop

80006f98 <__avr32_u32_to_f64>:
80006f98:	f8 cb 00 00 	sub	r11,r12,0
80006f9c:	30 0c       	mov	r12,0
80006f9e:	c0 38       	rjmp	80006fa4 <__avr32_s32_to_f64+0x4>

80006fa0 <__avr32_s32_to_f64>:
80006fa0:	18 9b       	mov	r11,r12
80006fa2:	5c 4b       	abs	r11
80006fa4:	30 0a       	mov	r10,0
80006fa6:	5e 0b       	reteq	r11
80006fa8:	d4 01       	pushm	lr
80006faa:	e0 69 04 1e 	mov	r9,1054
80006fae:	f6 08 12 00 	clz	r8,r11
80006fb2:	c1 70       	breq	80006fe0 <__avr32_s32_to_f64+0x40>
80006fb4:	c0 c3       	brcs	80006fcc <__avr32_s32_to_f64+0x2c>
80006fb6:	f0 0e 11 20 	rsub	lr,r8,32
80006fba:	f6 08 09 4b 	lsl	r11,r11,r8
80006fbe:	f4 0e 0a 4e 	lsr	lr,r10,lr
80006fc2:	1c 4b       	or	r11,lr
80006fc4:	f4 08 09 4a 	lsl	r10,r10,r8
80006fc8:	10 19       	sub	r9,r8
80006fca:	c0 b8       	rjmp	80006fe0 <__avr32_s32_to_f64+0x40>
80006fcc:	f4 08 12 00 	clz	r8,r10
80006fd0:	f9 b8 03 00 	movlo	r8,0
80006fd4:	f7 b8 02 e0 	subhs	r8,-32
80006fd8:	f4 08 09 4b 	lsl	r11,r10,r8
80006fdc:	30 0a       	mov	r10,0
80006fde:	10 19       	sub	r9,r8
80006fe0:	58 09       	cp.w	r9,0
80006fe2:	e0 89 00 30 	brgt	80007042 <__avr32_s32_to_f64+0xa2>
80006fe6:	5c 39       	neg	r9
80006fe8:	2f f9       	sub	r9,-1
80006fea:	e0 49 00 36 	cp.w	r9,54
80006fee:	c0 43       	brcs	80006ff6 <__avr32_s32_to_f64+0x56>
80006ff0:	30 0b       	mov	r11,0
80006ff2:	30 0a       	mov	r10,0
80006ff4:	c2 68       	rjmp	80007040 <__avr32_s32_to_f64+0xa0>
80006ff6:	2f 69       	sub	r9,-10
80006ff8:	f2 08 11 20 	rsub	r8,r9,32
80006ffc:	e0 49 00 20 	cp.w	r9,32
80007000:	c0 b2       	brcc	80007016 <__avr32_s32_to_f64+0x76>
80007002:	f4 08 09 4e 	lsl	lr,r10,r8
80007006:	f6 08 09 48 	lsl	r8,r11,r8
8000700a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000700e:	f6 09 0a 4b 	lsr	r11,r11,r9
80007012:	10 4b       	or	r11,r8
80007014:	c0 88       	rjmp	80007024 <__avr32_s32_to_f64+0x84>
80007016:	f6 08 09 4e 	lsl	lr,r11,r8
8000701a:	14 4e       	or	lr,r10
8000701c:	16 9a       	mov	r10,r11
8000701e:	30 0b       	mov	r11,0
80007020:	f4 09 0a 4a 	lsr	r10,r10,r9
80007024:	ed ba 00 00 	bld	r10,0x0
80007028:	c0 92       	brcc	8000703a <__avr32_s32_to_f64+0x9a>
8000702a:	1c 7e       	tst	lr,lr
8000702c:	c0 41       	brne	80007034 <__avr32_s32_to_f64+0x94>
8000702e:	ed ba 00 01 	bld	r10,0x1
80007032:	c0 42       	brcc	8000703a <__avr32_s32_to_f64+0x9a>
80007034:	2f fa       	sub	r10,-1
80007036:	f7 bb 02 ff 	subhs	r11,-1
8000703a:	5c fc       	rol	r12
8000703c:	5d 0b       	ror	r11
8000703e:	5d 0a       	ror	r10
80007040:	d8 02       	popm	pc
80007042:	e0 68 03 ff 	mov	r8,1023
80007046:	ed ba 00 0b 	bld	r10,0xb
8000704a:	f7 b8 00 ff 	subeq	r8,-1
8000704e:	10 0a       	add	r10,r8
80007050:	5c 0b       	acr	r11
80007052:	f7 b9 03 fe 	sublo	r9,-2
80007056:	e0 49 07 ff 	cp.w	r9,2047
8000705a:	c0 55       	brlt	80007064 <__avr32_s32_to_f64+0xc4>
8000705c:	30 0a       	mov	r10,0
8000705e:	fc 1b ff e0 	movh	r11,0xffe0
80007062:	c0 c8       	rjmp	8000707a <__floatsidf_return_op1>
80007064:	ed bb 00 1f 	bld	r11,0x1f
80007068:	f7 b9 01 01 	subne	r9,1
8000706c:	ab 9a       	lsr	r10,0xb
8000706e:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80007072:	a1 7b       	lsl	r11,0x1
80007074:	ab 9b       	lsr	r11,0xb
80007076:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

8000707a <__floatsidf_return_op1>:
8000707a:	a1 7c       	lsl	r12,0x1
8000707c:	5d 0b       	ror	r11
8000707e:	d8 02       	popm	pc

80007080 <__avr32_f64_div>:
80007080:	eb cd 40 ff 	pushm	r0-r7,lr
80007084:	f7 e9 20 0e 	eor	lr,r11,r9
80007088:	f6 07 16 14 	lsr	r7,r11,0x14
8000708c:	a9 7b       	lsl	r11,0x9
8000708e:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
80007092:	a9 7a       	lsl	r10,0x9
80007094:	bd bb       	sbr	r11,0x1d
80007096:	e4 1b 3f ff 	andh	r11,0x3fff
8000709a:	ab d7       	cbr	r7,0xb
8000709c:	e0 80 00 cc 	breq	80007234 <__avr32_f64_div_round_subnormal+0x54>
800070a0:	e0 47 07 ff 	cp.w	r7,2047
800070a4:	e0 84 00 b5 	brge	8000720e <__avr32_f64_div_round_subnormal+0x2e>
800070a8:	f2 06 16 14 	lsr	r6,r9,0x14
800070ac:	a9 79       	lsl	r9,0x9
800070ae:	f3 e8 13 79 	or	r9,r9,r8>>0x17
800070b2:	a9 78       	lsl	r8,0x9
800070b4:	bd b9       	sbr	r9,0x1d
800070b6:	e4 19 3f ff 	andh	r9,0x3fff
800070ba:	ab d6       	cbr	r6,0xb
800070bc:	e0 80 00 e2 	breq	80007280 <__avr32_f64_div_round_subnormal+0xa0>
800070c0:	e0 46 07 ff 	cp.w	r6,2047
800070c4:	e0 84 00 b2 	brge	80007228 <__avr32_f64_div_round_subnormal+0x48>
800070c8:	0c 17       	sub	r7,r6
800070ca:	fe 37 fc 01 	sub	r7,-1023
800070ce:	fc 1c 80 00 	movh	r12,0x8000
800070d2:	f8 03 16 01 	lsr	r3,r12,0x1
800070d6:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
800070da:	5c d4       	com	r4
800070dc:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
800070e0:	e6 09 06 44 	mulu.d	r4,r3,r9
800070e4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800070e8:	e6 05 06 44 	mulu.d	r4,r3,r5
800070ec:	ea 03 15 02 	lsl	r3,r5,0x2
800070f0:	e6 09 06 44 	mulu.d	r4,r3,r9
800070f4:	f8 05 01 25 	sub	r5,r12,r5<<0x2
800070f8:	e6 05 06 44 	mulu.d	r4,r3,r5
800070fc:	ea 03 15 02 	lsl	r3,r5,0x2
80007100:	e6 09 06 44 	mulu.d	r4,r3,r9
80007104:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80007108:	e6 05 06 44 	mulu.d	r4,r3,r5
8000710c:	ea 03 15 02 	lsl	r3,r5,0x2
80007110:	e6 08 06 40 	mulu.d	r0,r3,r8
80007114:	e4 09 07 40 	macu.d	r0,r2,r9
80007118:	e6 09 06 44 	mulu.d	r4,r3,r9
8000711c:	02 04       	add	r4,r1
8000711e:	5c 05       	acr	r5
80007120:	a3 65       	lsl	r5,0x2
80007122:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80007126:	a3 64       	lsl	r4,0x2
80007128:	5c 34       	neg	r4
8000712a:	f8 05 01 45 	sbc	r5,r12,r5
8000712e:	e6 04 06 40 	mulu.d	r0,r3,r4
80007132:	e4 05 07 40 	macu.d	r0,r2,r5
80007136:	e6 05 06 44 	mulu.d	r4,r3,r5
8000713a:	02 04       	add	r4,r1
8000713c:	5c 05       	acr	r5
8000713e:	ea 03 15 02 	lsl	r3,r5,0x2
80007142:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80007146:	e8 02 15 02 	lsl	r2,r4,0x2
8000714a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000714e:	e4 09 07 40 	macu.d	r0,r2,r9
80007152:	e6 09 06 44 	mulu.d	r4,r3,r9
80007156:	02 04       	add	r4,r1
80007158:	5c 05       	acr	r5
8000715a:	a3 65       	lsl	r5,0x2
8000715c:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80007160:	a3 64       	lsl	r4,0x2
80007162:	5c 34       	neg	r4
80007164:	f8 05 01 45 	sbc	r5,r12,r5
80007168:	e6 04 06 40 	mulu.d	r0,r3,r4
8000716c:	e4 05 07 40 	macu.d	r0,r2,r5
80007170:	e6 05 06 44 	mulu.d	r4,r3,r5
80007174:	02 04       	add	r4,r1
80007176:	5c 05       	acr	r5
80007178:	ea 03 15 02 	lsl	r3,r5,0x2
8000717c:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80007180:	e8 02 15 02 	lsl	r2,r4,0x2
80007184:	e6 0a 06 40 	mulu.d	r0,r3,r10
80007188:	e4 0b 07 40 	macu.d	r0,r2,r11
8000718c:	e6 0b 06 42 	mulu.d	r2,r3,r11
80007190:	02 02       	add	r2,r1
80007192:	5c 03       	acr	r3
80007194:	ed b3 00 1c 	bld	r3,0x1c
80007198:	c0 90       	breq	800071aa <__avr32_f64_div+0x12a>
8000719a:	a1 72       	lsl	r2,0x1
8000719c:	5c f3       	rol	r3
8000719e:	20 17       	sub	r7,1
800071a0:	a3 9a       	lsr	r10,0x3
800071a2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
800071a6:	a3 9b       	lsr	r11,0x3
800071a8:	c0 58       	rjmp	800071b2 <__avr32_f64_div+0x132>
800071aa:	a5 8a       	lsr	r10,0x4
800071ac:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
800071b0:	a5 8b       	lsr	r11,0x4
800071b2:	58 07       	cp.w	r7,0
800071b4:	e0 8a 00 8b 	brle	800072ca <__avr32_f64_div_res_subnormal>
800071b8:	e0 12 ff 00 	andl	r2,0xff00
800071bc:	e8 12 00 80 	orl	r2,0x80
800071c0:	e6 08 06 40 	mulu.d	r0,r3,r8
800071c4:	e4 09 07 40 	macu.d	r0,r2,r9
800071c8:	e4 08 06 44 	mulu.d	r4,r2,r8
800071cc:	e6 09 06 48 	mulu.d	r8,r3,r9
800071d0:	00 05       	add	r5,r0
800071d2:	f0 01 00 48 	adc	r8,r8,r1
800071d6:	5c 09       	acr	r9
800071d8:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
800071dc:	58 04       	cp.w	r4,0
800071de:	5c 25       	cpc	r5

800071e0 <__avr32_f64_div_round_subnormal>:
800071e0:	f4 08 13 00 	cpc	r8,r10
800071e4:	f6 09 13 00 	cpc	r9,r11
800071e8:	5f 36       	srlo	r6
800071ea:	f8 06 17 00 	moveq	r6,r12
800071ee:	e4 0a 16 08 	lsr	r10,r2,0x8
800071f2:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
800071f6:	e6 0b 16 08 	lsr	r11,r3,0x8
800071fa:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
800071fe:	ed be 00 1f 	bld	lr,0x1f
80007202:	ef bb 00 1f 	bst	r11,0x1f
80007206:	0c 0a       	add	r10,r6
80007208:	5c 0b       	acr	r11
8000720a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000720e:	e4 1b 00 0f 	andh	r11,0xf
80007212:	14 4b       	or	r11,r10
80007214:	e0 81 00 a7 	brne	80007362 <__avr32_f64_div_res_subnormal+0x98>
80007218:	f2 06 16 14 	lsr	r6,r9,0x14
8000721c:	ab d6       	cbr	r6,0xb
8000721e:	e0 46 07 ff 	cp.w	r6,2047
80007222:	e0 81 00 a4 	brne	8000736a <__avr32_f64_div_res_subnormal+0xa0>
80007226:	c9 e8       	rjmp	80007362 <__avr32_f64_div_res_subnormal+0x98>
80007228:	e4 19 00 0f 	andh	r9,0xf
8000722c:	10 49       	or	r9,r8
8000722e:	e0 81 00 9a 	brne	80007362 <__avr32_f64_div_res_subnormal+0x98>
80007232:	c9 28       	rjmp	80007356 <__avr32_f64_div_res_subnormal+0x8c>
80007234:	a3 7b       	lsl	r11,0x3
80007236:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000723a:	a3 7a       	lsl	r10,0x3
8000723c:	f5 eb 10 04 	or	r4,r10,r11
80007240:	e0 80 00 a0 	breq	80007380 <__avr32_f64_div_op1_zero>
80007244:	f6 04 12 00 	clz	r4,r11
80007248:	c1 70       	breq	80007276 <__avr32_f64_div_round_subnormal+0x96>
8000724a:	c0 c3       	brcs	80007262 <__avr32_f64_div_round_subnormal+0x82>
8000724c:	e8 05 11 20 	rsub	r5,r4,32
80007250:	f6 04 09 4b 	lsl	r11,r11,r4
80007254:	f4 05 0a 45 	lsr	r5,r10,r5
80007258:	0a 4b       	or	r11,r5
8000725a:	f4 04 09 4a 	lsl	r10,r10,r4
8000725e:	08 17       	sub	r7,r4
80007260:	c0 b8       	rjmp	80007276 <__avr32_f64_div_round_subnormal+0x96>
80007262:	f4 04 12 00 	clz	r4,r10
80007266:	f9 b4 03 00 	movlo	r4,0
8000726a:	f7 b4 02 e0 	subhs	r4,-32
8000726e:	f4 04 09 4b 	lsl	r11,r10,r4
80007272:	30 0a       	mov	r10,0
80007274:	08 17       	sub	r7,r4
80007276:	a3 8a       	lsr	r10,0x2
80007278:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
8000727c:	a3 8b       	lsr	r11,0x2
8000727e:	c1 1b       	rjmp	800070a0 <__avr32_f64_div+0x20>
80007280:	a3 79       	lsl	r9,0x3
80007282:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
80007286:	a3 78       	lsl	r8,0x3
80007288:	f3 e8 10 04 	or	r4,r9,r8
8000728c:	c6 f0       	breq	8000736a <__avr32_f64_div_res_subnormal+0xa0>
8000728e:	f2 04 12 00 	clz	r4,r9
80007292:	c1 70       	breq	800072c0 <__avr32_f64_div_round_subnormal+0xe0>
80007294:	c0 c3       	brcs	800072ac <__avr32_f64_div_round_subnormal+0xcc>
80007296:	e8 05 11 20 	rsub	r5,r4,32
8000729a:	f2 04 09 49 	lsl	r9,r9,r4
8000729e:	f0 05 0a 45 	lsr	r5,r8,r5
800072a2:	0a 49       	or	r9,r5
800072a4:	f0 04 09 48 	lsl	r8,r8,r4
800072a8:	08 16       	sub	r6,r4
800072aa:	c0 b8       	rjmp	800072c0 <__avr32_f64_div_round_subnormal+0xe0>
800072ac:	f0 04 12 00 	clz	r4,r8
800072b0:	f9 b4 03 00 	movlo	r4,0
800072b4:	f7 b4 02 e0 	subhs	r4,-32
800072b8:	f0 04 09 49 	lsl	r9,r8,r4
800072bc:	30 08       	mov	r8,0
800072be:	08 16       	sub	r6,r4
800072c0:	a3 88       	lsr	r8,0x2
800072c2:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
800072c6:	a3 89       	lsr	r9,0x2
800072c8:	cf ca       	rjmp	800070c0 <__avr32_f64_div+0x40>

800072ca <__avr32_f64_div_res_subnormal>:
800072ca:	5c 37       	neg	r7
800072cc:	2f f7       	sub	r7,-1
800072ce:	f1 b7 04 c0 	satu	r7,0x6
800072d2:	e0 47 00 20 	cp.w	r7,32
800072d6:	c1 54       	brge	80007300 <__avr32_f64_div_res_subnormal+0x36>
800072d8:	ee 06 11 20 	rsub	r6,r7,32
800072dc:	e4 07 0a 42 	lsr	r2,r2,r7
800072e0:	e6 06 09 4c 	lsl	r12,r3,r6
800072e4:	18 42       	or	r2,r12
800072e6:	e6 07 0a 43 	lsr	r3,r3,r7
800072ea:	f4 06 09 41 	lsl	r1,r10,r6
800072ee:	f4 07 0a 4a 	lsr	r10,r10,r7
800072f2:	f6 06 09 4c 	lsl	r12,r11,r6
800072f6:	18 4a       	or	r10,r12
800072f8:	f6 07 0a 4b 	lsr	r11,r11,r7
800072fc:	30 00       	mov	r0,0
800072fe:	c1 58       	rjmp	80007328 <__avr32_f64_div_res_subnormal+0x5e>
80007300:	ee 06 11 20 	rsub	r6,r7,32
80007304:	f9 b0 00 00 	moveq	r0,0
80007308:	f9 bc 00 00 	moveq	r12,0
8000730c:	c0 50       	breq	80007316 <__avr32_f64_div_res_subnormal+0x4c>
8000730e:	f4 06 09 40 	lsl	r0,r10,r6
80007312:	f6 06 09 4c 	lsl	r12,r11,r6
80007316:	e6 07 0a 42 	lsr	r2,r3,r7
8000731a:	30 03       	mov	r3,0
8000731c:	f4 07 0a 41 	lsr	r1,r10,r7
80007320:	18 41       	or	r1,r12
80007322:	f6 07 0a 4a 	lsr	r10,r11,r7
80007326:	30 0b       	mov	r11,0
80007328:	e0 12 ff 00 	andl	r2,0xff00
8000732c:	e8 12 00 80 	orl	r2,0x80
80007330:	e6 08 06 46 	mulu.d	r6,r3,r8
80007334:	e4 09 07 46 	macu.d	r6,r2,r9
80007338:	e4 08 06 44 	mulu.d	r4,r2,r8
8000733c:	e6 09 06 48 	mulu.d	r8,r3,r9
80007340:	0c 05       	add	r5,r6
80007342:	f0 07 00 48 	adc	r8,r8,r7
80007346:	5c 09       	acr	r9
80007348:	30 07       	mov	r7,0
8000734a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000734e:	00 34       	cp.w	r4,r0
80007350:	e2 05 13 00 	cpc	r5,r1
80007354:	c4 6b       	rjmp	800071e0 <__avr32_f64_div_round_subnormal>
80007356:	1c 9b       	mov	r11,lr
80007358:	e6 1b 80 00 	andh	r11,0x8000,COH
8000735c:	30 0a       	mov	r10,0
8000735e:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
80007362:	3f fb       	mov	r11,-1
80007364:	30 0a       	mov	r10,0
80007366:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000736a:	f5 eb 10 04 	or	r4,r10,r11
8000736e:	c0 90       	breq	80007380 <__avr32_f64_div_op1_zero>
80007370:	1c 9b       	mov	r11,lr
80007372:	e6 1b 80 00 	andh	r11,0x8000,COH
80007376:	ea 1b 7f f0 	orh	r11,0x7ff0
8000737a:	30 0a       	mov	r10,0
8000737c:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

80007380 <__avr32_f64_div_op1_zero>:
80007380:	f1 e9 10 15 	or	r5,r8,r9<<0x1
80007384:	ce f0       	breq	80007362 <__avr32_f64_div_res_subnormal+0x98>
80007386:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
8000738a:	e0 44 07 ff 	cp.w	r4,2047
8000738e:	ce 41       	brne	80007356 <__avr32_f64_div_res_subnormal+0x8c>
80007390:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
80007394:	ce 10       	breq	80007356 <__avr32_f64_div_res_subnormal+0x8c>
80007396:	ce 6b       	rjmp	80007362 <__avr32_f64_div_res_subnormal+0x98>

80007398 <__avr32_f32_div>:
80007398:	f7 ec 20 08 	eor	r8,r11,r12
8000739c:	a1 7c       	lsl	r12,0x1
8000739e:	a1 7b       	lsl	r11,0x1
800073a0:	c7 a0       	breq	80007494 <__divsf_return_op1+0x16>
800073a2:	18 7c       	tst	r12,r12
800073a4:	f9 b9 00 00 	moveq	r9,0
800073a8:	c0 90       	breq	800073ba <__avr32_f32_div+0x22>
800073aa:	f8 09 16 18 	lsr	r9,r12,0x18
800073ae:	c7 e0       	breq	800074aa <__divsf_return_op1+0x2c>
800073b0:	e0 49 00 ff 	cp.w	r9,255
800073b4:	c6 82       	brcc	80007484 <__divsf_return_op1+0x6>
800073b6:	a7 7c       	lsl	r12,0x7
800073b8:	bf bc       	sbr	r12,0x1f
800073ba:	f6 0a 16 18 	lsr	r10,r11,0x18
800073be:	c7 e0       	breq	800074ba <__divsf_return_op1+0x3c>
800073c0:	e0 4a 00 ff 	cp.w	r10,255
800073c4:	c6 62       	brcc	80007490 <__divsf_return_op1+0x12>
800073c6:	a7 7b       	lsl	r11,0x7
800073c8:	bf bb       	sbr	r11,0x1f
800073ca:	58 09       	cp.w	r9,0
800073cc:	f5 bc 00 00 	subfeq	r12,0
800073d0:	5e 0d       	reteq	0
800073d2:	1a d5       	st.w	--sp,r5
800073d4:	bb 27       	st.d	--sp,r6
800073d6:	14 19       	sub	r9,r10
800073d8:	28 19       	sub	r9,-127
800073da:	fc 1a 80 00 	movh	r10,0x8000
800073de:	a3 8c       	lsr	r12,0x2
800073e0:	f6 05 16 02 	lsr	r5,r11,0x2
800073e4:	f4 0b 16 01 	lsr	r11,r10,0x1
800073e8:	ed d5 c3 62 	bfextu	r6,r5,0x1b,0x2
800073ec:	5c d6       	com	r6
800073ee:	f7 d6 d3 82 	bfins	r11,r6,0x1c,0x2
800073f2:	f6 05 06 46 	mulu.d	r6,r11,r5
800073f6:	f4 07 01 27 	sub	r7,r10,r7<<0x2
800073fa:	f6 07 06 46 	mulu.d	r6,r11,r7
800073fe:	ee 0b 15 02 	lsl	r11,r7,0x2
80007402:	f6 05 06 46 	mulu.d	r6,r11,r5
80007406:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000740a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000740e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007412:	f6 05 06 46 	mulu.d	r6,r11,r5
80007416:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000741a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000741e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007422:	f6 05 06 46 	mulu.d	r6,r11,r5
80007426:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000742a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000742e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007432:	f6 0c 06 46 	mulu.d	r6,r11,r12
80007436:	a5 8c       	lsr	r12,0x4
80007438:	ed b7 00 1c 	bld	r7,0x1c
8000743c:	c0 40       	breq	80007444 <__avr32_f32_div+0xac>
8000743e:	a1 77       	lsl	r7,0x1
80007440:	20 19       	sub	r9,1
80007442:	a1 7c       	lsl	r12,0x1
80007444:	58 09       	cp.w	r9,0
80007446:	e0 8a 00 42 	brle	800074ca <__avr32_f32_div_res_subnormal>
8000744a:	e0 17 ff e0 	andl	r7,0xffe0
8000744e:	e8 17 00 10 	orl	r7,0x10
80007452:	ea 07 06 4a 	mulu.d	r10,r5,r7
80007456:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
8000745a:	58 0a       	cp.w	r10,0

8000745c <__avr32_f32_div_round_subnormal>:
8000745c:	f8 0b 13 00 	cpc	r11,r12
80007460:	5f 3b       	srlo	r11
80007462:	ea 0b 17 00 	moveq	r11,r5
80007466:	ee 0c 16 05 	lsr	r12,r7,0x5
8000746a:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8
8000746e:	bb 07       	ld.d	r6,sp++
80007470:	1b 05       	ld.w	r5,sp++
80007472:	ed b8 00 1f 	bld	r8,0x1f
80007476:	ef bc 00 1f 	bst	r12,0x1f
8000747a:	16 0c       	add	r12,r11
8000747c:	5e fc       	retal	r12

8000747e <__divsf_return_op1>:
8000747e:	a1 78       	lsl	r8,0x1
80007480:	5d 0c       	ror	r12
80007482:	5e fc       	retal	r12
80007484:	5e 1e       	retne	-1
80007486:	fc 19 ff 00 	movh	r9,0xff00
8000748a:	12 3b       	cp.w	r11,r9
8000748c:	cf 93       	brcs	8000747e <__divsf_return_op1>
8000748e:	5e fe       	retal	-1
80007490:	5e 0d       	reteq	0
80007492:	5e fe       	retal	-1
80007494:	18 7c       	tst	r12,r12
80007496:	5e 0e       	reteq	-1
80007498:	f8 09 16 18 	lsr	r9,r12,0x18
8000749c:	c0 70       	breq	800074aa <__divsf_return_op1+0x2c>
8000749e:	e0 49 00 ff 	cp.w	r9,255
800074a2:	cf 12       	brcc	80007484 <__divsf_return_op1+0x6>
800074a4:	fc 1c ff 00 	movh	r12,0xff00
800074a8:	ce bb       	rjmp	8000747e <__divsf_return_op1>
800074aa:	a7 7c       	lsl	r12,0x7
800074ac:	f8 09 12 00 	clz	r9,r12
800074b0:	f8 09 09 4c 	lsl	r12,r12,r9
800074b4:	f2 09 11 01 	rsub	r9,r9,1
800074b8:	c8 1b       	rjmp	800073ba <__avr32_f32_div+0x22>
800074ba:	a7 7b       	lsl	r11,0x7
800074bc:	f6 0a 12 00 	clz	r10,r11
800074c0:	f6 0a 09 4b 	lsl	r11,r11,r10
800074c4:	f4 0a 11 01 	rsub	r10,r10,1
800074c8:	c8 5b       	rjmp	800073d2 <__avr32_f32_div+0x3a>

800074ca <__avr32_f32_div_res_subnormal>:
800074ca:	5c 39       	neg	r9
800074cc:	2f f9       	sub	r9,-1
800074ce:	f1 b9 04 a0 	satu	r9,0x5
800074d2:	f2 0a 11 20 	rsub	r10,r9,32
800074d6:	ee 09 0a 47 	lsr	r7,r7,r9
800074da:	f8 0a 09 46 	lsl	r6,r12,r10
800074de:	f8 09 0a 4c 	lsr	r12,r12,r9
800074e2:	e0 17 ff e0 	andl	r7,0xffe0
800074e6:	e8 17 00 10 	orl	r7,0x10
800074ea:	ea 07 06 4a 	mulu.d	r10,r5,r7
800074ee:	30 09       	mov	r9,0
800074f0:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
800074f4:	0c 3a       	cp.w	r10,r6
800074f6:	cb 3b       	rjmp	8000745c <__avr32_f32_div_round_subnormal>

800074f8 <__avr32_f32_to_f64>:
800074f8:	f8 0b 15 01 	lsl	r11,r12,0x1
800074fc:	f9 ba 00 00 	moveq	r10,0
80007500:	5e 0b       	reteq	r11
80007502:	f3 db c3 08 	bfextu	r9,r11,0x18,0x8
80007506:	e0 49 00 ff 	cp.w	r9,255
8000750a:	c1 e0       	breq	80007546 <__extendsfdf_return_op1+0x6>
8000750c:	a7 7b       	lsl	r11,0x7
8000750e:	30 0a       	mov	r10,0
80007510:	58 09       	cp.w	r9,0
80007512:	f7 b9 00 ff 	subeq	r9,-1
80007516:	5f 18       	srne	r8
80007518:	f7 e8 11 fb 	or	r11,r11,r8<<0x1f
8000751c:	fe 39 fc 80 	sub	r9,-896
80007520:	f6 08 12 00 	clz	r8,r11
80007524:	10 19       	sub	r9,r8
80007526:	f6 08 09 4b 	lsl	r11,r11,r8
8000752a:	ed bb 00 1f 	bld	r11,0x1f
8000752e:	f7 b9 01 01 	subne	r9,1
80007532:	ab 9a       	lsr	r10,0xb
80007534:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80007538:	a1 7b       	lsl	r11,0x1
8000753a:	ab 9b       	lsr	r11,0xb
8000753c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80007540 <__extendsfdf_return_op1>:
80007540:	a1 7c       	lsl	r12,0x1
80007542:	5d 0b       	ror	r11
80007544:	5e fb       	retal	r11
80007546:	fc 1a ff e0 	movh	r10,0xffe0
8000754a:	a9 6b       	lsl	r11,0x8
8000754c:	f9 bb 01 ff 	movne	r11,-1
80007550:	f4 0b 17 00 	moveq	r11,r10
80007554:	30 0a       	mov	r10,0
80007556:	cf 5b       	rjmp	80007540 <__extendsfdf_return_op1>

80007558 <__avr32_f64_to_f32>:
80007558:	f6 09 15 01 	lsl	r9,r11,0x1
8000755c:	b5 99       	lsr	r9,0x15
8000755e:	5e 0d       	reteq	0
80007560:	f6 08 15 0a 	lsl	r8,r11,0xa
80007564:	f1 ea 13 6c 	or	r12,r8,r10>>0x16
80007568:	ab 6a       	lsl	r10,0xa
8000756a:	5c 3a       	neg	r10
8000756c:	5c fc       	rol	r12
8000756e:	e0 49 07 ff 	cp.w	r9,2047
80007572:	c1 a0       	breq	800075a6 <__truncdfsf_return_op1+0x6>
80007574:	e0 29 03 80 	sub	r9,896
80007578:	bf bc       	sbr	r12,0x1f
8000757a:	58 09       	cp.w	r9,0
8000757c:	e0 8a 00 1a 	brle	800075b0 <__truncdfsf_return_op1+0x10>
80007580:	37 fa       	mov	r10,127
80007582:	ed bc 00 08 	bld	r12,0x8
80007586:	f7 ba 00 ff 	subeq	r10,-1
8000758a:	14 0c       	add	r12,r10
8000758c:	f7 b9 03 fe 	sublo	r9,-2
80007590:	ed bc 00 1f 	bld	r12,0x1f
80007594:	f7 b9 01 01 	subne	r9,1
80007598:	f8 0c 16 07 	lsr	r12,r12,0x7
8000759c:	f9 d9 d3 08 	bfins	r12,r9,0x18,0x8

800075a0 <__truncdfsf_return_op1>:
800075a0:	a1 7b       	lsl	r11,0x1
800075a2:	5d 0c       	ror	r12
800075a4:	5e fc       	retal	r12
800075a6:	bf dc       	cbr	r12,0x1f
800075a8:	5e 1e       	retne	-1
800075aa:	fc 1c 7f 80 	movh	r12,0x7f80
800075ae:	5e fc       	retal	r12
800075b0:	f2 09 11 01 	rsub	r9,r9,1
800075b4:	59 99       	cp.w	r9,25
800075b6:	f9 bc 02 00 	movhs	r12,0
800075ba:	c1 32       	brcc	800075e0 <__truncdfsf_return_op1+0x40>
800075bc:	f2 0a 11 20 	rsub	r10,r9,32
800075c0:	f8 0a 09 4a 	lsl	r10,r12,r10
800075c4:	5f 1a       	srne	r10
800075c6:	f8 09 0a 4c 	lsr	r12,r12,r9
800075ca:	14 4c       	or	r12,r10
800075cc:	37 fa       	mov	r10,127
800075ce:	ed bc 00 08 	bld	r12,0x8
800075d2:	f7 ba 00 ff 	subeq	r10,-1
800075d6:	14 0c       	add	r12,r10
800075d8:	f8 0c 16 07 	lsr	r12,r12,0x7
800075dc:	a1 7b       	lsl	r11,0x1
800075de:	5d 0c       	ror	r12
800075e0:	5e fc       	retal	r12

800075e2 <__avr32_udiv64>:
800075e2:	d4 31       	pushm	r0-r7,lr
800075e4:	1a 97       	mov	r7,sp
800075e6:	20 3d       	sub	sp,12
800075e8:	10 9c       	mov	r12,r8
800075ea:	12 9e       	mov	lr,r9
800075ec:	14 93       	mov	r3,r10
800075ee:	58 09       	cp.w	r9,0
800075f0:	e0 81 00 bd 	brne	8000776a <__avr32_udiv64+0x188>
800075f4:	16 38       	cp.w	r8,r11
800075f6:	e0 88 00 40 	brls	80007676 <__avr32_udiv64+0x94>
800075fa:	f0 08 12 00 	clz	r8,r8
800075fe:	c0 d0       	breq	80007618 <__avr32_udiv64+0x36>
80007600:	f6 08 09 4b 	lsl	r11,r11,r8
80007604:	f0 09 11 20 	rsub	r9,r8,32
80007608:	f8 08 09 4c 	lsl	r12,r12,r8
8000760c:	f4 09 0a 49 	lsr	r9,r10,r9
80007610:	f4 08 09 43 	lsl	r3,r10,r8
80007614:	f3 eb 10 0b 	or	r11,r9,r11
80007618:	f8 0e 16 10 	lsr	lr,r12,0x10
8000761c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80007620:	f6 0e 0d 00 	divu	r0,r11,lr
80007624:	e6 0b 16 10 	lsr	r11,r3,0x10
80007628:	00 99       	mov	r9,r0
8000762a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000762e:	e0 0a 02 48 	mul	r8,r0,r10
80007632:	10 3b       	cp.w	r11,r8
80007634:	c0 a2       	brcc	80007648 <__avr32_udiv64+0x66>
80007636:	20 19       	sub	r9,1
80007638:	18 0b       	add	r11,r12
8000763a:	18 3b       	cp.w	r11,r12
8000763c:	c0 63       	brcs	80007648 <__avr32_udiv64+0x66>
8000763e:	10 3b       	cp.w	r11,r8
80007640:	f7 b9 03 01 	sublo	r9,1
80007644:	f7 dc e3 0b 	addcs	r11,r11,r12
80007648:	f6 08 01 01 	sub	r1,r11,r8
8000764c:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80007650:	e2 0e 0d 00 	divu	r0,r1,lr
80007654:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80007658:	00 98       	mov	r8,r0
8000765a:	e0 0a 02 4a 	mul	r10,r0,r10
8000765e:	14 33       	cp.w	r3,r10
80007660:	c0 82       	brcc	80007670 <__avr32_udiv64+0x8e>
80007662:	20 18       	sub	r8,1
80007664:	18 03       	add	r3,r12
80007666:	18 33       	cp.w	r3,r12
80007668:	c0 43       	brcs	80007670 <__avr32_udiv64+0x8e>
8000766a:	14 33       	cp.w	r3,r10
8000766c:	f7 b8 03 01 	sublo	r8,1
80007670:	f1 e9 11 08 	or	r8,r8,r9<<0x10
80007674:	cd f8       	rjmp	80007832 <__avr32_udiv64+0x250>
80007676:	58 08       	cp.w	r8,0
80007678:	c0 51       	brne	80007682 <__avr32_udiv64+0xa0>
8000767a:	30 19       	mov	r9,1
8000767c:	f2 08 0d 08 	divu	r8,r9,r8
80007680:	10 9c       	mov	r12,r8
80007682:	f8 06 12 00 	clz	r6,r12
80007686:	c0 41       	brne	8000768e <__avr32_udiv64+0xac>
80007688:	18 1b       	sub	r11,r12
8000768a:	30 19       	mov	r9,1
8000768c:	c4 08       	rjmp	8000770c <__avr32_udiv64+0x12a>
8000768e:	ec 01 11 20 	rsub	r1,r6,32
80007692:	f4 01 0a 49 	lsr	r9,r10,r1
80007696:	f8 06 09 4c 	lsl	r12,r12,r6
8000769a:	f6 06 09 48 	lsl	r8,r11,r6
8000769e:	f6 01 0a 41 	lsr	r1,r11,r1
800076a2:	f3 e8 10 08 	or	r8,r9,r8
800076a6:	f8 03 16 10 	lsr	r3,r12,0x10
800076aa:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800076ae:	e2 03 0d 00 	divu	r0,r1,r3
800076b2:	f0 0b 16 10 	lsr	r11,r8,0x10
800076b6:	00 9e       	mov	lr,r0
800076b8:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800076bc:	e0 05 02 49 	mul	r9,r0,r5
800076c0:	12 3b       	cp.w	r11,r9
800076c2:	c0 a2       	brcc	800076d6 <__avr32_udiv64+0xf4>
800076c4:	20 1e       	sub	lr,1
800076c6:	18 0b       	add	r11,r12
800076c8:	18 3b       	cp.w	r11,r12
800076ca:	c0 63       	brcs	800076d6 <__avr32_udiv64+0xf4>
800076cc:	12 3b       	cp.w	r11,r9
800076ce:	f7 be 03 01 	sublo	lr,1
800076d2:	f7 dc e3 0b 	addcs	r11,r11,r12
800076d6:	12 1b       	sub	r11,r9
800076d8:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
800076dc:	f6 03 0d 02 	divu	r2,r11,r3
800076e0:	f1 e3 11 08 	or	r8,r8,r3<<0x10
800076e4:	04 99       	mov	r9,r2
800076e6:	e4 05 02 4b 	mul	r11,r2,r5
800076ea:	16 38       	cp.w	r8,r11
800076ec:	c0 a2       	brcc	80007700 <__avr32_udiv64+0x11e>
800076ee:	20 19       	sub	r9,1
800076f0:	18 08       	add	r8,r12
800076f2:	18 38       	cp.w	r8,r12
800076f4:	c0 63       	brcs	80007700 <__avr32_udiv64+0x11e>
800076f6:	16 38       	cp.w	r8,r11
800076f8:	f7 b9 03 01 	sublo	r9,1
800076fc:	f1 dc e3 08 	addcs	r8,r8,r12
80007700:	f4 06 09 43 	lsl	r3,r10,r6
80007704:	f0 0b 01 0b 	sub	r11,r8,r11
80007708:	f3 ee 11 09 	or	r9,r9,lr<<0x10
8000770c:	f8 06 16 10 	lsr	r6,r12,0x10
80007710:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80007714:	f6 06 0d 00 	divu	r0,r11,r6
80007718:	e6 0b 16 10 	lsr	r11,r3,0x10
8000771c:	00 9a       	mov	r10,r0
8000771e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007722:	e0 0e 02 48 	mul	r8,r0,lr
80007726:	10 3b       	cp.w	r11,r8
80007728:	c0 a2       	brcc	8000773c <__avr32_udiv64+0x15a>
8000772a:	20 1a       	sub	r10,1
8000772c:	18 0b       	add	r11,r12
8000772e:	18 3b       	cp.w	r11,r12
80007730:	c0 63       	brcs	8000773c <__avr32_udiv64+0x15a>
80007732:	10 3b       	cp.w	r11,r8
80007734:	f7 ba 03 01 	sublo	r10,1
80007738:	f7 dc e3 0b 	addcs	r11,r11,r12
8000773c:	f6 08 01 01 	sub	r1,r11,r8
80007740:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80007744:	e2 06 0d 00 	divu	r0,r1,r6
80007748:	e7 e1 11 03 	or	r3,r3,r1<<0x10
8000774c:	00 98       	mov	r8,r0
8000774e:	e0 0e 02 4b 	mul	r11,r0,lr
80007752:	16 33       	cp.w	r3,r11
80007754:	c0 82       	brcc	80007764 <__avr32_udiv64+0x182>
80007756:	20 18       	sub	r8,1
80007758:	18 03       	add	r3,r12
8000775a:	18 33       	cp.w	r3,r12
8000775c:	c0 43       	brcs	80007764 <__avr32_udiv64+0x182>
8000775e:	16 33       	cp.w	r3,r11
80007760:	f7 b8 03 01 	sublo	r8,1
80007764:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80007768:	c6 98       	rjmp	8000783a <__avr32_udiv64+0x258>
8000776a:	16 39       	cp.w	r9,r11
8000776c:	e0 8b 00 65 	brhi	80007836 <__avr32_udiv64+0x254>
80007770:	f2 09 12 00 	clz	r9,r9
80007774:	c0 b1       	brne	8000778a <__avr32_udiv64+0x1a8>
80007776:	10 3a       	cp.w	r10,r8
80007778:	5f 2a       	srhs	r10
8000777a:	1c 3b       	cp.w	r11,lr
8000777c:	5f b8       	srhi	r8
8000777e:	10 4a       	or	r10,r8
80007780:	f2 0a 18 00 	cp.b	r10,r9
80007784:	c5 90       	breq	80007836 <__avr32_udiv64+0x254>
80007786:	30 18       	mov	r8,1
80007788:	c5 98       	rjmp	8000783a <__avr32_udiv64+0x258>
8000778a:	f0 09 09 46 	lsl	r6,r8,r9
8000778e:	f2 03 11 20 	rsub	r3,r9,32
80007792:	fc 09 09 4e 	lsl	lr,lr,r9
80007796:	f0 03 0a 48 	lsr	r8,r8,r3
8000779a:	f6 09 09 4c 	lsl	r12,r11,r9
8000779e:	f4 03 0a 42 	lsr	r2,r10,r3
800077a2:	ef 46 ff f4 	st.w	r7[-12],r6
800077a6:	f6 03 0a 43 	lsr	r3,r11,r3
800077aa:	18 42       	or	r2,r12
800077ac:	f1 ee 10 0c 	or	r12,r8,lr
800077b0:	f8 01 16 10 	lsr	r1,r12,0x10
800077b4:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
800077b8:	e6 01 0d 04 	divu	r4,r3,r1
800077bc:	e4 03 16 10 	lsr	r3,r2,0x10
800077c0:	08 9e       	mov	lr,r4
800077c2:	e7 e5 11 03 	or	r3,r3,r5<<0x10
800077c6:	e8 06 02 48 	mul	r8,r4,r6
800077ca:	10 33       	cp.w	r3,r8
800077cc:	c0 a2       	brcc	800077e0 <__avr32_udiv64+0x1fe>
800077ce:	20 1e       	sub	lr,1
800077d0:	18 03       	add	r3,r12
800077d2:	18 33       	cp.w	r3,r12
800077d4:	c0 63       	brcs	800077e0 <__avr32_udiv64+0x1fe>
800077d6:	10 33       	cp.w	r3,r8
800077d8:	f7 be 03 01 	sublo	lr,1
800077dc:	e7 dc e3 03 	addcs	r3,r3,r12
800077e0:	10 13       	sub	r3,r8
800077e2:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
800077e6:	e6 01 0d 00 	divu	r0,r3,r1
800077ea:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
800077ee:	00 98       	mov	r8,r0
800077f0:	e0 06 02 46 	mul	r6,r0,r6
800077f4:	0c 3b       	cp.w	r11,r6
800077f6:	c0 a2       	brcc	8000780a <__avr32_udiv64+0x228>
800077f8:	20 18       	sub	r8,1
800077fa:	18 0b       	add	r11,r12
800077fc:	18 3b       	cp.w	r11,r12
800077fe:	c0 63       	brcs	8000780a <__avr32_udiv64+0x228>
80007800:	0c 3b       	cp.w	r11,r6
80007802:	f7 dc e3 0b 	addcs	r11,r11,r12
80007806:	f7 b8 03 01 	sublo	r8,1
8000780a:	f1 ee 11 08 	or	r8,r8,lr<<0x10
8000780e:	ee f4 ff f4 	ld.w	r4,r7[-12]
80007812:	0c 1b       	sub	r11,r6
80007814:	f0 04 06 42 	mulu.d	r2,r8,r4
80007818:	06 95       	mov	r5,r3
8000781a:	16 35       	cp.w	r5,r11
8000781c:	e0 8b 00 0a 	brhi	80007830 <__avr32_udiv64+0x24e>
80007820:	5f 0b       	sreq	r11
80007822:	f4 09 09 49 	lsl	r9,r10,r9
80007826:	12 32       	cp.w	r2,r9
80007828:	5f b9       	srhi	r9
8000782a:	f7 e9 00 09 	and	r9,r11,r9
8000782e:	c0 60       	breq	8000783a <__avr32_udiv64+0x258>
80007830:	20 18       	sub	r8,1
80007832:	30 09       	mov	r9,0
80007834:	c0 38       	rjmp	8000783a <__avr32_udiv64+0x258>
80007836:	30 09       	mov	r9,0
80007838:	12 98       	mov	r8,r9
8000783a:	10 9a       	mov	r10,r8
8000783c:	12 93       	mov	r3,r9
8000783e:	10 92       	mov	r2,r8
80007840:	12 9b       	mov	r11,r9
80007842:	2f dd       	sub	sp,-12
80007844:	d8 32       	popm	r0-r7,pc

80007846 <memcpy>:
80007846:	58 8a       	cp.w	r10,8
80007848:	c2 f5       	brlt	800078a6 <memcpy+0x60>
8000784a:	f9 eb 10 09 	or	r9,r12,r11
8000784e:	e2 19 00 03 	andl	r9,0x3,COH
80007852:	e0 81 00 97 	brne	80007980 <memcpy+0x13a>
80007856:	e0 4a 00 20 	cp.w	r10,32
8000785a:	c3 b4       	brge	800078d0 <memcpy+0x8a>
8000785c:	f4 08 14 02 	asr	r8,r10,0x2
80007860:	f0 09 11 08 	rsub	r9,r8,8
80007864:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007868:	76 69       	ld.w	r9,r11[0x18]
8000786a:	99 69       	st.w	r12[0x18],r9
8000786c:	76 59       	ld.w	r9,r11[0x14]
8000786e:	99 59       	st.w	r12[0x14],r9
80007870:	76 49       	ld.w	r9,r11[0x10]
80007872:	99 49       	st.w	r12[0x10],r9
80007874:	76 39       	ld.w	r9,r11[0xc]
80007876:	99 39       	st.w	r12[0xc],r9
80007878:	76 29       	ld.w	r9,r11[0x8]
8000787a:	99 29       	st.w	r12[0x8],r9
8000787c:	76 19       	ld.w	r9,r11[0x4]
8000787e:	99 19       	st.w	r12[0x4],r9
80007880:	76 09       	ld.w	r9,r11[0x0]
80007882:	99 09       	st.w	r12[0x0],r9
80007884:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007888:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000788c:	e0 1a 00 03 	andl	r10,0x3
80007890:	f4 0a 11 04 	rsub	r10,r10,4
80007894:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007898:	17 a9       	ld.ub	r9,r11[0x2]
8000789a:	b0 a9       	st.b	r8[0x2],r9
8000789c:	17 99       	ld.ub	r9,r11[0x1]
8000789e:	b0 99       	st.b	r8[0x1],r9
800078a0:	17 89       	ld.ub	r9,r11[0x0]
800078a2:	b0 89       	st.b	r8[0x0],r9
800078a4:	5e fc       	retal	r12
800078a6:	f4 0a 11 09 	rsub	r10,r10,9
800078aa:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
800078ae:	17 f9       	ld.ub	r9,r11[0x7]
800078b0:	b8 f9       	st.b	r12[0x7],r9
800078b2:	17 e9       	ld.ub	r9,r11[0x6]
800078b4:	b8 e9       	st.b	r12[0x6],r9
800078b6:	17 d9       	ld.ub	r9,r11[0x5]
800078b8:	b8 d9       	st.b	r12[0x5],r9
800078ba:	17 c9       	ld.ub	r9,r11[0x4]
800078bc:	b8 c9       	st.b	r12[0x4],r9
800078be:	17 b9       	ld.ub	r9,r11[0x3]
800078c0:	b8 b9       	st.b	r12[0x3],r9
800078c2:	17 a9       	ld.ub	r9,r11[0x2]
800078c4:	b8 a9       	st.b	r12[0x2],r9
800078c6:	17 99       	ld.ub	r9,r11[0x1]
800078c8:	b8 99       	st.b	r12[0x1],r9
800078ca:	17 89       	ld.ub	r9,r11[0x0]
800078cc:	b8 89       	st.b	r12[0x0],r9
800078ce:	5e fc       	retal	r12
800078d0:	eb cd 40 c0 	pushm	r6-r7,lr
800078d4:	18 99       	mov	r9,r12
800078d6:	22 0a       	sub	r10,32
800078d8:	b7 07       	ld.d	r6,r11++
800078da:	b3 26       	st.d	r9++,r6
800078dc:	b7 07       	ld.d	r6,r11++
800078de:	b3 26       	st.d	r9++,r6
800078e0:	b7 07       	ld.d	r6,r11++
800078e2:	b3 26       	st.d	r9++,r6
800078e4:	b7 07       	ld.d	r6,r11++
800078e6:	b3 26       	st.d	r9++,r6
800078e8:	22 0a       	sub	r10,32
800078ea:	cf 74       	brge	800078d8 <memcpy+0x92>
800078ec:	2f 0a       	sub	r10,-16
800078ee:	c0 65       	brlt	800078fa <memcpy+0xb4>
800078f0:	b7 07       	ld.d	r6,r11++
800078f2:	b3 26       	st.d	r9++,r6
800078f4:	b7 07       	ld.d	r6,r11++
800078f6:	b3 26       	st.d	r9++,r6
800078f8:	21 0a       	sub	r10,16
800078fa:	5c 3a       	neg	r10
800078fc:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007900:	d7 03       	nop
80007902:	d7 03       	nop
80007904:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007908:	f3 66 00 0e 	st.b	r9[14],r6
8000790c:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007910:	f3 66 00 0d 	st.b	r9[13],r6
80007914:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007918:	f3 66 00 0c 	st.b	r9[12],r6
8000791c:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007920:	f3 66 00 0b 	st.b	r9[11],r6
80007924:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007928:	f3 66 00 0a 	st.b	r9[10],r6
8000792c:	f7 36 00 09 	ld.ub	r6,r11[9]
80007930:	f3 66 00 09 	st.b	r9[9],r6
80007934:	f7 36 00 08 	ld.ub	r6,r11[8]
80007938:	f3 66 00 08 	st.b	r9[8],r6
8000793c:	f7 36 00 07 	ld.ub	r6,r11[7]
80007940:	f3 66 00 07 	st.b	r9[7],r6
80007944:	f7 36 00 06 	ld.ub	r6,r11[6]
80007948:	f3 66 00 06 	st.b	r9[6],r6
8000794c:	f7 36 00 05 	ld.ub	r6,r11[5]
80007950:	f3 66 00 05 	st.b	r9[5],r6
80007954:	f7 36 00 04 	ld.ub	r6,r11[4]
80007958:	f3 66 00 04 	st.b	r9[4],r6
8000795c:	f7 36 00 03 	ld.ub	r6,r11[3]
80007960:	f3 66 00 03 	st.b	r9[3],r6
80007964:	f7 36 00 02 	ld.ub	r6,r11[2]
80007968:	f3 66 00 02 	st.b	r9[2],r6
8000796c:	f7 36 00 01 	ld.ub	r6,r11[1]
80007970:	f3 66 00 01 	st.b	r9[1],r6
80007974:	f7 36 00 00 	ld.ub	r6,r11[0]
80007978:	f3 66 00 00 	st.b	r9[0],r6
8000797c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007980:	20 1a       	sub	r10,1
80007982:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007986:	f8 0a 0b 09 	st.b	r12[r10],r9
8000798a:	cf b1       	brne	80007980 <memcpy+0x13a>
8000798c:	5e fc       	retal	r12

8000798e <memset>:
8000798e:	18 98       	mov	r8,r12
80007990:	c0 38       	rjmp	80007996 <memset+0x8>
80007992:	10 cb       	st.b	r8++,r11
80007994:	20 1a       	sub	r10,1
80007996:	58 0a       	cp.w	r10,0
80007998:	cf d1       	brne	80007992 <memset+0x4>
8000799a:	5e fc       	retal	r12

8000799c <strncpy>:
8000799c:	30 08       	mov	r8,0
8000799e:	10 3a       	cp.w	r10,r8
800079a0:	5e 0c       	reteq	r12
800079a2:	f6 08 07 09 	ld.ub	r9,r11[r8]
800079a6:	f8 08 0b 09 	st.b	r12[r8],r9
800079aa:	2f f8       	sub	r8,-1
800079ac:	58 09       	cp.w	r9,0
800079ae:	cf 81       	brne	8000799e <strncpy+0x2>
800079b0:	10 3a       	cp.w	r10,r8
800079b2:	5e 0c       	reteq	r12
800079b4:	f8 08 0b 09 	st.b	r12[r8],r9
800079b8:	2f f8       	sub	r8,-1
800079ba:	cf bb       	rjmp	800079b0 <strncpy+0x14>

Disassembly of section .exception:

80007a00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80007a00:	c0 08       	rjmp	80007a00 <_evba>
	...

80007a04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80007a04:	c0 08       	rjmp	80007a04 <_handle_TLB_Multiple_Hit>
	...

80007a08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80007a08:	c0 08       	rjmp	80007a08 <_handle_Bus_Error_Data_Fetch>
	...

80007a0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
80007a0c:	c0 08       	rjmp	80007a0c <_handle_Bus_Error_Instruction_Fetch>
	...

80007a10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80007a10:	c0 08       	rjmp	80007a10 <_handle_NMI>
	...

80007a14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80007a14:	c0 08       	rjmp	80007a14 <_handle_Instruction_Address>
	...

80007a18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80007a18:	c0 08       	rjmp	80007a18 <_handle_ITLB_Protection>
	...

80007a1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
80007a1c:	c0 08       	rjmp	80007a1c <_handle_Breakpoint>
	...

80007a20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80007a20:	c0 08       	rjmp	80007a20 <_handle_Illegal_Opcode>
	...

80007a24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80007a24:	c0 08       	rjmp	80007a24 <_handle_Unimplemented_Instruction>
	...

80007a28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80007a28:	c0 08       	rjmp	80007a28 <_handle_Privilege_Violation>
	...

80007a2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
80007a2c:	c0 08       	rjmp	80007a2c <_handle_Floating_Point>
	...

80007a30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80007a30:	c0 08       	rjmp	80007a30 <_handle_Coprocessor_Absent>
	...

80007a34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80007a34:	c0 08       	rjmp	80007a34 <_handle_Data_Address_Read>
	...

80007a38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80007a38:	c0 08       	rjmp	80007a38 <_handle_Data_Address_Write>
	...

80007a3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
80007a3c:	c0 08       	rjmp	80007a3c <_handle_DTLB_Protection_Read>
	...

80007a40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80007a40:	c0 08       	rjmp	80007a40 <_handle_DTLB_Protection_Write>
	...

80007a44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80007a44:	c0 08       	rjmp	80007a44 <_handle_DTLB_Modified>
	...

80007a50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80007a50:	c0 08       	rjmp	80007a50 <_handle_ITLB_Miss>
	...

80007a60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80007a60:	c0 08       	rjmp	80007a60 <_handle_DTLB_Miss_Read>
	...

80007a70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80007a70:	c0 08       	rjmp	80007a70 <_handle_DTLB_Miss_Write>
	...

80007b00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80007b00:	fe cf 23 cc 	sub	pc,pc,9164

80007b04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80007b04:	30 0c       	mov	r12,0
80007b06:	fe b0 f7 1f 	rcall	80006944 <_get_interrupt_handler>
80007b0a:	58 0c       	cp.w	r12,0
80007b0c:	f8 0f 17 10 	movne	pc,r12
80007b10:	d6 03       	rete

80007b12 <_int1>:
80007b12:	30 1c       	mov	r12,1
80007b14:	fe b0 f7 18 	rcall	80006944 <_get_interrupt_handler>
80007b18:	58 0c       	cp.w	r12,0
80007b1a:	f8 0f 17 10 	movne	pc,r12
80007b1e:	d6 03       	rete

80007b20 <_int2>:
80007b20:	30 2c       	mov	r12,2
80007b22:	fe b0 f7 11 	rcall	80006944 <_get_interrupt_handler>
80007b26:	58 0c       	cp.w	r12,0
80007b28:	f8 0f 17 10 	movne	pc,r12
80007b2c:	d6 03       	rete

80007b2e <_int3>:
80007b2e:	30 3c       	mov	r12,3
80007b30:	fe b0 f7 0a 	rcall	80006944 <_get_interrupt_handler>
80007b34:	58 0c       	cp.w	r12,0
80007b36:	f8 0f 17 10 	movne	pc,r12
80007b3a:	d6 03       	rete
80007b3c:	d7 03       	nop
80007b3e:	d7 03       	nop
80007b40:	d7 03       	nop
80007b42:	d7 03       	nop
80007b44:	d7 03       	nop
80007b46:	d7 03       	nop
80007b48:	d7 03       	nop
80007b4a:	d7 03       	nop
80007b4c:	d7 03       	nop
80007b4e:	d7 03       	nop
80007b50:	d7 03       	nop
80007b52:	d7 03       	nop
80007b54:	d7 03       	nop
80007b56:	d7 03       	nop
80007b58:	d7 03       	nop
80007b5a:	d7 03       	nop
80007b5c:	d7 03       	nop
80007b5e:	d7 03       	nop
80007b60:	d7 03       	nop
80007b62:	d7 03       	nop
80007b64:	d7 03       	nop
80007b66:	d7 03       	nop
80007b68:	d7 03       	nop
80007b6a:	d7 03       	nop
80007b6c:	d7 03       	nop
80007b6e:	d7 03       	nop
80007b70:	d7 03       	nop
80007b72:	d7 03       	nop
80007b74:	d7 03       	nop
80007b76:	d7 03       	nop
80007b78:	d7 03       	nop
80007b7a:	d7 03       	nop
80007b7c:	d7 03       	nop
80007b7e:	d7 03       	nop
80007b80:	d7 03       	nop
80007b82:	d7 03       	nop
80007b84:	d7 03       	nop
80007b86:	d7 03       	nop
80007b88:	d7 03       	nop
80007b8a:	d7 03       	nop
80007b8c:	d7 03       	nop
80007b8e:	d7 03       	nop
80007b90:	d7 03       	nop
80007b92:	d7 03       	nop
80007b94:	d7 03       	nop
80007b96:	d7 03       	nop
80007b98:	d7 03       	nop
80007b9a:	d7 03       	nop
80007b9c:	d7 03       	nop
80007b9e:	d7 03       	nop
80007ba0:	d7 03       	nop
80007ba2:	d7 03       	nop
80007ba4:	d7 03       	nop
80007ba6:	d7 03       	nop
80007ba8:	d7 03       	nop
80007baa:	d7 03       	nop
80007bac:	d7 03       	nop
80007bae:	d7 03       	nop
80007bb0:	d7 03       	nop
80007bb2:	d7 03       	nop
80007bb4:	d7 03       	nop
80007bb6:	d7 03       	nop
80007bb8:	d7 03       	nop
80007bba:	d7 03       	nop
80007bbc:	d7 03       	nop
80007bbe:	d7 03       	nop
80007bc0:	d7 03       	nop
80007bc2:	d7 03       	nop
80007bc4:	d7 03       	nop
80007bc6:	d7 03       	nop
80007bc8:	d7 03       	nop
80007bca:	d7 03       	nop
80007bcc:	d7 03       	nop
80007bce:	d7 03       	nop
80007bd0:	d7 03       	nop
80007bd2:	d7 03       	nop
80007bd4:	d7 03       	nop
80007bd6:	d7 03       	nop
80007bd8:	d7 03       	nop
80007bda:	d7 03       	nop
80007bdc:	d7 03       	nop
80007bde:	d7 03       	nop
80007be0:	d7 03       	nop
80007be2:	d7 03       	nop
80007be4:	d7 03       	nop
80007be6:	d7 03       	nop
80007be8:	d7 03       	nop
80007bea:	d7 03       	nop
80007bec:	d7 03       	nop
80007bee:	d7 03       	nop
80007bf0:	d7 03       	nop
80007bf2:	d7 03       	nop
80007bf4:	d7 03       	nop
80007bf6:	d7 03       	nop
80007bf8:	d7 03       	nop
80007bfa:	d7 03       	nop
80007bfc:	d7 03       	nop
80007bfe:	d7 03       	nop
