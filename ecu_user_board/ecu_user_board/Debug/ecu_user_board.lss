
ecu_user_board.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002004  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00005d08  80002004  80002004  00002404  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80007e00  80007e00  00008200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00000234  80008000  80008000  00008400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  80008234  80008234  00008634  2**0
                  ALLOC
  6 .data         000001fc  00000004  80008238  00008804  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .hsb_ram_loc  00000200  00000200  80008434  00008a00  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          0000cc30  00000400  80008634  00008c00  2**2
                  ALLOC
  9 .comment      00000030  00000000  00000000  00008c00  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00000e70  00000000  00000000  00008c30  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 00002f25  00000000  00000000  00009aa0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   00018cbb  00000000  00000000  0000c9c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00003a0a  00000000  00000000  00025680  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00011fdf  00000000  00000000  0002908a  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002458  00000000  00000000  0003b06c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00006292  00000000  00000000  0003d4c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000062af  00000000  00000000  00043756  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_macinfo 0202fb45  00000000  00000000  00049a05  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .stack        00001000  0000f000  0000f000  00000400  2**0
                  ALLOC
 20 .debug_ranges 00000eb8  00000000  00000000  02079550  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_trampoline>:

  .global _trampoline
  .type _trampoline, @function
_trampoline:
  // Jump to program start.
  rjmp    program_start
80000000:	e0 8f 10 00 	bral	80002000 <program_start>
	...

80002000 <program_start>:

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002000:	fe cf b5 08 	sub	pc,pc,-19192

Disassembly of section .text:

80002004 <getBaudDiv>:
80002004:	f8 c8 00 01 	sub	r8,r12,1
xSemaphoreHandle xSPIMutex;
#endif

int16_t getBaudDiv(const uint32_t baudrate, uint32_t pb_hz)
{
	uint32_t baudDiv = div_ceil(pb_hz, baudrate);
80002008:	f0 0b 00 0b 	add	r11,r8,r11
8000200c:	f6 0c 0d 0a 	divu	r10,r11,r12
80002010:	14 9c       	mov	r12,r10

	if (baudDiv <= 0 || baudDiv > 255) {
80002012:	f4 c8 00 01 	sub	r8,r10,1
80002016:	e0 48 00 fe 	cp.w	r8,254
8000201a:	e0 88 00 03 	brls	80002020 <getBaudDiv+0x1c>
8000201e:	5e fe       	retal	-1
		return -1;
	}

	return baudDiv;
80002020:	5c 8c       	casts.h	r12
}
80002022:	5e fc       	retal	r12

80002024 <spi_enable>:
	return SPI_OK;
}

void spi_enable(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SPIEN_MASK;
80002024:	30 18       	mov	r8,1
80002026:	99 08       	st.w	r12[0x0],r8
}
80002028:	5e fc       	retal	r12
8000202a:	d7 03       	nop

8000202c <spi_unselectChip>:

	return SPI_OK;
}

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000202c:	d4 01       	pushm	lr
8000202e:	e0 68 3a 98 	mov	r8,15000
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
80002032:	c0 58       	rjmp	8000203c <spi_unselectChip+0x10>
		if (!timeout--) {
80002034:	58 08       	cp.w	r8,0
80002036:	c0 21       	brne	8000203a <spi_unselectChip+0xe>
80002038:	da 0a       	popm	pc,r12=1
8000203a:	20 18       	sub	r8,1

spi_status_t spi_unselectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
	uint32_t timeout = SPI_TIMEOUT;

	while (!(spi->sr & AVR32_SPI_SR_TXEMPTY_MASK)) {
8000203c:	78 49       	ld.w	r9,r12[0x10]
8000203e:	e2 19 02 00 	andl	r9,0x200,COH
80002042:	cf 90       	breq	80002034 <spi_unselectChip+0x8>
			return SPI_ERROR_TIMEOUT;
		}
	}

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002044:	78 18       	ld.w	r8,r12[0x4]
80002046:	ea 18 00 0f 	orh	r8,0xf
8000204a:	99 18       	st.w	r12[0x4],r8

	/* Last transfer, so de-assert the current NPCS if CSAAT is set. */
	spi->cr = AVR32_SPI_CR_LASTXFER_MASK;
8000204c:	fc 18 01 00 	movh	r8,0x100
80002050:	99 08       	st.w	r12[0x0],r8

#ifdef FREERTOS_USED
	xSemaphoreGive(xSPIMutex);
80002052:	30 09       	mov	r9,0
80002054:	12 9a       	mov	r10,r9
80002056:	12 9b       	mov	r11,r9
80002058:	48 38       	lddpc	r8,80002064 <spi_unselectChip+0x38>
8000205a:	70 0c       	ld.w	r12,r8[0x0]
8000205c:	f0 1f 00 03 	mcall	80002068 <spi_unselectChip+0x3c>
80002060:	d8 0a       	popm	pc,r12=0
80002062:	00 00       	add	r0,r0
80002064:	00 00       	add	r0,r0
80002066:	cf 50       	breq	80002050 <spi_unselectChip+0x24>
80002068:	80 00       	ld.sh	r0,r0[0x0]
8000206a:	2e 88       	sub	r8,-24

8000206c <spi_selectChip>:

	return SPI_OK;
}

spi_status_t spi_selectChip(volatile avr32_spi_t *spi, uint8_t chip)
{
8000206c:	eb cd 40 f8 	pushm	r3-r7,lr
80002070:	18 94       	mov	r4,r12
80002072:	16 93       	mov	r3,r11
#ifdef FREERTOS_USED
	while (pdFALSE == xSemaphoreTake(xSPIMutex, 20)) {
80002074:	49 a6       	lddpc	r6,800020dc <spi_selectChip+0x70>
80002076:	30 07       	mov	r7,0
80002078:	31 45       	mov	r5,20
8000207a:	0e 99       	mov	r9,r7
8000207c:	0a 9a       	mov	r10,r5
8000207e:	0e 9b       	mov	r11,r7
80002080:	6c 0c       	ld.w	r12,r6[0x0]
80002082:	f0 1f 00 18 	mcall	800020e0 <spi_selectChip+0x74>
80002086:	cf a0       	breq	8000207a <spi_selectChip+0xe>
	}
#endif

	/* Assert all lines; no peripheral is selected. */
	spi->mr |= AVR32_SPI_MR_PCS_MASK;
80002088:	68 18       	ld.w	r8,r4[0x4]
8000208a:	ea 18 00 0f 	orh	r8,0xf
8000208e:	89 18       	st.w	r4[0x4],r8

	if (spi->mr & AVR32_SPI_MR_PCSDEC_MASK) {
80002090:	68 18       	ld.w	r8,r4[0x4]
80002092:	e2 18 00 04 	andl	r8,0x4,COH
80002096:	c1 10       	breq	800020b8 <spi_selectChip+0x4c>
		/* The signal is decoded; allow up to 15 chips. */
		if (chip > 14) {
80002098:	30 e8       	mov	r8,14
8000209a:	f0 03 18 00 	cp.b	r3,r8
8000209e:	e0 8b 00 1c 	brhi	800020d6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~AVR32_SPI_MR_PCS_MASK |
800020a2:	68 19       	ld.w	r9,r4[0x4]
800020a4:	e6 08 15 10 	lsl	r8,r3,0x10
800020a8:	ea 18 ff f0 	orh	r8,0xfff0
800020ac:	e8 18 ff ff 	orl	r8,0xffff
800020b0:	12 68       	and	r8,r9
800020b2:	89 18       	st.w	r4[0x4],r8
800020b4:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
				(chip << AVR32_SPI_MR_PCS_OFFSET);
	} else {
		if (chip > 3) {
800020b8:	30 38       	mov	r8,3
800020ba:	f0 03 18 00 	cp.b	r3,r8
800020be:	e0 8b 00 0c 	brhi	800020d6 <spi_selectChip+0x6a>
			return SPI_ERROR_ARGUMENT;
		}

		spi->mr &= ~(1 << (AVR32_SPI_MR_PCS_OFFSET + chip));
800020c2:	68 19       	ld.w	r9,r4[0x4]
800020c4:	2f 03       	sub	r3,-16
800020c6:	30 18       	mov	r8,1
800020c8:	f0 03 09 48 	lsl	r8,r8,r3
800020cc:	5c d8       	com	r8
800020ce:	12 68       	and	r8,r9
800020d0:	89 18       	st.w	r4[0x4],r8
800020d2:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
800020d6:	30 2c       	mov	r12,2
	}

	return SPI_OK;
}
800020d8:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc
800020dc:	00 00       	add	r0,r0
800020de:	cf 50       	breq	800020c8 <spi_selectChip+0x5c>
800020e0:	80 00       	ld.sh	r0,r0[0x0]
800020e2:	2d 6c       	sub	r12,-42

800020e4 <wdt_set_ctrl>:
 *
 * \note The KEY bit-field of \a ctrl is assumed to be zero.
 */
static void wdt_set_ctrl(uint32_t ctrl)
{
	AVR32_WDT.ctrl = ctrl | (AVR32_WDT_KEY_VALUE << AVR32_WDT_CTRL_KEY_OFFSET);
800020e4:	18 99       	mov	r9,r12
800020e6:	ea 19 55 00 	orh	r9,0x5500
800020ea:	fe 78 10 00 	mov	r8,-61440
800020ee:	91 09       	st.w	r8[0x0],r9
	AVR32_WDT.ctrl = ctrl | ((uint32_t) (~AVR32_WDT_KEY_VALUE << AVR32_WDT_CTRL_KEY_OFFSET) & AVR32_WDT_CTRL_KEY_MASK);
800020f0:	ea 1c aa 00 	orh	r12,0xaa00
800020f4:	91 0c       	st.w	r8[0x0],r12
}
800020f6:	5e fc       	retal	r12

800020f8 <wdt_get_us_timeout_period>:

int64_t wdt_get_us_timeout_period(wdt_opt_t *opt)
{
800020f8:	eb cd 40 c0 	pushm	r6-r7,lr
	// RCOSC
	if (opt->cssel == WDT_CLOCK_SOURCE_SELECT_RCSYS) {
800020fc:	f9 39 00 10 	ld.ub	r9,r12[16]
80002100:	30 08       	mov	r8,0
80002102:	f0 09 18 00 	cp.b	r9,r8
80002106:	c3 11       	brne	80002168 <wdt_get_us_timeout_period+0x70>
		// Read CTRL.PSEL and translate it into us.
		return (AVR32_WDT.ctrl & AVR32_WDT_CTRL_EN_MASK) ?
80002108:	fe 78 10 00 	mov	r8,-61440
8000210c:	70 08       	ld.w	r8,r8[0x0]
8000210e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002112:	c0 41       	brne	8000211a <wdt_get_us_timeout_period+0x22>
80002114:	3f f8       	mov	r8,-1
80002116:	3f f9       	mov	r9,-1
80002118:	c5 78       	rjmp	800021c6 <wdt_get_us_timeout_period+0xce>
				((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
8000211a:	fe 78 10 00 	mov	r8,-61440
8000211e:	70 08       	ld.w	r8,r8[0x0]
int64_t wdt_get_us_timeout_period(wdt_opt_t *opt)
{
	// RCOSC
	if (opt->cssel == WDT_CLOCK_SOURCE_SELECT_RCSYS) {
		// Read CTRL.PSEL and translate it into us.
		return (AVR32_WDT.ctrl & AVR32_WDT_CTRL_EN_MASK) ?
80002120:	f1 d8 c1 05 	bfextu	r8,r8,0x8,0x5
80002124:	2f f8       	sub	r8,-1
80002126:	10 9c       	mov	r12,r8
80002128:	e2 1c 00 20 	andl	r12,0x20,COH
8000212c:	30 09       	mov	r9,0
8000212e:	f0 07 11 ff 	rsub	r7,r8,-1
80002132:	e6 7e a1 20 	mov	lr,500000
80002136:	fc 07 0a 4b 	lsr	r11,lr,r7
8000213a:	ee 77 42 40 	mov	r7,1000000
8000213e:	ee 08 09 4a 	lsl	r10,r7,r8
80002142:	12 3c       	cp.w	r12,r9
80002144:	f4 0b 17 10 	movne	r11,r10
80002148:	f2 0a 17 10 	movne	r10,r9
8000214c:	e0 78 c2 00 	mov	r8,115200
80002150:	30 09       	mov	r9,0
80002152:	e0 66 e1 00 	mov	r6,57600
80002156:	30 07       	mov	r7,0
80002158:	0c 0a       	add	r10,r6
8000215a:	f6 07 00 4b 	adc	r11,r11,r7
8000215e:	f0 1f 00 1d 	mcall	800021d0 <wdt_get_us_timeout_period+0xd8>
80002162:	16 99       	mov	r9,r11
80002164:	14 98       	mov	r8,r10
80002166:	c3 08       	rjmp	800021c6 <wdt_get_us_timeout_period+0xce>
				((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
				1000000 + AVR32_SCIF_RCOSC_FREQUENCY / 2) / AVR32_SCIF_RCOSC_FREQUENCY :
				-1ULL;
	} else {
		// Read CTRL.PSEL and translate it into us.
		return (AVR32_WDT.ctrl & AVR32_WDT_CTRL_EN_MASK) ?
80002168:	fe 78 10 00 	mov	r8,-61440
8000216c:	70 08       	ld.w	r8,r8[0x0]
8000216e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002172:	c0 41       	brne	8000217a <wdt_get_us_timeout_period+0x82>
80002174:	3f f8       	mov	r8,-1
80002176:	3f f9       	mov	r9,-1
80002178:	c2 78       	rjmp	800021c6 <wdt_get_us_timeout_period+0xce>
				((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
8000217a:	fe 78 10 00 	mov	r8,-61440
8000217e:	70 0a       	ld.w	r10,r8[0x0]
				((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
				1000000 + AVR32_SCIF_RCOSC_FREQUENCY / 2) / AVR32_SCIF_RCOSC_FREQUENCY :
				-1ULL;
	} else {
		// Read CTRL.PSEL and translate it into us.
		return (AVR32_WDT.ctrl & AVR32_WDT_CTRL_EN_MASK) ?
80002180:	f5 da c1 05 	bfextu	r10,r10,0x8,0x5
80002184:	2f fa       	sub	r10,-1
80002186:	14 9c       	mov	r12,r10
80002188:	e2 1c 00 20 	andl	r12,0x20,COH
8000218c:	30 0b       	mov	r11,0
8000218e:	f4 0e 11 ff 	rsub	lr,r10,-1
80002192:	e6 77 a1 20 	mov	r7,500000
80002196:	ee 0e 0a 49 	lsr	r9,r7,lr
8000219a:	ee 7e 42 40 	mov	lr,1000000
8000219e:	fc 0a 09 48 	lsl	r8,lr,r10
800021a2:	16 3c       	cp.w	r12,r11
800021a4:	f0 09 17 10 	movne	r9,r8
800021a8:	f6 08 17 10 	movne	r8,r11
800021ac:	e0 6a 40 00 	mov	r10,16384
800021b0:	30 0b       	mov	r11,0
800021b2:	f0 0a 00 0a 	add	r10,r8,r10
800021b6:	f2 0b 00 4b 	adc	r11,r9,r11
800021ba:	f4 08 16 0f 	lsr	r8,r10,0xf
800021be:	f1 eb 11 18 	or	r8,r8,r11<<0x11
800021c2:	f6 09 16 0f 	lsr	r9,r11,0xf
				((1ULL << (((AVR32_WDT.ctrl & AVR32_WDT_CTRL_PSEL_MASK) >> AVR32_WDT_CTRL_PSEL_OFFSET) + 1)) *
				1000000 + AVR32_SCIF_OSC32_FREQUENCY / 2) / AVR32_SCIF_OSC32_FREQUENCY :
				-1ULL;
	}
}
800021c6:	12 9b       	mov	r11,r9
800021c8:	10 9a       	mov	r10,r8
800021ca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800021ce:	00 00       	add	r0,r0
800021d0:	80 00       	ld.sh	r0,r0[0x0]
800021d2:	79 32       	ld.w	r2,r12[0x4c]

800021d4 <wdt_disable>:
				-1ULL;
	}
}

void wdt_disable(void)
{
800021d4:	d4 01       	pushm	lr
	wdt_set_ctrl(AVR32_WDT.ctrl & ~AVR32_WDT_CTRL_EN_MASK);
800021d6:	fe 78 10 00 	mov	r8,-61440
800021da:	70 0c       	ld.w	r12,r8[0x0]
800021dc:	a1 cc       	cbr	r12,0x0
800021de:	f0 1f 00 02 	mcall	800021e4 <wdt_disable+0x10>
}
800021e2:	d8 02       	popm	pc
800021e4:	80 00       	ld.sh	r0,r0[0x0]
800021e6:	20 e4       	sub	r4,14

800021e8 <wdt_reenable>:
	// Return the actual wdt period in us.
	return wdt_get_us_timeout_period(opt);
}

void wdt_reenable(void)
{
800021e8:	d4 01       	pushm	lr
	wdt_set_ctrl(AVR32_WDT.ctrl | AVR32_WDT_CTRL_EN_MASK | AVR32_WDT_CTRL_CEN_MASK );
800021ea:	fe 78 10 00 	mov	r8,-61440
800021ee:	70 0c       	ld.w	r12,r8[0x0]
800021f0:	ea 1c 00 01 	orh	r12,0x1
800021f4:	e8 1c 00 01 	orl	r12,0x1
800021f8:	f0 1f 00 02 	mcall	80002200 <wdt_reenable+0x18>
}
800021fc:	d8 02       	popm	pc
800021fe:	00 00       	add	r0,r0
80002200:	80 00       	ld.sh	r0,r0[0x0]
80002202:	20 e4       	sub	r4,14

80002204 <wdt_clear>:

void wdt_clear(void)
{
	while (!(AVR32_WDT.sr & AVR32_WDT_SR_CLEARED_MASK));
80002204:	fe 78 10 00 	mov	r8,-61440
80002208:	70 29       	ld.w	r9,r8[0x8]
8000220a:	e2 19 00 02 	andl	r9,0x2,COH
8000220e:	cf d0       	breq	80002208 <wdt_clear+0x4>
	AVR32_WDT.clr = ( (AVR32_WDT_KEY_VALUE << AVR32_WDT_KEY_OFFSET) | AVR32_WDT_CLR_WDTCLR_MASK );
80002210:	fe 78 10 00 	mov	r8,-61440
80002214:	30 19       	mov	r9,1
80002216:	ea 19 55 00 	orh	r9,0x5500
8000221a:	91 19       	st.w	r8[0x4],r9
	AVR32_WDT.clr = ( (~AVR32_WDT_KEY_VALUE << AVR32_WDT_KEY_OFFSET) | AVR32_WDT_CLR_WDTCLR_MASK );
8000221c:	30 19       	mov	r9,1
8000221e:	ea 19 aa 00 	orh	r9,0xaa00
80002222:	91 19       	st.w	r8[0x4],r9
}
80002224:	5e fc       	retal	r12
80002226:	d7 03       	nop

80002228 <wdt_enable>:
{
	wdt_set_ctrl(AVR32_WDT.ctrl & ~AVR32_WDT_CTRL_EN_MASK);
}

uint64_t wdt_enable(wdt_opt_t *opt)
{
80002228:	d4 31       	pushm	r0-r7,lr
8000222a:	18 97       	mov	r7,r12
	// RCOSC
	if (opt->cssel == WDT_CLOCK_SOURCE_SELECT_RCSYS) {
8000222c:	f9 38 00 10 	ld.ub	r8,r12[16]
80002230:	58 08       	cp.w	r8,0
80002232:	e0 81 00 88 	brne	80002342 <wdt_enable+0x11a>
		// Set the CTRL.EN bit
		// Translate the us timeout to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fRCosc
		// Translate the us timeban to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fRCosc
		wdt_set_ctrl(AVR32_WDT_CTRL_EN_MASK | AVR32_WDT_CTRL_CEN_MASK |
				(opt->dar << AVR32_WDT_CTRL_DAR_OFFSET) |
80002236:	f9 35 00 14 	ld.ub	r5,r12[20]
				(opt->mode << AVR32_WDT_CTRL_MODE_OFFSET) |
8000223a:	f9 36 00 13 	ld.ub	r6,r12[19]
				(opt->sfv << AVR32_WDT_CTRL_SFV_OFFSET) |
8000223e:	f9 34 00 12 	ld.ub	r4,r12[18]
				(opt->fcd << AVR32_WDT_CTRL_FCD_OFFSET) |
80002242:	f9 33 00 11 	ld.ub	r3,r12[17]
				(opt->cssel << AVR32_WDT_CTRL_CSSEL_OFFSET) |
				((32 - clz(((((Min(Max(opt->us_timeout_period, MIN_US_TIMEOUT_PERIOD_RCSYS), MAX_US_TIMEOUT_PERIOD_RCSYS) *
80002246:	f8 e8 00 00 	ld.d	r8,r12[0]
8000224a:	e0 6a e3 8d 	mov	r10,58253
8000224e:	ea 1a ae 38 	orh	r10,0xae38
80002252:	30 8b       	mov	r11,8
80002254:	14 38       	cp.w	r8,r10
80002256:	f6 09 13 00 	cpc	r9,r11
8000225a:	e0 88 00 04 	brls	80002262 <wdt_enable+0x3a>
8000225e:	3f f2       	mov	r2,-1
80002260:	c2 58       	rjmp	800022aa <wdt_enable+0x82>
80002262:	59 18       	cp.w	r8,17
80002264:	5c 29       	cpc	r9
80002266:	f9 b8 03 11 	movlo	r8,17
8000226a:	f9 b9 03 00 	movlo	r9,0
8000226e:	e0 7c c2 00 	mov	r12,115200
80002272:	f0 0c 06 4a 	mulu.d	r10,r8,r12
80002276:	f8 09 03 4b 	mac	r11,r12,r9
8000227a:	ee 78 42 40 	mov	r8,1000000
8000227e:	30 09       	mov	r9,0
80002280:	e6 70 a1 20 	mov	r0,500000
80002284:	30 01       	mov	r1,0
80002286:	00 0a       	add	r10,r0
80002288:	f6 01 00 4b 	adc	r11,r11,r1
8000228c:	f0 1f 00 5c 	mcall	800023fc <wdt_enable+0x1d4>
80002290:	14 0a       	add	r10,r10
80002292:	f6 0b 00 4b 	adc	r11,r11,r11
80002296:	3f f8       	mov	r8,-1
80002298:	3f f9       	mov	r9,-1
8000229a:	f4 08 00 08 	add	r8,r10,r8
8000229e:	f6 09 00 49 	adc	r9,r11,r9
800022a2:	f0 02 16 01 	lsr	r2,r8,0x1
800022a6:	e5 e9 11 f2 	or	r2,r2,r9<<0x1f
800022aa:	e4 02 12 00 	clz	r2,r2
				AVR32_SCIF_RCOSC_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_PSEL_OFFSET) |
				((32 - clz(((((Min(Max(opt->us_timeban_period, MIN_US_TIMEBAN_PERIOD_RCSYS), MAX_US_TIMEBAN_PERIOD_RCSYS) *
800022ae:	ee e8 00 08 	ld.d	r8,r7[8]
800022b2:	e0 6a e3 8d 	mov	r10,58253
800022b6:	ea 1a ae 38 	orh	r10,0xae38
800022ba:	30 8b       	mov	r11,8
800022bc:	14 38       	cp.w	r8,r10
800022be:	f6 09 13 00 	cpc	r9,r11
800022c2:	e0 88 00 04 	brls	800022ca <wdt_enable+0xa2>
800022c6:	3f fc       	mov	r12,-1
800022c8:	c2 58       	rjmp	80002312 <wdt_enable+0xea>
800022ca:	59 18       	cp.w	r8,17
800022cc:	5c 29       	cpc	r9
800022ce:	f9 b8 03 11 	movlo	r8,17
800022d2:	f9 b9 03 00 	movlo	r9,0
800022d6:	e0 7c c2 00 	mov	r12,115200
800022da:	f0 0c 06 4a 	mulu.d	r10,r8,r12
800022de:	f8 09 03 4b 	mac	r11,r12,r9
800022e2:	ee 78 42 40 	mov	r8,1000000
800022e6:	30 09       	mov	r9,0
800022e8:	e6 70 a1 20 	mov	r0,500000
800022ec:	30 01       	mov	r1,0
800022ee:	00 0a       	add	r10,r0
800022f0:	f6 01 00 4b 	adc	r11,r11,r1
800022f4:	f0 1f 00 42 	mcall	800023fc <wdt_enable+0x1d4>
800022f8:	14 0a       	add	r10,r10
800022fa:	f6 0b 00 4b 	adc	r11,r11,r11
800022fe:	3f f8       	mov	r8,-1
80002300:	3f f9       	mov	r9,-1
80002302:	f4 08 00 08 	add	r8,r10,r8
80002306:	f6 09 00 49 	adc	r9,r11,r9
8000230a:	f0 0c 16 01 	lsr	r12,r8,0x1
8000230e:	f9 e9 11 fc 	or	r12,r12,r9<<0x1f
80002312:	f8 0c 12 00 	clz	r12,r12
	// RCOSC
	if (opt->cssel == WDT_CLOCK_SOURCE_SELECT_RCSYS) {
		// Set the CTRL.EN bit
		// Translate the us timeout to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fRCosc
		// Translate the us timeban to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fRCosc
		wdt_set_ctrl(AVR32_WDT_CTRL_EN_MASK | AVR32_WDT_CTRL_CEN_MASK |
80002316:	a3 66       	lsl	r6,0x2
80002318:	ed e5 10 15 	or	r5,r6,r5<<0x1
8000231c:	ea 15 00 01 	orh	r5,0x1
80002320:	e8 15 00 01 	orl	r5,0x1
80002324:	eb e4 10 34 	or	r4,r5,r4<<0x3
80002328:	e9 e3 10 73 	or	r3,r4,r3<<0x7
8000232c:	e4 02 11 1f 	rsub	r2,r2,31
80002330:	e7 e2 10 83 	or	r3,r3,r2<<0x8
80002334:	f8 0c 11 1f 	rsub	r12,r12,31
80002338:	e7 ec 11 2c 	or	r12,r3,r12<<0x12
8000233c:	f0 1f 00 31 	mcall	80002400 <wdt_enable+0x1d8>
80002340:	c5 58       	rjmp	800023ea <wdt_enable+0x1c2>
		wdt_set_ctrl(AVR32_WDT_CTRL_EN_MASK | AVR32_WDT_CTRL_CEN_MASK |
				(opt->dar << AVR32_WDT_CTRL_DAR_OFFSET) |
				(opt->mode << AVR32_WDT_CTRL_MODE_OFFSET) |
				(opt->sfv << AVR32_WDT_CTRL_SFV_OFFSET) |
				(opt->fcd << AVR32_WDT_CTRL_FCD_OFFSET) |
				(opt->cssel << AVR32_WDT_CTRL_CSSEL_OFFSET) |
80002342:	f9 39 00 14 	ld.ub	r9,r12[20]
80002346:	f9 36 00 13 	ld.ub	r6,r12[19]
8000234a:	a3 66       	lsl	r6,0x2
8000234c:	ed e9 10 16 	or	r6,r6,r9<<0x1
80002350:	ea 16 00 01 	orh	r6,0x1
80002354:	e8 16 00 01 	orl	r6,0x1
80002358:	f9 39 00 12 	ld.ub	r9,r12[18]
8000235c:	ed e9 10 36 	or	r6,r6,r9<<0x3
80002360:	f9 39 00 11 	ld.ub	r9,r12[17]
80002364:	ed e9 10 76 	or	r6,r6,r9<<0x7
80002368:	ed e8 11 16 	or	r6,r6,r8<<0x11
				((32 - clz(((((Min(Max(opt->us_timeout_period, MIN_US_TIMEOUT_PERIOD_OSC32K), MAX_US_TIMEOUT_PERIOD_OSC32K) *
8000236c:	f8 e8 00 00 	ld.d	r8,r12[0]
80002370:	e0 6a ff ff 	mov	r10,65535
80002374:	ea 1a 84 7f 	orh	r10,0x847f
80002378:	31 eb       	mov	r11,30
8000237a:	14 38       	cp.w	r8,r10
8000237c:	f6 09 13 00 	cpc	r9,r11
80002380:	e0 8b 00 39 	brhi	800023f2 <wdt_enable+0x1ca>
80002384:	e0 48 00 3d 	cp.w	r8,61
80002388:	5c 29       	cpc	r9
8000238a:	f9 b8 03 3d 	movlo	r8,61
8000238e:	f9 b9 03 00 	movlo	r9,0
80002392:	f2 0b 15 0f 	lsl	r11,r9,0xf
80002396:	f7 e8 13 1b 	or	r11,r11,r8>>0x11
8000239a:	f0 0a 15 0f 	lsl	r10,r8,0xf
8000239e:	ee 78 42 40 	mov	r8,1000000
800023a2:	30 09       	mov	r9,0
800023a4:	e6 74 a1 20 	mov	r4,500000
800023a8:	30 05       	mov	r5,0
800023aa:	08 0a       	add	r10,r4
800023ac:	f6 05 00 4b 	adc	r11,r11,r5
800023b0:	f0 1f 00 13 	mcall	800023fc <wdt_enable+0x1d4>
800023b4:	14 0a       	add	r10,r10
800023b6:	f6 0b 00 4b 	adc	r11,r11,r11
800023ba:	3f f8       	mov	r8,-1
800023bc:	3f f9       	mov	r9,-1
800023be:	f4 08 00 08 	add	r8,r10,r8
800023c2:	f6 09 00 49 	adc	r9,r11,r9
800023c6:	f0 0a 16 01 	lsr	r10,r8,0x1
800023ca:	f5 e9 11 f8 	or	r8,r10,r9<<0x1f
800023ce:	f0 09 12 00 	clz	r9,r8
				AVR32_SCIF_OSC32_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_PSEL_OFFSET) |
800023d2:	f2 09 11 1f 	rsub	r9,r9,31
800023d6:	ed e9 10 86 	or	r6,r6,r9<<0x8
				((32 - clz(((((Min(Max(opt->us_timeout_period, MIN_US_TIMEBAN_PERIOD_OSC32K), MAX_US_TIMEBAN_PERIOD_OSC32K) *
800023da:	f0 08 12 00 	clz	r8,r8
				AVR32_SCIF_RCOSC_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_TBAN_OFFSET));
	} else {
		// Set the CTRL.EN bit
		// Translate the us timeout to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fROSC32K
		// Translate the us timeban to fit in CTRL.PSEL using the formula Twdt = 2pow(PSEL+1) / fROSC32K
		wdt_set_ctrl(AVR32_WDT_CTRL_EN_MASK | AVR32_WDT_CTRL_CEN_MASK |
800023de:	f0 0c 11 1f 	rsub	r12,r8,31
800023e2:	ed ec 11 2c 	or	r12,r6,r12<<0x12
800023e6:	f0 1f 00 07 	mcall	80002400 <wdt_enable+0x1d8>
				AVR32_SCIF_OSC32_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_PSEL_OFFSET) |
				((32 - clz(((((Min(Max(opt->us_timeout_period, MIN_US_TIMEBAN_PERIOD_OSC32K), MAX_US_TIMEBAN_PERIOD_OSC32K) *
				AVR32_SCIF_OSC32_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_TBAN_OFFSET));
	}
	// Return the actual wdt period in us.
	return wdt_get_us_timeout_period(opt);
800023ea:	0e 9c       	mov	r12,r7
800023ec:	f0 1f 00 06 	mcall	80002404 <wdt_enable+0x1dc>
}
800023f0:	d8 32       	popm	r0-r7,pc
				(opt->mode << AVR32_WDT_CTRL_MODE_OFFSET) |
				(opt->sfv << AVR32_WDT_CTRL_SFV_OFFSET) |
				(opt->fcd << AVR32_WDT_CTRL_FCD_OFFSET) |
				(opt->cssel << AVR32_WDT_CTRL_CSSEL_OFFSET) |
				((32 - clz(((((Min(Max(opt->us_timeout_period, MIN_US_TIMEOUT_PERIOD_OSC32K), MAX_US_TIMEOUT_PERIOD_OSC32K) *
				AVR32_SCIF_OSC32_FREQUENCY + 500000) / 1000000) << 1) - 1) >> 1) - 1) << AVR32_WDT_CTRL_PSEL_OFFSET) |
800023f2:	e8 16 1f 00 	orl	r6,0x1f00
800023f6:	3f f8       	mov	r8,-1
800023f8:	cf 1b       	rjmp	800023da <wdt_enable+0x1b2>
800023fa:	00 00       	add	r0,r0
800023fc:	80 00       	ld.sh	r0,r0[0x0]
800023fe:	79 32       	ld.w	r2,r12[0x4c]
80002400:	80 00       	ld.sh	r0,r0[0x0]
80002402:	20 e4       	sub	r4,14
80002404:	80 00       	ld.sh	r0,r0[0x0]
80002406:	20 f8       	sub	r8,15

80002408 <spi_read_packet>:
#endif
}

status_code_t spi_read_packet(volatile avr32_spi_t *spi,
		uint8_t *data, size_t len)
{
80002408:	eb cd 40 80 	pushm	r7,lr
	unsigned int timeout = SPI_TIMEOUT;
	uint8_t val;
	size_t i=0;
	while(len) {
8000240c:	58 0a       	cp.w	r10,0
8000240e:	c0 61       	brne	8000241a <spi_read_packet+0x12>
80002410:	c2 28       	rjmp	80002454 <spi_read_packet+0x4c>
		timeout = SPI_TIMEOUT;
		while (!spi_is_tx_ready(spi)) {
			if (!timeout--) {
80002412:	58 08       	cp.w	r8,0
80002414:	c1 d0       	breq	8000244e <spi_read_packet+0x46>
80002416:	20 18       	sub	r8,1
80002418:	c0 68       	rjmp	80002424 <spi_read_packet+0x1c>
8000241a:	e0 6e 3a 98 	mov	lr,15000
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(volatile avr32_spi_t *spi, uint16_t data)
{
	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000241e:	e0 67 00 ff 	mov	r7,255
80002422:	1c 98       	mov	r8,lr
 *   \retval 1  All transmissions complete.
 *   \retval 0  Transmissions not complete.
 */
static inline bool spi_is_tx_ready(volatile avr32_spi_t *spi)
{
	return (spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0;
80002424:	78 49       	ld.w	r9,r12[0x10]
	unsigned int timeout = SPI_TIMEOUT;
	uint8_t val;
	size_t i=0;
	while(len) {
		timeout = SPI_TIMEOUT;
		while (!spi_is_tx_ready(spi)) {
80002426:	e2 19 00 02 	andl	r9,0x2,COH
8000242a:	cf 40       	breq	80002412 <spi_read_packet+0xa>
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(volatile avr32_spi_t *spi, uint16_t data)
{
	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000242c:	99 37       	st.w	r12[0xc],r7
8000242e:	1c 98       	mov	r8,lr
				return ERR_TIMEOUT;
			}
		}
		spi_write_single(spi,CONFIG_SPI_MASTER_DUMMY);
		timeout = SPI_TIMEOUT;
		while (!spi_is_rx_ready(spi)) {
80002430:	c0 48       	rjmp	80002438 <spi_read_packet+0x30>
			if (!timeout--) {
80002432:	58 08       	cp.w	r8,0
80002434:	c0 d0       	breq	8000244e <spi_read_packet+0x46>
80002436:	20 18       	sub	r8,1
 *
 * \return \c 1 if the SPI Receiver is ready, otherwise \c 0.
 */
static inline bool spi_is_rx_ready(volatile avr32_spi_t *spi)
{
	return (spi->sr &
80002438:	78 49       	ld.w	r9,r12[0x10]
				return ERR_TIMEOUT;
			}
		}
		spi_write_single(spi,CONFIG_SPI_MASTER_DUMMY);
		timeout = SPI_TIMEOUT;
		while (!spi_is_rx_ready(spi)) {
8000243a:	e2 19 02 01 	andl	r9,0x201,COH
8000243e:	e0 49 02 01 	cp.w	r9,513
80002442:	cf 81       	brne	80002432 <spi_read_packet+0x2a>
 * \return The data byte
 *
 */
static inline uint16_t spi_get(volatile avr32_spi_t *spi)
{
	return (spi->rdr >> AVR32_SPI_RDR_RD_OFFSET);
80002444:	78 28       	ld.w	r8,r12[0x8]
			if (!timeout--) {
				return ERR_TIMEOUT;
			}
		}
		spi_read_single(spi,&val);
		data[i] = val;
80002446:	16 c8       	st.b	r11++,r8
		i++;
		len--;
80002448:	20 1a       	sub	r10,1
		uint8_t *data, size_t len)
{
	unsigned int timeout = SPI_TIMEOUT;
	uint8_t val;
	size_t i=0;
	while(len) {
8000244a:	ce c1       	brne	80002422 <spi_read_packet+0x1a>
8000244c:	c0 48       	rjmp	80002454 <spi_read_packet+0x4c>
8000244e:	3f dc       	mov	r12,-3
80002450:	e3 cd 80 80 	ldm	sp++,r7,pc
80002454:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0

80002458 <spi_write_packet>:
	return STATUS_OK;
}

status_code_t spi_write_packet(volatile avr32_spi_t *spi, const uint8_t *data,
		size_t len)
{
80002458:	d4 01       	pushm	lr
	unsigned int timeout = SPI_TIMEOUT;
	size_t i=0;
	uint8_t val;
	while(len) {
8000245a:	58 0a       	cp.w	r10,0
8000245c:	c0 81       	brne	8000246c <spi_write_packet+0x14>
8000245e:	c1 28       	rjmp	80002482 <spi_write_packet+0x2a>
		timeout = SPI_TIMEOUT;
		while (!spi_is_tx_ready(spi)) {
			if (!timeout--) {
80002460:	58 08       	cp.w	r8,0
80002462:	c0 31       	brne	80002468 <spi_write_packet+0x10>
80002464:	3f dc       	mov	r12,-3
80002466:	d8 02       	popm	pc
80002468:	20 18       	sub	r8,1
8000246a:	c0 48       	rjmp	80002472 <spi_write_packet+0x1a>
8000246c:	e0 6e 3a 98 	mov	lr,15000
80002470:	1c 98       	mov	r8,lr
 *   \retval 1  All transmissions complete.
 *   \retval 0  Transmissions not complete.
 */
static inline bool spi_is_tx_ready(volatile avr32_spi_t *spi)
{
	return (spi->sr & AVR32_SPI_SR_TDRE_MASK) != 0;
80002472:	78 49       	ld.w	r9,r12[0x10]
	unsigned int timeout = SPI_TIMEOUT;
	size_t i=0;
	uint8_t val;
	while(len) {
		timeout = SPI_TIMEOUT;
		while (!spi_is_tx_ready(spi)) {
80002474:	e2 19 00 02 	andl	r9,0x2,COH
80002478:	cf 40       	breq	80002460 <spi_write_packet+0x8>
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(volatile avr32_spi_t *spi, uint16_t data)
{
	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000247a:	17 38       	ld.ub	r8,r11++
8000247c:	99 38       	st.w	r12[0xc],r8
			}
		}
		val = data[i];
		spi_write_single(spi,val);
		i++;
		len--;
8000247e:	20 1a       	sub	r10,1
		size_t len)
{
	unsigned int timeout = SPI_TIMEOUT;
	size_t i=0;
	uint8_t val;
	while(len) {
80002480:	cf 81       	brne	80002470 <spi_write_packet+0x18>
80002482:	d8 0a       	popm	pc,r12=0

80002484 <spi_master_setup_device>:
#endif

void spi_master_setup_device(volatile avr32_spi_t *spi,
		struct spi_device *device, spi_flags_t flags, uint32_t baud_rate,
		board_spi_select_id_t sel_id)
{
80002484:	eb cd 40 e0 	pushm	r5-r7,lr
80002488:	18 97       	mov	r7,r12
8000248a:	16 96       	mov	r6,r11
8000248c:	14 95       	mov	r5,r10
static inline void spi_set_chipselect_delay_bct(volatile avr32_spi_t *spi,
		uint8_t chip_select, uint8_t delay)
{
	Assert(chip_select <= 3);

	switch (chip_select) {
8000248e:	17 88       	ld.ub	r8,r11[0x0]
80002490:	30 1a       	mov	r10,1
80002492:	f4 08 18 00 	cp.b	r8,r10
80002496:	c1 10       	breq	800024b8 <spi_master_setup_device+0x34>
80002498:	c0 a3       	brcs	800024ac <spi_master_setup_device+0x28>
8000249a:	30 2a       	mov	r10,2
8000249c:	f4 08 18 00 	cp.b	r8,r10
800024a0:	c1 20       	breq	800024c4 <spi_master_setup_device+0x40>
800024a2:	30 3a       	mov	r10,3
800024a4:	f4 08 18 00 	cp.b	r8,r10
800024a8:	c1 91       	brne	800024da <spi_master_setup_device+0x56>
800024aa:	c1 38       	rjmp	800024d0 <spi_master_setup_device+0x4c>
	case 0:
		spi->CSR0.dlybct = delay;
800024ac:	78 c8       	ld.w	r8,r12[0x30]
800024ae:	30 0a       	mov	r10,0
800024b0:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
800024b4:	99 c8       	st.w	r12[0x30],r8
800024b6:	c1 28       	rjmp	800024da <spi_master_setup_device+0x56>
		break;

	case 1:
		spi->CSR1.dlybct  = delay;
800024b8:	78 d8       	ld.w	r8,r12[0x34]
800024ba:	30 0a       	mov	r10,0
800024bc:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
800024c0:	99 d8       	st.w	r12[0x34],r8
800024c2:	c0 c8       	rjmp	800024da <spi_master_setup_device+0x56>
		break;

	case 2:
		spi->CSR2.dlybct  = delay;
800024c4:	78 e8       	ld.w	r8,r12[0x38]
800024c6:	30 0a       	mov	r10,0
800024c8:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
800024cc:	99 e8       	st.w	r12[0x38],r8
800024ce:	c0 68       	rjmp	800024da <spi_master_setup_device+0x56>
		break;

	case 3:
		spi->CSR3.dlybct  = delay;
800024d0:	78 f8       	ld.w	r8,r12[0x3c]
800024d2:	30 0a       	mov	r10,0
800024d4:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
800024d8:	99 f8       	st.w	r12[0x3c],r8
static inline void spi_set_chipselect_delay_bs(volatile avr32_spi_t *spi,
		uint8_t chip_select, uint8_t delay)
{
	Assert(chip_select <= 3);

	switch (chip_select) {
800024da:	0d 88       	ld.ub	r8,r6[0x0]
800024dc:	30 1a       	mov	r10,1
800024de:	f4 08 18 00 	cp.b	r8,r10
800024e2:	c1 10       	breq	80002504 <spi_master_setup_device+0x80>
800024e4:	c0 a3       	brcs	800024f8 <spi_master_setup_device+0x74>
800024e6:	30 2a       	mov	r10,2
800024e8:	f4 08 18 00 	cp.b	r8,r10
800024ec:	c1 20       	breq	80002510 <spi_master_setup_device+0x8c>
800024ee:	30 3a       	mov	r10,3
800024f0:	f4 08 18 00 	cp.b	r8,r10
800024f4:	c1 91       	brne	80002526 <spi_master_setup_device+0xa2>
800024f6:	c1 38       	rjmp	8000251c <spi_master_setup_device+0x98>
	case 0:
		spi->CSR0.dlybs = delay;
800024f8:	6e c8       	ld.w	r8,r7[0x30]
800024fa:	30 0a       	mov	r10,0
800024fc:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
80002500:	8f c8       	st.w	r7[0x30],r8
80002502:	c1 28       	rjmp	80002526 <spi_master_setup_device+0xa2>
		break;

	case 1:
		spi->CSR1.dlybs  = delay;
80002504:	6e d8       	ld.w	r8,r7[0x34]
80002506:	30 0a       	mov	r10,0
80002508:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
8000250c:	8f d8       	st.w	r7[0x34],r8
8000250e:	c0 c8       	rjmp	80002526 <spi_master_setup_device+0xa2>
		break;

	case 2:
		spi->CSR2.dlybs  = delay;
80002510:	6e e8       	ld.w	r8,r7[0x38]
80002512:	30 0a       	mov	r10,0
80002514:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
80002518:	8f e8       	st.w	r7[0x38],r8
8000251a:	c0 68       	rjmp	80002526 <spi_master_setup_device+0xa2>
		break;

	case 3:
		spi->CSR3.dlybs  = delay;
8000251c:	6e f8       	ld.w	r8,r7[0x3c]
8000251e:	30 0a       	mov	r10,0
80002520:	f1 da d2 08 	bfins	r8,r10,0x10,0x8
80002524:	8f f8       	st.w	r7[0x3c],r8
		uint8_t chip_select,
		uint8_t len)
{
	Assert((len >= 8) && (len <= 16));

	switch (chip_select) {
80002526:	0d 88       	ld.ub	r8,r6[0x0]
80002528:	30 1a       	mov	r10,1
8000252a:	f4 08 18 00 	cp.b	r8,r10
8000252e:	c1 10       	breq	80002550 <spi_master_setup_device+0xcc>
80002530:	c0 a3       	brcs	80002544 <spi_master_setup_device+0xc0>
80002532:	30 2a       	mov	r10,2
80002534:	f4 08 18 00 	cp.b	r8,r10
80002538:	c1 20       	breq	8000255c <spi_master_setup_device+0xd8>
8000253a:	30 3a       	mov	r10,3
8000253c:	f4 08 18 00 	cp.b	r8,r10
80002540:	c1 91       	brne	80002572 <spi_master_setup_device+0xee>
80002542:	c1 38       	rjmp	80002568 <spi_master_setup_device+0xe4>
	case 0:
		spi->CSR0.bits = len - 8;
80002544:	6e c8       	ld.w	r8,r7[0x30]
80002546:	30 0a       	mov	r10,0
80002548:	f1 da d0 84 	bfins	r8,r10,0x4,0x4
8000254c:	8f c8       	st.w	r7[0x30],r8
8000254e:	c1 28       	rjmp	80002572 <spi_master_setup_device+0xee>
		break;

	case 1:
		spi->CSR1.bits  = len - 8;
80002550:	6e d8       	ld.w	r8,r7[0x34]
80002552:	30 0a       	mov	r10,0
80002554:	f1 da d0 84 	bfins	r8,r10,0x4,0x4
80002558:	8f d8       	st.w	r7[0x34],r8
8000255a:	c0 c8       	rjmp	80002572 <spi_master_setup_device+0xee>
		break;

	case 2:
		spi->CSR2.bits  = len - 8;
8000255c:	6e e8       	ld.w	r8,r7[0x38]
8000255e:	30 0a       	mov	r10,0
80002560:	f1 da d0 84 	bfins	r8,r10,0x4,0x4
80002564:	8f e8       	st.w	r7[0x38],r8
80002566:	c0 68       	rjmp	80002572 <spi_master_setup_device+0xee>
		break;

	case 3:
		spi->CSR3.bits  = len - 8;
80002568:	6e f8       	ld.w	r8,r7[0x3c]
8000256a:	30 0a       	mov	r10,0
8000256c:	f1 da d0 84 	bfins	r8,r10,0x4,0x4
80002570:	8f f8       	st.w	r7[0x3c],r8
 * \return Frequency of the bus attached to the specified peripheral, in Hz.
 */
static inline uint32_t sysclk_get_peripheral_bus_hz(const volatile void *module)
{
	/* Fallthroughs intended for modules sharing the same peripheral bus. */
	switch ((uintptr_t)module) {
80002572:	fe 57 10 00 	cp.w	r7,-61440
80002576:	e0 80 00 87 	breq	80002684 <spi_master_setup_device+0x200>
8000257a:	e0 8b 00 41 	brhi	800025fc <spi_master_setup_device+0x178>
8000257e:	fe 47 00 00 	cp.w	r7,-131072
80002582:	e0 80 00 86 	breq	8000268e <spi_master_setup_device+0x20a>
80002586:	e0 8b 00 1c 	brhi	800025be <spi_master_setup_device+0x13a>
8000258a:	fc 57 18 00 	cp.w	r7,-190464
8000258e:	e0 80 00 85 	breq	80002698 <spi_master_setup_device+0x214>
80002592:	e0 8b 00 0c 	brhi	800025aa <spi_master_setup_device+0x126>
80002596:	fc 57 10 00 	cp.w	r7,-192512
8000259a:	c7 f0       	breq	80002698 <spi_master_setup_device+0x214>
8000259c:	fc 57 14 00 	cp.w	r7,-191488
800025a0:	c7 c0       	breq	80002698 <spi_master_setup_device+0x214>
800025a2:	fc 57 00 00 	cp.w	r7,-196608
800025a6:	c6 d1       	brne	80002680 <spi_master_setup_device+0x1fc>
800025a8:	c7 88       	rjmp	80002698 <spi_master_setup_device+0x214>
800025aa:	fc 57 20 00 	cp.w	r7,-188416
800025ae:	c7 50       	breq	80002698 <spi_master_setup_device+0x214>
800025b0:	fc 57 24 00 	cp.w	r7,-187392
800025b4:	c7 20       	breq	80002698 <spi_master_setup_device+0x214>
800025b6:	fc 57 1c 00 	cp.w	r7,-189440
800025ba:	c6 31       	brne	80002680 <spi_master_setup_device+0x1fc>
800025bc:	c6 e8       	rjmp	80002698 <spi_master_setup_device+0x214>
800025be:	fe 47 30 00 	cp.w	r7,-118784
800025c2:	c6 60       	breq	8000268e <spi_master_setup_device+0x20a>
800025c4:	e0 8b 00 0c 	brhi	800025dc <spi_master_setup_device+0x158>
800025c8:	fe 47 20 00 	cp.w	r7,-122880
800025cc:	c6 10       	breq	8000268e <spi_master_setup_device+0x20a>
800025ce:	fe 47 24 00 	cp.w	r7,-121856
800025d2:	c5 e0       	breq	8000268e <spi_master_setup_device+0x20a>
800025d4:	fe 47 10 00 	cp.w	r7,-126976
800025d8:	c5 41       	brne	80002680 <spi_master_setup_device+0x1fc>
800025da:	c5 a8       	rjmp	8000268e <spi_master_setup_device+0x20a>
800025dc:	fe 57 04 00 	cp.w	r7,-64512
800025e0:	c5 20       	breq	80002684 <spi_master_setup_device+0x200>
800025e2:	e0 8b 00 06 	brhi	800025ee <spi_master_setup_device+0x16a>
800025e6:	fe 57 00 00 	cp.w	r7,-65536
800025ea:	c4 b1       	brne	80002680 <spi_master_setup_device+0x1fc>
800025ec:	c4 c8       	rjmp	80002684 <spi_master_setup_device+0x200>
800025ee:	fe 57 08 00 	cp.w	r7,-63488
800025f2:	c4 90       	breq	80002684 <spi_master_setup_device+0x200>
800025f4:	fe 57 0c 00 	cp.w	r7,-62464
800025f8:	c4 41       	brne	80002680 <spi_master_setup_device+0x1fc>
800025fa:	c4 58       	rjmp	80002684 <spi_master_setup_device+0x200>
800025fc:	fe 57 40 00 	cp.w	r7,-49152
80002600:	c4 20       	breq	80002684 <spi_master_setup_device+0x200>
80002602:	e0 8b 00 21 	brhi	80002644 <spi_master_setup_device+0x1c0>
80002606:	fe 57 28 00 	cp.w	r7,-55296
8000260a:	c3 d0       	breq	80002684 <spi_master_setup_device+0x200>
8000260c:	e0 8b 00 0c 	brhi	80002624 <spi_master_setup_device+0x1a0>
80002610:	fe 57 18 00 	cp.w	r7,-59392
80002614:	c3 80       	breq	80002684 <spi_master_setup_device+0x200>
80002616:	fe 57 20 00 	cp.w	r7,-57344
8000261a:	c3 50       	breq	80002684 <spi_master_setup_device+0x200>
8000261c:	fe 57 14 00 	cp.w	r7,-60416
80002620:	c3 01       	brne	80002680 <spi_master_setup_device+0x1fc>
80002622:	c3 18       	rjmp	80002684 <spi_master_setup_device+0x200>
80002624:	fe 57 30 00 	cp.w	r7,-53248
80002628:	c2 e0       	breq	80002684 <spi_master_setup_device+0x200>
8000262a:	e0 8b 00 06 	brhi	80002636 <spi_master_setup_device+0x1b2>
8000262e:	fe 57 2c 00 	cp.w	r7,-54272
80002632:	c2 71       	brne	80002680 <spi_master_setup_device+0x1fc>
80002634:	c2 88       	rjmp	80002684 <spi_master_setup_device+0x200>
80002636:	fe 57 38 00 	cp.w	r7,-51200
8000263a:	c2 50       	breq	80002684 <spi_master_setup_device+0x200>
8000263c:	fe 57 3c 00 	cp.w	r7,-50176
80002640:	c2 01       	brne	80002680 <spi_master_setup_device+0x1fc>
80002642:	c2 18       	rjmp	80002684 <spi_master_setup_device+0x200>
80002644:	fe 57 50 00 	cp.w	r7,-45056
80002648:	c1 e0       	breq	80002684 <spi_master_setup_device+0x200>
8000264a:	e0 8b 00 0c 	brhi	80002662 <spi_master_setup_device+0x1de>
8000264e:	fe 57 48 00 	cp.w	r7,-47104
80002652:	c1 90       	breq	80002684 <spi_master_setup_device+0x200>
80002654:	fe 57 4c 00 	cp.w	r7,-46080
80002658:	c1 60       	breq	80002684 <spi_master_setup_device+0x200>
8000265a:	fe 57 44 00 	cp.w	r7,-48128
8000265e:	c1 11       	brne	80002680 <spi_master_setup_device+0x1fc>
80002660:	c1 28       	rjmp	80002684 <spi_master_setup_device+0x200>
80002662:	fe 57 60 00 	cp.w	r7,-40960
80002666:	c0 f0       	breq	80002684 <spi_master_setup_device+0x200>
80002668:	e0 8b 00 06 	brhi	80002674 <spi_master_setup_device+0x1f0>
8000266c:	fe 57 5c 00 	cp.w	r7,-41984
80002670:	c0 81       	brne	80002680 <spi_master_setup_device+0x1fc>
80002672:	c0 98       	rjmp	80002684 <spi_master_setup_device+0x200>
80002674:	fe 57 68 00 	cp.w	r7,-38912
80002678:	c0 60       	breq	80002684 <spi_master_setup_device+0x200>
8000267a:	fe 57 70 00 	cp.w	r7,-36864
8000267e:	c0 30       	breq	80002684 <spi_master_setup_device+0x200>
80002680:	30 0b       	mov	r11,0
80002682:	c0 f8       	rjmp	800026a0 <spi_master_setup_device+0x21c>
 *
 * \return Frequency of the Peripheral Bus A clock, in Hz.
 */
static inline uint32_t sysclk_get_pba_hz(void)
{
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_PBA_DIV;
80002684:	e0 6b 36 00 	mov	r11,13824
80002688:	ea 1b 01 6e 	orh	r11,0x16e
8000268c:	c0 a8       	rjmp	800026a0 <spi_master_setup_device+0x21c>
 *
 * \return Frequency of the Peripheral Bus B clock, in Hz.
 */
static inline uint32_t sysclk_get_pbb_hz(void)
{
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_PBB_DIV;
8000268e:	e0 6b 36 00 	mov	r11,13824
80002692:	ea 1b 01 6e 	orh	r11,0x16e
80002696:	c0 58       	rjmp	800026a0 <spi_master_setup_device+0x21c>
 *
 * \return Frequency of the Peripheral Bus C clock, in Hz.
 */
static inline uint32_t sysclk_get_pbc_hz(void)
{
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_PBC_DIV;
80002698:	e0 6b 36 00 	mov	r11,13824
8000269c:	ea 1b 01 6e 	orh	r11,0x16e
	spi_set_chipselect_delay_bct(spi,device->id,CONFIG_SPI_MASTER_DELAY_BCT);
	spi_set_chipselect_delay_bs(spi,device->id,CONFIG_SPI_MASTER_DELAY_BS);
	spi_set_bits_per_transfer(spi,device->id,
			CONFIG_SPI_MASTER_BITS_PER_TRANSFER);
	spi_set_baudrate_register(spi,device->id,
			getBaudDiv(baud_rate, sysclk_get_peripheral_bus_hz(spi)));
800026a0:	12 9c       	mov	r12,r9
800026a2:	f0 1f 00 54 	mcall	800027f0 <spi_master_setup_device+0x36c>
{
	spi_set_chipselect_delay_bct(spi,device->id,CONFIG_SPI_MASTER_DELAY_BCT);
	spi_set_chipselect_delay_bs(spi,device->id,CONFIG_SPI_MASTER_DELAY_BS);
	spi_set_bits_per_transfer(spi,device->id,
			CONFIG_SPI_MASTER_BITS_PER_TRANSFER);
	spi_set_baudrate_register(spi,device->id,
800026a6:	5c 5c       	castu.b	r12
 */
static inline void spi_set_baudrate_register(volatile avr32_spi_t *spi,
		uint8_t chip_select,
		uint8_t scbr)
{
	switch (chip_select) {
800026a8:	0d 88       	ld.ub	r8,r6[0x0]
800026aa:	30 19       	mov	r9,1
800026ac:	f2 08 18 00 	cp.b	r8,r9
800026b0:	c1 00       	breq	800026d0 <spi_master_setup_device+0x24c>
800026b2:	c0 a3       	brcs	800026c6 <spi_master_setup_device+0x242>
800026b4:	30 29       	mov	r9,2
800026b6:	f2 08 18 00 	cp.b	r8,r9
800026ba:	c1 00       	breq	800026da <spi_master_setup_device+0x256>
800026bc:	30 39       	mov	r9,3
800026be:	f2 08 18 00 	cp.b	r8,r9
800026c2:	c1 51       	brne	800026ec <spi_master_setup_device+0x268>
800026c4:	c1 08       	rjmp	800026e4 <spi_master_setup_device+0x260>
	case 0:
		spi->CSR0.scbr = scbr;
800026c6:	6e c8       	ld.w	r8,r7[0x30]
800026c8:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
800026cc:	8f c8       	st.w	r7[0x30],r8
800026ce:	c0 f8       	rjmp	800026ec <spi_master_setup_device+0x268>
		break;

	case 1:
		spi->CSR1.scbr  = scbr;
800026d0:	6e d8       	ld.w	r8,r7[0x34]
800026d2:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
800026d6:	8f d8       	st.w	r7[0x34],r8
800026d8:	c0 a8       	rjmp	800026ec <spi_master_setup_device+0x268>
		break;

	case 2:
		spi->CSR2.scbr  = scbr;
800026da:	6e e8       	ld.w	r8,r7[0x38]
800026dc:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
800026e0:	8f e8       	st.w	r7[0x38],r8
800026e2:	c0 58       	rjmp	800026ec <spi_master_setup_device+0x268>
		break;

	case 3:
		spi->CSR3.scbr  = scbr;
800026e4:	6e f8       	ld.w	r8,r7[0x3c]
800026e6:	f1 dc d1 08 	bfins	r8,r12,0x8,0x8
800026ea:	8f f8       	st.w	r7[0x3c],r8
 * \param chip_select Chip Select.
 */
static inline void spi_enable_active_mode(volatile avr32_spi_t *spi,
		uint8_t chip_select)
{
	switch (chip_select) {
800026ec:	0d 88       	ld.ub	r8,r6[0x0]
800026ee:	30 19       	mov	r9,1
800026f0:	f2 08 18 00 	cp.b	r8,r9
800026f4:	c1 10       	breq	80002716 <spi_master_setup_device+0x292>
800026f6:	c0 a3       	brcs	8000270a <spi_master_setup_device+0x286>
800026f8:	30 29       	mov	r9,2
800026fa:	f2 08 18 00 	cp.b	r8,r9
800026fe:	c1 20       	breq	80002722 <spi_master_setup_device+0x29e>
80002700:	30 39       	mov	r9,3
80002702:	f2 08 18 00 	cp.b	r8,r9
80002706:	c1 91       	brne	80002738 <spi_master_setup_device+0x2b4>
80002708:	c1 38       	rjmp	8000272e <spi_master_setup_device+0x2aa>
	case 0:
		spi->CSR0.csaat = 1;
8000270a:	6e c8       	ld.w	r8,r7[0x30]
8000270c:	30 19       	mov	r9,1
8000270e:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
80002712:	8f c8       	st.w	r7[0x30],r8
80002714:	c1 28       	rjmp	80002738 <spi_master_setup_device+0x2b4>
		break;

	case 1:
		spi->CSR1.csaat  = 1;
80002716:	6e d8       	ld.w	r8,r7[0x34]
80002718:	30 19       	mov	r9,1
8000271a:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
8000271e:	8f d8       	st.w	r7[0x34],r8
80002720:	c0 c8       	rjmp	80002738 <spi_master_setup_device+0x2b4>
		break;

	case 2:
		spi->CSR2.csaat  = 1;
80002722:	6e e8       	ld.w	r8,r7[0x38]
80002724:	30 19       	mov	r9,1
80002726:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
8000272a:	8f e8       	st.w	r7[0x38],r8
8000272c:	c0 68       	rjmp	80002738 <spi_master_setup_device+0x2b4>
		break;

	case 3:
		spi->CSR3.csaat  = 1;
8000272e:	6e f8       	ld.w	r8,r7[0x3c]
80002730:	30 19       	mov	r9,1
80002732:	f1 d9 d0 61 	bfins	r8,r9,0x3,0x1
80002736:	8f f8       	st.w	r7[0x3c],r8
			getBaudDiv(baud_rate, sysclk_get_peripheral_bus_hz(spi)));
	spi_enable_active_mode(spi,device->id);
	spi_set_mode(spi,device->id,flags);
80002738:	0a 99       	mov	r9,r5
 * \param flags       SPI Mode.
 */
static inline void spi_set_mode(volatile avr32_spi_t *spi, uint8_t chip_select,
		uint8_t flags)
{
	switch (chip_select) {
8000273a:	0d 88       	ld.ub	r8,r6[0x0]
8000273c:	30 1a       	mov	r10,1
8000273e:	f4 08 18 00 	cp.b	r8,r10
80002742:	c1 80       	breq	80002772 <spi_master_setup_device+0x2ee>
80002744:	c0 a3       	brcs	80002758 <spi_master_setup_device+0x2d4>
80002746:	30 2a       	mov	r10,2
80002748:	f4 08 18 00 	cp.b	r8,r10
8000274c:	c2 00       	breq	8000278c <spi_master_setup_device+0x308>
8000274e:	30 3a       	mov	r10,3
80002750:	f4 08 18 00 	cp.b	r8,r10
80002754:	c3 51       	brne	800027be <spi_master_setup_device+0x33a>
80002756:	c2 88       	rjmp	800027a6 <spi_master_setup_device+0x322>
	case 0:
		spi->CSR0.cpol = flags >> 1;
80002758:	eb d5 c0 21 	bfextu	r5,r5,0x1,0x1
8000275c:	6e c8       	ld.w	r8,r7[0x30]
8000275e:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
80002762:	8f c8       	st.w	r7[0x30],r8
		spi->CSR0.ncpha = (flags & 0x1) ^ 0x1;
80002764:	ec 19 00 01 	eorl	r9,0x1
80002768:	6e c8       	ld.w	r8,r7[0x30]
8000276a:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
8000276e:	8f c8       	st.w	r7[0x30],r8
80002770:	c2 78       	rjmp	800027be <spi_master_setup_device+0x33a>
		break;

	case 1:
		spi->CSR1.cpol  = flags >> 1;
80002772:	eb d5 c0 21 	bfextu	r5,r5,0x1,0x1
80002776:	6e d8       	ld.w	r8,r7[0x34]
80002778:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
8000277c:	8f d8       	st.w	r7[0x34],r8
		spi->CSR1.ncpha = (flags & 0x1) ^ 0x1;
8000277e:	ec 19 00 01 	eorl	r9,0x1
80002782:	6e d8       	ld.w	r8,r7[0x34]
80002784:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
80002788:	8f d8       	st.w	r7[0x34],r8
8000278a:	c1 a8       	rjmp	800027be <spi_master_setup_device+0x33a>
		break;

	case 2:
		spi->CSR2.cpol  = flags >> 1;
8000278c:	eb d5 c0 21 	bfextu	r5,r5,0x1,0x1
80002790:	6e e8       	ld.w	r8,r7[0x38]
80002792:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
80002796:	8f e8       	st.w	r7[0x38],r8
		spi->CSR2.ncpha = (flags & 0x1) ^ 0x1;
80002798:	ec 19 00 01 	eorl	r9,0x1
8000279c:	6e e8       	ld.w	r8,r7[0x38]
8000279e:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800027a2:	8f e8       	st.w	r7[0x38],r8
800027a4:	c0 d8       	rjmp	800027be <spi_master_setup_device+0x33a>
		break;

	case 3:
		spi->CSR3.cpol  = flags >> 1;
800027a6:	eb d5 c0 21 	bfextu	r5,r5,0x1,0x1
800027aa:	6e f8       	ld.w	r8,r7[0x3c]
800027ac:	f1 d5 d0 01 	bfins	r8,r5,0x0,0x1
800027b0:	8f f8       	st.w	r7[0x3c],r8
		spi->CSR3.ncpha = (flags & 0x1) ^ 0x1;
800027b2:	ec 19 00 01 	eorl	r9,0x1
800027b6:	6e f8       	ld.w	r8,r7[0x3c]
800027b8:	f1 d9 d0 21 	bfins	r8,r9,0x1,0x1
800027bc:	8f f8       	st.w	r7[0x3c],r8

#ifdef FREERTOS_USED
	if (!xSPIMutex) {
800027be:	48 e8       	lddpc	r8,800027f4 <spi_master_setup_device+0x370>
800027c0:	70 08       	ld.w	r8,r8[0x0]
800027c2:	58 08       	cp.w	r8,0
800027c4:	c1 41       	brne	800027ec <spi_master_setup_device+0x368>
		// Create the SPI mutex.
		vSemaphoreCreateBinary(xSPIMutex);
800027c6:	30 0a       	mov	r10,0
800027c8:	14 9b       	mov	r11,r10
800027ca:	30 1c       	mov	r12,1
800027cc:	f0 1f 00 0b 	mcall	800027f8 <spi_master_setup_device+0x374>
800027d0:	48 98       	lddpc	r8,800027f4 <spi_master_setup_device+0x370>
800027d2:	91 0c       	st.w	r8[0x0],r12
800027d4:	58 0c       	cp.w	r12,0
800027d6:	c0 a0       	breq	800027ea <spi_master_setup_device+0x366>
800027d8:	30 09       	mov	r9,0
800027da:	12 9a       	mov	r10,r9
800027dc:	12 9b       	mov	r11,r9
800027de:	f0 1f 00 08 	mcall	800027fc <spi_master_setup_device+0x378>
		if (!xSPIMutex) {
800027e2:	48 58       	lddpc	r8,800027f4 <spi_master_setup_device+0x370>
800027e4:	70 08       	ld.w	r8,r8[0x0]
800027e6:	58 08       	cp.w	r8,0
800027e8:	c0 21       	brne	800027ec <spi_master_setup_device+0x368>
800027ea:	c0 08       	rjmp	800027ea <spi_master_setup_device+0x366>
800027ec:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800027f0:	80 00       	ld.sh	r0,r0[0x0]
800027f2:	20 04       	sub	r4,0
800027f4:	00 00       	add	r0,r0
800027f6:	cf 50       	breq	800027e0 <spi_master_setup_device+0x35c>
800027f8:	80 00       	ld.sh	r0,r0[0x0]
800027fa:	30 04       	mov	r4,0
800027fc:	80 00       	ld.sh	r0,r0[0x0]
800027fe:	2e 88       	sub	r8,-24

80002800 <ecu_can_send_slip_current>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_slip_current(int16_t val1, int16_t val2) {
80002800:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_slip_current.can_msg->data.u64		= 0x0LL;
80002804:	48 de       	lddpc	lr,80002838 <ecu_can_send_slip_current+0x38>
80002806:	7c 18       	ld.w	r8,lr[0x4]
80002808:	30 06       	mov	r6,0
8000280a:	30 07       	mov	r7,0
8000280c:	f0 e7 00 08 	st.d	r8[8],r6
	mob_slip_current.can_msg->data.s16[0]	= val1;
80002810:	7c 18       	ld.w	r8,lr[0x4]
80002812:	b0 4c       	st.h	r8[0x8],r12
	mob_slip_current.can_msg->data.s16[1]	= val2;
80002814:	7c 18       	ld.w	r8,lr[0x4]
80002816:	b0 5b       	st.h	r8[0xa],r11
	
	mob_slip_current.can_msg->id = (CANR_FCN_DATA_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID7_ID);
80002818:	7c 18       	ld.w	r8,lr[0x4]
8000281a:	e0 69 06 37 	mov	r9,1591
8000281e:	91 09       	st.w	r8[0x0],r9
	mob_slip_current.dlc = 4;
80002820:	30 48       	mov	r8,4
80002822:	fd 68 00 08 	st.b	lr[8],r8
	
	can_tx(CAN_BUS_0,
80002826:	7c 18       	ld.w	r8,lr[0x4]
80002828:	30 09       	mov	r9,0
8000282a:	30 4a       	mov	r10,4
8000282c:	1d 8b       	ld.ub	r11,lr[0x0]
8000282e:	12 9c       	mov	r12,r9
80002830:	f0 1f 00 03 	mcall	8000283c <ecu_can_send_slip_current+0x3c>
	mob_slip_current.handle,
	mob_slip_current.dlc,
	CAN_DATA_FRAME,
	mob_slip_current.can_msg);
}
80002834:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002838:	00 00       	add	r0,r0
8000283a:	00 e8       	st.h	--r0,r8
8000283c:	80 00       	ld.sh	r0,r0[0x0]
8000283e:	4b 04       	lddpc	r4,800028fc <ecu_can_send_alive+0x3c>

80002840 <ecu_can_send_launch_stop>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_launch_stop(void) {
80002840:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	= 0x0LL;
80002844:	48 db       	lddpc	r11,80002878 <ecu_can_send_launch_stop+0x38>
80002846:	76 18       	ld.w	r8,r11[0x4]
80002848:	30 06       	mov	r6,0
8000284a:	30 07       	mov	r7,0
8000284c:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u8[0]	= 255;
80002850:	76 18       	ld.w	r8,r11[0x4]
80002852:	3f f9       	mov	r9,-1
80002854:	f1 69 00 08 	st.b	r8[8],r9
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID1_ID;
80002858:	76 18       	ld.w	r8,r11[0x4]
8000285a:	e0 69 02 31 	mov	r9,561
8000285e:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 1;
80002860:	30 18       	mov	r8,1
80002862:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
80002866:	76 18       	ld.w	r8,r11[0x4]
80002868:	30 09       	mov	r9,0
8000286a:	30 1a       	mov	r10,1
8000286c:	17 8b       	ld.ub	r11,r11[0x0]
8000286e:	12 9c       	mov	r12,r9
80002870:	f0 1f 00 03 	mcall	8000287c <ecu_can_send_launch_stop+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
80002874:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002878:	00 00       	add	r0,r0
8000287a:	00 a0       	st.w	r0++,r0
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	4b 04       	lddpc	r4,8000293c <ecu_can_send_drive_disabled+0x1c>

80002880 <ecu_can_send_launch_ready>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_launch_ready(void) {
80002880:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	= 0x0LL;
80002884:	48 db       	lddpc	r11,800028b8 <ecu_can_send_launch_ready+0x38>
80002886:	76 18       	ld.w	r8,r11[0x4]
80002888:	30 06       	mov	r6,0
8000288a:	30 07       	mov	r7,0
8000288c:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u8[0]	= 0x2;
80002890:	76 18       	ld.w	r8,r11[0x4]
80002892:	30 29       	mov	r9,2
80002894:	f1 69 00 08 	st.b	r8[8],r9
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID1_ID;
80002898:	76 18       	ld.w	r8,r11[0x4]
8000289a:	e0 69 02 31 	mov	r9,561
8000289e:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 1;
800028a0:	30 18       	mov	r8,1
800028a2:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
800028a6:	76 18       	ld.w	r8,r11[0x4]
800028a8:	30 09       	mov	r9,0
800028aa:	30 1a       	mov	r10,1
800028ac:	17 8b       	ld.ub	r11,r11[0x0]
800028ae:	12 9c       	mov	r12,r9
800028b0:	f0 1f 00 03 	mcall	800028bc <ecu_can_send_launch_ready+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
800028b4:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800028b8:	00 00       	add	r0,r0
800028ba:	00 a0       	st.w	r0++,r0
800028bc:	80 00       	ld.sh	r0,r0[0x0]
800028be:	4b 04       	lddpc	r4,8000297c <ecu_can_send_ready_to_drive+0x1c>

800028c0 <ecu_can_send_alive>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_alive(uint8_t error) {
800028c0:	d4 01       	pushm	lr
	mob_tx_dash.can_msg->data.u64	 = 0x0LL;
800028c2:	49 68       	lddpc	r8,80002918 <ecu_can_send_alive+0x58>
800028c4:	70 19       	ld.w	r9,r8[0x4]
800028c6:	30 0a       	mov	r10,0
800028c8:	30 0b       	mov	r11,0
800028ca:	f2 eb 00 08 	st.d	r9[8],r10
	mob_tx_dash.can_msg->data.u8[0]  = CANR_CMD_ALIVE;
800028ce:	70 19       	ld.w	r9,r8[0x4]
800028d0:	30 9a       	mov	r10,9
800028d2:	f3 6a 00 08 	st.b	r9[8],r10
	mob_tx_dash.can_msg->data.u8[1]  = DASH_ALIVE_ECU;
800028d6:	70 18       	ld.w	r8,r8[0x4]
800028d8:	30 09       	mov	r9,0
800028da:	f1 69 00 09 	st.b	r8[9],r9
	if (error == 0) {
800028de:	58 0c       	cp.w	r12,0
800028e0:	c0 71       	brne	800028ee <ecu_can_send_alive+0x2e>
		mob_tx_dash.can_msg->data.u8[2]  = CANR_ALIVE_STATE_OPERATIVE;
800028e2:	48 e8       	lddpc	r8,80002918 <ecu_can_send_alive+0x58>
800028e4:	70 18       	ld.w	r8,r8[0x4]
800028e6:	30 19       	mov	r9,1
800028e8:	f1 69 00 0a 	st.b	r8[10],r9
800028ec:	c0 68       	rjmp	800028f8 <ecu_can_send_alive+0x38>
		} else {
		mob_tx_dash.can_msg->data.u8[2]  = CANR_ALIVE_STATE_ERROR;
800028ee:	48 b8       	lddpc	r8,80002918 <ecu_can_send_alive+0x58>
800028f0:	70 18       	ld.w	r8,r8[0x4]
800028f2:	30 09       	mov	r9,0
800028f4:	f1 69 00 0a 	st.b	r8[10],r9
	}
	
	mob_tx_dash.can_msg->id = CANR_FCN_DATA_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID7_ID;
800028f8:	48 8b       	lddpc	r11,80002918 <ecu_can_send_alive+0x58>
800028fa:	76 18       	ld.w	r8,r11[0x4]
800028fc:	e0 69 06 67 	mov	r9,1639
80002900:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 3;
80002902:	30 38       	mov	r8,3
80002904:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
80002908:	76 18       	ld.w	r8,r11[0x4]
8000290a:	30 09       	mov	r9,0
8000290c:	30 3a       	mov	r10,3
8000290e:	17 8b       	ld.ub	r11,r11[0x0]
80002910:	12 9c       	mov	r12,r9
80002912:	f0 1f 00 03 	mcall	8000291c <ecu_can_send_alive+0x5c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
80002916:	d8 02       	popm	pc
80002918:	00 00       	add	r0,r0
8000291a:	00 a0       	st.w	r0++,r0
8000291c:	80 00       	ld.sh	r0,r0[0x0]
8000291e:	4b 04       	lddpc	r4,800029dc <ecu_can_send_tractive_system_active>

80002920 <ecu_can_send_drive_disabled>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_drive_disabled(void) {
80002920:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	 = 0x0LL;
80002924:	48 db       	lddpc	r11,80002958 <ecu_can_send_drive_disabled+0x38>
80002926:	76 18       	ld.w	r8,r11[0x4]
80002928:	30 06       	mov	r6,0
8000292a:	30 07       	mov	r7,0
8000292c:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u16[0]  = 0x4;
80002930:	76 18       	ld.w	r8,r11[0x4]
80002932:	30 49       	mov	r9,4
80002934:	b0 49       	st.h	r8[0x8],r9
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID0_ID;
80002936:	76 18       	ld.w	r8,r11[0x4]
80002938:	e0 69 02 30 	mov	r9,560
8000293c:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 2;
8000293e:	30 28       	mov	r8,2
80002940:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
80002944:	76 18       	ld.w	r8,r11[0x4]
80002946:	30 09       	mov	r9,0
80002948:	30 2a       	mov	r10,2
8000294a:	17 8b       	ld.ub	r11,r11[0x0]
8000294c:	12 9c       	mov	r12,r9
8000294e:	f0 1f 00 04 	mcall	8000295c <ecu_can_send_drive_disabled+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
80002952:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002956:	00 00       	add	r0,r0
80002958:	00 00       	add	r0,r0
8000295a:	00 a0       	st.w	r0++,r0
8000295c:	80 00       	ld.sh	r0,r0[0x0]
8000295e:	4b 04       	lddpc	r4,80002a1c <ecu_can_send_slow_data>

80002960 <ecu_can_send_ready_to_drive>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_ready_to_drive(void) {
80002960:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	 = 0x0LL;
80002964:	48 db       	lddpc	r11,80002998 <ecu_can_send_ready_to_drive+0x38>
80002966:	76 18       	ld.w	r8,r11[0x4]
80002968:	30 06       	mov	r6,0
8000296a:	30 07       	mov	r7,0
8000296c:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u16[0]  = 0x3;
80002970:	76 18       	ld.w	r8,r11[0x4]
80002972:	30 39       	mov	r9,3
80002974:	b0 49       	st.h	r8[0x8],r9
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID0_ID;
80002976:	76 18       	ld.w	r8,r11[0x4]
80002978:	e0 69 02 30 	mov	r9,560
8000297c:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 2;
8000297e:	30 28       	mov	r8,2
80002980:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
80002984:	76 18       	ld.w	r8,r11[0x4]
80002986:	30 09       	mov	r9,0
80002988:	30 2a       	mov	r10,2
8000298a:	17 8b       	ld.ub	r11,r11[0x0]
8000298c:	12 9c       	mov	r12,r9
8000298e:	f0 1f 00 04 	mcall	8000299c <ecu_can_send_ready_to_drive+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
80002992:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002996:	00 00       	add	r0,r0
80002998:	00 00       	add	r0,r0
8000299a:	00 a0       	st.w	r0++,r0
8000299c:	80 00       	ld.sh	r0,r0[0x0]
8000299e:	4b 04       	lddpc	r4,80002a5c <ecu_can_send_fast_data+0x4>

800029a0 <ecu_can_send_play_rtds>:
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}

void ecu_can_send_play_rtds(void) {
800029a0:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	 = 0x0LL;
800029a4:	48 cb       	lddpc	r11,800029d4 <ecu_can_send_play_rtds+0x34>
800029a6:	76 18       	ld.w	r8,r11[0x4]
800029a8:	30 06       	mov	r6,0
800029aa:	30 07       	mov	r7,0
800029ac:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u16[0]  = 0x2;
800029b0:	76 19       	ld.w	r9,r11[0x4]
800029b2:	30 28       	mov	r8,2
800029b4:	b2 48       	st.h	r9[0x8],r8
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID0_ID;
800029b6:	76 19       	ld.w	r9,r11[0x4]
800029b8:	e0 6a 02 30 	mov	r10,560
800029bc:	93 0a       	st.w	r9[0x0],r10
	mob_tx_dash.dlc = 2;
800029be:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
800029c2:	76 18       	ld.w	r8,r11[0x4]
800029c4:	30 09       	mov	r9,0
800029c6:	30 2a       	mov	r10,2
800029c8:	17 8b       	ld.ub	r11,r11[0x0]
800029ca:	12 9c       	mov	r12,r9
800029cc:	f0 1f 00 03 	mcall	800029d8 <ecu_can_send_play_rtds+0x38>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
800029d0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800029d4:	00 00       	add	r0,r0
800029d6:	00 a0       	st.w	r0++,r0
800029d8:	80 00       	ld.sh	r0,r0[0x0]
800029da:	4b 04       	lddpc	r4,80002a98 <ecu_can_inverter_read_reg+0x4>

800029dc <ecu_can_send_tractive_system_active>:
	// 	mob_tx_inverter.dlc,
	// 	CAN_DATA_FRAME,
	// 	mob_tx_inverter.can_msg);
}

void ecu_can_send_tractive_system_active(void) {
800029dc:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_tx_dash.can_msg->data.u64	 = 0x0LL;
800029e0:	48 db       	lddpc	r11,80002a14 <ecu_can_send_tractive_system_active+0x38>
800029e2:	76 18       	ld.w	r8,r11[0x4]
800029e4:	30 06       	mov	r6,0
800029e6:	30 07       	mov	r7,0
800029e8:	f0 e7 00 08 	st.d	r8[8],r6
	mob_tx_dash.can_msg->data.u16[0]  = 0x1;
800029ec:	76 18       	ld.w	r8,r11[0x4]
800029ee:	30 19       	mov	r9,1
800029f0:	b0 49       	st.h	r8[0x8],r9
	
	mob_tx_dash.can_msg->id = CANR_FCN_PRI_ID | CANR_GRP_ECU_ID | CANR_MODULE_ID0_ID;
800029f2:	76 18       	ld.w	r8,r11[0x4]
800029f4:	e0 69 02 30 	mov	r9,560
800029f8:	91 09       	st.w	r8[0x0],r9
	mob_tx_dash.dlc = 2;
800029fa:	30 28       	mov	r8,2
800029fc:	f7 68 00 08 	st.b	r11[8],r8
	
	can_tx(CAN_BUS_0,
80002a00:	76 18       	ld.w	r8,r11[0x4]
80002a02:	30 09       	mov	r9,0
80002a04:	30 2a       	mov	r10,2
80002a06:	17 8b       	ld.ub	r11,r11[0x0]
80002a08:	12 9c       	mov	r12,r9
80002a0a:	f0 1f 00 04 	mcall	80002a18 <ecu_can_send_tractive_system_active+0x3c>
	mob_tx_dash.handle,
	mob_tx_dash.dlc,
	CAN_DATA_FRAME,
	mob_tx_dash.can_msg);
}
80002a0e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a12:	00 00       	add	r0,r0
80002a14:	00 00       	add	r0,r0
80002a16:	00 a0       	st.w	r0++,r0
80002a18:	80 00       	ld.sh	r0,r0[0x0]
80002a1a:	4b 04       	lddpc	r4,80002ad8 <ecu_can_inverter_torque_cmd+0x10>

80002a1c <ecu_can_send_slow_data>:
	mob_ecu_fast_data.dlc,
	CAN_DATA_FRAME,
	mob_ecu_fast_data.can_msg);
}

void ecu_can_send_slow_data(uint16_t motor_temp, uint16_t inverter_temp, uint8_t max_trq) {
80002a1c:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_ecu_slow_data.can_msg->data.u64	 = 0x0LL;
80002a20:	48 ce       	lddpc	lr,80002a50 <ecu_can_send_slow_data+0x34>
80002a22:	7c 18       	ld.w	r8,lr[0x4]
80002a24:	30 06       	mov	r6,0
80002a26:	30 07       	mov	r7,0
80002a28:	f0 e7 00 08 	st.d	r8[8],r6
	mob_ecu_slow_data.can_msg->data.u16[0] = motor_temp;
80002a2c:	7c 18       	ld.w	r8,lr[0x4]
80002a2e:	b0 4c       	st.h	r8[0x8],r12
	mob_ecu_slow_data.can_msg->data.u16[1] = inverter_temp;
80002a30:	7c 18       	ld.w	r8,lr[0x4]
80002a32:	b0 5b       	st.h	r8[0xa],r11
	mob_ecu_slow_data.can_msg->data.u8[4] = max_trq;
80002a34:	7c 18       	ld.w	r8,lr[0x4]
80002a36:	f1 6a 00 0c 	st.b	r8[12],r10
	
	can_tx(CAN_BUS_1,
80002a3a:	7c 18       	ld.w	r8,lr[0x4]
80002a3c:	30 09       	mov	r9,0
80002a3e:	fd 3a 00 08 	ld.ub	r10,lr[8]
80002a42:	1d 8b       	ld.ub	r11,lr[0x0]
80002a44:	30 1c       	mov	r12,1
80002a46:	f0 1f 00 04 	mcall	80002a54 <ecu_can_send_slow_data+0x38>
	mob_ecu_slow_data.handle,
	mob_ecu_slow_data.dlc,
	CAN_DATA_FRAME,
	mob_ecu_slow_data.can_msg);
}
80002a4a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a4e:	00 00       	add	r0,r0
80002a50:	00 00       	add	r0,r0
80002a52:	01 40       	ld.w	r0,--r0
80002a54:	80 00       	ld.sh	r0,r0[0x0]
80002a56:	4b 04       	lddpc	r4,80002b14 <ecu_can_send_to_inverter+0x10>

80002a58 <ecu_can_send_fast_data>:
	mob_tx_bms.dlc,
	CAN_DATA_FRAME,
	mob_tx_bms.can_msg);
}

void ecu_can_send_fast_data(uint16_t inverter_vdc, uint16_t ecu_error, uint16_t rpm, int16_t trq_cmd) {
80002a58:	eb cd 40 c0 	pushm	r6-r7,lr
	mob_ecu_fast_data.can_msg->data.u64	  = 0x0LL;
80002a5c:	48 ce       	lddpc	lr,80002a8c <ecu_can_send_fast_data+0x34>
80002a5e:	7c 18       	ld.w	r8,lr[0x4]
80002a60:	30 06       	mov	r6,0
80002a62:	30 07       	mov	r7,0
80002a64:	f0 e7 00 08 	st.d	r8[8],r6
	mob_ecu_fast_data.can_msg->data.u16[0] = inverter_vdc;
80002a68:	7c 18       	ld.w	r8,lr[0x4]
80002a6a:	b0 4c       	st.h	r8[0x8],r12
	mob_ecu_fast_data.can_msg->data.u16[1] = ecu_error;
80002a6c:	7c 18       	ld.w	r8,lr[0x4]
80002a6e:	b0 5b       	st.h	r8[0xa],r11
	mob_ecu_fast_data.can_msg->data.u16[2] = rpm;
80002a70:	7c 18       	ld.w	r8,lr[0x4]
80002a72:	b0 6a       	st.h	r8[0xc],r10
	mob_ecu_fast_data.can_msg->data.s16[3] = trq_cmd;
80002a74:	7c 18       	ld.w	r8,lr[0x4]
80002a76:	b0 79       	st.h	r8[0xe],r9
	
	can_tx(CAN_BUS_0,
80002a78:	7c 18       	ld.w	r8,lr[0x4]
80002a7a:	30 09       	mov	r9,0
80002a7c:	fd 3a 00 08 	ld.ub	r10,lr[8]
80002a80:	1d 8b       	ld.ub	r11,lr[0x0]
80002a82:	12 9c       	mov	r12,r9
80002a84:	f0 1f 00 03 	mcall	80002a90 <ecu_can_send_fast_data+0x38>
	mob_ecu_fast_data.handle,
	mob_ecu_fast_data.dlc,
	CAN_DATA_FRAME,
	mob_ecu_fast_data.can_msg);
}
80002a88:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002a8c:	00 00       	add	r0,r0
80002a8e:	00 64       	and	r4,r0
80002a90:	80 00       	ld.sh	r0,r0[0x0]
80002a92:	4b 04       	lddpc	r4,80002b50 <ecu_can_inverter_enable_drive+0x4>

80002a94 <ecu_can_inverter_read_reg>:

void ecu_can_inverter_read_torque_periodic() {
	ecu_can_send_to_inverter(READ_CMD, 0x90FA); //FA = 250 ms period
}

void ecu_can_inverter_read_reg(uint8_t inverter_reg) {
80002a94:	d4 01       	pushm	lr
80002a96:	20 3d       	sub	sp,12
	/* Msg = 0x3D inverter_reg 00, ex: 0x3DE800 (read FRG_RUN) */
	
	inverter_can_msg_t message;
	
	message.data.u64 = 0x0LL;
80002a98:	30 08       	mov	r8,0
80002a9a:	30 09       	mov	r9,0
80002a9c:	fa e9 00 00 	st.d	sp[0],r8
	message.data.u32[0] = READ_CMD << 24 | inverter_reg << 16;
80002aa0:	b1 6c       	lsl	r12,0x10
80002aa2:	ea 1c 3d 00 	orh	r12,0x3d00
80002aa6:	50 0c       	stdsp	sp[0x0],r12
	message.dlc = INVERTER_DLC_3;
80002aa8:	30 38       	mov	r8,3
80002aaa:	50 28       	stdsp	sp[0x8],r8
	
	xQueueSendToBack(queue_to_inverter,&message,0);
80002aac:	30 09       	mov	r9,0
80002aae:	12 9a       	mov	r10,r9
80002ab0:	1a 9b       	mov	r11,sp
80002ab2:	48 48       	lddpc	r8,80002ac0 <ecu_can_inverter_read_reg+0x2c>
80002ab4:	70 0c       	ld.w	r12,r8[0x0]
80002ab6:	f0 1f 00 04 	mcall	80002ac4 <ecu_can_inverter_read_reg+0x30>
}
80002aba:	2f dd       	sub	sp,-12
80002abc:	d8 02       	popm	pc
80002abe:	00 00       	add	r0,r0
80002ac0:	00 00       	add	r0,r0
80002ac2:	cf 64       	brge	80002aae <ecu_can_inverter_read_reg+0x1a>
80002ac4:	80 00       	ld.sh	r0,r0[0x0]
80002ac6:	2e 88       	sub	r8,-24

80002ac8 <ecu_can_inverter_torque_cmd>:
	message.dlc = INVERTER_DLC_3;
	message.data.u32[0] = inverter_reg << 24 | data << 8;
	xQueueSendToBack(queue_to_inverter,&message,0);
}

void ecu_can_inverter_torque_cmd(int16_t torque) {
80002ac8:	d4 01       	pushm	lr
80002aca:	20 3d       	sub	sp,12
	/* This code also handles negative numbers */
	uint16_t torque_intel = ((torque >> 8) & 0xff) | ((torque & 0xff) << 8);
	
	inverter_can_msg_t message;
	
	message.data.u64 = 0x0LL;
80002acc:	30 08       	mov	r8,0
80002ace:	30 09       	mov	r9,0
80002ad0:	fa e9 00 00 	st.d	sp[0],r8
	message.dlc = INVERTER_DLC_3;
80002ad4:	30 38       	mov	r8,3
80002ad6:	50 28       	stdsp	sp[0x8],r8
	message.data.u32[0] = TORQUE_CMD << 24 | torque_intel << 8;
80002ad8:	f1 dc c1 08 	bfextu	r8,r12,0x8,0x8
80002adc:	f1 ec 10 88 	or	r8,r8,r12<<0x8
80002ae0:	5c 78       	castu.h	r8
80002ae2:	a9 68       	lsl	r8,0x8
80002ae4:	ea 18 90 00 	orh	r8,0x9000
80002ae8:	50 08       	stdsp	sp[0x0],r8
	
	xQueueSendToBack(queue_to_inverter,&message,0);
80002aea:	30 09       	mov	r9,0
80002aec:	12 9a       	mov	r10,r9
80002aee:	1a 9b       	mov	r11,sp
80002af0:	48 38       	lddpc	r8,80002afc <ecu_can_inverter_torque_cmd+0x34>
80002af2:	70 0c       	ld.w	r12,r8[0x0]
80002af4:	f0 1f 00 03 	mcall	80002b00 <ecu_can_inverter_torque_cmd+0x38>
}
80002af8:	2f dd       	sub	sp,-12
80002afa:	d8 02       	popm	pc
80002afc:	00 00       	add	r0,r0
80002afe:	cf 64       	brge	80002aea <ecu_can_inverter_torque_cmd+0x22>
80002b00:	80 00       	ld.sh	r0,r0[0x0]
80002b02:	2e 88       	sub	r8,-24

80002b04 <ecu_can_send_to_inverter>:
#include "ecu_can.h"
#include "ecu_can_mob.h"
#include "ecu_can_messages.h"


void ecu_can_send_to_inverter(uint8_t inverter_reg, uint16_t data) {
80002b04:	d4 01       	pushm	lr
80002b06:	20 3d       	sub	sp,12
	inverter_can_msg_t message;
	
	message.data.u64 = 0x0LL;
80002b08:	30 08       	mov	r8,0
80002b0a:	30 09       	mov	r9,0
80002b0c:	fa e9 00 00 	st.d	sp[0],r8
	message.dlc = INVERTER_DLC_3;
80002b10:	30 38       	mov	r8,3
80002b12:	50 28       	stdsp	sp[0x8],r8
	message.data.u32[0] = inverter_reg << 24 | data << 8;
80002b14:	5c 7b       	castu.h	r11
80002b16:	b9 6c       	lsl	r12,0x18
80002b18:	f9 eb 10 8b 	or	r11,r12,r11<<0x8
80002b1c:	50 0b       	stdsp	sp[0x0],r11
	xQueueSendToBack(queue_to_inverter,&message,0);
80002b1e:	30 09       	mov	r9,0
80002b20:	12 9a       	mov	r10,r9
80002b22:	1a 9b       	mov	r11,sp
80002b24:	48 38       	lddpc	r8,80002b30 <ecu_can_send_to_inverter+0x2c>
80002b26:	70 0c       	ld.w	r12,r8[0x0]
80002b28:	f0 1f 00 03 	mcall	80002b34 <ecu_can_send_to_inverter+0x30>
}
80002b2c:	2f dd       	sub	sp,-12
80002b2e:	d8 02       	popm	pc
80002b30:	00 00       	add	r0,r0
80002b32:	cf 64       	brge	80002b1e <ecu_can_send_to_inverter+0x1a>
80002b34:	80 00       	ld.sh	r0,r0[0x0]
80002b36:	2e 88       	sub	r8,-24

80002b38 <ecu_can_inverter_disable_drive>:

void ecu_can_inverter_enable_drive() {
	ecu_can_send_to_inverter(MODE_REG, 0x0000);
}

void ecu_can_inverter_disable_drive() {
80002b38:	d4 01       	pushm	lr
	ecu_can_send_to_inverter(MODE_REG, 0x0400);
80002b3a:	e0 6b 04 00 	mov	r11,1024
80002b3e:	35 1c       	mov	r12,81
80002b40:	f0 1f 00 02 	mcall	80002b48 <ecu_can_inverter_disable_drive+0x10>
}
80002b44:	d8 02       	popm	pc
80002b46:	00 00       	add	r0,r0
80002b48:	80 00       	ld.sh	r0,r0[0x0]
80002b4a:	2b 04       	sub	r4,-80

80002b4c <ecu_can_inverter_enable_drive>:
	CAN_DATA_FRAME,
	mob_debug.can_msg);
}


void ecu_can_inverter_enable_drive() {
80002b4c:	d4 01       	pushm	lr
	ecu_can_send_to_inverter(MODE_REG, 0x0000);
80002b4e:	30 0b       	mov	r11,0
80002b50:	35 1c       	mov	r12,81
80002b52:	f0 1f 00 02 	mcall	80002b58 <ecu_can_inverter_enable_drive+0xc>
}
80002b56:	d8 02       	popm	pc
80002b58:	80 00       	ld.sh	r0,r0[0x0]
80002b5a:	2b 04       	sub	r4,-80

80002b5c <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
80002b5c:	5e fc       	retal	r12
80002b5e:	d7 03       	nop

80002b60 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80002b60:	eb cd 40 c0 	pushm	r6-r7,lr
80002b64:	18 97       	mov	r7,r12
void *pvReturn = NULL;
static unsigned char *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
80002b66:	f1 dc c0 02 	bfextu	r8,r12,0x0,0x2
80002b6a:	c0 40       	breq	80002b72 <pvPortMalloc+0x12>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
80002b6c:	e0 17 ff fc 	andl	r7,0xfffc
80002b70:	2f c7       	sub	r7,-4
		}
	#endif

	vTaskSuspendAll();
80002b72:	f0 1f 00 11 	mcall	80002bb4 <pvPortMalloc+0x54>
	{
		if( pucAlignedHeap == NULL )
80002b76:	49 18       	lddpc	r8,80002bb8 <pvPortMalloc+0x58>
80002b78:	70 08       	ld.w	r8,r8[0x0]
80002b7a:	58 08       	cp.w	r8,0
80002b7c:	c0 71       	brne	80002b8a <pvPortMalloc+0x2a>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
80002b7e:	49 09       	lddpc	r9,80002bbc <pvPortMalloc+0x5c>
80002b80:	2f c9       	sub	r9,-4
80002b82:	e0 19 ff fc 	andl	r9,0xfffc
80002b86:	48 d8       	lddpc	r8,80002bb8 <pvPortMalloc+0x58>
80002b88:	91 09       	st.w	r8[0x0],r9
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
80002b8a:	48 e8       	lddpc	r8,80002bc0 <pvPortMalloc+0x60>
80002b8c:	70 08       	ld.w	r8,r8[0x0]
80002b8e:	10 07       	add	r7,r8
80002b90:	e0 47 c7 fb 	cp.w	r7,51195
80002b94:	e0 8b 00 0a 	brhi	80002ba8 <pvPortMalloc+0x48>
80002b98:	0e 38       	cp.w	r8,r7
80002b9a:	c0 72       	brcc	80002ba8 <pvPortMalloc+0x48>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
80002b9c:	48 79       	lddpc	r9,80002bb8 <pvPortMalloc+0x58>
80002b9e:	72 06       	ld.w	r6,r9[0x0]
80002ba0:	10 06       	add	r6,r8
			xNextFreeByte += xWantedSize;
80002ba2:	48 88       	lddpc	r8,80002bc0 <pvPortMalloc+0x60>
80002ba4:	91 07       	st.w	r8[0x0],r7
80002ba6:	c0 28       	rjmp	80002baa <pvPortMalloc+0x4a>
80002ba8:	30 06       	mov	r6,0
		}

		traceMALLOC( pvReturn, xWantedSize );
	}	
	xTaskResumeAll();
80002baa:	f0 1f 00 07 	mcall	80002bc4 <pvPortMalloc+0x64>
		}
	}
	#endif

	return pvReturn;
}
80002bae:	0c 9c       	mov	r12,r6
80002bb0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002bb4:	80 00       	ld.sh	r0,r0[0x0]
80002bb6:	59 f8       	cp.w	r8,31
80002bb8:	00 00       	add	r0,r0
80002bba:	cc 04       	brge	80002b3a <ecu_can_inverter_disable_drive+0x2>
80002bbc:	00 00       	add	r0,r0
80002bbe:	04 04       	add	r4,r2
80002bc0:	00 00       	add	r0,r0
80002bc2:	04 00       	add	r0,r2
80002bc4:	80 00       	ld.sh	r0,r0[0x0]
80002bc6:	5c d0       	com	r0

80002bc8 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, void * const pvBuffer )
{
80002bc8:	d4 01       	pushm	lr
80002bca:	16 98       	mov	r8,r11
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
80002bcc:	78 09       	ld.w	r9,r12[0x0]
80002bce:	58 09       	cp.w	r9,0
80002bd0:	c1 10       	breq	80002bf2 <prvCopyDataFromQueue+0x2a>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
80002bd2:	78 3a       	ld.w	r10,r12[0xc]
80002bd4:	79 09       	ld.w	r9,r12[0x40]
80002bd6:	f4 09 00 09 	add	r9,r10,r9
80002bda:	99 39       	st.w	r12[0xc],r9
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
80002bdc:	78 1a       	ld.w	r10,r12[0x4]
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
80002bde:	14 39       	cp.w	r9,r10
80002be0:	f9 f9 20 00 	ld.wcc	r9,r12[0x0]
80002be4:	f9 f9 2a 03 	st.wcc	r12[0xc],r9
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
80002be8:	79 0a       	ld.w	r10,r12[0x40]
80002bea:	78 3b       	ld.w	r11,r12[0xc]
80002bec:	10 9c       	mov	r12,r8
80002bee:	f0 1f 00 02 	mcall	80002bf4 <prvCopyDataFromQueue+0x2c>
80002bf2:	d8 02       	popm	pc
80002bf4:	80 00       	ld.sh	r0,r0[0x0]
80002bf6:	7b 96       	ld.w	r6,sp[0x64]

80002bf8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
80002bf8:	eb cd 40 c0 	pushm	r6-r7,lr
80002bfc:	18 97       	mov	r7,r12
80002bfe:	14 96       	mov	r6,r10
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
80002c00:	79 0a       	ld.w	r10,r12[0x40]
80002c02:	58 0a       	cp.w	r10,0
80002c04:	c2 d0       	breq	80002c5e <prvCopyDataToQueue+0x66>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
80002c06:	58 06       	cp.w	r6,0
80002c08:	c0 f1       	brne	80002c26 <prvCopyDataToQueue+0x2e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
80002c0a:	78 2c       	ld.w	r12,r12[0x8]
80002c0c:	f0 1f 00 17 	mcall	80002c68 <prvCopyDataToQueue+0x70>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80002c10:	6e 29       	ld.w	r9,r7[0x8]
80002c12:	6f 08       	ld.w	r8,r7[0x40]
80002c14:	f2 08 00 08 	add	r8,r9,r8
80002c18:	8f 28       	st.w	r7[0x8],r8
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80002c1a:	6e 19       	ld.w	r9,r7[0x4]
80002c1c:	12 38       	cp.w	r8,r9
80002c1e:	c2 03       	brcs	80002c5e <prvCopyDataToQueue+0x66>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80002c20:	6e 08       	ld.w	r8,r7[0x0]
80002c22:	8f 28       	st.w	r7[0x8],r8
80002c24:	c1 d8       	rjmp	80002c5e <prvCopyDataToQueue+0x66>
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80002c26:	78 3c       	ld.w	r12,r12[0xc]
80002c28:	f0 1f 00 10 	mcall	80002c68 <prvCopyDataToQueue+0x70>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
80002c2c:	6f 08       	ld.w	r8,r7[0x40]
80002c2e:	6e 39       	ld.w	r9,r7[0xc]
80002c30:	f2 08 01 08 	sub	r8,r9,r8
80002c34:	8f 38       	st.w	r7[0xc],r8
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80002c36:	6e 09       	ld.w	r9,r7[0x0]
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80002c38:	12 38       	cp.w	r8,r9
80002c3a:	ef f8 30 10 	ld.wcs	r8,r7[0x40]
80002c3e:	ef f9 30 01 	ld.wcs	r9,r7[0x4]
80002c42:	f3 d8 e3 19 	subcs	r9,r9,r8
80002c46:	ef f9 3a 03 	st.wcs	r7[0xc],r9
		}

		if( xPosition == queueOVERWRITE )
80002c4a:	58 26       	cp.w	r6,2
80002c4c:	c0 91       	brne	80002c5e <prvCopyDataToQueue+0x66>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80002c4e:	6e e8       	ld.w	r8,r7[0x38]
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
80002c50:	58 08       	cp.w	r8,0
80002c52:	ef f8 10 0e 	ld.wne	r8,r7[0x38]
80002c56:	f7 b8 01 01 	subne	r8,1
80002c5a:	ef f8 1a 0e 	st.wne	r7[0x38],r8
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
80002c5e:	6e e8       	ld.w	r8,r7[0x38]
80002c60:	2f f8       	sub	r8,-1
80002c62:	8f e8       	st.w	r7[0x38],r8
}
80002c64:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002c68:	80 00       	ld.sh	r0,r0[0x0]
80002c6a:	7b 96       	ld.w	r6,sp[0x64]

80002c6c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
80002c6c:	eb cd 40 c0 	pushm	r6-r7,lr
80002c70:	14 96       	mov	r6,r10
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
80002c72:	18 97       	mov	r7,r12
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80002c74:	78 ea       	ld.w	r10,r12[0x38]
80002c76:	78 f8       	ld.w	r8,r12[0x3c]
80002c78:	10 3a       	cp.w	r10,r8
80002c7a:	c0 53       	brcs	80002c84 <xQueueGenericSendFromISR+0x18>
80002c7c:	58 29       	cp.w	r9,2
80002c7e:	c0 30       	breq	80002c84 <xQueueGenericSendFromISR+0x18>
80002c80:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80002c84:	12 9a       	mov	r10,r9
80002c86:	0e 9c       	mov	r12,r7
80002c88:	f0 1f 00 0e 	mcall	80002cc0 <xQueueGenericSendFromISR+0x54>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
80002c8c:	6f 28       	ld.w	r8,r7[0x48]
80002c8e:	5b f8       	cp.w	r8,-1
80002c90:	c0 f1       	brne	80002cae <xQueueGenericSendFromISR+0x42>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002c92:	6e 98       	ld.w	r8,r7[0x24]
80002c94:	58 08       	cp.w	r8,0
80002c96:	c1 20       	breq	80002cba <xQueueGenericSendFromISR+0x4e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002c98:	ee cc ff dc 	sub	r12,r7,-36
80002c9c:	f0 1f 00 0a 	mcall	80002cc4 <xQueueGenericSendFromISR+0x58>
80002ca0:	c0 d0       	breq	80002cba <xQueueGenericSendFromISR+0x4e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
80002ca2:	58 06       	cp.w	r6,0
80002ca4:	c0 b0       	breq	80002cba <xQueueGenericSendFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
80002ca6:	30 1c       	mov	r12,1
80002ca8:	8d 0c       	st.w	r6[0x0],r12
80002caa:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
80002cae:	6f 28       	ld.w	r8,r7[0x48]
80002cb0:	2f f8       	sub	r8,-1
80002cb2:	ef 48 00 48 	st.w	r7[72],r8
80002cb6:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80002cba:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80002cbe:	00 00       	add	r0,r0
80002cc0:	80 00       	ld.sh	r0,r0[0x0]
80002cc2:	2b f8       	sub	r8,-65
80002cc4:	80 00       	ld.sh	r0,r0[0x0]
80002cc6:	5b 3c       	cp.w	r12,-13

80002cc8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
80002cc8:	eb cd 40 c0 	pushm	r6-r7,lr
80002ccc:	18 97       	mov	r7,r12

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80002cce:	f0 1f 00 24 	mcall	80002d5c <prvUnlockQueue+0x94>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002cd2:	6f 28       	ld.w	r8,r7[0x48]
80002cd4:	58 08       	cp.w	r8,0
80002cd6:	e0 8a 00 19 	brle	80002d08 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002cda:	6e 98       	ld.w	r8,r7[0x24]
80002cdc:	58 08       	cp.w	r8,0
80002cde:	c1 50       	breq	80002d08 <prvUnlockQueue+0x40>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002ce0:	ee c6 ff dc 	sub	r6,r7,-36
80002ce4:	c0 48       	rjmp	80002cec <prvUnlockQueue+0x24>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002ce6:	6e 98       	ld.w	r8,r7[0x24]
80002ce8:	58 08       	cp.w	r8,0
80002cea:	c0 f0       	breq	80002d08 <prvUnlockQueue+0x40>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002cec:	0c 9c       	mov	r12,r6
80002cee:	f0 1f 00 1d 	mcall	80002d60 <prvUnlockQueue+0x98>
80002cf2:	c0 30       	breq	80002cf8 <prvUnlockQueue+0x30>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
80002cf4:	f0 1f 00 1c 	mcall	80002d64 <prvUnlockQueue+0x9c>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
80002cf8:	6f 28       	ld.w	r8,r7[0x48]
80002cfa:	20 18       	sub	r8,1
80002cfc:	ef 48 00 48 	st.w	r7[72],r8
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
80002d00:	6f 28       	ld.w	r8,r7[0x48]
80002d02:	58 08       	cp.w	r8,0
80002d04:	fe 99 ff f1 	brgt	80002ce6 <prvUnlockQueue+0x1e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
80002d08:	3f f8       	mov	r8,-1
80002d0a:	ef 48 00 48 	st.w	r7[72],r8
	}
	taskEXIT_CRITICAL();
80002d0e:	f0 1f 00 17 	mcall	80002d68 <prvUnlockQueue+0xa0>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80002d12:	f0 1f 00 13 	mcall	80002d5c <prvUnlockQueue+0x94>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002d16:	6f 18       	ld.w	r8,r7[0x44]
80002d18:	58 08       	cp.w	r8,0
80002d1a:	e0 8a 00 19 	brle	80002d4c <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002d1e:	6e 48       	ld.w	r8,r7[0x10]
80002d20:	58 08       	cp.w	r8,0
80002d22:	c1 50       	breq	80002d4c <prvUnlockQueue+0x84>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002d24:	ee c6 ff f0 	sub	r6,r7,-16
80002d28:	c0 48       	rjmp	80002d30 <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002d2a:	6e 48       	ld.w	r8,r7[0x10]
80002d2c:	58 08       	cp.w	r8,0
80002d2e:	c0 f0       	breq	80002d4c <prvUnlockQueue+0x84>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80002d30:	0c 9c       	mov	r12,r6
80002d32:	f0 1f 00 0c 	mcall	80002d60 <prvUnlockQueue+0x98>
80002d36:	c0 30       	breq	80002d3c <prvUnlockQueue+0x74>
				{
					vTaskMissedYield();
80002d38:	f0 1f 00 0b 	mcall	80002d64 <prvUnlockQueue+0x9c>
				}

				--( pxQueue->xRxLock );
80002d3c:	6f 18       	ld.w	r8,r7[0x44]
80002d3e:	20 18       	sub	r8,1
80002d40:	ef 48 00 44 	st.w	r7[68],r8
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
80002d44:	6f 18       	ld.w	r8,r7[0x44]
80002d46:	58 08       	cp.w	r8,0
80002d48:	fe 99 ff f1 	brgt	80002d2a <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
80002d4c:	3f f8       	mov	r8,-1
80002d4e:	ef 48 00 44 	st.w	r7[68],r8
	}
	taskEXIT_CRITICAL();
80002d52:	f0 1f 00 06 	mcall	80002d68 <prvUnlockQueue+0xa0>
}
80002d56:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80002d5a:	00 00       	add	r0,r0
80002d5c:	80 00       	ld.sh	r0,r0[0x0]
80002d5e:	58 48       	cp.w	r8,4
80002d60:	80 00       	ld.sh	r0,r0[0x0]
80002d62:	5b 3c       	cp.w	r12,-13
80002d64:	80 00       	ld.sh	r0,r0[0x0]
80002d66:	5a 9c       	cp.w	r12,-23
80002d68:	80 00       	ld.sh	r0,r0[0x0]
80002d6a:	59 54       	cp.w	r4,21

80002d6c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
80002d6c:	d4 31       	pushm	r0-r7,lr
80002d6e:	20 5d       	sub	sp,20
80002d70:	50 0b       	stdsp	sp[0x0],r11
80002d72:	50 2a       	stdsp	sp[0x8],r10
80002d74:	50 19       	stdsp	sp[0x4],r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
80002d76:	18 97       	mov	r7,r12
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002d78:	f8 c1 ff dc 	sub	r1,r12,-36
80002d7c:	30 05       	mov	r5,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002d7e:	fa c4 ff f4 	sub	r4,sp,-12
80002d82:	30 10       	mov	r0,1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80002d84:	0a 92       	mov	r2,r5

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002d86:	fa c3 ff f8 	sub	r3,sp,-8
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80002d8a:	f0 1f 00 36 	mcall	80002e60 <xQueueGenericReceive+0xf4>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
80002d8e:	6e e8       	ld.w	r8,r7[0x38]
80002d90:	58 08       	cp.w	r8,0
80002d92:	c2 40       	breq	80002dda <xQueueGenericReceive+0x6e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
80002d94:	6e 36       	ld.w	r6,r7[0xc]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80002d96:	40 0b       	lddsp	r11,sp[0x0]
80002d98:	0e 9c       	mov	r12,r7
80002d9a:	f0 1f 00 33 	mcall	80002e64 <xQueueGenericReceive+0xf8>

				if( xJustPeeking == pdFALSE )
80002d9e:	40 18       	lddsp	r8,sp[0x4]
80002da0:	58 08       	cp.w	r8,0
80002da2:	c0 f1       	brne	80002dc0 <xQueueGenericReceive+0x54>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
80002da4:	6e e8       	ld.w	r8,r7[0x38]
80002da6:	20 18       	sub	r8,1
80002da8:	8f e8       	st.w	r7[0x38],r8
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002daa:	6e 48       	ld.w	r8,r7[0x10]
80002dac:	58 08       	cp.w	r8,0
80002dae:	c1 20       	breq	80002dd2 <xQueueGenericReceive+0x66>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80002db0:	ee cc ff f0 	sub	r12,r7,-16
80002db4:	f0 1f 00 2d 	mcall	80002e68 <xQueueGenericReceive+0xfc>
80002db8:	58 1c       	cp.w	r12,1
80002dba:	c0 c1       	brne	80002dd2 <xQueueGenericReceive+0x66>
						{
							queueYIELD_IF_USING_PREEMPTION();
80002dbc:	d7 33       	scall
80002dbe:	c0 a8       	rjmp	80002dd2 <xQueueGenericReceive+0x66>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
80002dc0:	8f 36       	st.w	r7[0xc],r6

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002dc2:	6e 98       	ld.w	r8,r7[0x24]
80002dc4:	58 08       	cp.w	r8,0
80002dc6:	c0 60       	breq	80002dd2 <xQueueGenericReceive+0x66>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80002dc8:	02 9c       	mov	r12,r1
80002dca:	f0 1f 00 28 	mcall	80002e68 <xQueueGenericReceive+0xfc>
80002dce:	c0 20       	breq	80002dd2 <xQueueGenericReceive+0x66>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
80002dd0:	d7 33       	scall
						}
					}
				}

				taskEXIT_CRITICAL();
80002dd2:	f0 1f 00 27 	mcall	80002e6c <xQueueGenericReceive+0x100>
80002dd6:	30 1c       	mov	r12,1
				return pdPASS;
80002dd8:	c4 28       	rjmp	80002e5c <xQueueGenericReceive+0xf0>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80002dda:	40 28       	lddsp	r8,sp[0x8]
80002ddc:	58 08       	cp.w	r8,0
80002dde:	c0 51       	brne	80002de8 <xQueueGenericReceive+0x7c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80002de0:	f0 1f 00 23 	mcall	80002e6c <xQueueGenericReceive+0x100>
80002de4:	30 0c       	mov	r12,0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80002de6:	c3 b8       	rjmp	80002e5c <xQueueGenericReceive+0xf0>
				}
				else if( xEntryTimeSet == pdFALSE )
80002de8:	58 05       	cp.w	r5,0
80002dea:	c0 51       	brne	80002df4 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002dec:	08 9c       	mov	r12,r4
80002dee:	f0 1f 00 21 	mcall	80002e70 <xQueueGenericReceive+0x104>
80002df2:	00 95       	mov	r5,r0
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
80002df4:	f0 1f 00 1e 	mcall	80002e6c <xQueueGenericReceive+0x100>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80002df8:	f0 1f 00 1f 	mcall	80002e74 <xQueueGenericReceive+0x108>
		prvLockQueue( pxQueue );
80002dfc:	f0 1f 00 19 	mcall	80002e60 <xQueueGenericReceive+0xf4>
80002e00:	6f 18       	ld.w	r8,r7[0x44]
80002e02:	5b f8       	cp.w	r8,-1
80002e04:	ef f2 0a 11 	st.weq	r7[0x44],r2
80002e08:	6f 28       	ld.w	r8,r7[0x48]
80002e0a:	5b f8       	cp.w	r8,-1
80002e0c:	ef f2 0a 12 	st.weq	r7[0x48],r2
80002e10:	f0 1f 00 17 	mcall	80002e6c <xQueueGenericReceive+0x100>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002e14:	06 9b       	mov	r11,r3
80002e16:	08 9c       	mov	r12,r4
80002e18:	f0 1f 00 18 	mcall	80002e78 <xQueueGenericReceive+0x10c>
80002e1c:	c1 a1       	brne	80002e50 <xQueueGenericReceive+0xe4>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80002e1e:	f0 1f 00 11 	mcall	80002e60 <xQueueGenericReceive+0xf4>
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
80002e22:	6e e6       	ld.w	r6,r7[0x38]
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
80002e24:	f0 1f 00 12 	mcall	80002e6c <xQueueGenericReceive+0x100>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80002e28:	58 06       	cp.w	r6,0
80002e2a:	c0 d1       	brne	80002e44 <xQueueGenericReceive+0xd8>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80002e2c:	40 2b       	lddsp	r11,sp[0x8]
80002e2e:	02 9c       	mov	r12,r1
80002e30:	f0 1f 00 13 	mcall	80002e7c <xQueueGenericReceive+0x110>
				prvUnlockQueue( pxQueue );
80002e34:	0e 9c       	mov	r12,r7
80002e36:	f0 1f 00 13 	mcall	80002e80 <xQueueGenericReceive+0x114>
				if( xTaskResumeAll() == pdFALSE )
80002e3a:	f0 1f 00 13 	mcall	80002e84 <xQueueGenericReceive+0x118>
80002e3e:	ca 61       	brne	80002d8a <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
80002e40:	d7 33       	scall
80002e42:	ca 4b       	rjmp	80002d8a <xQueueGenericReceive+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80002e44:	0e 9c       	mov	r12,r7
80002e46:	f0 1f 00 0f 	mcall	80002e80 <xQueueGenericReceive+0x114>
				( void ) xTaskResumeAll();
80002e4a:	f0 1f 00 0f 	mcall	80002e84 <xQueueGenericReceive+0x118>
80002e4e:	c9 eb       	rjmp	80002d8a <xQueueGenericReceive+0x1e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80002e50:	0e 9c       	mov	r12,r7
80002e52:	f0 1f 00 0c 	mcall	80002e80 <xQueueGenericReceive+0x114>
			( void ) xTaskResumeAll();
80002e56:	f0 1f 00 0c 	mcall	80002e84 <xQueueGenericReceive+0x118>
80002e5a:	30 0c       	mov	r12,0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
80002e5c:	2f bd       	sub	sp,-20
80002e5e:	d8 32       	popm	r0-r7,pc
80002e60:	80 00       	ld.sh	r0,r0[0x0]
80002e62:	58 48       	cp.w	r8,4
80002e64:	80 00       	ld.sh	r0,r0[0x0]
80002e66:	2b c8       	sub	r8,-68
80002e68:	80 00       	ld.sh	r0,r0[0x0]
80002e6a:	5b 3c       	cp.w	r12,-13
80002e6c:	80 00       	ld.sh	r0,r0[0x0]
80002e6e:	59 54       	cp.w	r4,21
80002e70:	80 00       	ld.sh	r0,r0[0x0]
80002e72:	5a 84       	cp.w	r4,-24
80002e74:	80 00       	ld.sh	r0,r0[0x0]
80002e76:	59 f8       	cp.w	r8,31
80002e78:	80 00       	ld.sh	r0,r0[0x0]
80002e7a:	5a a8       	cp.w	r8,-22
80002e7c:	80 00       	ld.sh	r0,r0[0x0]
80002e7e:	5e 94       	retgt	r4
80002e80:	80 00       	ld.sh	r0,r0[0x0]
80002e82:	2c c8       	sub	r8,-52
80002e84:	80 00       	ld.sh	r0,r0[0x0]
80002e86:	5c d0       	com	r0

80002e88 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
80002e88:	d4 31       	pushm	r0-r7,lr
80002e8a:	20 5d       	sub	sp,20
80002e8c:	50 1b       	stdsp	sp[0x4],r11
80002e8e:	50 2a       	stdsp	sp[0x8],r10
80002e90:	12 92       	mov	r2,r9
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
80002e92:	18 97       	mov	r7,r12
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80002e94:	f8 c8 ff f0 	sub	r8,r12,-16
80002e98:	50 08       	stdsp	sp[0x0],r8
80002e9a:	30 04       	mov	r4,0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002e9c:	fa c3 ff f4 	sub	r3,sp,-12

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
80002ea0:	08 90       	mov	r0,r4

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002ea2:	fa c1 ff f8 	sub	r1,sp,-8
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80002ea6:	f0 1f 00 30 	mcall	80002f64 <xQueueGenericSend+0xdc>
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80002eaa:	6e e9       	ld.w	r9,r7[0x38]
80002eac:	6e f8       	ld.w	r8,r7[0x3c]
80002eae:	10 39       	cp.w	r9,r8
80002eb0:	c0 33       	brcs	80002eb6 <xQueueGenericSend+0x2e>
80002eb2:	58 22       	cp.w	r2,2
80002eb4:	c1 41       	brne	80002edc <xQueueGenericSend+0x54>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80002eb6:	04 9a       	mov	r10,r2
80002eb8:	40 1b       	lddsp	r11,sp[0x4]
80002eba:	0e 9c       	mov	r12,r7
80002ebc:	f0 1f 00 2b 	mcall	80002f68 <xQueueGenericSend+0xe0>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80002ec0:	6e 98       	ld.w	r8,r7[0x24]
80002ec2:	58 08       	cp.w	r8,0
80002ec4:	c0 80       	breq	80002ed4 <xQueueGenericSend+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
80002ec6:	ee cc ff dc 	sub	r12,r7,-36
80002eca:	f0 1f 00 29 	mcall	80002f6c <xQueueGenericSend+0xe4>
80002ece:	58 1c       	cp.w	r12,1
80002ed0:	c0 21       	brne	80002ed4 <xQueueGenericSend+0x4c>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
80002ed2:	d7 33       	scall
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
80002ed4:	f0 1f 00 27 	mcall	80002f70 <xQueueGenericSend+0xe8>
80002ed8:	30 1c       	mov	r12,1

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
80002eda:	c4 38       	rjmp	80002f60 <xQueueGenericSend+0xd8>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
80002edc:	40 28       	lddsp	r8,sp[0x8]
80002ede:	58 08       	cp.w	r8,0
80002ee0:	c0 51       	brne	80002eea <xQueueGenericSend+0x62>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80002ee2:	f0 1f 00 24 	mcall	80002f70 <xQueueGenericSend+0xe8>
80002ee6:	30 0c       	mov	r12,0

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
80002ee8:	c3 c8       	rjmp	80002f60 <xQueueGenericSend+0xd8>
				}
				else if( xEntryTimeSet == pdFALSE )
80002eea:	58 04       	cp.w	r4,0
80002eec:	c0 51       	brne	80002ef6 <xQueueGenericSend+0x6e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80002eee:	06 9c       	mov	r12,r3
80002ef0:	f0 1f 00 21 	mcall	80002f74 <xQueueGenericSend+0xec>
80002ef4:	30 14       	mov	r4,1
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
80002ef6:	f0 1f 00 1f 	mcall	80002f70 <xQueueGenericSend+0xe8>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80002efa:	f0 1f 00 20 	mcall	80002f78 <xQueueGenericSend+0xf0>
		prvLockQueue( pxQueue );
80002efe:	f0 1f 00 1a 	mcall	80002f64 <xQueueGenericSend+0xdc>
80002f02:	6f 18       	ld.w	r8,r7[0x44]
80002f04:	5b f8       	cp.w	r8,-1
80002f06:	ef f0 0a 11 	st.weq	r7[0x44],r0
80002f0a:	6f 28       	ld.w	r8,r7[0x48]
80002f0c:	5b f8       	cp.w	r8,-1
80002f0e:	ef f0 0a 12 	st.weq	r7[0x48],r0
80002f12:	f0 1f 00 18 	mcall	80002f70 <xQueueGenericSend+0xe8>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80002f16:	02 9b       	mov	r11,r1
80002f18:	06 9c       	mov	r12,r3
80002f1a:	f0 1f 00 19 	mcall	80002f7c <xQueueGenericSend+0xf4>
80002f1e:	c1 b1       	brne	80002f54 <xQueueGenericSend+0xcc>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
80002f20:	f0 1f 00 11 	mcall	80002f64 <xQueueGenericSend+0xdc>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
80002f24:	6e e5       	ld.w	r5,r7[0x38]
80002f26:	6e f6       	ld.w	r6,r7[0x3c]
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
80002f28:	f0 1f 00 12 	mcall	80002f70 <xQueueGenericSend+0xe8>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
80002f2c:	0c 35       	cp.w	r5,r6
80002f2e:	c0 d1       	brne	80002f48 <xQueueGenericSend+0xc0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80002f30:	40 2b       	lddsp	r11,sp[0x8]
80002f32:	40 0c       	lddsp	r12,sp[0x0]
80002f34:	f0 1f 00 13 	mcall	80002f80 <xQueueGenericSend+0xf8>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
80002f38:	0e 9c       	mov	r12,r7
80002f3a:	f0 1f 00 13 	mcall	80002f84 <xQueueGenericSend+0xfc>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
80002f3e:	f0 1f 00 13 	mcall	80002f88 <xQueueGenericSend+0x100>
80002f42:	cb 21       	brne	80002ea6 <xQueueGenericSend+0x1e>
				{
					portYIELD_WITHIN_API();
80002f44:	d7 33       	scall
80002f46:	cb 0b       	rjmp	80002ea6 <xQueueGenericSend+0x1e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80002f48:	0e 9c       	mov	r12,r7
80002f4a:	f0 1f 00 0f 	mcall	80002f84 <xQueueGenericSend+0xfc>
				( void ) xTaskResumeAll();
80002f4e:	f0 1f 00 0f 	mcall	80002f88 <xQueueGenericSend+0x100>
80002f52:	ca ab       	rjmp	80002ea6 <xQueueGenericSend+0x1e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
80002f54:	0e 9c       	mov	r12,r7
80002f56:	f0 1f 00 0c 	mcall	80002f84 <xQueueGenericSend+0xfc>
			( void ) xTaskResumeAll();
80002f5a:	f0 1f 00 0c 	mcall	80002f88 <xQueueGenericSend+0x100>
80002f5e:	30 0c       	mov	r12,0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80002f60:	2f bd       	sub	sp,-20
80002f62:	d8 32       	popm	r0-r7,pc
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	58 48       	cp.w	r8,4
80002f68:	80 00       	ld.sh	r0,r0[0x0]
80002f6a:	2b f8       	sub	r8,-65
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	5b 3c       	cp.w	r12,-13
80002f70:	80 00       	ld.sh	r0,r0[0x0]
80002f72:	59 54       	cp.w	r4,21
80002f74:	80 00       	ld.sh	r0,r0[0x0]
80002f76:	5a 84       	cp.w	r4,-24
80002f78:	80 00       	ld.sh	r0,r0[0x0]
80002f7a:	59 f8       	cp.w	r8,31
80002f7c:	80 00       	ld.sh	r0,r0[0x0]
80002f7e:	5a a8       	cp.w	r8,-22
80002f80:	80 00       	ld.sh	r0,r0[0x0]
80002f82:	5e 94       	retgt	r4
80002f84:	80 00       	ld.sh	r0,r0[0x0]
80002f86:	2c c8       	sub	r8,-52
80002f88:	80 00       	ld.sh	r0,r0[0x0]
80002f8a:	5c d0       	com	r0

80002f8c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
80002f8c:	eb cd 40 c0 	pushm	r6-r7,lr
80002f90:	16 96       	mov	r6,r11
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;
80002f92:	18 97       	mov	r7,r12

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
80002f94:	f0 1f 00 18 	mcall	80002ff4 <xQueueGenericReset+0x68>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80002f98:	6f 09       	ld.w	r9,r7[0x40]
80002f9a:	6e fa       	ld.w	r10,r7[0x3c]
80002f9c:	f2 0a 02 4b 	mul	r11,r9,r10
80002fa0:	6e 08       	ld.w	r8,r7[0x0]
80002fa2:	f0 0b 00 0b 	add	r11,r8,r11
80002fa6:	8f 1b       	st.w	r7[0x4],r11
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
80002fa8:	30 0b       	mov	r11,0
80002faa:	8f eb       	st.w	r7[0x38],r11
		pxQueue->pcWriteTo = pxQueue->pcHead;
80002fac:	8f 28       	st.w	r7[0x8],r8
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
80002fae:	20 1a       	sub	r10,1
80002fb0:	f4 09 02 49 	mul	r9,r10,r9
80002fb4:	12 08       	add	r8,r9
80002fb6:	8f 38       	st.w	r7[0xc],r8
		pxQueue->xRxLock = queueUNLOCKED;
80002fb8:	3f f8       	mov	r8,-1
80002fba:	ef 48 00 44 	st.w	r7[68],r8
		pxQueue->xTxLock = queueUNLOCKED;
80002fbe:	ef 48 00 48 	st.w	r7[72],r8

		if( xNewQueue == pdFALSE )
80002fc2:	58 06       	cp.w	r6,0
80002fc4:	c0 c1       	brne	80002fdc <xQueueGenericReset+0x50>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80002fc6:	6e 48       	ld.w	r8,r7[0x10]
80002fc8:	58 08       	cp.w	r8,0
80002fca:	c1 10       	breq	80002fec <xQueueGenericReset+0x60>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
80002fcc:	ee cc ff f0 	sub	r12,r7,-16
80002fd0:	f0 1f 00 0a 	mcall	80002ff8 <xQueueGenericReset+0x6c>
80002fd4:	58 1c       	cp.w	r12,1
80002fd6:	c0 b1       	brne	80002fec <xQueueGenericReset+0x60>
				{
					queueYIELD_IF_USING_PREEMPTION();
80002fd8:	d7 33       	scall
80002fda:	c0 98       	rjmp	80002fec <xQueueGenericReset+0x60>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80002fdc:	ee cc ff f0 	sub	r12,r7,-16
80002fe0:	f0 1f 00 07 	mcall	80002ffc <xQueueGenericReset+0x70>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
80002fe4:	ee cc ff dc 	sub	r12,r7,-36
80002fe8:	f0 1f 00 05 	mcall	80002ffc <xQueueGenericReset+0x70>
		}
	}
	taskEXIT_CRITICAL();
80002fec:	f0 1f 00 05 	mcall	80003000 <xQueueGenericReset+0x74>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
80002ff0:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
80002ff4:	80 00       	ld.sh	r0,r0[0x0]
80002ff6:	58 48       	cp.w	r8,4
80002ff8:	80 00       	ld.sh	r0,r0[0x0]
80002ffa:	5b 3c       	cp.w	r12,-13
80002ffc:	80 00       	ld.sh	r0,r0[0x0]
80002ffe:	57 24       	stdsp	sp[0x1c8],r4
80003000:	80 00       	ld.sh	r0,r0[0x0]
80003002:	59 54       	cp.w	r4,21

80003004 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
80003004:	eb cd 40 e0 	pushm	r5-r7,lr
80003008:	18 97       	mov	r7,r12
8000300a:	16 96       	mov	r6,r11
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
8000300c:	58 0c       	cp.w	r12,0
8000300e:	c1 c0       	breq	80003046 <xQueueGenericCreate+0x42>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
80003010:	34 cc       	mov	r12,76
80003012:	f0 1f 00 0f 	mcall	8000304c <xQueueGenericCreate+0x48>
80003016:	18 95       	mov	r5,r12
		if( pxNewQueue != NULL )
80003018:	c1 70       	breq	80003046 <xQueueGenericCreate+0x42>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
8000301a:	ec 07 02 4c 	mul	r12,r6,r7
8000301e:	2f fc       	sub	r12,-1
80003020:	f0 1f 00 0b 	mcall	8000304c <xQueueGenericCreate+0x48>
80003024:	8b 0c       	st.w	r5[0x0],r12
			if( pxNewQueue->pcHead != NULL )
80003026:	c0 b0       	breq	8000303c <xQueueGenericCreate+0x38>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
80003028:	8b f7       	st.w	r5[0x3c],r7
				pxNewQueue->uxItemSize = uxItemSize;
8000302a:	eb 46 00 40 	st.w	r5[64],r6
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
8000302e:	30 1b       	mov	r11,1
80003030:	0a 9c       	mov	r12,r5
80003032:	f0 1f 00 08 	mcall	80003050 <xQueueGenericCreate+0x4c>
80003036:	0a 9c       	mov	r12,r5
80003038:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
8000303c:	0a 9c       	mov	r12,r5
8000303e:	f0 1f 00 06 	mcall	80003054 <xQueueGenericCreate+0x50>
80003042:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
80003046:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0
8000304a:	00 00       	add	r0,r0
8000304c:	80 00       	ld.sh	r0,r0[0x0]
8000304e:	2b 60       	sub	r0,-74
80003050:	80 00       	ld.sh	r0,r0[0x0]
80003052:	2f 8c       	sub	r12,-8
80003054:	80 00       	ld.sh	r0,r0[0x0]
80003056:	2b 5c       	sub	r12,-75

80003058 <mcp2515_read_array>:
	spi_deselect_device(MCP2515_SPI_ADDRESS,spi_dev);
	
	//Missing return? / --> Added 21/5-14
}

void mcp2515_read_array (struct spi_device * spi_dev, uint8_t * data, uint8_t len, uint8_t first_reg_addr ){
80003058:	eb cd 40 e0 	pushm	r5-r7,lr
8000305c:	20 1d       	sub	sp,4
8000305e:	18 97       	mov	r7,r12
80003060:	16 95       	mov	r5,r11
80003062:	14 96       	mov	r6,r10
	
	uint8_t dataToSend[2] = {MCP2515_INSTR_READ,first_reg_addr};
80003064:	30 38       	mov	r8,3
80003066:	ba 88       	st.b	sp[0x0],r8
80003068:	ba 99       	st.b	sp[0x1],r9
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
8000306a:	19 8b       	ld.ub	r11,r12[0x0]
8000306c:	fc 7c 18 00 	mov	r12,-190464
80003070:	f0 1f 00 0b 	mcall	8000309c <mcp2515_read_array+0x44>
		
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);
	spi_write_packet(MCP2515_SPI_ADDRESS,dataToSend,2);
80003074:	30 2a       	mov	r10,2
80003076:	1a 9b       	mov	r11,sp
80003078:	fc 7c 18 00 	mov	r12,-190464
8000307c:	f0 1f 00 09 	mcall	800030a0 <mcp2515_read_array+0x48>
	spi_read_packet(MCP2515_SPI_ADDRESS,data,len);
80003080:	0c 9a       	mov	r10,r6
80003082:	0a 9b       	mov	r11,r5
80003084:	fc 7c 18 00 	mov	r12,-190464
80003088:	f0 1f 00 07 	mcall	800030a4 <mcp2515_read_array+0x4c>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
8000308c:	0f 8b       	ld.ub	r11,r7[0x0]
8000308e:	fc 7c 18 00 	mov	r12,-190464
80003092:	f0 1f 00 06 	mcall	800030a8 <mcp2515_read_array+0x50>
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
	
80003096:	2f fd       	sub	sp,-4
80003098:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000309c:	80 00       	ld.sh	r0,r0[0x0]
8000309e:	20 6c       	sub	r12,6
800030a0:	80 00       	ld.sh	r0,r0[0x0]
800030a2:	24 58       	sub	r8,69
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	24 08       	sub	r8,64
800030a8:	80 00       	ld.sh	r0,r0[0x0]
800030aa:	20 2c       	sub	r12,2

800030ac <load_state>:
		ecu_data->config_max_trq
	}; 
	mcp2515_write_array(spi_dev,dataToWrite, ECU_DATA_BUF_LEN ,addr);
}

void load_state(struct spi_device * spi_dev, fsm_ecu_data_t *ecu_data) {
800030ac:	eb cd 40 80 	pushm	r7,lr
800030b0:	20 2d       	sub	sp,8
800030b2:	16 97       	mov	r7,r11
	uint8_t addr = ECU_DATA_BUF;
	uint8_t data[ECU_DATA_BUF_LEN] = {0};
800030b4:	30 09       	mov	r9,0
800030b6:	50 09       	stdsp	sp[0x0],r9
800030b8:	fa c8 ff fc 	sub	r8,sp,-4
800030bc:	b0 09       	st.h	r8[0x0],r9
800030be:	fa c8 ff fa 	sub	r8,sp,-6
800030c2:	b0 89       	st.b	r8[0x0],r9
	mcp2515_read_array(spi_dev, data, ECU_DATA_BUF_LEN, addr);
800030c4:	35 69       	mov	r9,86
800030c6:	30 7a       	mov	r10,7
800030c8:	1a 9b       	mov	r11,sp
800030ca:	f0 1f 00 0e 	mcall	80003100 <load_state+0x54>
	ecu_data->state					 = (fsm_ecu_state_t)data[0];
800030ce:	1b 88       	ld.ub	r8,sp[0x0]
800030d0:	8f 08       	st.w	r7[0x0],r8
	ecu_data->flag_start_precharge	 = data[1];
800030d2:	1b 98       	ld.ub	r8,sp[0x1]
800030d4:	ef 68 00 4a 	st.b	r7[74],r8
	ecu_data->flag_drive_enable		 = (flag_drive_enable_t)data[2];
800030d8:	1b a8       	ld.ub	r8,sp[0x2]
800030da:	ef 48 00 50 	st.w	r7[80],r8
	ecu_data->flag_brake_implausible = data[3];
800030de:	1b b8       	ld.ub	r8,sp[0x3]
800030e0:	ef 68 00 4b 	st.b	r7[75],r8
	uint16_t temp					 = data[4] << 8;
	ecu_data->control_u				 = (int16_t)(temp | (uint16_t)data[5]);
800030e4:	1b c9       	ld.ub	r9,sp[0x4]
800030e6:	1b d8       	ld.ub	r8,sp[0x5]
800030e8:	f1 e9 10 88 	or	r8,r8,r9<<0x8
800030ec:	5c 88       	casts.h	r8
800030ee:	e5 a6 08 08 	cop	cp0,cr8,cr0,cr8,0x4c
800030f2:	8f 78       	st.w	r7[0x1c],r8
	ecu_data->config_max_trq		 = (uint8_t)data[6];
800030f4:	1b e8       	ld.ub	r8,sp[0x6]
800030f6:	ef 68 00 69 	st.b	r7[105],r8
}
800030fa:	2f ed       	sub	sp,-8
800030fc:	e3 cd 80 80 	ldm	sp++,r7,pc
80003100:	80 00       	ld.sh	r0,r0[0x0]
80003102:	30 58       	mov	r8,5

80003104 <mcp2515_readRXbuffer>:
	spi_write_packet(MCP2515_SPI_ADDRESS,bitModifyMessage,4);
	spi_deselect_device(MCP2515_SPI_ADDRESS,spi_dev);
	
}

uint8_t mcp2515_readRXbuffer ( struct spi_device * spi_dev, uint8_t bufferNumber, uint8_t * data, uint8_t dlc){
80003104:	d4 21       	pushm	r4-r7,lr
80003106:	18 96       	mov	r6,r12
80003108:	14 94       	mov	r4,r10
8000310a:	12 95       	mov	r5,r9
8000310c:	30 18       	mov	r8,1
8000310e:	f0 0b 18 00 	cp.b	r11,r8
80003112:	e0 88 00 04 	brls	8000311a <mcp2515_readRXbuffer+0x16>
80003116:	30 27       	mov	r7,2
80003118:	c0 48       	rjmp	80003120 <mcp2515_readRXbuffer+0x1c>
8000311a:	48 d8       	lddpc	r8,8000314c <mcp2515_readRXbuffer+0x48>
8000311c:	f0 0b 07 07 	ld.ub	r7,r8[r11]
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
80003120:	0d 8b       	ld.ub	r11,r6[0x0]
80003122:	fc 7c 18 00 	mov	r12,-190464
80003126:	f0 1f 00 0b 	mcall	80003150 <mcp2515_readRXbuffer+0x4c>
 * \param data The data byte to be loaded
 *
 */
static inline void spi_put(volatile avr32_spi_t *spi, uint16_t data)
{
	spi->tdr = data << AVR32_SPI_TDR_TD_OFFSET;
8000312a:	0e 98       	mov	r8,r7
8000312c:	e8 18 00 90 	orl	r8,0x90
80003130:	fc 77 18 00 	mov	r7,-190464
80003134:	8f 38       	st.w	r7[0xc],r8
	
	spi_select_device(MCP2515_SPI_ADDRESS,spi_dev);
	
	uint8_t spi_cmd = MCP2515_INSTR_READ_RX_BUF | rxBufferReadAddress;
	spi_write_single(MCP2515_SPI_ADDRESS, spi_cmd);
	spi_read_packet(MCP2515_SPI_ADDRESS,data,dlc);	
80003136:	0a 9a       	mov	r10,r5
80003138:	08 9b       	mov	r11,r4
8000313a:	0e 9c       	mov	r12,r7
8000313c:	f0 1f 00 06 	mcall	80003154 <mcp2515_readRXbuffer+0x50>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
80003140:	0d 8b       	ld.ub	r11,r6[0x0]
80003142:	0e 9c       	mov	r12,r7
80003144:	f0 1f 00 05 	mcall	80003158 <mcp2515_readRXbuffer+0x54>
	
	spi_deselect_device(MCP2515_SPI_ADDRESS,spi_dev);
	
	//Missing return? / --> Added 21/5-14
}
80003148:	d8 22       	popm	r4-r7,pc
8000314a:	00 00       	add	r0,r0
8000314c:	80 00       	ld.sh	r0,r0[0x0]
8000314e:	80 28       	ld.sh	r8,r0[0x4]
80003150:	80 00       	ld.sh	r0,r0[0x0]
80003152:	20 6c       	sub	r12,6
80003154:	80 00       	ld.sh	r0,r0[0x0]
80003156:	24 08       	sub	r8,64
80003158:	80 00       	ld.sh	r0,r0[0x0]
8000315a:	20 2c       	sub	r12,2

8000315c <mcp2515_write_array>:
	regValue &= MCP2515_MODE_bm;
	
	return ( regValue >> 5);
}

void mcp2515_write_array (struct spi_device * spi_dev, uint8_t * data, uint8_t len, uint8_t first_reg_addr ){		//This function is not working, must be fixed
8000315c:	d4 21       	pushm	r4-r7,lr
8000315e:	20 3d       	sub	sp,12
80003160:	18 97       	mov	r7,r12
80003162:	14 96       	mov	r6,r10
	
	uint8_t dataToSend[10] = {MCP2515_INSTR_WRITE,first_reg_addr};
80003164:	30 04       	mov	r4,0
80003166:	30 05       	mov	r5,0
80003168:	fa e5 00 00 	st.d	sp[0],r4
8000316c:	30 08       	mov	r8,0
8000316e:	ba 48       	st.h	sp[0x8],r8
80003170:	30 28       	mov	r8,2
80003172:	ba 88       	st.b	sp[0x0],r8
80003174:	ba 99       	st.b	sp[0x1],r9
80003176:	fa c8 ff fe 	sub	r8,sp,-2
	regValue &= MCP2515_MODE_bm;
	
	return ( regValue >> 5);
}

void mcp2515_write_array (struct spi_device * spi_dev, uint8_t * data, uint8_t len, uint8_t first_reg_addr ){		//This function is not working, must be fixed
8000317a:	fa ca ff f5 	sub	r10,sp,-11
	
	uint8_t dataToSend[10] = {MCP2515_INSTR_WRITE,first_reg_addr};
	
	for ( uint8_t i = 2 ; i < 11 ; ++i){
		dataToSend[i] = data[i-2]; 
8000317e:	17 39       	ld.ub	r9,r11++
80003180:	10 c9       	st.b	r8++,r9

void mcp2515_write_array (struct spi_device * spi_dev, uint8_t * data, uint8_t len, uint8_t first_reg_addr ){		//This function is not working, must be fixed
	
	uint8_t dataToSend[10] = {MCP2515_INSTR_WRITE,first_reg_addr};
	
	for ( uint8_t i = 2 ; i < 11 ; ++i){
80003182:	14 38       	cp.w	r8,r10
80003184:	cf d1       	brne	8000317e <mcp2515_write_array+0x22>
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
80003186:	0f 8b       	ld.ub	r11,r7[0x0]
80003188:	fc 7c 18 00 	mov	r12,-190464
8000318c:	f0 1f 00 08 	mcall	800031ac <mcp2515_write_array+0x50>
		dataToSend[i] = data[i-2]; 
	}
	
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);	
	spi_write_packet(MCP2515_SPI_ADDRESS,dataToSend,len+2);
80003190:	ec ca ff fe 	sub	r10,r6,-2
80003194:	1a 9b       	mov	r11,sp
80003196:	fc 7c 18 00 	mov	r12,-190464
8000319a:	f0 1f 00 06 	mcall	800031b0 <mcp2515_write_array+0x54>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
8000319e:	0f 8b       	ld.ub	r11,r7[0x0]
800031a0:	fc 7c 18 00 	mov	r12,-190464
800031a4:	f0 1f 00 04 	mcall	800031b4 <mcp2515_write_array+0x58>
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);

}
800031a8:	2f dd       	sub	sp,-12
800031aa:	d8 22       	popm	r4-r7,pc
800031ac:	80 00       	ld.sh	r0,r0[0x0]
800031ae:	20 6c       	sub	r12,6
800031b0:	80 00       	ld.sh	r0,r0[0x0]
800031b2:	24 58       	sub	r8,69
800031b4:	80 00       	ld.sh	r0,r0[0x0]
800031b6:	20 2c       	sub	r12,2

800031b8 <save_state>:
	gpio_set_pin_high(LED1);
	return DLC;

}

void save_state(struct spi_device * spi_dev, fsm_ecu_data_t *ecu_data) {
800031b8:	eb cd 40 80 	pushm	r7,lr
800031bc:	20 2d       	sub	sp,8
	uint8_t addr = ECU_DATA_BUF;
	uint8_t dataToWrite[ECU_DATA_BUF_LEN] = { 
		ecu_data->state,
		ecu_data->flag_start_precharge,
800031be:	f7 37 00 4a 	ld.ub	r7,r11[74]
		(uint8_t)ecu_data->flag_drive_enable,
800031c2:	f7 3e 00 53 	ld.ub	lr,r11[83]
		ecu_data->flag_brake_implausible,
800031c6:	f7 3a 00 4b 	ld.ub	r10,r11[75]
		(int8_t)((int16_t)ecu_data->control_u >> 8),
		(int8_t)(ecu_data->control_u),
		ecu_data->config_max_trq
	}; 
800031ca:	76 78       	ld.w	r8,r11[0x1c]
		ecu_data->flag_start_precharge,
		(uint8_t)ecu_data->flag_drive_enable,
		ecu_data->flag_brake_implausible,
		(int8_t)((int16_t)ecu_data->control_u >> 8),
		(int8_t)(ecu_data->control_u),
		ecu_data->config_max_trq
800031cc:	f7 39 00 69 	ld.ub	r9,r11[105]
	}; 
800031d0:	76 0b       	ld.w	r11,r11[0x0]
800031d2:	ba 8b       	st.b	sp[0x0],r11
800031d4:	ba 97       	st.b	sp[0x1],r7
800031d6:	ba ae       	st.b	sp[0x2],lr
800031d8:	ba ba       	st.b	sp[0x3],r10
800031da:	e5 ab 08 08 	cop	cp0,cr8,cr0,cr8,0x56
800031de:	f5 d8 b1 08 	bfexts	r10,r8,0x8,0x8
800031e2:	ba ca       	st.b	sp[0x4],r10
800031e4:	ba d8       	st.b	sp[0x5],r8
800031e6:	ba e9       	st.b	sp[0x6],r9
	mcp2515_write_array(spi_dev,dataToWrite, ECU_DATA_BUF_LEN ,addr);
800031e8:	35 69       	mov	r9,86
800031ea:	30 7a       	mov	r10,7
800031ec:	1a 9b       	mov	r11,sp
800031ee:	f0 1f 00 03 	mcall	800031f8 <save_state+0x40>
}
800031f2:	2f ed       	sub	sp,-8
800031f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800031f8:	80 00       	ld.sh	r0,r0[0x0]
800031fa:	31 5c       	mov	r12,21

800031fc <mcp2515_setToMode>:
	mcp2515_writeRegister (spi_dev, controlRegisterAddress, dataTransmissionSetting );
	gpio_set_pin_high(LED2);
	//done
}

void mcp2515_setToMode (struct spi_device * spi_dev, mcp2515_mode_t mode ){
800031fc:	eb cd 40 80 	pushm	r7,lr
80003200:	20 1d       	sub	sp,4
80003202:	18 97       	mov	r7,r12
	uint8_t data[4] = {
		MCP2515_CMD_BIT_MODIFY,
		MCP2515_CAN_CTRL_REG_ADDR,	
		MCP2515_MODE_bm ,	
		( mode << 5 )				// data
	};
80003204:	30 58       	mov	r8,5
80003206:	ba 88       	st.b	sp[0x0],r8
80003208:	30 f8       	mov	r8,15
8000320a:	ba 98       	st.b	sp[0x1],r8
8000320c:	3e 08       	mov	r8,-32
8000320e:	ba a8       	st.b	sp[0x2],r8
80003210:	a5 7b       	lsl	r11,0x5
80003212:	ba bb       	st.b	sp[0x3],r11
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
80003214:	19 8b       	ld.ub	r11,r12[0x0]
80003216:	fc 7c 18 00 	mov	r12,-190464
8000321a:	f0 1f 00 09 	mcall	8000323c <mcp2515_setToMode+0x40>
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);
	spi_write_packet(MCP2515_SPI_ADDRESS, data, 4);
8000321e:	30 4a       	mov	r10,4
80003220:	1a 9b       	mov	r11,sp
80003222:	fc 7c 18 00 	mov	r12,-190464
80003226:	f0 1f 00 07 	mcall	80003240 <mcp2515_setToMode+0x44>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
8000322a:	0f 8b       	ld.ub	r11,r7[0x0]
8000322c:	fc 7c 18 00 	mov	r12,-190464
80003230:	f0 1f 00 05 	mcall	80003244 <mcp2515_setToMode+0x48>
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
	
	
}
80003234:	2f fd       	sub	sp,-4
80003236:	e3 cd 80 80 	ldm	sp++,r7,pc
8000323a:	00 00       	add	r0,r0
8000323c:	80 00       	ld.sh	r0,r0[0x0]
8000323e:	20 6c       	sub	r12,6
80003240:	80 00       	ld.sh	r0,r0[0x0]
80003242:	24 58       	sub	r8,69
80003244:	80 00       	ld.sh	r0,r0[0x0]
80003246:	20 2c       	sub	r12,2

80003248 <mcp2515_readRegister>:
	
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
}


uint8_t mcp2515_readRegister ( struct spi_device * spi_dev, uint8_t reg_addr ){
80003248:	eb cd 40 c0 	pushm	r6-r7,lr
8000324c:	20 2d       	sub	sp,8
8000324e:	18 97       	mov	r7,r12
80003250:	16 96       	mov	r6,r11
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
80003252:	19 8b       	ld.ub	r11,r12[0x0]
80003254:	fc 7c 18 00 	mov	r12,-190464
80003258:	f0 1f 00 0f 	mcall	80003294 <mcp2515_readRegister+0x4c>
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);
	
	uint8_t data[2] = {
		MCP2515_INSTR_READ,
		reg_addr
	};
8000325c:	30 38       	mov	r8,3
8000325e:	ba c8       	st.b	sp[0x4],r8
80003260:	ba d6       	st.b	sp[0x5],r6
		
	spi_write_packet(MCP2515_SPI_ADDRESS, data, 2 );
80003262:	30 2a       	mov	r10,2
80003264:	fa cb ff fc 	sub	r11,sp,-4
80003268:	fc 7c 18 00 	mov	r12,-190464
8000326c:	f0 1f 00 0b 	mcall	80003298 <mcp2515_readRegister+0x50>
	uint8_t registerValue[1] = {0x00};
80003270:	30 08       	mov	r8,0
80003272:	ba 88       	st.b	sp[0x0],r8
	
	spi_read_packet(MCP2515_SPI_ADDRESS, registerValue, 1 );
80003274:	30 1a       	mov	r10,1
80003276:	1a 9b       	mov	r11,sp
80003278:	fc 7c 18 00 	mov	r12,-190464
8000327c:	f0 1f 00 08 	mcall	8000329c <mcp2515_readRegister+0x54>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
80003280:	0f 8b       	ld.ub	r11,r7[0x0]
80003282:	fc 7c 18 00 	mov	r12,-190464
80003286:	f0 1f 00 07 	mcall	800032a0 <mcp2515_readRegister+0x58>

	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
	return registerValue[0];
	
}
8000328a:	1b 8c       	ld.ub	r12,sp[0x0]
8000328c:	2f ed       	sub	sp,-8
8000328e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003292:	00 00       	add	r0,r0
80003294:	80 00       	ld.sh	r0,r0[0x0]
80003296:	20 6c       	sub	r12,6
80003298:	80 00       	ld.sh	r0,r0[0x0]
8000329a:	24 58       	sub	r8,69
8000329c:	80 00       	ld.sh	r0,r0[0x0]
8000329e:	24 08       	sub	r8,64
800032a0:	80 00       	ld.sh	r0,r0[0x0]
800032a2:	20 2c       	sub	r12,2

800032a4 <mcp2515_getCurrentMode>:
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
	
	
}

mcp2515_mode_t mcp2515_getCurrentMode ( struct spi_device * spi_dev ){
800032a4:	d4 01       	pushm	lr
	
	uint8_t regValue = mcp2515_readRegister(spi_dev, MCP2515_CAN_CTRL_REG_ADDR);
800032a6:	30 fb       	mov	r11,15
800032a8:	f0 1f 00 03 	mcall	800032b4 <mcp2515_getCurrentMode+0x10>
	regValue &= MCP2515_MODE_bm;
	
	return ( regValue >> 5);
}
800032ac:	f9 dc c0 a3 	bfextu	r12,r12,0x5,0x3
800032b0:	d8 02       	popm	pc
800032b2:	00 00       	add	r0,r0
800032b4:	80 00       	ld.sh	r0,r0[0x0]
800032b6:	32 48       	mov	r8,36

800032b8 <mcp2515_writeRegister>:
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);
	spi_write_single(MCP2515_SPI_ADDRESS, MCP2515_INSTR_RESET);
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
}

void mcp2515_writeRegister ( struct spi_device * spi_dev, uint8_t reg_addr, uint8_t reg_data ){
800032b8:	eb cd 40 e0 	pushm	r5-r7,lr
800032bc:	20 1d       	sub	sp,4
800032be:	18 97       	mov	r7,r12
800032c0:	16 96       	mov	r6,r11
800032c2:	14 95       	mov	r5,r10
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
800032c4:	19 8b       	ld.ub	r11,r12[0x0]
800032c6:	fc 7c 18 00 	mov	r12,-190464
800032ca:	f0 1f 00 0b 	mcall	800032f4 <mcp2515_writeRegister+0x3c>
	
	uint8_t data[3] = {
		MCP2515_INSTR_WRITE,
		reg_addr,
		reg_data
	};
800032ce:	30 28       	mov	r8,2
800032d0:	ba 88       	st.b	sp[0x0],r8
800032d2:	ba 96       	st.b	sp[0x1],r6
800032d4:	ba a5       	st.b	sp[0x2],r5
	
	spi_write_packet(MCP2515_SPI_ADDRESS, data,3);
800032d6:	30 3a       	mov	r10,3
800032d8:	1a 9b       	mov	r11,sp
800032da:	fc 7c 18 00 	mov	r12,-190464
800032de:	f0 1f 00 07 	mcall	800032f8 <mcp2515_writeRegister+0x40>
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
800032e2:	0f 8b       	ld.ub	r11,r7[0x0]
800032e4:	fc 7c 18 00 	mov	r12,-190464
800032e8:	f0 1f 00 05 	mcall	800032fc <mcp2515_writeRegister+0x44>
	
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
}
800032ec:	2f fd       	sub	sp,-4
800032ee:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800032f2:	00 00       	add	r0,r0
800032f4:	80 00       	ld.sh	r0,r0[0x0]
800032f6:	20 6c       	sub	r12,6
800032f8:	80 00       	ld.sh	r0,r0[0x0]
800032fa:	24 58       	sub	r8,69
800032fc:	80 00       	ld.sh	r0,r0[0x0]
800032fe:	20 2c       	sub	r12,2

80003300 <mcp2515_reset>:

	return 1;
	
}

void mcp2515_reset( struct spi_device * spi_dev ){
80003300:	eb cd 40 80 	pushm	r7,lr
80003304:	18 97       	mov	r7,r12
 *
 */
static inline void spi_select_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_selectChip(spi,device->id);
80003306:	19 8b       	ld.ub	r11,r12[0x0]
80003308:	fc 7c 18 00 	mov	r12,-190464
8000330c:	f0 1f 00 06 	mcall	80003324 <mcp2515_reset+0x24>
80003310:	fc 7c 18 00 	mov	r12,-190464
80003314:	e0 68 00 c0 	mov	r8,192
80003318:	99 38       	st.w	r12[0xc],r8
 * \pre SPI device must be selected with spi_select_device() first
 */
static inline void spi_deselect_device(volatile avr32_spi_t *spi,
		struct spi_device *device)
{
	spi_unselectChip(spi,device->id);
8000331a:	0f 8b       	ld.ub	r11,r7[0x0]
8000331c:	f0 1f 00 03 	mcall	80003328 <mcp2515_reset+0x28>
	
	spi_select_device(MCP2515_SPI_ADDRESS, spi_dev);
	spi_write_single(MCP2515_SPI_ADDRESS, MCP2515_INSTR_RESET);
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
}
80003320:	e3 cd 80 80 	ldm	sp++,r7,pc
80003324:	80 00       	ld.sh	r0,r0[0x0]
80003326:	20 6c       	sub	r12,6
80003328:	80 00       	ld.sh	r0,r0[0x0]
8000332a:	20 2c       	sub	r12,2

8000332c <mcp2515_init>:
	spi_enable(SPI_ADRESS);
	return spi_device_conf;
}


uint8_t mcp2515_init ( struct spi_device * spi_dev ){
8000332c:	eb cd 40 80 	pushm	r7,lr
80003330:	18 97       	mov	r7,r12

	
	mcp2515_reset(spi_dev);
80003332:	f0 1f 00 1a 	mcall	80003398 <mcp2515_init+0x6c>
	
	mcp2515_mode_t currentMode = mcp2515_getCurrentMode(spi_dev); 	
80003336:	0e 9c       	mov	r12,r7
80003338:	f0 1f 00 19 	mcall	8000339c <mcp2515_init+0x70>
	if ( currentMode != CONFIG ){
8000333c:	58 4c       	cp.w	r12,4
8000333e:	c0 30       	breq	80003344 <mcp2515_init+0x18>
80003340:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
	}
	
	
	// setup receive buffers:
	uint8_t receiveBuffer0Settings = RX_MASK_FILTER_OFF_bm;
	mcp2515_writeRegister(spi_dev, RXB0CTRL, receiveBuffer0Settings );
80003344:	36 0a       	mov	r10,96
80003346:	14 9b       	mov	r11,r10
80003348:	0e 9c       	mov	r12,r7
8000334a:	f0 1f 00 16 	mcall	800033a0 <mcp2515_init+0x74>
	
	uint8_t receiveBuffer1Settings = RX_MASK_FILTER_OFF_bm;
	mcp2515_writeRegister(spi_dev, RXB1CTRL, receiveBuffer1Settings );
8000334e:	36 0a       	mov	r10,96
80003350:	37 0b       	mov	r11,112
80003352:	0e 9c       	mov	r12,r7
80003354:	f0 1f 00 13 	mcall	800033a0 <mcp2515_init+0x74>
	
	
	uint8_t interruptSettings = RX0IE_bm | RX1IE_bm;		//enable interrupts on full receive buffers
	mcp2515_writeRegister(spi_dev,CANINTE,interruptSettings);
80003358:	30 3a       	mov	r10,3
8000335a:	32 bb       	mov	r11,43
8000335c:	0e 9c       	mov	r12,r7
8000335e:	f0 1f 00 11 	mcall	800033a0 <mcp2515_init+0x74>
	
	
	
	// set timing bits
	uint8_t cnf1RegisterSettings = SJW_LENGTH_1XTQ_bm | CAN_BAUD_RATE_PRESCALER;
	mcp2515_writeRegister(spi_dev, CNF1, cnf1RegisterSettings );
80003362:	30 0a       	mov	r10,0
80003364:	32 ab       	mov	r11,42
80003366:	0e 9c       	mov	r12,r7
80003368:	f0 1f 00 0e 	mcall	800033a0 <mcp2515_init+0x74>
	
	uint8_t cnf2RegisterSettings = PRSEG_2_bm | PHSEG1_1_bm | BTLMODE_1_bm; 
	mcp2515_writeRegister(spi_dev,CNF2,cnf2RegisterSettings);
8000336c:	e0 6a 00 8a 	mov	r10,138
80003370:	32 9b       	mov	r11,41
80003372:	0e 9c       	mov	r12,r7
80003374:	f0 1f 00 0b 	mcall	800033a0 <mcp2515_init+0x74>
	
	uint8_t cnf3RegisterSettings = 	PHSEG2_1_bm;
	mcp2515_writeRegister(spi_dev,CNF3,cnf3RegisterSettings);
80003378:	30 1a       	mov	r10,1
8000337a:	32 8b       	mov	r11,40
8000337c:	0e 9c       	mov	r12,r7
8000337e:	f0 1f 00 09 	mcall	800033a0 <mcp2515_init+0x74>
	
	
	
	
	mcp2515_setToMode(spi_dev,NORMAL);			// finish initializing
80003382:	30 0b       	mov	r11,0
80003384:	0e 9c       	mov	r12,r7
80003386:	f0 1f 00 08 	mcall	800033a4 <mcp2515_init+0x78>
	currentMode = mcp2515_getCurrentMode(spi_dev);
8000338a:	0e 9c       	mov	r12,r7
8000338c:	f0 1f 00 04 	mcall	8000339c <mcp2515_init+0x70>
80003390:	5f 0c       	sreq	r12
		return 0;
	}

	return 1;
	
}
80003392:	e3 cd 80 80 	ldm	sp++,r7,pc
80003396:	00 00       	add	r0,r0
80003398:	80 00       	ld.sh	r0,r0[0x0]
8000339a:	33 00       	mov	r0,48
8000339c:	80 00       	ld.sh	r0,r0[0x0]
8000339e:	32 a4       	mov	r4,42
800033a0:	80 00       	ld.sh	r0,r0[0x0]
800033a2:	32 b8       	mov	r8,43
800033a4:	80 00       	ld.sh	r0,r0[0x0]
800033a6:	31 fc       	mov	r12,31

800033a8 <mcp2515_getReceivedMessage>:
	interruptFlagRegister = mcp2515_readRegister(spi_dev, CANINTF );
	
	return interruptFlagRegister & ( 0b11 << 0 );
}

uint8_t mcp2515_getReceivedMessage ( struct spi_device * spi_dev, uint8_t bufferNum, uint8_t * data, uint8_t len ){
800033a8:	d4 21       	pushm	r4-r7,lr
800033aa:	18 95       	mov	r5,r12
800033ac:	16 97       	mov	r7,r11
800033ae:	14 94       	mov	r4,r10
	gpio_set_pin_low(LED1);
800033b0:	35 3c       	mov	r12,83
800033b2:	f0 1f 00 10 	mcall	800033f0 <mcp2515_getReceivedMessage+0x48>
	uint8_t messageAddress;
	uint8_t messageDLCAddress;
	uint8_t receivedMessageInterrupt_bm;

	switch(bufferNum){
800033b6:	58 07       	cp.w	r7,0
800033b8:	c0 a0       	breq	800033cc <mcp2515_getReceivedMessage+0x24>
800033ba:	30 18       	mov	r8,1
800033bc:	f0 07 18 00 	cp.b	r7,r8
800033c0:	c0 40       	breq	800033c8 <mcp2515_getReceivedMessage+0x20>
800033c2:	e0 66 00 ff 	mov	r6,255
800033c6:	c1 28       	rjmp	800033ea <mcp2515_getReceivedMessage+0x42>
800033c8:	37 5b       	mov	r11,117
800033ca:	c0 28       	rjmp	800033ce <mcp2515_getReceivedMessage+0x26>
800033cc:	36 5b       	mov	r11,101
			return 0xFF; //faulty call of function
	}
	
	
	//get DLC:
	uint8_t DLC =  mcp2515_readRegister(spi_dev, messageDLCAddress);
800033ce:	0a 9c       	mov	r12,r5
800033d0:	f0 1f 00 09 	mcall	800033f4 <mcp2515_getReceivedMessage+0x4c>
	DLC &= RX_DLC_BITS_bm;	// filter away any unwanted bits
800033d4:	ed dc c0 04 	bfextu	r6,r12,0x0,0x4
	
	// get Data:
	mcp2515_readRXbuffer(spi_dev,bufferNum,data,DLC);	
800033d8:	0c 99       	mov	r9,r6
800033da:	08 9a       	mov	r10,r4
800033dc:	0e 9b       	mov	r11,r7
800033de:	0a 9c       	mov	r12,r5
800033e0:	f0 1f 00 06 	mcall	800033f8 <mcp2515_getReceivedMessage+0x50>
	//mcp2515_read_array(spi_dev,data,DLC,messageAddress);
	
	
	//reset interrupt flag: (perhaps no longer needed due to the readRXbuffer function over - it should automatically reset the flag)
	//mcp2515_bitModifyRegister(spi_dev, CANINTF, receivedMessageInterrupt_bm,0x00);
	gpio_set_pin_high(LED1);
800033e4:	35 3c       	mov	r12,83
800033e6:	f0 1f 00 06 	mcall	800033fc <mcp2515_getReceivedMessage+0x54>
	return DLC;

}
800033ea:	0c 9c       	mov	r12,r6
800033ec:	d8 22       	popm	r4-r7,pc
800033ee:	00 00       	add	r0,r0
800033f0:	80 00       	ld.sh	r0,r0[0x0]
800033f2:	69 bc       	ld.w	r12,r4[0x6c]
800033f4:	80 00       	ld.sh	r0,r0[0x0]
800033f6:	32 48       	mov	r8,36
800033f8:	80 00       	ld.sh	r0,r0[0x0]
800033fa:	31 04       	mov	r4,16
800033fc:	80 00       	ld.sh	r0,r0[0x0]
800033fe:	69 a6       	ld.w	r6,r4[0x68]

80003400 <mcp2515_sendCanMessage>:
	spi_deselect_device(MCP2515_SPI_ADDRESS, spi_dev);
	return registerValue[0];
	
}

void mcp2515_sendCanMessage ( struct spi_device * spi_dev, uint8_t DLC, uint8_t * data, uint16_t address, uint8_t bufferNumber ){
80003400:	eb cd 40 fe 	pushm	r1-r7,lr
80003404:	18 97       	mov	r7,r12
80003406:	16 94       	mov	r4,r11
80003408:	14 93       	mov	r3,r10
8000340a:	12 95       	mov	r5,r9
8000340c:	10 96       	mov	r6,r8
	
	gpio_set_pin_low(LED2);
8000340e:	35 2c       	mov	r12,82
80003410:	f0 1f 00 1b 	mcall	8000347c <mcp2515_sendCanMessage+0x7c>
	uint8_t messageAddress;
	uint8_t messageDLCAddress;
	uint8_t dataAddress;
	uint8_t controlRegisterAddress;
	
	switch(bufferNumber){
80003414:	58 06       	cp.w	r6,0
80003416:	c0 a0       	breq	8000342a <mcp2515_sendCanMessage+0x2a>
80003418:	30 18       	mov	r8,1
8000341a:	f0 06 18 00 	cp.b	r6,r8
8000341e:	c2 c1       	brne	80003476 <mcp2515_sendCanMessage+0x76>
80003420:	34 01       	mov	r1,64
80003422:	34 62       	mov	r2,70
80003424:	34 5b       	mov	r11,69
80003426:	34 16       	mov	r6,65
80003428:	c0 58       	rjmp	80003432 <mcp2515_sendCanMessage+0x32>
8000342a:	33 01       	mov	r1,48
8000342c:	33 62       	mov	r2,54
8000342e:	33 5b       	mov	r11,53
80003430:	33 16       	mov	r6,49
	//	dataToSend[i] = data[i-5];
	//}
	//mcp2515_write_array(spi_dev,dataToSend,5+DLC,messageAddress);
	
	// Set up length of message
	mcp2515_writeRegister(spi_dev, messageDLCAddress, DLC );
80003432:	08 9a       	mov	r10,r4
80003434:	0e 9c       	mov	r12,r7
80003436:	f0 1f 00 13 	mcall	80003480 <mcp2515_sendCanMessage+0x80>
	
	// set up address
	uint8_t addressMSB = ( address >> 3);
	mcp2515_writeRegister(spi_dev, messageAddress, addressMSB );
8000343a:	f5 d5 c0 68 	bfextu	r10,r5,0x3,0x8
8000343e:	0c 9b       	mov	r11,r6
80003440:	0e 9c       	mov	r12,r7
80003442:	f0 1f 00 10 	mcall	80003480 <mcp2515_sendCanMessage+0x80>
	uint8_t addressLSB = (address << 5);
	mcp2515_writeRegister(spi_dev, messageAddress + 1 , addressLSB);
80003446:	ea 0a 15 05 	lsl	r10,r5,0x5
8000344a:	ec cb ff ff 	sub	r11,r6,-1
8000344e:	e2 1a 00 e0 	andl	r10,0xe0,COH
80003452:	5c 5b       	castu.b	r11
80003454:	0e 9c       	mov	r12,r7
80003456:	f0 1f 00 0b 	mcall	80003480 <mcp2515_sendCanMessage+0x80>
	
	// set up data
	
	mcp2515_write_array(spi_dev,data,DLC,dataAddress);
8000345a:	04 99       	mov	r9,r2
8000345c:	08 9a       	mov	r10,r4
8000345e:	06 9b       	mov	r11,r3
80003460:	0e 9c       	mov	r12,r7
80003462:	f0 1f 00 09 	mcall	80003484 <mcp2515_sendCanMessage+0x84>
	
	// Request data transmission, priority set to low
	uint8_t dataTransmissionSetting = MCP2515_CAN_MESSAGE_PRIORITY_HIGHEST_bm | MCP2515_CAN_TRANSMIT_REQUEST_bm;
	mcp2515_writeRegister (spi_dev, controlRegisterAddress, dataTransmissionSetting );
80003466:	30 ba       	mov	r10,11
80003468:	02 9b       	mov	r11,r1
8000346a:	0e 9c       	mov	r12,r7
8000346c:	f0 1f 00 05 	mcall	80003480 <mcp2515_sendCanMessage+0x80>
	gpio_set_pin_high(LED2);
80003470:	35 2c       	mov	r12,82
80003472:	f0 1f 00 06 	mcall	80003488 <mcp2515_sendCanMessage+0x88>
80003476:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
8000347a:	00 00       	add	r0,r0
8000347c:	80 00       	ld.sh	r0,r0[0x0]
8000347e:	69 bc       	ld.w	r12,r4[0x6c]
80003480:	80 00       	ld.sh	r0,r0[0x0]
80003482:	32 b8       	mov	r8,43
80003484:	80 00       	ld.sh	r0,r0[0x0]
80003486:	31 5c       	mov	r12,21
80003488:	80 00       	ld.sh	r0,r0[0x0]
8000348a:	69 a6       	ld.w	r6,r4[0x68]

8000348c <spi_init_module>:
	gpio_enable_module(MCP2515_SPI_GPIO_MAP,
	sizeof(MCP2515_SPI_GPIO_MAP) / sizeof(MCP2515_SPI_GPIO_MAP[0]));

}

struct spi_device spi_init_module(void) {
8000348c:	eb cd 40 c0 	pushm	r6-r7,lr
80003490:	20 1d       	sub	sp,4
	struct spi_device spi_device_conf = {
		.id = 0
	};
80003492:	fa c7 ff fc 	sub	r7,sp,-4
80003496:	30 08       	mov	r8,0
80003498:	0e f8       	st.b	--r7,r8
 * \brief Enable a module clock derived from the PBC clock
 * \param index Index of the module clock in the PBCMASK register
 */
static inline void sysclk_enable_pbc_module(unsigned int index)
{
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBC, index);
8000349a:	30 3b       	mov	r11,3
8000349c:	30 4c       	mov	r12,4
8000349e:	f0 1f 00 1b 	mcall	80003508 <spi_init_module+0x7c>
 * \param spi       Base address of the SPI instance.
 *
 */
static inline void spi_reset(volatile avr32_spi_t *spi)
{
	spi->cr = AVR32_SPI_CR_SWRST_MASK;
800034a2:	fc 76 18 00 	mov	r6,-190464
800034a6:	e0 68 00 80 	mov	r8,128
800034aa:	8d 08       	st.w	r6[0x0],r8
 *
 * \param spi         Base address of the SPI instance.
 */
static inline void spi_set_master_mode(volatile avr32_spi_t *spi)
{
	spi->MR.mstr = 1;
800034ac:	6c 18       	ld.w	r8,r6[0x4]
800034ae:	30 19       	mov	r9,1
800034b0:	f1 d9 d0 01 	bfins	r8,r9,0x0,0x1
800034b4:	8d 18       	st.w	r6[0x4],r8
 *
 * \param spi Base address of the SPI instance.
 */
static inline void spi_disable_modfault(volatile avr32_spi_t *spi)
{
	spi->MR.modfdis = 1;
800034b6:	6c 18       	ld.w	r8,r6[0x4]
800034b8:	f1 d9 d0 81 	bfins	r8,r9,0x4,0x1
800034bc:	8d 18       	st.w	r6[0x4],r8
 *
 * \param spi Base address of the SPI instance.
 */
static inline void spi_disable_loopback(volatile avr32_spi_t *spi)
{
	spi->MR.llb = 0;
800034be:	6c 18       	ld.w	r8,r6[0x4]
800034c0:	30 0a       	mov	r10,0
800034c2:	f1 da d0 e1 	bfins	r8,r10,0x7,0x1
800034c6:	8d 18       	st.w	r6[0x4],r8
 * \param chip_select Chip Select.
 */
static inline void spi_set_chipselect(volatile avr32_spi_t *spi,
		uint8_t chip_select)
{
	spi->MR.pcs = chip_select;
800034c8:	6c 18       	ld.w	r8,r6[0x4]
800034ca:	30 f9       	mov	r9,15
800034cc:	f1 d9 d2 04 	bfins	r8,r9,0x10,0x4
800034d0:	8d 18       	st.w	r6[0x4],r8
 *
 * \param spi         Base address of the SPI instance.
 */
static inline void spi_disable_variable_chipselect(volatile avr32_spi_t *spi)
{
	spi->MR.ps = 0;
800034d2:	6c 18       	ld.w	r8,r6[0x4]
800034d4:	f1 da d0 21 	bfins	r8,r10,0x1,0x1
800034d8:	8d 18       	st.w	r6[0x4],r8
 *
 * \param spi Base address of the SPI instance.
 */
static inline void spi_disable_chipselect_decoding(volatile avr32_spi_t *spi)
{
	spi->MR.pcsdec = 0;
800034da:	6c 18       	ld.w	r8,r6[0x4]
800034dc:	f1 da d0 41 	bfins	r8,r10,0x2,0x1
800034e0:	8d 18       	st.w	r6[0x4],r8
 * \param spi         Base address of the SPI instance.
 * \param delay       Delay.
 */
static inline void spi_set_delay(volatile avr32_spi_t *spi, uint8_t delay)
{
	spi->MR.dlybcs = delay;
800034e2:	6c 18       	ld.w	r8,r6[0x4]
800034e4:	f1 da d3 08 	bfins	r8,r10,0x18,0x8
800034e8:	8d 18       	st.w	r6[0x4],r8

	spi_master_init(SPI_ADRESS);
	spi_master_setup_device(SPI_ADRESS, &spi_device_conf, SPI_MODE_0, 1000000, 0);
800034ea:	14 98       	mov	r8,r10
800034ec:	ee 79 42 40 	mov	r9,1000000
800034f0:	0e 9b       	mov	r11,r7
800034f2:	0c 9c       	mov	r12,r6
800034f4:	f0 1f 00 06 	mcall	8000350c <spi_init_module+0x80>
	spi_enable(SPI_ADRESS);
800034f8:	0c 9c       	mov	r12,r6
800034fa:	f0 1f 00 06 	mcall	80003510 <spi_init_module+0x84>
	return spi_device_conf;
}
800034fe:	1b bc       	ld.ub	r12,sp[0x3]
80003500:	2f fd       	sub	sp,-4
80003502:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003506:	00 00       	add	r0,r0
80003508:	80 00       	ld.sh	r0,r0[0x0]
8000350a:	6c ec       	ld.w	r12,r6[0x38]
8000350c:	80 00       	ld.sh	r0,r0[0x0]
8000350e:	24 84       	sub	r4,72
80003510:	80 00       	ld.sh	r0,r0[0x0]
80003512:	20 24       	sub	r4,2

80003514 <spi_init_pins>:
	MCP2515_CMD_RTS = 0x80,
	MCP2515_CMD_READ_STATUS = 0xA0,
	MCP2515_CMD_BIT_MODIFY = 0x05,
} MCP2515_CMD_t;

void spi_init_pins(void) {
80003514:	d4 01       	pushm	lr
		{SPI_MOSI_PIN,	SPI_MOSI_FUNCTION},
		{SPI_CS_PIN,	SPI_CS_FUNCTION},
	};

	// Assign I/Os to SPI.
	gpio_enable_module(MCP2515_SPI_GPIO_MAP,
80003516:	30 5b       	mov	r11,5
80003518:	48 2c       	lddpc	r12,80003520 <spi_init_pins+0xc>
8000351a:	f0 1f 00 03 	mcall	80003524 <spi_init_pins+0x10>
	sizeof(MCP2515_SPI_GPIO_MAP) / sizeof(MCP2515_SPI_GPIO_MAP[0]));

}
8000351e:	d8 02       	popm	pc
80003520:	80 00       	ld.sh	r0,r0[0x0]
80003522:	80 00       	ld.sh	r0,r0[0x0]
80003524:	80 00       	ld.sh	r0,r0[0x0]
80003526:	68 30       	ld.w	r0,r4[0xc]

80003528 <fsm_ecu_init>:
#define SOFTWARE_TIMER_0_5_SEC		25
#define SOFTWARE_TIMER_1_SEC		50

static uint16_t attempts =	0;

void fsm_ecu_init(fsm_ecu_data_t *ecu_data) {
80003528:	eb cd 00 c0 	pushm	r6-r7
	ecu_data->state = STATE_STARTUP;
8000352c:	30 08       	mov	r8,0
8000352e:	99 08       	st.w	r12[0x0],r8
	ecu_data->inverter_can_msg = (inverter_can_msg_t){.data.u64 = 0x0LL, .dlc = 0};
80003530:	30 06       	mov	r6,0
80003532:	30 07       	mov	r7,0
80003534:	f8 e7 00 04 	st.d	r12[4],r6
80003538:	99 38       	st.w	r12[0xc],r8
	ecu_data->trq_sens0 = 0;
8000353a:	f9 58 00 10 	st.h	r12[16],r8
	ecu_data->trq_sens1 = 0;
8000353e:	f9 58 00 12 	st.h	r12[18],r8
	ecu_data->trq_pedal = 0;
80003542:	30 0a       	mov	r10,0
80003544:	99 8a       	st.w	r12[0x20],r10
	ecu_data->trq_sens0_err = 0;
80003546:	f9 68 00 14 	st.b	r12[20],r8
	ecu_data->trq_sens1_err = 0;
8000354a:	f9 68 00 15 	st.b	r12[21],r8
	ecu_data->trq_cmd = 0;
8000354e:	f9 58 00 16 	st.h	r12[22],r8
	ecu_data->traction_control_limit = MAX_TORQUE;
80003552:	e0 6b 7f f8 	mov	r11,32760
80003556:	f9 5b 00 18 	st.h	r12[24],r11
	ecu_data->control_u = 0;
8000355a:	99 7a       	st.w	r12[0x1c],r10
	ecu_data->dash_msg = (dash_can_msg_t){.data.u64 = 0x0LL, .id = 0};
8000355c:	f8 e7 00 24 	st.d	r12[36],r6
80003560:	99 b8       	st.w	r12[0x2c],r8
	ecu_data->bms_msg = (bms_can_msg_t){.data.u64 = 0x0LL, .id = 0};
80003562:	f8 e7 00 30 	st.d	r12[48],r6
80003566:	99 e8       	st.w	r12[0x38],r8
	ecu_data->vdc_battery = 0;
80003568:	f9 58 00 3c 	st.h	r12[60],r8
	ecu_data->inverter_vdc = 0;
8000356c:	f9 58 00 3e 	st.h	r12[62],r8
	ecu_data->rpm = 0;
80003570:	f9 58 00 40 	st.h	r12[64],r8
	ecu_data->motor_temp = 0;
80003574:	f9 58 00 42 	st.h	r12[66],r8
	ecu_data->inverter_temp = 0;
80003578:	f9 58 00 44 	st.h	r12[68],r8
	ecu_data->brake_front = 0;
8000357c:	f9 58 00 46 	st.h	r12[70],r8
	ecu_data->brake_rear = 0;
80003580:	f9 58 00 48 	st.h	r12[72],r8
	ecu_data->flag_start_precharge = 0;
80003584:	f9 68 00 4a 	st.b	r12[74],r8
	ecu_data->flag_brake_implausible = 0;
80003588:	f9 68 00 4b 	st.b	r12[75],r8
	ecu_data->max_cell_temp = 0;
8000358c:	f9 68 00 4c 	st.b	r12[76],r8
	ecu_data->flag_drive_enable = DRIVE_DISABLED;
80003590:	f9 48 00 50 	st.w	r12[80],r8
	ecu_data->arctos_mode = ARCTOS_MODE_NORMAL;
80003594:	f9 48 00 54 	st.w	r12[84],r8
	ecu_data->inverter_error = 0;
80003598:	f9 58 00 58 	st.h	r12[88],r8
	ecu_data->ecu_error = 0;
8000359c:	f9 58 00 5a 	st.h	r12[90],r8
	ecu_data->WFL_sens = 0;
800035a0:	f9 58 00 5c 	st.h	r12[92],r8
	ecu_data->WFR_sens = 0;
800035a4:	f9 58 00 5e 	st.h	r12[94],r8
	ecu_data->WRL_sens = 0;
800035a8:	f9 58 00 60 	st.h	r12[96],r8
	ecu_data->WRR_sens = 0;
800035ac:	f9 58 00 62 	st.h	r12[98],r8
	ecu_data->launch_control_flag = LAUNCH_CONTROL_INACTIVE;
800035b0:	f9 48 00 64 	st.w	r12[100],r8
	ecu_data->reboot = 0;
800035b4:	f9 68 00 68 	st.b	r12[104],r8
	ecu_data->config_max_trq = 100;
800035b8:	36 4b       	mov	r11,100
800035ba:	f9 6b 00 69 	st.b	r12[105],r11
	ecu_data->Kp = Kp_default;
800035be:	fc 1b 40 00 	movh	r11,0x4000
800035c2:	f9 4b 00 6c 	st.w	r12[108],r11
	ecu_data->Ki = Ki_default;
800035c6:	fc 1b 3f 80 	movh	r11,0x3f80
800035ca:	f9 4b 00 70 	st.w	r12[112],r11
	ecu_data->Kd = Kd_default;
800035ce:	f9 4a 00 74 	st.w	r12[116],r10
	ecu_data->d_filter_gain = D_FILTER_GAIN_DEFAULT;
800035d2:	f9 4b 00 7c 	st.w	r12[124],r11
	ecu_data->slip_target = 0;
800035d6:	f9 4a 00 78 	st.w	r12[120],r10
	ecu_data->inverter_timeout = 0;
800035da:	f9 68 00 80 	st.b	r12[128],r8
	ecu_data->lc_filter_gain = LC_FILTER_GAIN_DEFAULT;
800035de:	e0 6a 94 36 	mov	r10,37942
800035e2:	ea 1a 3c 57 	orh	r10,0x3c57
800035e6:	f9 4a 00 84 	st.w	r12[132],r10
	ecu_data->lc_trq_init = LC_TRQ_INIT_DEFAULT;
800035ea:	e0 6b 90 00 	mov	r11,36864
800035ee:	ea 1b 46 19 	orh	r11,0x4619
800035f2:	f9 4b 00 88 	st.w	r12[136],r11
	ecu_data->kers_factor = 0;
800035f6:	f9 58 00 8c 	st.h	r12[140],r8
	ecu_data->bms_current = 0;
800035fa:	f9 58 00 8e 	st.h	r12[142],r8
	ecu_data->slip = 0;
800035fe:	f9 58 00 90 	st.h	r12[144],r8
	ecu_data->speed_sens_alive[0] = 0;
80003602:	f9 68 00 92 	st.b	r12[146],r8
	ecu_data->speed_sens_alive[1] = 0;
80003606:	f9 68 00 93 	st.b	r12[147],r8
	ecu_data->speed_sens_alive[2] = 0;
8000360a:	f9 68 00 94 	st.b	r12[148],r8
}
8000360e:	e3 cd 00 c0 	ldm	sp++,r6-r7
80003612:	5e fc       	retal	r12

80003614 <fsm_ecu_run_state>:
	fsm_ecu_state_deactivate_launch_func,
	fsm_ecu_state_plausibility_error_func,
	fsm_ecu_state_error_func,
};

fsm_ecu_state_t fsm_ecu_run_state( fsm_ecu_state_t current_state, fsm_ecu_data_t *data) {
80003614:	d4 01       	pushm	lr
	return fsm_ecu_state_table[ current_state ]( data );
80003616:	48 48       	lddpc	r8,80003624 <fsm_ecu_run_state+0x10>
80003618:	f0 0c 03 28 	ld.w	r8,r8[r12<<0x2]
8000361c:	16 9c       	mov	r12,r11
8000361e:	5d 18       	icall	r8
};
80003620:	d8 02       	popm	pc
80003622:	00 00       	add	r0,r0
80003624:	80 00       	ld.sh	r0,r0[0x0]
80003626:	80 2c       	ld.sh	r12,r0[0x4]

80003628 <fsm_ecu_state_error_func>:
	return next_state;
};


	
fsm_ecu_state_t fsm_ecu_state_error_func( fsm_ecu_data_t *ecu_data ) {
80003628:	eb cd 40 80 	pushm	r7,lr
8000362c:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_ERROR;
	get_new_data(ecu_data);
8000362e:	f0 1f 00 12 	mcall	80003674 <fsm_ecu_state_error_func+0x4c>
	/* Disable AIR+ */
	gpio_set_pin_low(AIR_PLUS);
80003632:	30 4c       	mov	r12,4
80003634:	f0 1f 00 11 	mcall	80003678 <fsm_ecu_state_error_func+0x50>
	gpio_set_pin_low(FRG_PIN);
80003638:	30 9c       	mov	r12,9
8000363a:	f0 1f 00 10 	mcall	80003678 <fsm_ecu_state_error_func+0x50>
	gpio_set_pin_low(RFE_PIN);
8000363e:	31 0c       	mov	r12,16
80003640:	f0 1f 00 0e 	mcall	80003678 <fsm_ecu_state_error_func+0x50>
	ecu_data->trq_cmd = 0x0;
80003644:	30 08       	mov	r8,0
80003646:	ef 58 00 16 	st.h	r7[22],r8
	ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
8000364a:	30 0c       	mov	r12,0
8000364c:	f0 1f 00 0c 	mcall	8000367c <fsm_ecu_state_error_func+0x54>
	
	if (ecu_data->reboot == 1) {
80003650:	ef 39 00 68 	ld.ub	r9,r7[104]
80003654:	30 18       	mov	r8,1
80003656:	f0 09 18 00 	cp.b	r9,r8
8000365a:	c0 40       	breq	80003662 <fsm_ecu_state_error_func+0x3a>
8000365c:	30 8c       	mov	r12,8
8000365e:	e3 cd 80 80 	ldm	sp++,r7,pc
		ecu_data->reboot = 0;
80003662:	30 08       	mov	r8,0
80003664:	ef 68 00 68 	st.b	r7[104],r8
		fsm_ecu_init(ecu_data); // Reinitialize data struct
80003668:	0e 9c       	mov	r12,r7
8000366a:	f0 1f 00 06 	mcall	80003680 <fsm_ecu_state_error_func+0x58>
8000366e:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
80003672:	00 00       	add	r0,r0
80003674:	80 00       	ld.sh	r0,r0[0x0]
80003676:	43 20       	lddsp	r0,sp[0xc8]
80003678:	80 00       	ld.sh	r0,r0[0x0]
8000367a:	69 bc       	ld.w	r12,r4[0x6c]
8000367c:	80 00       	ld.sh	r0,r0[0x0]
8000367e:	2a c8       	sub	r8,-84
80003680:	80 00       	ld.sh	r0,r0[0x0]
80003682:	35 28       	mov	r8,82

80003684 <fsm_ecu_state_plausibility_error_func>:
		ecu_can_send_ready_to_drive();
		return STATE_READY;
	}
}

fsm_ecu_state_t fsm_ecu_state_plausibility_error_func( fsm_ecu_data_t *ecu_data ) {
80003684:	eb cd 40 c0 	pushm	r6-r7,lr
80003688:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_PLAUSIBILITY_ERROR;

	get_new_data(ecu_data);
8000368a:	f0 1f 00 1b 	mcall	800036f4 <fsm_ecu_state_plausibility_error_func+0x70>
	get_trq_sens(ecu_data);
8000368e:	0e 9c       	mov	r12,r7
80003690:	f0 1f 00 1a 	mcall	800036f8 <fsm_ecu_state_plausibility_error_func+0x74>

	if ( torque_plausibility_check(ecu_data) == true ) {
80003694:	0e 9c       	mov	r12,r7
80003696:	f0 1f 00 1a 	mcall	800036fc <fsm_ecu_state_plausibility_error_func+0x78>
8000369a:	c2 30       	breq	800036e0 <fsm_ecu_state_plausibility_error_func+0x5c>
		if (ecu_data->flag_brake_implausible) {
8000369c:	ef 39 00 4b 	ld.ub	r9,r7[75]
800036a0:	30 08       	mov	r8,0
800036a2:	f0 09 18 00 	cp.b	r9,r8
800036a6:	c1 30       	breq	800036cc <fsm_ecu_state_plausibility_error_func+0x48>
			/* Can return to normal state if pedal travel < 5% (pedal = <0,1000>) */
			if (max(ecu_data->trq_sens0, ecu_data->trq_sens1) < 50) {
800036a8:	ef 08 00 10 	ld.sh	r8,r7[16]
800036ac:	ef 09 00 12 	ld.sh	r9,r7[18]
800036b0:	f0 09 0c 48 	max	r8,r8,r9
800036b4:	e0 48 00 31 	cp.w	r8,49
800036b8:	e0 89 00 14 	brgt	800036e0 <fsm_ecu_state_plausibility_error_func+0x5c>
				ecu_data->flag_brake_implausible = 0;
800036bc:	30 08       	mov	r8,0
800036be:	ef 68 00 4b 	st.b	r7[75],r8
				gpio_set_pin_high(FRG_PIN);
800036c2:	30 9c       	mov	r12,9
800036c4:	f0 1f 00 0f 	mcall	80003700 <fsm_ecu_state_plausibility_error_func+0x7c>
800036c8:	30 36       	mov	r6,3
800036ca:	c0 c8       	rjmp	800036e2 <fsm_ecu_state_plausibility_error_func+0x5e>
				next_state = STATE_READY;
			}
		} else {
			gpio_set_pin_high(FRG_PIN);
800036cc:	30 9c       	mov	r12,9
800036ce:	f0 1f 00 0d 	mcall	80003700 <fsm_ecu_state_plausibility_error_func+0x7c>
			if (ecu_data->launch_control_flag == LAUNCH_CONTROL_ACTIVE) {
800036d2:	6f 96       	ld.w	r6,r7[0x64]
800036d4:	58 36       	cp.w	r6,3
800036d6:	f9 b6 00 05 	moveq	r6,5
800036da:	f9 b6 01 03 	movne	r6,3
800036de:	c0 28       	rjmp	800036e2 <fsm_ecu_state_plausibility_error_func+0x5e>
800036e0:	30 76       	mov	r6,7
			} else {
				next_state = STATE_READY;	
			}
		}
	}
	ecu_data->trq_cmd = 0x0;
800036e2:	30 08       	mov	r8,0
800036e4:	ef 58 00 16 	st.h	r7[22],r8
	ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
800036e8:	30 0c       	mov	r12,0
800036ea:	f0 1f 00 07 	mcall	80003704 <fsm_ecu_state_plausibility_error_func+0x80>
	return next_state;
};
800036ee:	0c 9c       	mov	r12,r6
800036f0:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800036f4:	80 00       	ld.sh	r0,r0[0x0]
800036f6:	43 20       	lddsp	r0,sp[0xc8]
800036f8:	80 00       	ld.sh	r0,r0[0x0]
800036fa:	43 e0       	lddsp	r0,sp[0xf8]
800036fc:	80 00       	ld.sh	r0,r0[0x0]
800036fe:	3e 8c       	mov	r12,-24
80003700:	80 00       	ld.sh	r0,r0[0x0]
80003702:	69 a6       	ld.w	r6,r4[0x68]
80003704:	80 00       	ld.sh	r0,r0[0x0]
80003706:	2a c8       	sub	r8,-84

80003708 <fsm_ecu_state_deactivate_launch_func>:
	}
	
	return next_state;
}

fsm_ecu_state_t fsm_ecu_state_deactivate_launch_func( fsm_ecu_data_t *ecu_data ) {
80003708:	d4 01       	pushm	lr
	//Wait for 5 seconds before returning to ready state
	static uint8_t timer = 0;
	if (timer < SOFTWARE_TIMER_5_SEC) {
8000370a:	48 d8       	lddpc	r8,8000373c <fsm_ecu_state_deactivate_launch_func+0x34>
8000370c:	11 88       	ld.ub	r8,r8[0x0]
8000370e:	3f 99       	mov	r9,-7
80003710:	f2 08 18 00 	cp.b	r8,r9
80003714:	e0 8b 00 0d 	brhi	8000372e <fsm_ecu_state_deactivate_launch_func+0x26>
		timer++;
80003718:	2f f8       	sub	r8,-1
8000371a:	48 99       	lddpc	r9,8000373c <fsm_ecu_state_deactivate_launch_func+0x34>
8000371c:	b2 88       	st.b	r9[0x0],r8
		ecu_data->trq_cmd = 0;
8000371e:	30 08       	mov	r8,0
80003720:	f9 58 00 16 	st.h	r12[22],r8
		ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
80003724:	30 0c       	mov	r12,0
80003726:	f0 1f 00 07 	mcall	80003740 <fsm_ecu_state_deactivate_launch_func+0x38>
8000372a:	30 6c       	mov	r12,6
		return STATE_DEACTIVATE_LAUNCH;
8000372c:	d8 02       	popm	pc
	} else {
		timer = 0;
8000372e:	30 09       	mov	r9,0
80003730:	48 38       	lddpc	r8,8000373c <fsm_ecu_state_deactivate_launch_func+0x34>
80003732:	b0 89       	st.b	r8[0x0],r9
		ecu_can_send_ready_to_drive();
80003734:	f0 1f 00 04 	mcall	80003744 <fsm_ecu_state_deactivate_launch_func+0x3c>
80003738:	30 3c       	mov	r12,3
		return STATE_READY;
	}
}
8000373a:	d8 02       	popm	pc
8000373c:	00 00       	add	r0,r0
8000373e:	cc 0c       	rcall	800038be <fsm_ecu_state_init_launch_func+0x7e>
80003740:	80 00       	ld.sh	r0,r0[0x0]
80003742:	2a c8       	sub	r8,-84
80003744:	80 00       	ld.sh	r0,r0[0x0]
80003746:	29 60       	sub	r0,-106

80003748 <fsm_ecu_state_launch_control_func>:
	}
	
	return next_state;
}	

fsm_ecu_state_t fsm_ecu_state_launch_control_func( fsm_ecu_data_t *ecu_data ) {
80003748:	eb cd 40 80 	pushm	r7,lr
8000374c:	18 97       	mov	r7,r12
	int16_t trq_min = 0;
	static uint16_t activation_timer = 0;
	fsm_ecu_state_t next_state = STATE_LAUNCH_CONTROL;
	
	get_new_data(ecu_data);
8000374e:	f0 1f 00 35 	mcall	80003820 <fsm_ecu_state_launch_control_func+0xd8>
	get_trq_sens(ecu_data);
80003752:	0e 9c       	mov	r12,r7
80003754:	f0 1f 00 34 	mcall	80003824 <fsm_ecu_state_launch_control_func+0xdc>
	
	if (torque_plausibility_check(ecu_data)) {
80003758:	0e 9c       	mov	r12,r7
8000375a:	f0 1f 00 34 	mcall	80003828 <fsm_ecu_state_launch_control_func+0xe0>
8000375e:	c4 80       	breq	800037ee <fsm_ecu_state_launch_control_func+0xa6>
		trq_min = min(ecu_data->trq_sens0, ecu_data->trq_sens1);
80003760:	ef 08 00 10 	ld.sh	r8,r7[16]
80003764:	ef 09 00 12 	ld.sh	r9,r7[18]
80003768:	f0 09 0d 49 	min	r9,r8,r9
		if (trq_min > 500) {
8000376c:	e0 68 01 f4 	mov	r8,500
80003770:	f0 09 19 00 	cp.h	r9,r8
80003774:	e0 8a 00 23 	brle	800037ba <fsm_ecu_state_launch_control_func+0x72>
			switch (ecu_data->launch_control_flag) {
80003778:	6f 98       	ld.w	r8,r7[0x64]
8000377a:	58 28       	cp.w	r8,2
8000377c:	c0 d0       	breq	80003796 <fsm_ecu_state_launch_control_func+0x4e>
8000377e:	58 38       	cp.w	r8,3
80003780:	c1 40       	breq	800037a8 <fsm_ecu_state_launch_control_func+0x60>
80003782:	58 18       	cp.w	r8,1
80003784:	c0 30       	breq	8000378a <fsm_ecu_state_launch_control_func+0x42>
80003786:	30 5c       	mov	r12,5
80003788:	c3 d8       	rjmp	80003802 <fsm_ecu_state_launch_control_func+0xba>
				case LAUNCH_CONTROL_INITIATE:
				activation_timer++;
8000378a:	4a 98       	lddpc	r8,8000382c <fsm_ecu_state_launch_control_func+0xe4>
8000378c:	90 09       	ld.sh	r9,r8[0x0]
8000378e:	2f f9       	sub	r9,-1
80003790:	b0 09       	st.h	r8[0x0],r9
80003792:	30 5c       	mov	r12,5
				break;
80003794:	c3 78       	rjmp	80003802 <fsm_ecu_state_launch_control_func+0xba>
				
				case LAUNCH_CONTROL_COUNTDOWN_COMPLETE:
				ecu_data->launch_control_flag = LAUNCH_CONTROL_ACTIVE;
80003796:	30 38       	mov	r8,3
80003798:	ef 48 00 64 	st.w	r7[100],r8
				activation_timer = 0;	
8000379c:	30 09       	mov	r9,0
8000379e:	4a 48       	lddpc	r8,8000382c <fsm_ecu_state_launch_control_func+0xe4>
800037a0:	b0 09       	st.h	r8[0x0],r9
800037a2:	30 5c       	mov	r12,5
				break;
800037a4:	e3 cd 80 80 	ldm	sp++,r7,pc
				
				case LAUNCH_CONTROL_ACTIVE:
				launch_control(ecu_data);
800037a8:	0e 9c       	mov	r12,r7
800037aa:	f0 1f 00 22 	mcall	80003830 <fsm_ecu_state_launch_control_func+0xe8>
				ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
800037ae:	ef 0c 00 16 	ld.sh	r12,r7[22]
800037b2:	f0 1f 00 21 	mcall	80003834 <fsm_ecu_state_launch_control_func+0xec>
800037b6:	30 5c       	mov	r12,5
800037b8:	c2 58       	rjmp	80003802 <fsm_ecu_state_launch_control_func+0xba>
				default:
				break;	
			}
		} else {
			// Exit launch control
			switch (ecu_data->launch_control_flag) {
800037ba:	6f 98       	ld.w	r8,r7[0x64]
800037bc:	58 18       	cp.w	r8,1
800037be:	c0 40       	breq	800037c6 <fsm_ecu_state_launch_control_func+0x7e>
800037c0:	58 38       	cp.w	r8,3
800037c2:	c0 f1       	brne	800037e0 <fsm_ecu_state_launch_control_func+0x98>
800037c4:	c0 88       	rjmp	800037d4 <fsm_ecu_state_launch_control_func+0x8c>
				case LAUNCH_CONTROL_INITIATE:
					activation_timer = 0;
800037c6:	30 09       	mov	r9,0
800037c8:	49 98       	lddpc	r8,8000382c <fsm_ecu_state_launch_control_func+0xe4>
800037ca:	b0 09       	st.h	r8[0x0],r9
					ecu_can_send_launch_stop();
800037cc:	f0 1f 00 1b 	mcall	80003838 <fsm_ecu_state_launch_control_func+0xf0>
800037d0:	30 6c       	mov	r12,6
					next_state = STATE_DEACTIVATE_LAUNCH;
					break;
800037d2:	c1 88       	rjmp	80003802 <fsm_ecu_state_launch_control_func+0xba>
				case LAUNCH_CONTROL_ACTIVE:
					activation_timer = 0;
800037d4:	30 09       	mov	r9,0
800037d6:	49 68       	lddpc	r8,8000382c <fsm_ecu_state_launch_control_func+0xe4>
800037d8:	b0 09       	st.h	r8[0x0],r9
800037da:	30 3c       	mov	r12,3
					next_state = STATE_READY;
					break;
800037dc:	e3 cd 80 80 	ldm	sp++,r7,pc
				default:
					activation_timer = 0;
800037e0:	30 09       	mov	r9,0
800037e2:	49 38       	lddpc	r8,8000382c <fsm_ecu_state_launch_control_func+0xe4>
800037e4:	b0 09       	st.h	r8[0x0],r9
					ecu_can_send_launch_stop();
800037e6:	f0 1f 00 15 	mcall	80003838 <fsm_ecu_state_launch_control_func+0xf0>
800037ea:	30 6c       	mov	r12,6
800037ec:	c0 b8       	rjmp	80003802 <fsm_ecu_state_launch_control_func+0xba>
					break;
			}	
		}
	} else {
		//Torque sensor implausibility
		ecu_data->trq_cmd = 0;
800037ee:	30 08       	mov	r8,0
800037f0:	ef 58 00 16 	st.h	r7[22],r8
		ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
800037f4:	30 0c       	mov	r12,0
800037f6:	f0 1f 00 10 	mcall	80003834 <fsm_ecu_state_launch_control_func+0xec>
		gpio_set_pin_low(FRG_PIN);
800037fa:	30 9c       	mov	r12,9
800037fc:	f0 1f 00 10 	mcall	8000383c <fsm_ecu_state_launch_control_func+0xf4>
80003800:	30 7c       	mov	r12,7
		next_state = STATE_PLAUSIBILITY_ERROR;	
	}
	
	if (activation_timer == SOFTWARE_TIMER_10_SEC) {
80003802:	48 b8       	lddpc	r8,8000382c <fsm_ecu_state_launch_control_func+0xe4>
80003804:	90 09       	ld.sh	r9,r8[0x0]
80003806:	e0 68 01 f4 	mov	r8,500
8000380a:	f0 09 19 00 	cp.h	r9,r8
8000380e:	c0 71       	brne	8000381c <fsm_ecu_state_launch_control_func+0xd4>
		activation_timer = 0;
80003810:	30 09       	mov	r9,0
80003812:	48 78       	lddpc	r8,8000382c <fsm_ecu_state_launch_control_func+0xe4>
80003814:	b0 09       	st.h	r8[0x0],r9
		ecu_can_send_launch_stop();
80003816:	f0 1f 00 09 	mcall	80003838 <fsm_ecu_state_launch_control_func+0xf0>
8000381a:	30 6c       	mov	r12,6
		next_state = STATE_DEACTIVATE_LAUNCH;
	}
	
	return next_state;
}
8000381c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003820:	80 00       	ld.sh	r0,r0[0x0]
80003822:	43 20       	lddsp	r0,sp[0xc8]
80003824:	80 00       	ld.sh	r0,r0[0x0]
80003826:	43 e0       	lddsp	r0,sp[0xf8]
80003828:	80 00       	ld.sh	r0,r0[0x0]
8000382a:	3e 8c       	mov	r12,-24
8000382c:	00 00       	add	r0,r0
8000382e:	cc 08       	rjmp	800039ae <fsm_ecu_state_ready_func+0xba>
80003830:	80 00       	ld.sh	r0,r0[0x0]
80003832:	45 94       	lddsp	r4,sp[0x164]
80003834:	80 00       	ld.sh	r0,r0[0x0]
80003836:	2a c8       	sub	r8,-84
80003838:	80 00       	ld.sh	r0,r0[0x0]
8000383a:	28 40       	sub	r0,-124
8000383c:	80 00       	ld.sh	r0,r0[0x0]
8000383e:	69 bc       	ld.w	r12,r4[0x6c]

80003840 <fsm_ecu_state_init_launch_func>:
 	ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
 	
	return next_state;
};

fsm_ecu_state_t fsm_ecu_state_init_launch_func( fsm_ecu_data_t *ecu_data ) {	
80003840:	eb cd 40 80 	pushm	r7,lr
80003844:	18 97       	mov	r7,r12
	static uint16_t activation_timer = 0;
	static uint8_t verification_timer = 0;
	int16_t trq_min = 0;
	fsm_ecu_state_t next_state = STATE_INIT_LAUNCH;
	
	get_new_data(ecu_data);
80003846:	f0 1f 00 25 	mcall	800038d8 <fsm_ecu_state_init_launch_func+0x98>
	get_trq_sens(ecu_data);
8000384a:	0e 9c       	mov	r12,r7
8000384c:	f0 1f 00 24 	mcall	800038dc <fsm_ecu_state_init_launch_func+0x9c>
	if (torque_plausibility_check(ecu_data)) {
80003850:	0e 9c       	mov	r12,r7
80003852:	f0 1f 00 24 	mcall	800038e0 <fsm_ecu_state_init_launch_func+0xa0>
80003856:	c0 31       	brne	8000385c <fsm_ecu_state_init_launch_func+0x1c>
80003858:	30 4c       	mov	r12,4
8000385a:	c2 a8       	rjmp	800038ae <fsm_ecu_state_init_launch_func+0x6e>
		trq_min = min(ecu_data->trq_sens0, ecu_data->trq_sens1);
8000385c:	ef 08 00 10 	ld.sh	r8,r7[16]
80003860:	ef 09 00 12 	ld.sh	r9,r7[18]
80003864:	f0 09 0d 49 	min	r9,r8,r9
		if (trq_min > 500) {
80003868:	e0 68 01 f4 	mov	r8,500
8000386c:	f0 09 19 00 	cp.h	r9,r8
80003870:	e0 8a 00 17 	brle	8000389e <fsm_ecu_state_init_launch_func+0x5e>
			if (verification_timer < SOFTWARE_TIMER_0_5_SEC) {
80003874:	49 c8       	lddpc	r8,800038e4 <fsm_ecu_state_init_launch_func+0xa4>
80003876:	11 88       	ld.ub	r8,r8[0x0]
80003878:	31 89       	mov	r9,24
8000387a:	f2 08 18 00 	cp.b	r8,r9
8000387e:	e0 8b 00 07 	brhi	8000388c <fsm_ecu_state_init_launch_func+0x4c>
				verification_timer++;
80003882:	2f f8       	sub	r8,-1
80003884:	49 89       	lddpc	r9,800038e4 <fsm_ecu_state_init_launch_func+0xa4>
80003886:	b2 88       	st.b	r9[0x0],r8
80003888:	30 4c       	mov	r12,4
8000388a:	c1 28       	rjmp	800038ae <fsm_ecu_state_init_launch_func+0x6e>
			} else {
				activation_timer = 0;
8000388c:	30 08       	mov	r8,0
8000388e:	49 79       	lddpc	r9,800038e8 <fsm_ecu_state_init_launch_func+0xa8>
80003890:	b2 08       	st.h	r9[0x0],r8
				verification_timer = 0;
				//Pedals has been > 500 for 0.5 sec
				verification_timer = 0;
80003892:	49 59       	lddpc	r9,800038e4 <fsm_ecu_state_init_launch_func+0xa4>
80003894:	b2 88       	st.b	r9[0x0],r8
				ecu_can_send_launch_ready();
80003896:	f0 1f 00 16 	mcall	800038ec <fsm_ecu_state_init_launch_func+0xac>
8000389a:	30 5c       	mov	r12,5
8000389c:	c0 98       	rjmp	800038ae <fsm_ecu_state_init_launch_func+0x6e>
				next_state = STATE_LAUNCH_CONTROL;
			}
		} else {
			verification_timer = 0;
8000389e:	30 09       	mov	r9,0
800038a0:	49 18       	lddpc	r8,800038e4 <fsm_ecu_state_init_launch_func+0xa4>
800038a2:	b0 89       	st.b	r8[0x0],r9
			activation_timer++;
800038a4:	49 18       	lddpc	r8,800038e8 <fsm_ecu_state_init_launch_func+0xa8>
800038a6:	90 09       	ld.sh	r9,r8[0x0]
800038a8:	2f f9       	sub	r9,-1
800038aa:	b0 09       	st.h	r8[0x0],r9
800038ac:	30 4c       	mov	r12,4
		}
	}
	
	if (activation_timer == SOFTWARE_TIMER_10_SEC) {
800038ae:	48 f8       	lddpc	r8,800038e8 <fsm_ecu_state_init_launch_func+0xa8>
800038b0:	90 09       	ld.sh	r9,r8[0x0]
800038b2:	e0 68 01 f4 	mov	r8,500
800038b6:	f0 09 19 00 	cp.h	r9,r8
800038ba:	c0 c1       	brne	800038d2 <fsm_ecu_state_init_launch_func+0x92>
		activation_timer = 0;
800038bc:	30 08       	mov	r8,0
800038be:	48 b9       	lddpc	r9,800038e8 <fsm_ecu_state_init_launch_func+0xa8>
800038c0:	b2 08       	st.h	r9[0x0],r8
		verification_timer = 0;
800038c2:	48 99       	lddpc	r9,800038e4 <fsm_ecu_state_init_launch_func+0xa4>
800038c4:	b2 88       	st.b	r9[0x0],r8
		ecu_can_send_launch_stop();
800038c6:	f0 1f 00 0b 	mcall	800038f0 <fsm_ecu_state_init_launch_func+0xb0>
		ecu_data->launch_control_flag = LAUNCH_CONTROL_INACTIVE;
800038ca:	30 08       	mov	r8,0
800038cc:	ef 48 00 64 	st.w	r7[100],r8
800038d0:	30 6c       	mov	r12,6
		next_state = STATE_DEACTIVATE_LAUNCH;
	}
	
	return next_state;
}	
800038d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800038d6:	00 00       	add	r0,r0
800038d8:	80 00       	ld.sh	r0,r0[0x0]
800038da:	43 20       	lddsp	r0,sp[0xc8]
800038dc:	80 00       	ld.sh	r0,r0[0x0]
800038de:	43 e0       	lddsp	r0,sp[0xf8]
800038e0:	80 00       	ld.sh	r0,r0[0x0]
800038e2:	3e 8c       	mov	r12,-24
800038e4:	00 00       	add	r0,r0
800038e6:	cc 12       	brcc	80003868 <fsm_ecu_state_init_launch_func+0x28>
800038e8:	00 00       	add	r0,r0
800038ea:	cc 0e       	rcall	8000366a <fsm_ecu_state_error_func+0x42>
800038ec:	80 00       	ld.sh	r0,r0[0x0]
800038ee:	28 80       	sub	r0,-120
800038f0:	80 00       	ld.sh	r0,r0[0x0]
800038f2:	28 40       	sub	r0,-124

800038f4 <fsm_ecu_state_ready_func>:
	
	return next_state;
};
	
	
fsm_ecu_state_t fsm_ecu_state_ready_func( fsm_ecu_data_t *ecu_data ) {
800038f4:	eb cd 40 c0 	pushm	r6-r7,lr
800038f8:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_READY;
	int16_t kers = 0;
	
	get_new_data(ecu_data);
800038fa:	f0 1f 00 49 	mcall	80003a1c <fsm_ecu_state_ready_func+0x128>
	get_trq_sens(ecu_data);
800038fe:	0e 9c       	mov	r12,r7
80003900:	f0 1f 00 48 	mcall	80003a20 <fsm_ecu_state_ready_func+0x12c>
	get_speed_sens(ecu_data);
80003904:	0e 9c       	mov	r12,r7
80003906:	f0 1f 00 48 	mcall	80003a24 <fsm_ecu_state_ready_func+0x130>
	get_brake_sens(ecu_data);
8000390a:	0e 9c       	mov	r12,r7
8000390c:	f0 1f 00 47 	mcall	80003a28 <fsm_ecu_state_ready_func+0x134>
	
	if (ecu_data->flag_drive_enable == DRIVE_DISABLE_REQUEST) {
80003910:	6f 48       	ld.w	r8,r7[0x50]
80003912:	58 48       	cp.w	r8,4
80003914:	c0 b1       	brne	8000392a <fsm_ecu_state_ready_func+0x36>
		gpio_set_pin_low(FRG_PIN);
80003916:	30 9c       	mov	r12,9
80003918:	f0 1f 00 45 	mcall	80003a2c <fsm_ecu_state_ready_func+0x138>
		ecu_data->flag_drive_enable = DRIVE_DISABLED;
8000391c:	30 08       	mov	r8,0
8000391e:	ef 48 00 50 	st.w	r7[80],r8
		ecu_can_send_drive_disabled();
80003922:	f0 1f 00 44 	mcall	80003a30 <fsm_ecu_state_ready_func+0x13c>
80003926:	30 16       	mov	r6,1
		return STATE_CHARGED;
80003928:	c7 78       	rjmp	80003a16 <fsm_ecu_state_ready_func+0x122>
	}
	
	if (ecu_data->inverter_vdc < 50) {
8000392a:	ef 09 00 3e 	ld.sh	r9,r7[62]
8000392e:	33 18       	mov	r8,49
80003930:	f0 09 19 00 	cp.h	r9,r8
80003934:	e0 8b 00 13 	brhi	8000395a <fsm_ecu_state_ready_func+0x66>
		gpio_set_pin_low(FRG_PIN);
80003938:	30 9c       	mov	r12,9
8000393a:	f0 1f 00 3d 	mcall	80003a2c <fsm_ecu_state_ready_func+0x138>
		gpio_set_pin_low(RFE_PIN);
8000393e:	31 0c       	mov	r12,16
80003940:	f0 1f 00 3b 	mcall	80003a2c <fsm_ecu_state_ready_func+0x138>
		gpio_set_pin_low(AIR_PLUS);
80003944:	30 4c       	mov	r12,4
80003946:	f0 1f 00 3a 	mcall	80003a2c <fsm_ecu_state_ready_func+0x138>
		ecu_can_send_drive_disabled();
8000394a:	f0 1f 00 3a 	mcall	80003a30 <fsm_ecu_state_ready_func+0x13c>
		ecu_data->flag_drive_enable = DRIVE_DISABLED;
8000394e:	30 06       	mov	r6,0
80003950:	ef 46 00 50 	st.w	r7[80],r6
		ecu_data->flag_start_precharge = 0;
80003954:	ef 66 00 4a 	st.b	r7[74],r6

		return STATE_STARTUP;
80003958:	c5 f8       	rjmp	80003a16 <fsm_ecu_state_ready_func+0x122>
// 			ecu_can_confirm_activate_launch();
// 			return STATE_INIT_LAUNCH;
// 		} 	
// 	}
	
	uint8_t bspd = check_bspd();
8000395a:	f0 1f 00 37 	mcall	80003a34 <fsm_ecu_state_ready_func+0x140>
8000395e:	18 96       	mov	r6,r12
	
	/* First set trq_cmd to 0. Will be updated if the following tests are passed. 
	 * If not, the motor will be disabled and zero torque requested (stored in inverter?). 
	 * When transitioning from plausibility error state to ready state, the zero command
	 * stored in inverter memory will be used (it may also be zero by default) */
 	ecu_data->trq_cmd = 0;
80003960:	30 08       	mov	r8,0
80003962:	ef 58 00 16 	st.h	r7[22],r8
	if ( bspd == BSPD_SIGNAL_LOSS_WARNING ) {
80003966:	34 28       	mov	r8,66
80003968:	f0 0c 18 00 	cp.b	r12,r8
8000396c:	c1 11       	brne	8000398e <fsm_ecu_state_ready_func+0x9a>
		gpio_set_pin_low(RFE_PIN);
8000396e:	31 0c       	mov	r12,16
80003970:	f0 1f 00 2f 	mcall	80003a2c <fsm_ecu_state_ready_func+0x138>
		gpio_set_pin_low(FRG_PIN);
80003974:	30 9c       	mov	r12,9
80003976:	f0 1f 00 2e 	mcall	80003a2c <fsm_ecu_state_ready_func+0x138>
		gpio_set_pin_low(AIR_PLUS);
8000397a:	30 4c       	mov	r12,4
8000397c:	f0 1f 00 2c 	mcall	80003a2c <fsm_ecu_state_ready_func+0x138>
		ecu_data->ecu_error |= (1 << ERR_BSPD);
80003980:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003984:	a9 a8       	sbr	r8,0x8
80003986:	ef 58 00 5a 	st.h	r7[90],r8
8000398a:	30 86       	mov	r6,8
8000398c:	c4 18       	rjmp	80003a0e <fsm_ecu_state_ready_func+0x11a>
		next_state = STATE_ERROR;
		
 	} else if ( torque_plausibility_check(ecu_data) == false ) {
8000398e:	0e 9c       	mov	r12,r7
80003990:	f0 1f 00 2a 	mcall	80003a38 <fsm_ecu_state_ready_func+0x144>
80003994:	c0 61       	brne	800039a0 <fsm_ecu_state_ready_func+0xac>
 		/* Deviation > 10 %. Shut down power to motor */
 		gpio_set_pin_low(FRG_PIN);
80003996:	30 9c       	mov	r12,9
80003998:	f0 1f 00 25 	mcall	80003a2c <fsm_ecu_state_ready_func+0x138>
8000399c:	30 76       	mov	r6,7
8000399e:	c3 88       	rjmp	80003a0e <fsm_ecu_state_ready_func+0x11a>
 		next_state = STATE_PLAUSIBILITY_ERROR;
		 
 	} else if ((brake_plausibility_check(ecu_data) == false) || (bspd == BSPD_PLAUSIBILITY_OCCURED)) {
800039a0:	0e 9c       	mov	r12,r7
800039a2:	f0 1f 00 27 	mcall	80003a3c <fsm_ecu_state_ready_func+0x148>
800039a6:	c0 50       	breq	800039b0 <fsm_ecu_state_ready_func+0xbc>
800039a8:	39 98       	mov	r8,-103
800039aa:	f0 06 18 00 	cp.b	r6,r8
800039ae:	c0 91       	brne	800039c0 <fsm_ecu_state_ready_func+0xcc>
 		gpio_set_pin_low(FRG_PIN);
800039b0:	30 9c       	mov	r12,9
800039b2:	f0 1f 00 1f 	mcall	80003a2c <fsm_ecu_state_ready_func+0x138>
 		ecu_data->flag_brake_implausible = 1;
800039b6:	30 18       	mov	r8,1
800039b8:	ef 68 00 4b 	st.b	r7[75],r8
800039bc:	30 76       	mov	r6,7
 	} else if ( torque_plausibility_check(ecu_data) == false ) {
 		/* Deviation > 10 %. Shut down power to motor */
 		gpio_set_pin_low(FRG_PIN);
 		next_state = STATE_PLAUSIBILITY_ERROR;
		 
 	} else if ((brake_plausibility_check(ecu_data) == false) || (bspd == BSPD_PLAUSIBILITY_OCCURED)) {
800039be:	c2 88       	rjmp	80003a0e <fsm_ecu_state_ready_func+0x11a>
 		gpio_set_pin_low(FRG_PIN);
 		ecu_data->flag_brake_implausible = 1;
 		next_state = STATE_PLAUSIBILITY_ERROR;
		 
  	} else {
		kers = calc_kers(ecu_data);
800039c0:	0e 9c       	mov	r12,r7
800039c2:	f0 1f 00 20 	mcall	80003a40 <fsm_ecu_state_ready_func+0x14c>
		if (kers < 0) {
800039c6:	30 08       	mov	r8,0
800039c8:	f0 0c 19 00 	cp.h	r12,r8
800039cc:	c0 54       	brge	800039d6 <fsm_ecu_state_ready_func+0xe2>
			ecu_data->trq_cmd = kers;
800039ce:	ef 5c 00 16 	st.h	r7[22],r12
800039d2:	30 36       	mov	r6,3
800039d4:	c1 d8       	rjmp	80003a0e <fsm_ecu_state_ready_func+0x11a>
		} else {
 			map_pedal(ecu_data);
800039d6:	0e 9c       	mov	r12,r7
800039d8:	f0 1f 00 1b 	mcall	80003a44 <fsm_ecu_state_ready_func+0x150>
			traction_control(ecu_data);
800039dc:	0e 9c       	mov	r12,r7
800039de:	f0 1f 00 1b 	mcall	80003a48 <fsm_ecu_state_ready_func+0x154>
			//ecu_data->slip = (int16_t)(100*calculate_slip(ecu_data));
			// DEBUG
			ecu_can_send_slip_current((int16_t)ecu_data->control_u, ecu_data->traction_control_limit);
800039e2:	6e 7c       	ld.w	r12,r7[0x1c]
800039e4:	e5 ab 0c 0c 	cop	cp0,cr12,cr0,cr12,0x56
800039e8:	ef 0b 00 18 	ld.sh	r11,r7[24]
800039ec:	5c 8c       	casts.h	r12
800039ee:	f0 1f 00 18 	mcall	80003a4c <fsm_ecu_state_ready_func+0x158>
			ecu_data->trq_cmd = max(0, min((int16_t)ecu_data->trq_pedal, ecu_data->traction_control_limit));
800039f2:	6e 88       	ld.w	r8,r7[0x20]
800039f4:	e5 ab 08 08 	cop	cp0,cr8,cr0,cr8,0x56
800039f8:	5c 88       	casts.h	r8
800039fa:	ef 09 00 18 	ld.sh	r9,r7[24]
800039fe:	f0 09 0d 49 	min	r9,r8,r9
80003a02:	30 08       	mov	r8,0
80003a04:	f0 09 0c 48 	max	r8,r8,r9
80003a08:	ef 58 00 16 	st.h	r7[22],r8
80003a0c:	30 36       	mov	r6,3
 		}
	}
 	
 	ecu_can_inverter_torque_cmd(ecu_data->trq_cmd);
80003a0e:	ef 0c 00 16 	ld.sh	r12,r7[22]
80003a12:	f0 1f 00 10 	mcall	80003a50 <fsm_ecu_state_ready_func+0x15c>
 	
	return next_state;
};
80003a16:	0c 9c       	mov	r12,r6
80003a18:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003a1c:	80 00       	ld.sh	r0,r0[0x0]
80003a1e:	43 20       	lddsp	r0,sp[0xc8]
80003a20:	80 00       	ld.sh	r0,r0[0x0]
80003a22:	43 e0       	lddsp	r0,sp[0xf8]
80003a24:	80 00       	ld.sh	r0,r0[0x0]
80003a26:	44 54       	lddsp	r4,sp[0x114]
80003a28:	80 00       	ld.sh	r0,r0[0x0]
80003a2a:	44 d0       	lddsp	r0,sp[0x134]
80003a2c:	80 00       	ld.sh	r0,r0[0x0]
80003a2e:	69 bc       	ld.w	r12,r4[0x6c]
80003a30:	80 00       	ld.sh	r0,r0[0x0]
80003a32:	29 20       	sub	r0,-110
80003a34:	80 00       	ld.sh	r0,r0[0x0]
80003a36:	45 10       	lddsp	r0,sp[0x144]
80003a38:	80 00       	ld.sh	r0,r0[0x0]
80003a3a:	3e 8c       	mov	r12,-24
80003a3c:	80 00       	ld.sh	r0,r0[0x0]
80003a3e:	3e 3c       	mov	r12,-29
80003a40:	80 00       	ld.sh	r0,r0[0x0]
80003a42:	3e bc       	mov	r12,-21
80003a44:	80 00       	ld.sh	r0,r0[0x0]
80003a46:	42 88       	lddsp	r8,sp[0xa0]
80003a48:	80 00       	ld.sh	r0,r0[0x0]
80003a4a:	47 18       	lddsp	r8,sp[0x1c4]
80003a4c:	80 00       	ld.sh	r0,r0[0x0]
80003a4e:	28 00       	sub	r0,-128
80003a50:	80 00       	ld.sh	r0,r0[0x0]
80003a52:	2a c8       	sub	r8,-84

80003a54 <fsm_ecu_state_enable_drive_func>:
		}
	}
	return next_state;
};
	
fsm_ecu_state_t fsm_ecu_state_enable_drive_func( fsm_ecu_data_t *ecu_data ) {
80003a54:	eb cd 40 80 	pushm	r7,lr
80003a58:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_ENABLE_DRIVE;
	static uint8_t internal_state = 0;
	get_new_data(ecu_data);
80003a5a:	f0 1f 00 4d 	mcall	80003b8c <fsm_ecu_state_enable_drive_func+0x138>
	
	if (ecu_data->inverter_vdc < 50) {
80003a5e:	ef 09 00 3e 	ld.sh	r9,r7[62]
80003a62:	33 18       	mov	r8,49
80003a64:	f0 09 19 00 	cp.h	r9,r8
80003a68:	e0 8b 00 10 	brhi	80003a88 <fsm_ecu_state_enable_drive_func+0x34>
		gpio_set_pin_low(FRG_PIN);
80003a6c:	30 9c       	mov	r12,9
80003a6e:	f0 1f 00 49 	mcall	80003b90 <fsm_ecu_state_enable_drive_func+0x13c>
		gpio_set_pin_low(RFE_PIN);
80003a72:	31 0c       	mov	r12,16
80003a74:	f0 1f 00 47 	mcall	80003b90 <fsm_ecu_state_enable_drive_func+0x13c>
		gpio_set_pin_low(AIR_PLUS);
80003a78:	30 4c       	mov	r12,4
80003a7a:	f0 1f 00 46 	mcall	80003b90 <fsm_ecu_state_enable_drive_func+0x13c>
		ecu_data->flag_start_precharge = 0;
80003a7e:	30 08       	mov	r8,0
80003a80:	ef 68 00 4a 	st.b	r7[74],r8
80003a84:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
		//Reinitialize ECU here if still <90% error
		return STATE_STARTUP;
	}
	
	if (ecu_data->flag_drive_enable == DRIVE_ENABLE_RTDS_PLAYS) {
80003a88:	6f 48       	ld.w	r8,r7[0x50]
80003a8a:	58 38       	cp.w	r8,3
80003a8c:	c5 e1       	brne	80003b48 <fsm_ecu_state_enable_drive_func+0xf4>
		switch (internal_state) {
80003a8e:	4c 28       	lddpc	r8,80003b94 <fsm_ecu_state_enable_drive_func+0x140>
80003a90:	11 88       	ld.ub	r8,r8[0x0]
80003a92:	30 19       	mov	r9,1
80003a94:	f2 08 18 00 	cp.b	r8,r9
80003a98:	c2 90       	breq	80003aea <fsm_ecu_state_enable_drive_func+0x96>
80003a9a:	c0 63       	brcs	80003aa6 <fsm_ecu_state_enable_drive_func+0x52>
80003a9c:	30 29       	mov	r9,2
80003a9e:	f2 08 18 00 	cp.b	r8,r9
80003aa2:	c5 31       	brne	80003b48 <fsm_ecu_state_enable_drive_func+0xf4>
80003aa4:	c3 d8       	rjmp	80003b1e <fsm_ecu_state_enable_drive_func+0xca>
			case 0:
			gpio_set_pin_high(RFE_PIN);
80003aa6:	31 0c       	mov	r12,16
80003aa8:	f0 1f 00 3c 	mcall	80003b98 <fsm_ecu_state_enable_drive_func+0x144>
			ecu_can_inverter_enable_drive();
80003aac:	f0 1f 00 3c 	mcall	80003b9c <fsm_ecu_state_enable_drive_func+0x148>
			gpio_set_pin_high(FRG_PIN);
80003ab0:	30 9c       	mov	r12,9
80003ab2:	f0 1f 00 3a 	mcall	80003b98 <fsm_ecu_state_enable_drive_func+0x144>
 * \return bool    \c true  if the pin is in high logical level
 *                 \c false if the pin is not in high logical level
 */
__always_inline static bool gpio_pin_is_high(uint32_t pin)
{
	return (gpio_get_pin_value(pin) != 0);
80003ab6:	37 5c       	mov	r12,117
80003ab8:	f0 1f 00 3a 	mcall	80003ba0 <fsm_ecu_state_enable_drive_func+0x14c>
			if (gpio_pin_is_high(INVERTER_DOUT1)) {
80003abc:	c1 10       	breq	80003ade <fsm_ecu_state_enable_drive_func+0x8a>
				attempts = 0;
80003abe:	30 09       	mov	r9,0
80003ac0:	4b 98       	lddpc	r8,80003ba4 <fsm_ecu_state_enable_drive_func+0x150>
80003ac2:	b0 09       	st.h	r8[0x0],r9
				internal_state = 1;
80003ac4:	30 19       	mov	r9,1
80003ac6:	4b 48       	lddpc	r8,80003b94 <fsm_ecu_state_enable_drive_func+0x140>
80003ac8:	b0 89       	st.b	r8[0x0],r9
				ecu_dio_inverter_clear_error();
80003aca:	f0 1f 00 38 	mcall	80003ba8 <fsm_ecu_state_enable_drive_func+0x154>
				ecu_data->inverter_error = 0xDEAD;
80003ace:	fe 78 de ad 	mov	r8,-8531
80003ad2:	ef 58 00 58 	st.h	r7[88],r8
				ecu_can_inverter_read_reg(ERROR_REG);
80003ad6:	e0 6c 00 8f 	mov	r12,143
80003ada:	f0 1f 00 35 	mcall	80003bac <fsm_ecu_state_enable_drive_func+0x158>
			}
			attempts++;
80003ade:	4b 28       	lddpc	r8,80003ba4 <fsm_ecu_state_enable_drive_func+0x150>
80003ae0:	90 09       	ld.sh	r9,r8[0x0]
80003ae2:	2f f9       	sub	r9,-1
80003ae4:	b0 09       	st.h	r8[0x0],r9
80003ae6:	30 2c       	mov	r12,2
			break;
80003ae8:	c3 18       	rjmp	80003b4a <fsm_ecu_state_enable_drive_func+0xf6>
			
			case 1:
			if (ecu_data->inverter_error != 0xDEAD) {
80003aea:	ef 09 00 58 	ld.sh	r9,r7[88]
80003aee:	fe 78 de ad 	mov	r8,-8531
80003af2:	f0 09 19 00 	cp.h	r9,r8
80003af6:	c0 a0       	breq	80003b0a <fsm_ecu_state_enable_drive_func+0xb6>
				internal_state = 2;
80003af8:	30 29       	mov	r9,2
80003afa:	4a 78       	lddpc	r8,80003b94 <fsm_ecu_state_enable_drive_func+0x140>
80003afc:	b0 89       	st.b	r8[0x0],r9
				attempts = 0;
80003afe:	30 09       	mov	r9,0
80003b00:	4a 98       	lddpc	r8,80003ba4 <fsm_ecu_state_enable_drive_func+0x150>
80003b02:	b0 09       	st.h	r8[0x0],r9
80003b04:	30 2c       	mov	r12,2
80003b06:	e3 cd 80 80 	ldm	sp++,r7,pc
			} else {
				ecu_can_inverter_read_reg(ERROR_REG);
80003b0a:	e0 6c 00 8f 	mov	r12,143
80003b0e:	f0 1f 00 28 	mcall	80003bac <fsm_ecu_state_enable_drive_func+0x158>
				attempts++;
80003b12:	4a 58       	lddpc	r8,80003ba4 <fsm_ecu_state_enable_drive_func+0x150>
80003b14:	90 09       	ld.sh	r9,r8[0x0]
80003b16:	2f f9       	sub	r9,-1
80003b18:	b0 09       	st.h	r8[0x0],r9
80003b1a:	30 2c       	mov	r12,2
80003b1c:	c1 78       	rjmp	80003b4a <fsm_ecu_state_enable_drive_func+0xf6>
			}
			break;
			
			case 2:
			if (check_inverter_error(ecu_data) == 0) {
80003b1e:	0e 9c       	mov	r12,r7
80003b20:	f0 1f 00 24 	mcall	80003bb0 <fsm_ecu_state_enable_drive_func+0x15c>
80003b24:	c0 b1       	brne	80003b3a <fsm_ecu_state_enable_drive_func+0xe6>
				internal_state = 0; //Reset for next possible restart
80003b26:	30 09       	mov	r9,0
80003b28:	49 b8       	lddpc	r8,80003b94 <fsm_ecu_state_enable_drive_func+0x140>
80003b2a:	b0 89       	st.b	r8[0x0],r9
				ecu_can_send_ready_to_drive();
80003b2c:	f0 1f 00 22 	mcall	80003bb4 <fsm_ecu_state_enable_drive_func+0x160>
				ecu_data->flag_drive_enable = DRIVE_ENABLED;
80003b30:	30 28       	mov	r8,2
80003b32:	ef 48 00 50 	st.w	r7[80],r8
80003b36:	30 3c       	mov	r12,3
80003b38:	c0 98       	rjmp	80003b4a <fsm_ecu_state_enable_drive_func+0xf6>
				next_state = STATE_READY;
			} else {
				//set error code - return inverters error register?
				ecu_data->ecu_error |= (1 << ERR_INVERTER_INTERNAL);
80003b3a:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003b3e:	a3 b8       	sbr	r8,0x3
80003b40:	ef 58 00 5a 	st.h	r7[90],r8
80003b44:	30 8c       	mov	r12,8
80003b46:	c0 28       	rjmp	80003b4a <fsm_ecu_state_enable_drive_func+0xf6>
80003b48:	30 2c       	mov	r12,2
			
			default:
			break;
		}
	}
	if (attempts == ATTEMPT_LIMIT) {
80003b4a:	49 78       	lddpc	r8,80003ba4 <fsm_ecu_state_enable_drive_func+0x150>
80003b4c:	90 09       	ld.sh	r9,r8[0x0]
80003b4e:	36 48       	mov	r8,100
80003b50:	f0 09 19 00 	cp.h	r9,r8
80003b54:	c1 a1       	brne	80003b88 <fsm_ecu_state_enable_drive_func+0x134>
		if (internal_state == 0) {
80003b56:	49 08       	lddpc	r8,80003b94 <fsm_ecu_state_enable_drive_func+0x140>
80003b58:	11 88       	ld.ub	r8,r8[0x0]
80003b5a:	58 08       	cp.w	r8,0
80003b5c:	c0 71       	brne	80003b6a <fsm_ecu_state_enable_drive_func+0x116>
			ecu_data->ecu_error |= (1 << ERR_FRG);
80003b5e:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003b62:	a7 a8       	sbr	r8,0x6
80003b64:	ef 58 00 5a 	st.h	r7[90],r8
80003b68:	c0 a8       	rjmp	80003b7c <fsm_ecu_state_enable_drive_func+0x128>
		} else if (internal_state == 1) {
80003b6a:	30 19       	mov	r9,1
80003b6c:	f2 08 18 00 	cp.b	r8,r9
80003b70:	c0 61       	brne	80003b7c <fsm_ecu_state_enable_drive_func+0x128>
			ecu_data->ecu_error |= (1 << ERR_INVERTER_COM);
80003b72:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003b76:	a3 a8       	sbr	r8,0x2
80003b78:	ef 58 00 5a 	st.h	r7[90],r8
		}
		attempts = 0; //Reset
80003b7c:	30 08       	mov	r8,0
80003b7e:	48 a9       	lddpc	r9,80003ba4 <fsm_ecu_state_enable_drive_func+0x150>
80003b80:	b2 08       	st.h	r9[0x0],r8
		internal_state = 0; //Reset
80003b82:	48 59       	lddpc	r9,80003b94 <fsm_ecu_state_enable_drive_func+0x140>
80003b84:	b2 88       	st.b	r9[0x0],r8
80003b86:	30 8c       	mov	r12,8
		next_state = STATE_ERROR;
	}
	
	return next_state;
};
80003b88:	e3 cd 80 80 	ldm	sp++,r7,pc
80003b8c:	80 00       	ld.sh	r0,r0[0x0]
80003b8e:	43 20       	lddsp	r0,sp[0xc8]
80003b90:	80 00       	ld.sh	r0,r0[0x0]
80003b92:	69 bc       	ld.w	r12,r4[0x6c]
80003b94:	00 00       	add	r0,r0
80003b96:	cc 10       	breq	80003b18 <fsm_ecu_state_enable_drive_func+0xc4>
80003b98:	80 00       	ld.sh	r0,r0[0x0]
80003b9a:	69 a6       	ld.w	r6,r4[0x68]
80003b9c:	80 00       	ld.sh	r0,r0[0x0]
80003b9e:	2b 4c       	sub	r12,-76
80003ba0:	80 00       	ld.sh	r0,r0[0x0]
80003ba2:	69 90       	ld.w	r0,r4[0x64]
80003ba4:	00 00       	add	r0,r0
80003ba6:	cc 0a       	rjmp	80003926 <fsm_ecu_state_ready_func+0x32>
80003ba8:	80 00       	ld.sh	r0,r0[0x0]
80003baa:	45 38       	lddsp	r8,sp[0x14c]
80003bac:	80 00       	ld.sh	r0,r0[0x0]
80003bae:	2a 94       	sub	r4,-87
80003bb0:	80 00       	ld.sh	r0,r0[0x0]
80003bb2:	3f 88       	mov	r8,-8
80003bb4:	80 00       	ld.sh	r0,r0[0x0]
80003bb6:	29 60       	sub	r0,-106

80003bb8 <fsm_ecu_state_charged_func>:
	return next_state;
}

	

fsm_ecu_state_t fsm_ecu_state_charged_func( fsm_ecu_data_t *ecu_data ) {
80003bb8:	eb cd 40 c0 	pushm	r6-r7,lr
80003bbc:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_CHARGED;
	uint8_t no_trq_sens = 0;
	uint8_t no_speed_sens = 0;

	get_new_data(ecu_data);
80003bbe:	f0 1f 00 35 	mcall	80003c90 <fsm_ecu_state_charged_func+0xd8>
	no_trq_sens	  = get_trq_sens(ecu_data);
80003bc2:	0e 9c       	mov	r12,r7
80003bc4:	f0 1f 00 34 	mcall	80003c94 <fsm_ecu_state_charged_func+0xdc>
80003bc8:	18 96       	mov	r6,r12
	get_speed_sens(ecu_data); //Previously returned a value
80003bca:	0e 9c       	mov	r12,r7
80003bcc:	f0 1f 00 33 	mcall	80003c98 <fsm_ecu_state_charged_func+0xe0>
	get_brake_sens(ecu_data);
80003bd0:	0e 9c       	mov	r12,r7
80003bd2:	f0 1f 00 33 	mcall	80003c9c <fsm_ecu_state_charged_func+0xe4>
	no_speed_sens = 0;
	
	if (ecu_data->inverter_vdc < 50) {
80003bd6:	ef 09 00 3e 	ld.sh	r9,r7[62]
80003bda:	33 18       	mov	r8,49
80003bdc:	f0 09 19 00 	cp.h	r9,r8
80003be0:	e0 8b 00 10 	brhi	80003c00 <fsm_ecu_state_charged_func+0x48>
		gpio_set_pin_low(FRG_PIN);
80003be4:	30 9c       	mov	r12,9
80003be6:	f0 1f 00 2f 	mcall	80003ca0 <fsm_ecu_state_charged_func+0xe8>
		gpio_set_pin_low(RFE_PIN);
80003bea:	31 0c       	mov	r12,16
80003bec:	f0 1f 00 2d 	mcall	80003ca0 <fsm_ecu_state_charged_func+0xe8>
		gpio_set_pin_low(AIR_PLUS);
80003bf0:	30 4c       	mov	r12,4
80003bf2:	f0 1f 00 2c 	mcall	80003ca0 <fsm_ecu_state_charged_func+0xe8>
		ecu_data->flag_start_precharge = 0;
80003bf6:	30 08       	mov	r8,0
80003bf8:	ef 68 00 4a 	st.b	r7[74],r8
80003bfc:	e3 cf 80 c0 	ldm	sp++,r6-r7,pc,r12=0
		//Reinitialize ECU here if still <90% error
		return STATE_STARTUP;
	}
	
	if(ecu_data->flag_drive_enable == DRIVE_ENABLE_REQUEST) {
80003c00:	6f 48       	ld.w	r8,r7[0x50]
80003c02:	58 18       	cp.w	r8,1
80003c04:	c0 30       	breq	80003c0a <fsm_ecu_state_charged_func+0x52>
80003c06:	e3 cf 90 c0 	ldm	sp++,r6-r7,pc,r12=1
 * \return bool    \c true if the pin is in low logical level
 *                 \c false if the pin is not in low logical level
 */
__always_inline static bool gpio_pin_is_low(uint32_t pin)
{
	return (gpio_get_pin_value(pin) == 0);
80003c0a:	30 4c       	mov	r12,4
80003c0c:	f0 1f 00 26 	mcall	80003ca4 <fsm_ecu_state_charged_func+0xec>
		if (gpio_pin_is_low(AIR_PLUS)) {
80003c10:	c0 30       	breq	80003c16 <fsm_ecu_state_charged_func+0x5e>
80003c12:	30 1c       	mov	r12,1
80003c14:	c0 78       	rjmp	80003c22 <fsm_ecu_state_charged_func+0x6a>
			ecu_data->ecu_error |= (1 << ERR_AIR_PLUS);
80003c16:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003c1a:	a7 b8       	sbr	r8,0x7
80003c1c:	ef 58 00 5a 	st.h	r7[90],r8
80003c20:	30 8c       	mov	r12,8
			next_state = STATE_ERROR;
		}
		if (no_trq_sens) {
80003c22:	58 06       	cp.w	r6,0
80003c24:	c0 70       	breq	80003c32 <fsm_ecu_state_charged_func+0x7a>
			ecu_data->ecu_error |= (1 << ERR_TRQ_SENSORS);
80003c26:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003c2a:	a5 a8       	sbr	r8,0x4
80003c2c:	ef 58 00 5a 	st.h	r7[90],r8
80003c30:	30 8c       	mov	r12,8
		}
		if (no_speed_sens) {
			ecu_data->ecu_error |= (1 << ERR_SPEED_SENSORS);
			next_state = STATE_ERROR;
		}
		if (ecu_data->brake_front == 0) {
80003c32:	ef 09 00 46 	ld.sh	r9,r7[70]
80003c36:	30 08       	mov	r8,0
80003c38:	f0 09 19 00 	cp.h	r9,r8
80003c3c:	c0 71       	brne	80003c4a <fsm_ecu_state_charged_func+0x92>
			ecu_data->ecu_error |= (1 << ERR_BRAKE_SENS_FRONT);
80003c3e:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003c42:	a9 b8       	sbr	r8,0x9
80003c44:	ef 58 00 5a 	st.h	r7[90],r8
80003c48:	30 8c       	mov	r12,8
			next_state = STATE_ERROR;
		}
		if (ecu_data->brake_rear == 0) {
80003c4a:	ef 09 00 48 	ld.sh	r9,r7[72]
80003c4e:	30 08       	mov	r8,0
80003c50:	f0 09 19 00 	cp.h	r9,r8
80003c54:	c0 91       	brne	80003c66 <fsm_ecu_state_charged_func+0xae>
			ecu_data->ecu_error |= (1 << ERR_BRAKE_SENS_REAR);
80003c56:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003c5a:	ab a8       	sbr	r8,0xa
80003c5c:	ef 58 00 5a 	st.h	r7[90],r8
80003c60:	30 8c       	mov	r12,8
80003c62:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
			next_state = STATE_ERROR;
		}
		if (next_state != STATE_ERROR) {
80003c66:	58 8c       	cp.w	r12,8
80003c68:	c1 10       	breq	80003c8a <fsm_ecu_state_charged_func+0xd2>
			if ((ecu_data->trq_sens0 < 20) && (ecu_data->trq_sens1 < 20)) {
80003c6a:	ef 09 00 10 	ld.sh	r9,r7[16]
80003c6e:	31 38       	mov	r8,19
80003c70:	f0 09 19 00 	cp.h	r9,r8
80003c74:	e0 89 00 0b 	brgt	80003c8a <fsm_ecu_state_charged_func+0xd2>
80003c78:	ef 09 00 12 	ld.sh	r9,r7[18]
80003c7c:	f0 09 19 00 	cp.h	r9,r8
80003c80:	e0 89 00 05 	brgt	80003c8a <fsm_ecu_state_charged_func+0xd2>
				ecu_can_send_play_rtds();
80003c84:	f0 1f 00 09 	mcall	80003ca8 <fsm_ecu_state_charged_func+0xf0>
80003c88:	30 2c       	mov	r12,2
				
			}
		}
	}
	return next_state;
};
80003c8a:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80003c8e:	00 00       	add	r0,r0
80003c90:	80 00       	ld.sh	r0,r0[0x0]
80003c92:	43 20       	lddsp	r0,sp[0xc8]
80003c94:	80 00       	ld.sh	r0,r0[0x0]
80003c96:	43 e0       	lddsp	r0,sp[0xf8]
80003c98:	80 00       	ld.sh	r0,r0[0x0]
80003c9a:	44 54       	lddsp	r4,sp[0x114]
80003c9c:	80 00       	ld.sh	r0,r0[0x0]
80003c9e:	44 d0       	lddsp	r0,sp[0x134]
80003ca0:	80 00       	ld.sh	r0,r0[0x0]
80003ca2:	69 bc       	ld.w	r12,r4[0x6c]
80003ca4:	80 00       	ld.sh	r0,r0[0x0]
80003ca6:	69 90       	ld.w	r0,r4[0x64]
80003ca8:	80 00       	ld.sh	r0,r0[0x0]
80003caa:	29 a0       	sub	r0,-102

80003cac <fsm_ecu_state_startup_func>:

fsm_ecu_state_t fsm_ecu_run_state( fsm_ecu_state_t current_state, fsm_ecu_data_t *data) {
	return fsm_ecu_state_table[ current_state ]( data );
};

fsm_ecu_state_t fsm_ecu_state_startup_func( fsm_ecu_data_t *ecu_data ) {
80003cac:	eb cd 40 80 	pushm	r7,lr
80003cb0:	18 97       	mov	r7,r12
	fsm_ecu_state_t next_state = STATE_STARTUP;
	static uint8_t internal_state = 0;
	static uint8_t precharge_timer = 0;

	get_new_data(ecu_data);
80003cb2:	f0 1f 00 5a 	mcall	80003e18 <fsm_ecu_state_startup_func+0x16c>
// 	traction_control(ecu_data);
// 	ecu_data->slip = (int16_t)(100*calculate_slip(ecu_data));
// 	ecu_can_send_slip_current((int16_t)ecu_data->control_u, ecu_data->traction_control_limit);
	//DEBUG

	if (ecu_data->flag_start_precharge == 1) {
80003cb6:	ef 39 00 4a 	ld.ub	r9,r7[74]
80003cba:	30 18       	mov	r8,1
80003cbc:	f0 09 18 00 	cp.b	r9,r8
80003cc0:	c7 51       	brne	80003daa <fsm_ecu_state_startup_func+0xfe>
		switch (internal_state) {
80003cc2:	4d 78       	lddpc	r8,80003e1c <fsm_ecu_state_startup_func+0x170>
80003cc4:	11 88       	ld.ub	r8,r8[0x0]
80003cc6:	30 19       	mov	r9,1
80003cc8:	f2 08 18 00 	cp.b	r8,r9
80003ccc:	c2 20       	breq	80003d10 <fsm_ecu_state_startup_func+0x64>
80003cce:	c0 a3       	brcs	80003ce2 <fsm_ecu_state_startup_func+0x36>
80003cd0:	30 29       	mov	r9,2
80003cd2:	f2 08 18 00 	cp.b	r8,r9
80003cd6:	c3 b0       	breq	80003d4c <fsm_ecu_state_startup_func+0xa0>
80003cd8:	30 39       	mov	r9,3
80003cda:	f2 08 18 00 	cp.b	r8,r9
80003cde:	c6 61       	brne	80003daa <fsm_ecu_state_startup_func+0xfe>
80003ce0:	c4 f8       	rjmp	80003d7e <fsm_ecu_state_startup_func+0xd2>
			case 0:
			if (ecu_data->vdc_battery > 0) {
80003ce2:	ef 09 00 3c 	ld.sh	r9,r7[60]
80003ce6:	30 08       	mov	r8,0
80003ce8:	f0 09 19 00 	cp.h	r9,r8
80003cec:	c0 c0       	breq	80003d04 <fsm_ecu_state_startup_func+0x58>
				if (ecu_data->inverter_vdc > 0) {
80003cee:	ef 09 00 3e 	ld.sh	r9,r7[62]
80003cf2:	f0 09 19 00 	cp.h	r9,r8
80003cf6:	c0 70       	breq	80003d04 <fsm_ecu_state_startup_func+0x58>
					internal_state = 1;
80003cf8:	30 19       	mov	r9,1
80003cfa:	4c 98       	lddpc	r8,80003e1c <fsm_ecu_state_startup_func+0x170>
80003cfc:	b0 89       	st.b	r8[0x0],r9
					attempts = 0;	
80003cfe:	30 09       	mov	r9,0
80003d00:	4c 88       	lddpc	r8,80003e20 <fsm_ecu_state_startup_func+0x174>
80003d02:	b0 09       	st.h	r8[0x0],r9
				}
			}
			attempts++;
80003d04:	4c 78       	lddpc	r8,80003e20 <fsm_ecu_state_startup_func+0x174>
80003d06:	90 09       	ld.sh	r9,r8[0x0]
80003d08:	2f f9       	sub	r9,-1
80003d0a:	b0 09       	st.h	r8[0x0],r9
80003d0c:	30 0c       	mov	r12,0
			break;
80003d0e:	c4 f8       	rjmp	80003dac <fsm_ecu_state_startup_func+0x100>
			
			case 1:
			if (precharge_timer < 3*SOFTWARE_TIMER_1_SEC) {
80003d10:	4c 58       	lddpc	r8,80003e24 <fsm_ecu_state_startup_func+0x178>
80003d12:	11 88       	ld.ub	r8,r8[0x0]
80003d14:	39 59       	mov	r9,-107
80003d16:	f2 08 18 00 	cp.b	r8,r9
80003d1a:	e0 8b 00 07 	brhi	80003d28 <fsm_ecu_state_startup_func+0x7c>
				precharge_timer++;
80003d1e:	2f f8       	sub	r8,-1
80003d20:	4c 19       	lddpc	r9,80003e24 <fsm_ecu_state_startup_func+0x178>
80003d22:	b2 88       	st.b	r9[0x0],r8
80003d24:	30 0c       	mov	r12,0
80003d26:	c4 38       	rjmp	80003dac <fsm_ecu_state_startup_func+0x100>
			} else {
				precharge_timer = 0;
80003d28:	30 09       	mov	r9,0
80003d2a:	4b f8       	lddpc	r8,80003e24 <fsm_ecu_state_startup_func+0x178>
80003d2c:	b0 89       	st.b	r8[0x0],r9
				ecu_dio_inverter_clear_error();
80003d2e:	f0 1f 00 3f 	mcall	80003e28 <fsm_ecu_state_startup_func+0x17c>
				ecu_data->inverter_error = 0xDEAD;
80003d32:	fe 78 de ad 	mov	r8,-8531
80003d36:	ef 58 00 58 	st.h	r7[88],r8
				ecu_can_inverter_read_reg(ERROR_REG);
80003d3a:	e0 6c 00 8f 	mov	r12,143
80003d3e:	f0 1f 00 3c 	mcall	80003e2c <fsm_ecu_state_startup_func+0x180>
				internal_state = 2;	
80003d42:	30 29       	mov	r9,2
80003d44:	4b 68       	lddpc	r8,80003e1c <fsm_ecu_state_startup_func+0x170>
80003d46:	b0 89       	st.b	r8[0x0],r9
80003d48:	30 0c       	mov	r12,0
80003d4a:	c3 18       	rjmp	80003dac <fsm_ecu_state_startup_func+0x100>
			}
			break;
			
			case 2:
			if (ecu_data->inverter_error != 0xDEAD) {
80003d4c:	ef 09 00 58 	ld.sh	r9,r7[88]
80003d50:	fe 78 de ad 	mov	r8,-8531
80003d54:	f0 09 19 00 	cp.h	r9,r8
80003d58:	c0 90       	breq	80003d6a <fsm_ecu_state_startup_func+0xbe>
				internal_state = 3;
80003d5a:	30 39       	mov	r9,3
80003d5c:	4b 08       	lddpc	r8,80003e1c <fsm_ecu_state_startup_func+0x170>
80003d5e:	b0 89       	st.b	r8[0x0],r9
				attempts = 0;
80003d60:	30 09       	mov	r9,0
80003d62:	4b 08       	lddpc	r8,80003e20 <fsm_ecu_state_startup_func+0x174>
80003d64:	b0 09       	st.h	r8[0x0],r9
80003d66:	e3 cf 80 80 	ldm	sp++,r7,pc,r12=0
			} else {
				ecu_can_inverter_read_reg(ERROR_REG);
80003d6a:	e0 6c 00 8f 	mov	r12,143
80003d6e:	f0 1f 00 30 	mcall	80003e2c <fsm_ecu_state_startup_func+0x180>
				attempts++;
80003d72:	4a c8       	lddpc	r8,80003e20 <fsm_ecu_state_startup_func+0x174>
80003d74:	90 09       	ld.sh	r9,r8[0x0]
80003d76:	2f f9       	sub	r9,-1
80003d78:	b0 09       	st.h	r8[0x0],r9
80003d7a:	30 0c       	mov	r12,0
80003d7c:	c1 88       	rjmp	80003dac <fsm_ecu_state_startup_func+0x100>
			}
			break;
			
			case 3:
			if(check_inverter_error(ecu_data) == 0) {
80003d7e:	0e 9c       	mov	r12,r7
80003d80:	f0 1f 00 2c 	mcall	80003e30 <fsm_ecu_state_startup_func+0x184>
80003d84:	c0 30       	breq	80003d8a <fsm_ecu_state_startup_func+0xde>
80003d86:	30 0c       	mov	r12,0
80003d88:	c0 c8       	rjmp	80003da0 <fsm_ecu_state_startup_func+0xf4>
				attempts = 0; //Reset
80003d8a:	30 08       	mov	r8,0
80003d8c:	4a 59       	lddpc	r9,80003e20 <fsm_ecu_state_startup_func+0x174>
80003d8e:	b2 08       	st.h	r9[0x0],r8
				internal_state = 0; //Reset
80003d90:	4a 39       	lddpc	r9,80003e1c <fsm_ecu_state_startup_func+0x170>
80003d92:	b2 88       	st.b	r9[0x0],r8
				gpio_set_pin_high(AIR_PLUS);
80003d94:	30 4c       	mov	r12,4
80003d96:	f0 1f 00 28 	mcall	80003e34 <fsm_ecu_state_startup_func+0x188>
				ecu_can_send_tractive_system_active();
80003d9a:	f0 1f 00 28 	mcall	80003e38 <fsm_ecu_state_startup_func+0x18c>
80003d9e:	30 1c       	mov	r12,1
				next_state =  STATE_CHARGED;
			}
			attempts++;
80003da0:	4a 08       	lddpc	r8,80003e20 <fsm_ecu_state_startup_func+0x174>
80003da2:	90 09       	ld.sh	r9,r8[0x0]
80003da4:	2f f9       	sub	r9,-1
80003da6:	b0 09       	st.h	r8[0x0],r9
80003da8:	c0 28       	rjmp	80003dac <fsm_ecu_state_startup_func+0x100>
80003daa:	30 0c       	mov	r12,0
			break;
		}
	}
	
	
	if (attempts == ATTEMPT_LIMIT) {
80003dac:	49 d8       	lddpc	r8,80003e20 <fsm_ecu_state_startup_func+0x174>
80003dae:	90 09       	ld.sh	r9,r8[0x0]
80003db0:	36 48       	mov	r8,100
80003db2:	f0 09 19 00 	cp.h	r9,r8
80003db6:	c2 e1       	brne	80003e12 <fsm_ecu_state_startup_func+0x166>
		switch (internal_state) {
80003db8:	49 98       	lddpc	r8,80003e1c <fsm_ecu_state_startup_func+0x170>
80003dba:	11 88       	ld.ub	r8,r8[0x0]
80003dbc:	30 19       	mov	r9,1
80003dbe:	f2 08 18 00 	cp.b	r8,r9
80003dc2:	c1 10       	breq	80003de4 <fsm_ecu_state_startup_func+0x138>
80003dc4:	c0 a3       	brcs	80003dd8 <fsm_ecu_state_startup_func+0x12c>
80003dc6:	30 29       	mov	r9,2
80003dc8:	f2 08 18 00 	cp.b	r8,r9
80003dcc:	c1 20       	breq	80003df0 <fsm_ecu_state_startup_func+0x144>
80003dce:	30 39       	mov	r9,3
80003dd0:	f2 08 18 00 	cp.b	r8,r9
80003dd4:	c1 91       	brne	80003e06 <fsm_ecu_state_startup_func+0x15a>
80003dd6:	c1 38       	rjmp	80003dfc <fsm_ecu_state_startup_func+0x150>
			case 0:
			ecu_data->ecu_error |= (1 << ERR_BMS_COM);
80003dd8:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003ddc:	a1 a8       	sbr	r8,0x0
80003dde:	ef 58 00 5a 	st.h	r7[90],r8
			break;
80003de2:	c1 28       	rjmp	80003e06 <fsm_ecu_state_startup_func+0x15a>
			case 1:
			ecu_data->ecu_error |= (1 << ERR_INVERTER_VDC_LOW);
80003de4:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003de8:	a1 b8       	sbr	r8,0x1
80003dea:	ef 58 00 5a 	st.h	r7[90],r8
			break;
80003dee:	c0 c8       	rjmp	80003e06 <fsm_ecu_state_startup_func+0x15a>
			case 2:
			ecu_data->ecu_error |= (1 << ERR_INVERTER_COM);
80003df0:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003df4:	a3 a8       	sbr	r8,0x2
80003df6:	ef 58 00 5a 	st.h	r7[90],r8
			break;
80003dfa:	c0 68       	rjmp	80003e06 <fsm_ecu_state_startup_func+0x15a>
			case 3:
			ecu_data->ecu_error |= (1 << ERR_INVERTER_INTERNAL);
80003dfc:	ef 08 00 5a 	ld.sh	r8,r7[90]
80003e00:	a3 b8       	sbr	r8,0x3
80003e02:	ef 58 00 5a 	st.h	r7[90],r8
			break;
		}
		attempts = 0;
80003e06:	30 08       	mov	r8,0
80003e08:	48 69       	lddpc	r9,80003e20 <fsm_ecu_state_startup_func+0x174>
80003e0a:	b2 08       	st.h	r9[0x0],r8
		internal_state = 0;
80003e0c:	48 49       	lddpc	r9,80003e1c <fsm_ecu_state_startup_func+0x170>
80003e0e:	b2 88       	st.b	r9[0x0],r8
80003e10:	30 8c       	mov	r12,8
		next_state =  STATE_ERROR;
	}
	return next_state;
}
80003e12:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e16:	00 00       	add	r0,r0
80003e18:	80 00       	ld.sh	r0,r0[0x0]
80003e1a:	43 20       	lddsp	r0,sp[0xc8]
80003e1c:	00 00       	add	r0,r0
80003e1e:	cc 0d       	rcall	8000419e <handle_dash_data+0x14a>
80003e20:	00 00       	add	r0,r0
80003e22:	cc 0a       	rjmp	80003ba2 <fsm_ecu_state_enable_drive_func+0x14e>
80003e24:	00 00       	add	r0,r0
80003e26:	cc 11       	brne	80003da8 <fsm_ecu_state_startup_func+0xfc>
80003e28:	80 00       	ld.sh	r0,r0[0x0]
80003e2a:	45 38       	lddsp	r8,sp[0x14c]
80003e2c:	80 00       	ld.sh	r0,r0[0x0]
80003e2e:	2a 94       	sub	r4,-87
80003e30:	80 00       	ld.sh	r0,r0[0x0]
80003e32:	3f 88       	mov	r8,-8
80003e34:	80 00       	ld.sh	r0,r0[0x0]
80003e36:	69 a6       	ld.w	r6,r4[0x68]
80003e38:	80 00       	ld.sh	r0,r0[0x0]
80003e3a:	29 dc       	sub	r12,-99

80003e3c <brake_plausibility_check>:
	return true;
}

bool brake_plausibility_check(fsm_ecu_data_t *ecu_data) {
	static uint8_t plausibility_timer = 0;
	int16_t trq_sens = max(ecu_data->trq_sens0, ecu_data->trq_sens1);
80003e3c:	f9 08 00 10 	ld.sh	r8,r12[16]
80003e40:	f9 09 00 12 	ld.sh	r9,r12[18]
80003e44:	f0 09 0c 49 	max	r9,r8,r9
	
	if ((trq_sens > 250) && (ecu_data->brake_front > BRAKE_TRESHOLD)) {
80003e48:	e0 68 00 fa 	mov	r8,250
80003e4c:	f0 09 19 00 	cp.h	r9,r8
80003e50:	e0 8a 00 17 	brle	80003e7e <brake_plausibility_check+0x42>
80003e54:	f9 09 00 46 	ld.sh	r9,r12[70]
80003e58:	e0 68 13 88 	mov	r8,5000
80003e5c:	f0 09 19 00 	cp.h	r9,r8
80003e60:	e0 88 00 0f 	brls	80003e7e <brake_plausibility_check+0x42>
		plausibility_timer++;
80003e64:	48 99       	lddpc	r9,80003e88 <brake_plausibility_check+0x4c>
80003e66:	13 88       	ld.ub	r8,r9[0x0]
80003e68:	2f f8       	sub	r8,-1
80003e6a:	b2 88       	st.b	r9[0x0],r8
		if (plausibility_timer == BRAKE_PLAUSIBILITY_TIME_LIMIT) {
80003e6c:	31 99       	mov	r9,25
80003e6e:	f2 08 18 00 	cp.b	r8,r9
80003e72:	c0 20       	breq	80003e76 <brake_plausibility_check+0x3a>
80003e74:	5e ff       	retal	1
			plausibility_timer = 0;
80003e76:	30 09       	mov	r9,0
80003e78:	48 48       	lddpc	r8,80003e88 <brake_plausibility_check+0x4c>
80003e7a:	b0 89       	st.b	r8[0x0],r9
80003e7c:	5e fd       	retal	0
			return false;
		}
	} else {
		plausibility_timer = 0;
80003e7e:	30 09       	mov	r9,0
80003e80:	48 28       	lddpc	r8,80003e88 <brake_plausibility_check+0x4c>
80003e82:	b0 89       	st.b	r8[0x0],r9
80003e84:	5e ff       	retal	1
80003e86:	00 00       	add	r0,r0
80003e88:	00 00       	add	r0,r0
80003e8a:	cc 19       	rjmp	8000420c <handle_inverter_data+0x30>

80003e8c <torque_plausibility_check>:

}

bool torque_plausibility_check(fsm_ecu_data_t *ecu_data) {
	/* Torque sensors = <0, 1000> */
	if ( ecu_data->trq_sens0_err || ecu_data->trq_sens1_err) {
80003e8c:	78 58       	ld.w	r8,r12[0x14]
80003e8e:	e0 18 00 00 	andl	r8,0x0
80003e92:	c0 30       	breq	80003e98 <torque_plausibility_check+0xc>
		asm("nop");
80003e94:	d7 03       	nop
80003e96:	5e fd       	retal	0
		return false;
	} else {
		int16_t deviation = max(ecu_data->trq_sens0, ecu_data->trq_sens1) - min(ecu_data->trq_sens0,ecu_data->trq_sens1);
80003e98:	f9 08 00 10 	ld.sh	r8,r12[16]
80003e9c:	f9 09 00 12 	ld.sh	r9,r12[18]
80003ea0:	f0 09 0c 4a 	max	r10,r8,r9
80003ea4:	f0 09 0d 48 	min	r8,r8,r9
		if (deviation > 100) {
80003ea8:	f4 08 01 08 	sub	r8,r10,r8
80003eac:	36 4a       	mov	r10,100
80003eae:	f4 08 19 00 	cp.h	r8,r10
80003eb2:	e0 89 00 03 	brgt	80003eb8 <torque_plausibility_check+0x2c>
80003eb6:	5e ff       	retal	1
			asm("nop");
80003eb8:	d7 03       	nop
80003eba:	5e fd       	retal	0

80003ebc <calc_kers>:
	uint16_t trq = (uint16_t)ecu_data->trq_cmd*180/MAX_TORQUE;//180Nm
	uint32_t power = trq*rpm*628/(100*60*1000); //In kW
	return (uint16_t)power; //Such number
}

int16_t calc_kers(fsm_ecu_data_t *ecu_data) {
80003ebc:	eb cd 40 80 	pushm	r7,lr
80003ec0:	18 97       	mov	r7,r12
	float speed = ecu_data->WRR_sens & 0xFF;
	speed = speed*2.574;
80003ec2:	f9 3c 00 63 	ld.ub	r12,r12[99]
80003ec6:	e5 a6 0c 0c 	cop	cp0,cr12,cr0,cr12,0x4c
80003eca:	f0 1f 00 2c 	mcall	80003f78 <calc_kers+0xbc>
80003ece:	e0 68 3b 64 	mov	r8,15204
80003ed2:	ea 18 4f df 	orh	r8,0x4fdf
80003ed6:	e0 69 97 8d 	mov	r9,38797
80003eda:	ea 19 40 04 	orh	r9,0x4004
80003ede:	f0 1f 00 28 	mcall	80003f7c <calc_kers+0xc0>
80003ee2:	f0 1f 00 28 	mcall	80003f80 <calc_kers+0xc4>
	static bool allow_kers = false;
	
	if (speed > 10) {
80003ee6:	fc 18 41 20 	movh	r8,0x4120
80003eea:	e5 ac 00 c8 	cop	cp0,cr0,cr12,cr8,0x58
80003eee:	e0 8c 00 08 	brvs	80003efe <calc_kers+0x42>
80003ef2:	e0 8a 00 06 	brle	80003efe <calc_kers+0x42>
		allow_kers = true;
80003ef6:	30 19       	mov	r9,1
80003ef8:	4a 38       	lddpc	r8,80003f84 <calc_kers+0xc8>
80003efa:	b0 89       	st.b	r8[0x0],r9
80003efc:	c0 78       	rjmp	80003f0a <calc_kers+0x4e>
	}
	
	if (allow_kers) {
80003efe:	4a 28       	lddpc	r8,80003f84 <calc_kers+0xc8>
80003f00:	11 89       	ld.ub	r9,r8[0x0]
80003f02:	30 08       	mov	r8,0
80003f04:	f0 09 18 00 	cp.b	r9,r8
80003f08:	c3 60       	breq	80003f74 <calc_kers+0xb8>
		if ((ecu_data->trq_sens0 < 100) && (ecu_data->trq_sens1 < 100)) {
80003f0a:	ef 09 00 10 	ld.sh	r9,r7[16]
80003f0e:	36 38       	mov	r8,99
80003f10:	f0 09 19 00 	cp.h	r9,r8
80003f14:	e0 89 00 30 	brgt	80003f74 <calc_kers+0xb8>
80003f18:	ef 09 00 12 	ld.sh	r9,r7[18]
80003f1c:	f0 09 19 00 	cp.h	r9,r8
80003f20:	e0 89 00 2a 	brgt	80003f74 <calc_kers+0xb8>
			if (speed > 5.5) { //km/h
80003f24:	fc 18 40 b0 	movh	r8,0x40b0
80003f28:	e5 ac 00 c8 	cop	cp0,cr0,cr12,cr8,0x58
80003f2c:	e0 8c 00 1f 	brvs	80003f6a <calc_kers+0xae>
80003f30:	e0 8a 00 1d 	brle	80003f6a <calc_kers+0xae>
				if ((ecu_data->max_cell_temp > 0) && (ecu_data->max_cell_temp < 44)) {
80003f34:	ef 39 00 4c 	ld.ub	r9,r7[76]
80003f38:	20 19       	sub	r9,1
80003f3a:	32 a8       	mov	r8,42
80003f3c:	f0 09 18 00 	cp.b	r9,r8
80003f40:	e0 8b 00 1a 	brhi	80003f74 <calc_kers+0xb8>
					return (MAX_KERS*ecu_data->kers_factor)/100; //TODO Return a value from ecu_data that is received from dash
80003f44:	ef 09 00 8c 	ld.sh	r9,r7[140]
80003f48:	fe 78 f3 33 	mov	r8,-3277
80003f4c:	f2 08 07 88 	mulhh.w	r8,r9:b,r8:b
80003f50:	e0 6b 85 1f 	mov	r11,34079
80003f54:	ea 1b 51 eb 	orh	r11,0x51eb
80003f58:	f0 0b 04 4a 	muls.d	r10,r8,r11
80003f5c:	f6 0c 14 05 	asr	r12,r11,0x5
80003f60:	bf 58       	asr	r8,0x1f
80003f62:	10 1c       	sub	r12,r8
80003f64:	5c 8c       	casts.h	r12
80003f66:	e3 cd 80 80 	ldm	sp++,r7,pc
				}
			} else {
				allow_kers = false;
80003f6a:	30 09       	mov	r9,0
80003f6c:	48 68       	lddpc	r8,80003f84 <calc_kers+0xc8>
80003f6e:	b0 89       	st.b	r8[0x0],r9
80003f70:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80003f74:	e3 cf 90 80 	ldm	sp++,r7,pc,r12=1
80003f78:	80 00       	ld.sh	r0,r0[0x0]
80003f7a:	78 48       	ld.w	r8,r12[0x10]
80003f7c:	80 00       	ld.sh	r0,r0[0x0]
80003f7e:	6e 64       	ld.w	r4,r7[0x18]
80003f80:	80 00       	ld.sh	r0,r0[0x0]
80003f82:	78 a8       	ld.w	r8,r12[0x28]
80003f84:	00 00       	add	r0,r0
80003f86:	cc 18       	rjmp	80004108 <handle_dash_data+0xb4>

80003f88 <check_inverter_error>:
	return temp;
}

uint8_t check_inverter_error(fsm_ecu_data_t *ecu_data) {
	uint16_t temp = ecu_data->inverter_error;
	return (uint8_t)(temp & 1 << PWR_FAULT) | (temp & 1 << RFE_FAULT) | (temp & 1 << RESOLVER_FAULT);
80003f88:	f9 39 00 59 	ld.ub	r9,r12[89]
80003f8c:	12 98       	mov	r8,r9
80003f8e:	10 9c       	mov	r12,r8
80003f90:	e2 1c 00 04 	andl	r12,0x4,COH
80003f94:	e2 19 00 02 	andl	r9,0x2,COH
80003f98:	12 4c       	or	r12,r9
80003f9a:	e2 18 00 08 	andl	r8,0x8,COH
80003f9e:	10 4c       	or	r12,r8
}
80003fa0:	e2 1c 00 0e 	andl	r12,0xe,COH
80003fa4:	5e fc       	retal	r12

80003fa6 <convert_to_big_endian>:
	return (uint16_t)(float)((num_be + 827) / 33.2);
}

uint16_t convert_to_big_endian(uint32_t data) {
	/* Input: 0x49 D2 2A 00 Output:0x2A D2 */
	uint16_t relevant_data = (data & 0xFFFF00) >> 8;
80003fa6:	f9 dc c1 10 	bfextu	r12,r12,0x8,0x10
80003faa:	f8 08 16 08 	lsr	r8,r12,0x8
80003fae:	f1 ec 10 8c 	or	r12,r8,r12<<0x8
	return ((relevant_data & 0xFF) << 8 | (relevant_data & 0xFF00) >> 8);
}
80003fb2:	5c 8c       	casts.h	r12
80003fb4:	5e fc       	retal	r12
80003fb6:	d7 03       	nop

80003fb8 <convert_num_to_vdc>:
		status++;
	}
	return status;
}

uint16_t convert_num_to_vdc(uint32_t num) {
80003fb8:	d4 01       	pushm	lr
	/* num = 33.2*vdc - 827 */
	uint32_t num_be = convert_to_big_endian(num);
80003fba:	f0 1f 00 0c 	mcall	80003fe8 <convert_num_to_vdc+0x30>
80003fbe:	5c 7c       	castu.h	r12
80003fc0:	f8 cc fc c5 	sub	r12,r12,-827
80003fc4:	f0 1f 00 0a 	mcall	80003fec <convert_num_to_vdc+0x34>
80003fc8:	e0 68 99 9a 	mov	r8,39322
80003fcc:	ea 18 99 99 	orh	r8,0x9999
80003fd0:	e0 69 99 99 	mov	r9,39321
80003fd4:	ea 19 40 40 	orh	r9,0x4040
80003fd8:	f0 1f 00 06 	mcall	80003ff0 <convert_num_to_vdc+0x38>
80003fdc:	f0 1f 00 06 	mcall	80003ff4 <convert_num_to_vdc+0x3c>
80003fe0:	e5 a9 0c 0c 	cop	cp0,cr12,cr0,cr12,0x52
	return (uint16_t)(float)((num_be + 827) / 33.2);
}
80003fe4:	5c 8c       	casts.h	r12
80003fe6:	d8 02       	popm	pc
80003fe8:	80 00       	ld.sh	r0,r0[0x0]
80003fea:	3f a6       	mov	r6,-6
80003fec:	80 00       	ld.sh	r0,r0[0x0]
80003fee:	72 e8       	ld.w	r8,r9[0x38]
80003ff0:	80 00       	ld.sh	r0,r0[0x0]
80003ff2:	73 d0       	ld.w	r0,r9[0x74]
80003ff4:	80 00       	ld.sh	r0,r0[0x0]
80003ff6:	78 a8       	ld.w	r8,r12[0x28]

80003ff8 <handle_bms_data>:
	}
}

void handle_bms_data(fsm_ecu_data_t *ecu_data) {
	/* Max period 300 ms, contactor req, battery current input msg */
	switch (ecu_data->bms_msg.id) {
80003ff8:	78 e8       	ld.w	r8,r12[0x38]
80003ffa:	e0 48 04 2a 	cp.w	r8,1066
80003ffe:	c1 b0       	breq	80004034 <handle_bms_data+0x3c>
80004000:	e0 8b 00 06 	brhi	8000400c <handle_bms_data+0x14>
80004004:	e0 48 04 29 	cp.w	r8,1065
80004008:	5e 1c       	retne	r12
8000400a:	c0 88       	rjmp	8000401a <handle_bms_data+0x22>
8000400c:	e0 48 04 2b 	cp.w	r8,1067
80004010:	c1 c0       	breq	80004048 <handle_bms_data+0x50>
80004012:	e0 48 04 2e 	cp.w	r8,1070
80004016:	5e 1c       	retne	r12
80004018:	c1 38       	rjmp	8000403e <handle_bms_data+0x46>
		case (BMS_PRECHARGE_ID):
		if ((ecu_data->bms_msg.data.u8[3] & (1 << BMS_PRECHARGE_BIT)) != 0) {
8000401a:	f9 38 00 33 	ld.ub	r8,r12[51]
8000401e:	e2 18 00 08 	andl	r8,0x8,COH
			/* There is a hardwire contactor request */
			ecu_data->flag_start_precharge = 1;
80004022:	f9 b8 01 01 	movne	r8,1
80004026:	f9 f8 1e 4a 	st.bne	r12[0x4a],r8
		} else {
			ecu_data->flag_start_precharge = 0;
8000402a:	f9 b8 00 00 	moveq	r8,0
8000402e:	f9 f8 0e 4a 	st.beq	r12[0x4a],r8
80004032:	5e fc       	retal	r12
		}
		break;
		case (BMS_BATT_VOLT_ID):
		ecu_data->vdc_battery = ecu_data->bms_msg.data.u16[0];
80004034:	f9 08 00 30 	ld.sh	r8,r12[48]
80004038:	f9 58 00 3c 	st.h	r12[60],r8
		break;
8000403c:	5e fc       	retal	r12
		case (BMS_BATT_TEMP_ID):
		ecu_data->max_cell_temp = ecu_data->bms_msg.data.s8[4];
8000403e:	f9 38 00 34 	ld.ub	r8,r12[52]
80004042:	f9 68 00 4c 	st.b	r12[76],r8
		break;
80004046:	5e fc       	retal	r12
		
		case (0x42B):
		ecu_data->bms_current = ecu_data->bms_msg.data.s16[0];
80004048:	f9 08 00 30 	ld.sh	r8,r12[48]
8000404c:	f9 58 00 8e 	st.h	r12[142],r8
80004050:	5e fc       	retal	r12
80004052:	d7 03       	nop

80004054 <handle_dash_data>:
		default:
		break;
	}
}

void handle_dash_data(fsm_ecu_data_t *ecu_data) {
80004054:	eb cd 40 80 	pushm	r7,lr
80004058:	18 97       	mov	r7,r12
	uint8_t rtds_plays;
	uint8_t start;
	uint8_t lc_filter_time;
	uint8_t state_of_lc = 0;
	uint16_t slip_index = 0;
	switch (ecu_data->dash_msg.id) {
8000405a:	f9 08 00 2c 	ld.sh	r8,r12[44]
8000405e:	e0 69 02 63 	mov	r9,611
80004062:	f2 08 19 00 	cp.h	r8,r9
80004066:	e0 80 00 8e 	breq	80004182 <handle_dash_data+0x12e>
8000406a:	e0 8b 00 10 	brhi	8000408a <handle_dash_data+0x36>
8000406e:	e0 69 02 61 	mov	r9,609
80004072:	f2 08 19 00 	cp.h	r8,r9
80004076:	c2 40       	breq	800040be <handle_dash_data+0x6a>
80004078:	e0 8b 00 45 	brhi	80004102 <handle_dash_data+0xae>
8000407c:	e0 69 02 60 	mov	r9,608
80004080:	f2 08 19 00 	cp.h	r8,r9
80004084:	e0 81 00 9f 	brne	800041c2 <handle_dash_data+0x16e>
80004088:	c0 f8       	rjmp	800040a6 <handle_dash_data+0x52>
8000408a:	e0 69 02 65 	mov	r9,613
8000408e:	f2 08 19 00 	cp.h	r8,r9
80004092:	e0 80 00 94 	breq	800041ba <handle_dash_data+0x166>
80004096:	c7 c3       	brcs	8000418e <handle_dash_data+0x13a>
80004098:	e0 69 06 63 	mov	r9,1635
8000409c:	f2 08 19 00 	cp.h	r8,r9
800040a0:	e0 81 00 91 	brne	800041c2 <handle_dash_data+0x16e>
800040a4:	c6 28       	rjmp	80004168 <handle_dash_data+0x114>
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID0_ID):
		rtds_plays = ecu_data->dash_msg.data.u8[0];
800040a6:	f9 39 00 24 	ld.ub	r9,r12[36]
800040aa:	30 18       	mov	r8,1
800040ac:	f0 09 18 00 	cp.b	r9,r8
800040b0:	e0 81 00 89 	brne	800041c2 <handle_dash_data+0x16e>
		if (rtds_plays == 1) {
			ecu_data->flag_drive_enable = DRIVE_ENABLE_RTDS_PLAYS;
800040b4:	30 38       	mov	r8,3
800040b6:	f9 48 00 50 	st.w	r12[80],r8
800040ba:	e3 cd 80 80 	ldm	sp++,r7,pc
		}
		break;
		
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID1_ID):
		start = ecu_data->dash_msg.data.u8[0];
800040be:	f9 38 00 24 	ld.ub	r8,r12[36]
		//uint8_t tractive = ecu_data->dash_msg.data.u8[1];
		ecu_data->kers_factor = ecu_data->dash_msg.data.s16[1];
800040c2:	f9 09 00 26 	ld.sh	r9,r12[38]
800040c6:	f9 59 00 8c 	st.h	r12[140],r9
		slip_index = ecu_data->dash_msg.data.u16[2];
		slip_index = min(slip_index, 5);
800040ca:	f9 19 00 28 	ld.uh	r9,r12[40]
800040ce:	30 5a       	mov	r10,5
800040d0:	f2 0a 0d 4a 	min	r10,r9,r10
		ecu_data->slip_target = slip_target[slip_index-1];
800040d4:	5c 7a       	castu.h	r10
800040d6:	20 1a       	sub	r10,1
800040d8:	4b c9       	lddpc	r9,800041c8 <handle_dash_data+0x174>
800040da:	f2 0a 03 2a 	ld.w	r10,r9[r10<<0x2]
800040de:	f9 4a 00 78 	st.w	r12[120],r10

		if (start == 0) {
800040e2:	58 08       	cp.w	r8,0
800040e4:	c0 51       	brne	800040ee <handle_dash_data+0x9a>
			ecu_data->flag_drive_enable = DRIVE_DISABLE_REQUEST;
800040e6:	30 48       	mov	r8,4
800040e8:	f9 48 00 50 	st.w	r12[80],r8
800040ec:	c0 88       	rjmp	800040fc <handle_dash_data+0xa8>
		} else if (start == 1) {
800040ee:	30 19       	mov	r9,1
			ecu_data->flag_drive_enable = DRIVE_ENABLE_REQUEST;
800040f0:	f2 08 18 00 	cp.b	r8,r9
800040f4:	f9 b8 00 01 	moveq	r8,1
800040f8:	ef f8 0a 14 	st.weq	r7[0x50],r8
		}
		asm("nop");
800040fc:	d7 03       	nop
		break;
800040fe:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID2_ID):
		//PID gains
		ecu_data->Kp = ecu_data->dash_msg.data.u16[0]/10.0;
80004102:	f9 1c 00 24 	ld.uh	r12,r12[36]
80004106:	f0 1f 00 32 	mcall	800041cc <handle_dash_data+0x178>
8000410a:	30 08       	mov	r8,0
8000410c:	fc 19 40 24 	movh	r9,0x4024
80004110:	f0 1f 00 30 	mcall	800041d0 <handle_dash_data+0x17c>
80004114:	f0 1f 00 30 	mcall	800041d4 <handle_dash_data+0x180>
80004118:	ef 4c 00 6c 	st.w	r7[108],r12
		ecu_data->Ki = ecu_data->dash_msg.data.u16[1]/10.0;
8000411c:	ef 1c 00 26 	ld.uh	r12,r7[38]
80004120:	f0 1f 00 2b 	mcall	800041cc <handle_dash_data+0x178>
80004124:	30 08       	mov	r8,0
80004126:	fc 19 40 24 	movh	r9,0x4024
8000412a:	f0 1f 00 2a 	mcall	800041d0 <handle_dash_data+0x17c>
8000412e:	f0 1f 00 2a 	mcall	800041d4 <handle_dash_data+0x180>
80004132:	ef 4c 00 70 	st.w	r7[112],r12
		ecu_data->Kd = ecu_data->dash_msg.data.u16[2]/10.0;
80004136:	ef 1c 00 28 	ld.uh	r12,r7[40]
8000413a:	f0 1f 00 25 	mcall	800041cc <handle_dash_data+0x178>
8000413e:	30 08       	mov	r8,0
80004140:	fc 19 40 24 	movh	r9,0x4024
80004144:	f0 1f 00 23 	mcall	800041d0 <handle_dash_data+0x17c>
80004148:	f0 1f 00 23 	mcall	800041d4 <handle_dash_data+0x180>
8000414c:	ef 4c 00 74 	st.w	r7[116],r12
		ecu_data->d_filter_gain = (N_filter*Ts/(ecu_data->Kd+N_filter*Ts));
80004150:	fc 18 40 00 	movh	r8,0x4000
80004154:	e5 a0 0b c8 	cop	cp0,cr11,cr12,cr8,0x40
80004158:	10 9c       	mov	r12,r8
8000415a:	f0 1f 00 20 	mcall	800041d8 <handle_dash_data+0x184>
8000415e:	ef 4c 00 7c 	st.w	r7[124],r12
		asm("nop");
80004162:	d7 03       	nop
		break;
80004164:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		case (CANR_FCN_DATA_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID3_ID):
		//Only permit if ECU in error
		if (ecu_data->state == STATE_ERROR) {
80004168:	78 08       	ld.w	r8,r12[0x0]
8000416a:	58 88       	cp.w	r8,8
8000416c:	c0 81       	brne	8000417c <handle_dash_data+0x128>
			if (ecu_data->dash_msg.data.u8[1]==1) {// Message also contains the current driver
8000416e:	f9 39 00 25 	ld.ub	r9,r12[37]
80004172:	30 18       	mov	r8,1
				ecu_data->reboot = 1;
80004174:	f0 09 18 00 	cp.b	r9,r8
80004178:	f9 f8 0e 68 	st.beq	r12[0x68],r8
			}
		}
		asm("nop");
8000417c:	d7 03       	nop
		break;
8000417e:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID3_ID):
		ecu_data->config_max_trq = ecu_data->dash_msg.data.u8[1];
80004182:	f9 38 00 25 	ld.ub	r8,r12[37]
80004186:	f9 68 00 69 	st.b	r12[105],r8
		break;
8000418a:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID4_ID):
		ecu_data->lc_trq_init = ecu_data->dash_msg.data.u8[0];
8000418e:	f9 38 00 24 	ld.ub	r8,r12[36]
80004192:	e5 a4 08 08 	cop	cp0,cr8,cr0,cr8,0x48
80004196:	f9 48 00 88 	st.w	r12[136],r8
		lc_filter_time = ecu_data->dash_msg.data.u8[1];
		ecu_data->lc_filter_gain = Ts/(Ts + lc_filter_time);
8000419a:	f9 3b 00 25 	ld.ub	r11,r12[37]
8000419e:	e5 a6 0b 0b 	cop	cp0,cr11,cr0,cr11,0x4c
800041a2:	e0 6c d7 0a 	mov	r12,55050
800041a6:	ea 1c 3c a3 	orh	r12,0x3ca3
800041aa:	e5 a0 0b bc 	cop	cp0,cr11,cr11,cr12,0x40
800041ae:	f0 1f 00 0b 	mcall	800041d8 <handle_dash_data+0x184>
800041b2:	ef 4c 00 84 	st.w	r7[132],r12
		break;
800041b6:	e3 cd 80 80 	ldm	sp++,r7,pc
		
		case (CANR_FCN_PRI_ID | CANR_GRP_DASH_ID | CANR_MODULE_ID5_ID):
		state_of_lc = ecu_data->dash_msg.data.u8[0];
		ecu_data->launch_control_flag = (launch_control_t)state_of_lc;
800041ba:	f9 38 00 24 	ld.ub	r8,r12[36]
800041be:	f9 48 00 64 	st.w	r12[100],r8
800041c2:	e3 cd 80 80 	ldm	sp++,r7,pc
800041c6:	00 00       	add	r0,r0
800041c8:	00 00       	add	r0,r0
800041ca:	01 c4       	ld.ub	r4,r0[0x4]
800041cc:	80 00       	ld.sh	r0,r0[0x0]
800041ce:	72 f0       	ld.w	r0,r9[0x3c]
800041d0:	80 00       	ld.sh	r0,r0[0x0]
800041d2:	73 d0       	ld.w	r0,r9[0x74]
800041d4:	80 00       	ld.sh	r0,r0[0x0]
800041d6:	78 a8       	ld.w	r8,r12[0x28]
800041d8:	80 00       	ld.sh	r0,r0[0x0]
800041da:	76 e8       	ld.w	r8,r11[0x38]

800041dc <handle_inverter_data>:
		default:
		break;
	}
}

void handle_inverter_data(fsm_ecu_data_t *ecu_data) {
800041dc:	eb cd 40 80 	pushm	r7,lr
800041e0:	18 97       	mov	r7,r12
	 * consist of 4 bytes etc. Refer to manual for the individual
	 * bits in state and error reg.
	 * Temp e.g.: 49d62a00 
	 */
	uint16_t temp;
	switch (ecu_data->inverter_can_msg.data.u8[0]) {
800041e2:	19 c8       	ld.ub	r8,r12[0x4]
800041e4:	34 a9       	mov	r9,74
800041e6:	f2 08 18 00 	cp.b	r8,r9
800041ea:	c1 c0       	breq	80004222 <handle_inverter_data+0x46>
800041ec:	e0 8b 00 0b 	brhi	80004202 <handle_inverter_data+0x26>
800041f0:	33 09       	mov	r9,48
800041f2:	f2 08 18 00 	cp.b	r8,r9
800041f6:	c2 b0       	breq	8000424c <handle_inverter_data+0x70>
800041f8:	34 99       	mov	r9,73
800041fa:	f2 08 18 00 	cp.b	r8,r9
800041fe:	c3 f1       	brne	8000427c <handle_inverter_data+0xa0>
80004200:	c0 a8       	rjmp	80004214 <handle_inverter_data+0x38>
80004202:	38 f9       	mov	r9,-113
80004204:	f2 08 18 00 	cp.b	r8,r9
80004208:	c3 50       	breq	80004272 <handle_inverter_data+0x96>
8000420a:	3e b9       	mov	r9,-21
8000420c:	f2 08 18 00 	cp.b	r8,r9
80004210:	c3 61       	brne	8000427c <handle_inverter_data+0xa0>
80004212:	c0 f8       	rjmp	80004230 <handle_inverter_data+0x54>
		case BTB_REG:
			break;
		case FRG_REG:
			break;
		case MOTOR_TEMP_REG:
			ecu_data->motor_temp = convert_to_big_endian(ecu_data->inverter_can_msg.data.u32[0]);
80004214:	78 1c       	ld.w	r12,r12[0x4]
80004216:	f0 1f 00 1b 	mcall	80004280 <handle_inverter_data+0xa4>
8000421a:	ef 5c 00 42 	st.h	r7[66],r12
			break;
8000421e:	e3 cd 80 80 	ldm	sp++,r7,pc
		case IGBT_TEMP_REG:
			ecu_data->inverter_temp = convert_to_big_endian(ecu_data->inverter_can_msg.data.u32[0]);
80004222:	78 1c       	ld.w	r12,r12[0x4]
80004224:	f0 1f 00 17 	mcall	80004280 <handle_inverter_data+0xa4>
80004228:	ef 5c 00 44 	st.h	r7[68],r12
			break;
8000422c:	e3 cd 80 80 	ldm	sp++,r7,pc
		case CURRENT_REG:
			break;
		case VDC_REG:
			/* 16 bit value */
			temp = convert_num_to_vdc(ecu_data->inverter_can_msg.data.u32[0]);
80004230:	78 1c       	ld.w	r12,r12[0x4]
80004232:	f0 1f 00 15 	mcall	80004284 <handle_inverter_data+0xa8>
			if (temp < 30) {
80004236:	31 d8       	mov	r8,29
				ecu_data->inverter_vdc = 0;	
80004238:	f0 0c 19 00 	cp.h	r12,r8
8000423c:	f9 b8 08 00 	movls	r8,0
80004240:	ef f8 8c 1f 	st.hls	r7[0x3e],r8
			} else {
				ecu_data->inverter_vdc = temp;
80004244:	ef fc bc 1f 	st.hhi	r7[0x3e],r12
80004248:	e3 cd 80 80 	ldm	sp++,r7,pc
			}	 
			break;
		case RPM_REG:
			ecu_data->rpm = (MAX_RPM * convert_to_big_endian(ecu_data->inverter_can_msg.data.u32[0])) / 32767;
8000424c:	78 1c       	ld.w	r12,r12[0x4]
8000424e:	f0 1f 00 0d 	mcall	80004280 <handle_inverter_data+0xa4>
80004252:	5c 7c       	castu.h	r12
80004254:	e0 68 13 88 	mov	r8,5000
80004258:	f8 08 02 48 	mul	r8,r12,r8
8000425c:	30 3b       	mov	r11,3
8000425e:	ea 1b 80 01 	orh	r11,0x8001
80004262:	f0 0b 04 4a 	muls.d	r10,r8,r11
80004266:	16 08       	add	r8,r11
80004268:	af 48       	asr	r8,0xe
8000426a:	ef 58 00 40 	st.h	r7[64],r8
			break;
8000426e:	e3 cd 80 80 	ldm	sp++,r7,pc
		case ERROR_REG:
			ecu_data->inverter_error = (ecu_data->inverter_can_msg.data.u32[0] & 0x00FFFF00) >> 8;
80004272:	78 18       	ld.w	r8,r12[0x4]
80004274:	f1 d8 c1 10 	bfextu	r8,r8,0x8,0x10
80004278:	f9 58 00 58 	st.h	r12[88],r8
8000427c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004280:	80 00       	ld.sh	r0,r0[0x0]
80004282:	3f a6       	mov	r6,-6
80004284:	80 00       	ld.sh	r0,r0[0x0]
80004286:	3f b8       	mov	r8,-5

80004288 <map_pedal>:
		default:
			break;
	}
}

void map_pedal(fsm_ecu_data_t *ecu_data) {
80004288:	eb cd 40 c0 	pushm	r6-r7,lr
8000428c:	18 97       	mov	r7,r12
	// Torque sensors = <0,1000>
	static float pedal_filter = 0.0F;
	float config_max_trq = (float)ecu_data->config_max_trq / 100.0;
8000428e:	f9 3c 00 69 	ld.ub	r12,r12[105]
	
	int16_t trq_sens = (int16_t)min(ecu_data->trq_sens0, ecu_data->trq_sens1);
80004292:	ef 08 00 10 	ld.sh	r8,r7[16]
80004296:	ef 09 00 12 	ld.sh	r9,r7[18]
8000429a:	f0 09 0d 48 	min	r8,r8,r9
8000429e:	5c 88       	casts.h	r8
	if (trq_sens > 150) { 
800042a0:	e0 69 00 96 	mov	r9,150
800042a4:	f2 08 19 00 	cp.h	r8,r9
800042a8:	e0 8a 00 34 	brle	80004310 <map_pedal+0x88>
		// Handle values below 0
		trq_sens = max(0, trq_sens);
800042ac:	30 09       	mov	r9,0
800042ae:	f2 08 0c 48 	max	r8,r9,r8
		// Handle values above 1000
		trq_sens = min(trq_sens, 1000);
800042b2:	5c 88       	casts.h	r8
800042b4:	e0 66 03 e8 	mov	r6,1000
800042b8:	f0 06 0d 48 	min	r8,r8,r6
		
		float pedal = (float)MAX_TORQUE*(float)trq_sens*(float)trq_sens*config_max_trq/1000000.0;
800042bc:	5c 88       	casts.h	r8
800042be:	e5 a6 08 08 	cop	cp0,cr8,cr0,cr8,0x4c
800042c2:	e0 66 f0 00 	mov	r6,61440
800042c6:	ea 16 46 ff 	orh	r6,0x46ff
800042ca:	e5 a2 06 86 	cop	cp0,cr6,cr8,cr6,0x44
800042ce:	e5 a2 06 86 	cop	cp0,cr6,cr8,cr6,0x44
800042d2:	fc 1b 42 c8 	movh	r11,0x42c8
800042d6:	e5 a4 0c 0c 	cop	cp0,cr12,cr0,cr12,0x48
800042da:	f0 1f 00 10 	mcall	80004318 <map_pedal+0x90>
800042de:	e0 6b 24 00 	mov	r11,9216
800042e2:	ea 1b 49 74 	orh	r11,0x4974
800042e6:	e5 a2 0c 6c 	cop	cp0,cr12,cr6,cr12,0x44
800042ea:	f0 1f 00 0c 	mcall	80004318 <map_pedal+0x90>
		//float pedal = (float)MAX_TORQUE*(float)trq_sens*config_max_trq/1000.0; //Linear curve
		pedal_filter = (1-PEDAL_FILTER_GAIN)*pedal_filter + PEDAL_FILTER_GAIN*pedal;
800042ee:	48 c9       	lddpc	r9,8000431c <map_pedal+0x94>
800042f0:	72 0a       	ld.w	r10,r9[0x0]
800042f2:	30 08       	mov	r8,0
800042f4:	e1 ac 08 a8 	cop	cp0,cr8,cr10,cr8,0x18
800042f8:	93 08       	st.w	r9[0x0],r8
		
		ecu_data->trq_pedal = min(pedal_filter, pedal); //Selects filter when input increases, pedal when decreases
800042fa:	e5 ab 08 08 	cop	cp0,cr8,cr0,cr8,0x56
800042fe:	e5 ab 0c 0c 	cop	cp0,cr12,cr0,cr12,0x56
80004302:	f0 0c 0d 48 	min	r8,r8,r12
80004306:	e5 a6 08 08 	cop	cp0,cr8,cr0,cr8,0x4c
8000430a:	8f 88       	st.w	r7[0x20],r8
8000430c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
	} else {
		ecu_data->trq_pedal = 0;
80004310:	30 08       	mov	r8,0
80004312:	8f 88       	st.w	r7[0x20],r8
80004314:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004318:	80 00       	ld.sh	r0,r0[0x0]
8000431a:	76 e8       	ld.w	r8,r11[0x38]
8000431c:	00 00       	add	r0,r0
8000431e:	cc 14       	brge	800042a0 <map_pedal+0x18>

80004320 <get_new_data>:
	gpio_set_pin_high(INVERTER_DIN1);
	delay_us(200);
	gpio_set_pin_low(INVERTER_DIN1);
}

void get_new_data(fsm_ecu_data_t *ecu_data) {
80004320:	eb cd 40 fe 	pushm	r1-r7,lr
80004324:	18 96       	mov	r6,r12
	uint8_t i;
	for (i=0; i<QUEUE_INVERTER_RX_LEN; i++) {
		if (xQueueReceive( queue_from_inverter, &ecu_data->inverter_can_msg, 0 ) == pdTRUE) {
80004326:	f8 c3 ff fc 	sub	r3,r12,-4
8000432a:	30 07       	mov	r7,0
8000432c:	4a 62       	lddpc	r2,800043c4 <get_new_data+0xa4>
8000432e:	0e 91       	mov	r1,r7
			handle_inverter_data(ecu_data);
			ecu_data->inverter_timeout = 0;
80004330:	30 05       	mov	r5,0
	gpio_set_pin_low(INVERTER_DIN1);
}

void get_new_data(fsm_ecu_data_t *ecu_data) {
	uint8_t i;
	for (i=0; i<QUEUE_INVERTER_RX_LEN; i++) {
80004332:	30 54       	mov	r4,5
		if (xQueueReceive( queue_from_inverter, &ecu_data->inverter_can_msg, 0 ) == pdTRUE) {
80004334:	02 99       	mov	r9,r1
80004336:	02 9a       	mov	r10,r1
80004338:	06 9b       	mov	r11,r3
8000433a:	64 0c       	ld.w	r12,r2[0x0]
8000433c:	f0 1f 00 23 	mcall	800043c8 <get_new_data+0xa8>
80004340:	58 1c       	cp.w	r12,1
80004342:	c0 c1       	brne	8000435a <get_new_data+0x3a>
			handle_inverter_data(ecu_data);
80004344:	0c 9c       	mov	r12,r6
80004346:	f0 1f 00 22 	mcall	800043cc <get_new_data+0xac>
			ecu_data->inverter_timeout = 0;
8000434a:	ed 65 00 80 	st.b	r6[128],r5
	gpio_set_pin_low(INVERTER_DIN1);
}

void get_new_data(fsm_ecu_data_t *ecu_data) {
	uint8_t i;
	for (i=0; i<QUEUE_INVERTER_RX_LEN; i++) {
8000434e:	2f f7       	sub	r7,-1
80004350:	5c 57       	castu.b	r7
80004352:	e8 07 18 00 	cp.b	r7,r4
80004356:	ce f1       	brne	80004334 <get_new_data+0x14>
80004358:	c0 68       	rjmp	80004364 <get_new_data+0x44>
		if (xQueueReceive( queue_from_inverter, &ecu_data->inverter_can_msg, 0 ) == pdTRUE) {
			handle_inverter_data(ecu_data);
			ecu_data->inverter_timeout = 0;
		} else {
			ecu_data->inverter_timeout++;
8000435a:	ed 38 00 80 	ld.ub	r8,r6[128]
8000435e:	2f f8       	sub	r8,-1
80004360:	ed 68 00 80 	st.b	r6[128],r8
			break;
		}
	}
	
	for (i=0; i<QUEUE_DASH_MSG_LEN; i++) {
		if (xQueueReceive( queue_dash_msg, &ecu_data->dash_msg, 0 ) == pdTRUE) {
80004364:	ec c4 ff dc 	sub	r4,r6,-36
80004368:	30 07       	mov	r7,0
8000436a:	49 a3       	lddpc	r3,800043d0 <get_new_data+0xb0>
8000436c:	0e 92       	mov	r2,r7
			ecu_data->inverter_timeout++;
			break;
		}
	}
	
	for (i=0; i<QUEUE_DASH_MSG_LEN; i++) {
8000436e:	30 55       	mov	r5,5
		if (xQueueReceive( queue_dash_msg, &ecu_data->dash_msg, 0 ) == pdTRUE) {
80004370:	04 99       	mov	r9,r2
80004372:	04 9a       	mov	r10,r2
80004374:	08 9b       	mov	r11,r4
80004376:	66 0c       	ld.w	r12,r3[0x0]
80004378:	f0 1f 00 14 	mcall	800043c8 <get_new_data+0xa8>
8000437c:	58 1c       	cp.w	r12,1
8000437e:	c0 80       	breq	8000438e <get_new_data+0x6e>
			break;
		}
	}
	
	for (i=0; i<QUEUE_BMS_RX_LEN; i++) {
		if (xQueueReceive( queue_bms_rx, &ecu_data->bms_msg, 0 ) == pdTRUE) {
80004380:	ec c4 ff d0 	sub	r4,r6,-48
80004384:	30 07       	mov	r7,0
80004386:	49 43       	lddpc	r3,800043d4 <get_new_data+0xb4>
80004388:	0e 92       	mov	r2,r7
		} else {
			break;
		}
	}
	
	for (i=0; i<QUEUE_BMS_RX_LEN; i++) {
8000438a:	30 55       	mov	r5,5
8000438c:	c0 a8       	rjmp	800043a0 <get_new_data+0x80>
		}
	}
	
	for (i=0; i<QUEUE_DASH_MSG_LEN; i++) {
		if (xQueueReceive( queue_dash_msg, &ecu_data->dash_msg, 0 ) == pdTRUE) {
			handle_dash_data(ecu_data);
8000438e:	0c 9c       	mov	r12,r6
80004390:	f0 1f 00 12 	mcall	800043d8 <get_new_data+0xb8>
			ecu_data->inverter_timeout++;
			break;
		}
	}
	
	for (i=0; i<QUEUE_DASH_MSG_LEN; i++) {
80004394:	2f f7       	sub	r7,-1
80004396:	5c 57       	castu.b	r7
80004398:	ea 07 18 00 	cp.b	r7,r5
8000439c:	ce a1       	brne	80004370 <get_new_data+0x50>
8000439e:	cf 1b       	rjmp	80004380 <get_new_data+0x60>
			break;
		}
	}
	
	for (i=0; i<QUEUE_BMS_RX_LEN; i++) {
		if (xQueueReceive( queue_bms_rx, &ecu_data->bms_msg, 0 ) == pdTRUE) {
800043a0:	04 99       	mov	r9,r2
800043a2:	04 9a       	mov	r10,r2
800043a4:	08 9b       	mov	r11,r4
800043a6:	66 0c       	ld.w	r12,r3[0x0]
800043a8:	f0 1f 00 08 	mcall	800043c8 <get_new_data+0xa8>
800043ac:	58 1c       	cp.w	r12,1
800043ae:	c0 91       	brne	800043c0 <get_new_data+0xa0>
			handle_bms_data(ecu_data);
800043b0:	0c 9c       	mov	r12,r6
800043b2:	f0 1f 00 0b 	mcall	800043dc <get_new_data+0xbc>
		} else {
			break;
		}
	}
	
	for (i=0; i<QUEUE_BMS_RX_LEN; i++) {
800043b6:	2f f7       	sub	r7,-1
800043b8:	5c 57       	castu.b	r7
800043ba:	ea 07 18 00 	cp.b	r7,r5
800043be:	cf 11       	brne	800043a0 <get_new_data+0x80>
800043c0:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
800043c4:	00 00       	add	r0,r0
800043c6:	cf 58       	rjmp	800045b0 <launch_control+0x1c>
800043c8:	80 00       	ld.sh	r0,r0[0x0]
800043ca:	2d 6c       	sub	r12,-42
800043cc:	80 00       	ld.sh	r0,r0[0x0]
800043ce:	41 dc       	lddsp	r12,sp[0x74]
800043d0:	00 00       	add	r0,r0
800043d2:	cf 7c       	rcall	800045c0 <launch_control+0x2c>
800043d4:	00 00       	add	r0,r0
800043d6:	cf 54       	brge	800043c0 <get_new_data+0xa0>
800043d8:	80 00       	ld.sh	r0,r0[0x0]
800043da:	40 54       	lddsp	r4,sp[0x14]
800043dc:	80 00       	ld.sh	r0,r0[0x0]
800043de:	3f f8       	mov	r8,-1

800043e0 <get_trq_sens>:
		ecu_data->speed_sens_alive[2] = 1;
	}
	asm("nop");
}

uint8_t get_trq_sens(fsm_ecu_data_t *ecu_data) {
800043e0:	eb cd 40 c0 	pushm	r6-r7,lr
800043e4:	18 96       	mov	r6,r12
	uint8_t status = 0;
	if (xQueueReceive( queue_trq_sens0, &ecu_data->trq_sens0, 0 ) == pdFALSE ) {
800043e6:	30 09       	mov	r9,0
800043e8:	12 9a       	mov	r10,r9
800043ea:	f8 cb ff f0 	sub	r11,r12,-16
800043ee:	49 58       	lddpc	r8,80004440 <get_trq_sens+0x60>
800043f0:	70 0c       	ld.w	r12,r8[0x0]
800043f2:	f0 1f 00 15 	mcall	80004444 <get_trq_sens+0x64>
800043f6:	5f 07       	sreq	r7
		status++;
	}
	if (xQueueReceive( queue_trq_sens1, &ecu_data->trq_sens1, 0 ) == pdFALSE ) {
800043f8:	30 09       	mov	r9,0
800043fa:	12 9a       	mov	r10,r9
800043fc:	ec cb ff ee 	sub	r11,r6,-18
80004400:	49 28       	lddpc	r8,80004448 <get_trq_sens+0x68>
80004402:	70 0c       	ld.w	r12,r8[0x0]
80004404:	f0 1f 00 10 	mcall	80004444 <get_trq_sens+0x64>
80004408:	c0 31       	brne	8000440e <get_trq_sens+0x2e>
		status++;
8000440a:	2f f7       	sub	r7,-1
8000440c:	5c 57       	castu.b	r7
	}
	if (xQueueReceive( queue_trq_sens0_err, &ecu_data->trq_sens0_err, 0 ) == pdFALSE ) {
8000440e:	30 09       	mov	r9,0
80004410:	12 9a       	mov	r10,r9
80004412:	ec cb ff ec 	sub	r11,r6,-20
80004416:	48 e8       	lddpc	r8,8000444c <get_trq_sens+0x6c>
80004418:	70 0c       	ld.w	r12,r8[0x0]
8000441a:	f0 1f 00 0b 	mcall	80004444 <get_trq_sens+0x64>
8000441e:	c0 31       	brne	80004424 <get_trq_sens+0x44>
		status++;
80004420:	2f f7       	sub	r7,-1
80004422:	5c 57       	castu.b	r7
	}
	if (xQueueReceive( queue_trq_sens1_err, &ecu_data->trq_sens1_err, 0 ) == pdFALSE ) {
80004424:	30 09       	mov	r9,0
80004426:	12 9a       	mov	r10,r9
80004428:	ec cb ff eb 	sub	r11,r6,-21
8000442c:	48 98       	lddpc	r8,80004450 <get_trq_sens+0x70>
8000442e:	70 0c       	ld.w	r12,r8[0x0]
80004430:	f0 1f 00 05 	mcall	80004444 <get_trq_sens+0x64>
80004434:	c0 31       	brne	8000443a <get_trq_sens+0x5a>
		status++;
80004436:	2f f7       	sub	r7,-1
80004438:	5c 57       	castu.b	r7
	}
	return status;
}
8000443a:	0e 9c       	mov	r12,r7
8000443c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004440:	00 00       	add	r0,r0
80004442:	cf 60       	breq	8000442e <get_trq_sens+0x4e>
80004444:	80 00       	ld.sh	r0,r0[0x0]
80004446:	2d 6c       	sub	r12,-42
80004448:	00 00       	add	r0,r0
8000444a:	cf 88       	rjmp	8000463a <launch_control+0xa6>
8000444c:	00 00       	add	r0,r0
8000444e:	cf 8c       	rcall	8000463e <launch_control+0xaa>
80004450:	00 00       	add	r0,r0
80004452:	cf 74       	brge	80004440 <get_trq_sens+0x60>

80004454 <get_speed_sens>:
		status |= 1 << 1;
	}
	return status;
}

void get_speed_sens(fsm_ecu_data_t *ecu_data) {
80004454:	eb cd 40 80 	pushm	r7,lr
80004458:	18 97       	mov	r7,r12
	if (xQueueReceive( queue_wheel_fl, &ecu_data->WFL_sens, 0 ) == pdFALSE) {
8000445a:	30 09       	mov	r9,0
8000445c:	12 9a       	mov	r10,r9
8000445e:	f8 cb ff a4 	sub	r11,r12,-92
80004462:	49 88       	lddpc	r8,800044c0 <get_speed_sens+0x6c>
80004464:	70 0c       	ld.w	r12,r8[0x0]
80004466:	f0 1f 00 18 	mcall	800044c4 <get_speed_sens+0x70>
		ecu_data->speed_sens_alive[0] = 0;
8000446a:	f9 b8 00 00 	moveq	r8,0
8000446e:	ef f8 0e 92 	st.beq	r7[0x92],r8
	} else {
		ecu_data->speed_sens_alive[0] = 1;
80004472:	f9 b8 01 01 	movne	r8,1
80004476:	ef f8 1e 92 	st.bne	r7[0x92],r8
	}
	if (xQueueReceive( queue_wheel_fr, &ecu_data->WFR_sens, 0 ) == pdFALSE) {
8000447a:	30 09       	mov	r9,0
8000447c:	12 9a       	mov	r10,r9
8000447e:	ee cb ff a2 	sub	r11,r7,-94
80004482:	49 28       	lddpc	r8,800044c8 <get_speed_sens+0x74>
80004484:	70 0c       	ld.w	r12,r8[0x0]
80004486:	f0 1f 00 10 	mcall	800044c4 <get_speed_sens+0x70>
		ecu_data->speed_sens_alive[1] = 0;
8000448a:	f9 b8 00 00 	moveq	r8,0
8000448e:	ef f8 0e 93 	st.beq	r7[0x93],r8
	} else {
		ecu_data->speed_sens_alive[1] = 1;
80004492:	f9 b8 01 01 	movne	r8,1
80004496:	ef f8 1e 93 	st.bne	r7[0x93],r8
	}
// 	if (xQueueReceive( queue_wheel_rl, &ecu_data->WRL_sens, 0 ) == pdFALSE) { // Sensor not working
// 		status++;
// 	}
	if (xQueueReceive( queue_wheel_rr, &ecu_data->WRR_sens, 0 ) == pdFALSE) {
8000449a:	30 09       	mov	r9,0
8000449c:	12 9a       	mov	r10,r9
8000449e:	ee cb ff 9e 	sub	r11,r7,-98
800044a2:	48 b8       	lddpc	r8,800044cc <get_speed_sens+0x78>
800044a4:	70 0c       	ld.w	r12,r8[0x0]
800044a6:	f0 1f 00 08 	mcall	800044c4 <get_speed_sens+0x70>
		ecu_data->speed_sens_alive[2] = 0;
800044aa:	f9 b8 00 00 	moveq	r8,0
800044ae:	ef f8 0e 94 	st.beq	r7[0x94],r8
	} else {
		ecu_data->speed_sens_alive[2] = 1;
800044b2:	f9 b8 01 01 	movne	r8,1
800044b6:	ef f8 1e 94 	st.bne	r7[0x94],r8
	}
	asm("nop");
800044ba:	d7 03       	nop
}
800044bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800044c0:	00 00       	add	r0,r0
800044c2:	cf 78       	rjmp	800046b0 <calculate_slip+0x24>
800044c4:	80 00       	ld.sh	r0,r0[0x0]
800044c6:	2d 6c       	sub	r12,-42
800044c8:	00 00       	add	r0,r0
800044ca:	cf 70       	breq	800044b8 <get_speed_sens+0x64>
800044cc:	00 00       	add	r0,r0
800044ce:	cf 6c       	rcall	800046ba <calculate_slip+0x2e>

800044d0 <get_brake_sens>:
		return 1;
	}
	return 0;
}

uint8_t get_brake_sens(fsm_ecu_data_t *ecu_data) {
800044d0:	eb cd 40 c0 	pushm	r6-r7,lr
800044d4:	18 96       	mov	r6,r12
	uint8_t status = 0;
	if (xQueueReceive( queue_brake_front, &ecu_data->brake_front, 0 ) == pdFALSE) {
800044d6:	30 09       	mov	r9,0
800044d8:	12 9a       	mov	r10,r9
800044da:	f8 cb ff ba 	sub	r11,r12,-70
800044de:	48 a8       	lddpc	r8,80004504 <get_brake_sens+0x34>
800044e0:	70 0c       	ld.w	r12,r8[0x0]
800044e2:	f0 1f 00 0a 	mcall	80004508 <get_brake_sens+0x38>
800044e6:	5f 07       	sreq	r7
		status |= 1 << 0;
	}
	if (xQueueReceive( queue_brake_rear, &ecu_data->brake_rear, 0 ) == pdFALSE) {
800044e8:	30 09       	mov	r9,0
800044ea:	12 9a       	mov	r10,r9
800044ec:	ec cb ff b8 	sub	r11,r6,-72
800044f0:	48 78       	lddpc	r8,8000450c <get_brake_sens+0x3c>
800044f2:	70 0c       	ld.w	r12,r8[0x0]
800044f4:	f0 1f 00 05 	mcall	80004508 <get_brake_sens+0x38>
800044f8:	c0 31       	brne	800044fe <get_brake_sens+0x2e>
		status |= 1 << 1;
800044fa:	a1 b7       	sbr	r7,0x1
800044fc:	5c 57       	castu.b	r7
	}
	return status;
}
800044fe:	0e 9c       	mov	r12,r7
80004500:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80004504:	00 00       	add	r0,r0
80004506:	cf 90       	breq	800044f8 <get_brake_sens+0x28>
80004508:	80 00       	ld.sh	r0,r0[0x0]
8000450a:	2d 6c       	sub	r12,-42
8000450c:	00 00       	add	r0,r0
8000450e:	cf 68       	rjmp	800046fa <calculate_slip+0x6e>

80004510 <check_bspd>:
		return (82500 / ecu_data->vdc_battery);	
	}
	return 0;
}

uint8_t check_bspd(void) {
80004510:	d4 01       	pushm	lr
80004512:	20 1d       	sub	sp,4
	uint8_t temp=0;
80004514:	fa cb ff fc 	sub	r11,sp,-4
80004518:	30 08       	mov	r8,0
8000451a:	16 f8       	st.b	--r11,r8
	xQueueReceive(queue_bspd, &temp, 0);
8000451c:	30 09       	mov	r9,0
8000451e:	12 9a       	mov	r10,r9
80004520:	48 48       	lddpc	r8,80004530 <check_bspd+0x20>
80004522:	70 0c       	ld.w	r12,r8[0x0]
80004524:	f0 1f 00 04 	mcall	80004534 <check_bspd+0x24>
	return temp;
}
80004528:	1b bc       	ld.ub	r12,sp[0x3]
8000452a:	2f fd       	sub	sp,-4
8000452c:	d8 02       	popm	pc
8000452e:	00 00       	add	r0,r0
80004530:	00 00       	add	r0,r0
80004532:	cf 80       	breq	80004522 <check_bspd+0x12>
80004534:	80 00       	ld.sh	r0,r0[0x0]
80004536:	2d 6c       	sub	r12,-42

80004538 <ecu_dio_inverter_clear_error>:
	/* Input: 0x49 D2 2A 00 Output:0x2A D2 */
	uint16_t relevant_data = (data & 0xFFFF00) >> 8;
	return ((relevant_data & 0xFF) << 8 | (relevant_data & 0xFF00) >> 8);
}

void ecu_dio_inverter_clear_error() {
80004538:	eb cd 40 80 	pushm	r7,lr
	gpio_set_pin_high(INVERTER_DIN1);
8000453c:	30 5c       	mov	r12,5
8000453e:	f0 1f 00 13 	mcall	80004588 <ecu_dio_inverter_clear_error+0x50>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80004542:	e1 b7 00 42 	mfsr	r7,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80004546:	ee 78 42 40 	mov	r8,1000000
8000454a:	30 09       	mov	r9,0
8000454c:	e0 6a a2 3f 	mov	r10,41535
80004550:	ea 1a 3c 43 	orh	r10,0x3c43
80004554:	30 2b       	mov	r11,2
80004556:	f0 1f 00 0e 	mcall	8000458c <ecu_dio_inverter_clear_error+0x54>
8000455a:	ee 0a 00 0a 	add	r10,r7,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
8000455e:	e1 b8 00 42 	mfsr	r8,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80004562:	14 37       	cp.w	r7,r10
80004564:	e0 88 00 08 	brls	80004574 <ecu_dio_inverter_clear_error+0x3c>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80004568:	10 37       	cp.w	r7,r8
8000456a:	fe 98 ff fa 	brls	8000455e <ecu_dio_inverter_clear_error+0x26>
8000456e:	10 3a       	cp.w	r10,r8
80004570:	c0 73       	brcs	8000457e <ecu_dio_inverter_clear_error+0x46>
80004572:	cf 6b       	rjmp	8000455e <ecu_dio_inverter_clear_error+0x26>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80004574:	10 37       	cp.w	r7,r8
80004576:	e0 8b 00 04 	brhi	8000457e <ecu_dio_inverter_clear_error+0x46>
8000457a:	10 3a       	cp.w	r10,r8
8000457c:	cf 12       	brcc	8000455e <ecu_dio_inverter_clear_error+0x26>
	delay_us(200);
	gpio_set_pin_low(INVERTER_DIN1);
8000457e:	30 5c       	mov	r12,5
80004580:	f0 1f 00 04 	mcall	80004590 <ecu_dio_inverter_clear_error+0x58>
}
80004584:	e3 cd 80 80 	ldm	sp++,r7,pc
80004588:	80 00       	ld.sh	r0,r0[0x0]
8000458a:	69 a6       	ld.w	r6,r4[0x68]
8000458c:	80 00       	ld.sh	r0,r0[0x0]
8000458e:	79 32       	ld.w	r2,r12[0x4c]
80004590:	80 00       	ld.sh	r0,r0[0x0]
80004592:	69 bc       	ld.w	r12,r4[0x6c]

80004594 <launch_control>:
		}
	}
	ecu_data->control_u = Kp*e;
}

void launch_control(fsm_ecu_data_t *ecu_data) {
80004594:	eb cd 40 fc 	pushm	r2-r7,lr
80004598:	18 97       	mov	r7,r12
	static float filter_output = 0.0F;
	static uint8_t first_run = 1;
	float filter_gain = ecu_data->lc_filter_gain;
8000459a:	f8 f6 00 84 	ld.w	r6,r12[132]
	int16_t trq_min = min(ecu_data->trq_sens0, ecu_data->trq_sens1);
8000459e:	f9 08 00 10 	ld.sh	r8,r12[16]
800045a2:	f9 04 00 12 	ld.sh	r4,r12[18]
800045a6:	f0 04 0d 44 	min	r4,r8,r4
800045aa:	5c 84       	casts.h	r4
	
	//Because statics cannot be initialized with variables...
	if (first_run) {
800045ac:	4b 28       	lddpc	r8,80004674 <launch_control+0xe0>
800045ae:	11 89       	ld.ub	r9,r8[0x0]
800045b0:	30 08       	mov	r8,0
800045b2:	f0 09 18 00 	cp.b	r9,r8
800045b6:	c2 e0       	breq	80004612 <launch_control+0x7e>
		first_run = 0;
800045b8:	10 99       	mov	r9,r8
800045ba:	4a f8       	lddpc	r8,80004674 <launch_control+0xe0>
800045bc:	b0 89       	st.b	r8[0x0],r9
		filter_output = (1-filter_gain)*ecu_data->lc_trq_init + filter_gain*trq_min*(float)MAX_TORQUE/1000.0; 
800045be:	fc 1c 3f 80 	movh	r12,0x3f80
800045c2:	e5 a1 0c c6 	cop	cp0,cr12,cr12,cr6,0x42
800045c6:	ee f8 00 88 	ld.w	r8,r7[136]
800045ca:	e5 a2 0c c8 	cop	cp0,cr12,cr12,cr8,0x44
800045ce:	f0 1f 00 2b 	mcall	80004678 <launch_control+0xe4>
800045d2:	14 92       	mov	r2,r10
800045d4:	16 93       	mov	r3,r11
800045d6:	e5 a6 04 04 	cop	cp0,cr4,cr0,cr4,0x4c
800045da:	e5 a2 06 46 	cop	cp0,cr6,cr4,cr6,0x44
800045de:	e0 68 f0 00 	mov	r8,61440
800045e2:	ea 18 46 ff 	orh	r8,0x46ff
800045e6:	e5 a2 0c 68 	cop	cp0,cr12,cr6,cr8,0x44
800045ea:	f0 1f 00 24 	mcall	80004678 <launch_control+0xe4>
800045ee:	30 08       	mov	r8,0
800045f0:	e0 69 40 00 	mov	r9,16384
800045f4:	ea 19 40 8f 	orh	r9,0x408f
800045f8:	f0 1f 00 21 	mcall	8000467c <launch_control+0xe8>
800045fc:	14 98       	mov	r8,r10
800045fe:	16 99       	mov	r9,r11
80004600:	04 9a       	mov	r10,r2
80004602:	06 9b       	mov	r11,r3
80004604:	f0 1f 00 1f 	mcall	80004680 <launch_control+0xec>
80004608:	f0 1f 00 1f 	mcall	80004684 <launch_control+0xf0>
8000460c:	49 f8       	lddpc	r8,80004688 <launch_control+0xf4>
8000460e:	91 0c       	st.w	r8[0x0],r12
80004610:	c2 98       	rjmp	80004662 <launch_control+0xce>
	} else {
		filter_output = (1-filter_gain)*filter_output + filter_gain*trq_min*(float)MAX_TORQUE/1000.0;	
80004612:	49 e5       	lddpc	r5,80004688 <launch_control+0xf4>
80004614:	fc 1c 3f 80 	movh	r12,0x3f80
80004618:	e5 a1 0c c6 	cop	cp0,cr12,cr12,cr6,0x42
8000461c:	6a 08       	ld.w	r8,r5[0x0]
8000461e:	e5 a2 0c c8 	cop	cp0,cr12,cr12,cr8,0x44
80004622:	f0 1f 00 16 	mcall	80004678 <launch_control+0xe4>
80004626:	14 92       	mov	r2,r10
80004628:	16 93       	mov	r3,r11
8000462a:	e5 a6 04 04 	cop	cp0,cr4,cr0,cr4,0x4c
8000462e:	e5 a2 06 46 	cop	cp0,cr6,cr4,cr6,0x44
80004632:	e0 68 f0 00 	mov	r8,61440
80004636:	ea 18 46 ff 	orh	r8,0x46ff
8000463a:	e5 a2 0c 68 	cop	cp0,cr12,cr6,cr8,0x44
8000463e:	f0 1f 00 0f 	mcall	80004678 <launch_control+0xe4>
80004642:	30 08       	mov	r8,0
80004644:	e0 69 40 00 	mov	r9,16384
80004648:	ea 19 40 8f 	orh	r9,0x408f
8000464c:	f0 1f 00 0c 	mcall	8000467c <launch_control+0xe8>
80004650:	14 98       	mov	r8,r10
80004652:	16 99       	mov	r9,r11
80004654:	04 9a       	mov	r10,r2
80004656:	06 9b       	mov	r11,r3
80004658:	f0 1f 00 0a 	mcall	80004680 <launch_control+0xec>
8000465c:	f0 1f 00 0a 	mcall	80004684 <launch_control+0xf0>
80004660:	8b 0c       	st.w	r5[0x0],r12
	}
	
	//Add feedback from speed sensors to do slip control here (if needed)
	
	ecu_data->trq_cmd = filter_output;
80004662:	48 a8       	lddpc	r8,80004688 <launch_control+0xf4>
80004664:	70 08       	ld.w	r8,r8[0x0]
80004666:	e5 ab 08 08 	cop	cp0,cr8,cr0,cr8,0x56
8000466a:	ef 58 00 16 	st.h	r7[22],r8
	asm("nop");
8000466e:	d7 03       	nop
}
80004670:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80004674:	00 00       	add	r0,r0
80004676:	01 d8       	ld.ub	r8,r0[0x5]
80004678:	80 00       	ld.sh	r0,r0[0x0]
8000467a:	78 48       	ld.w	r8,r12[0x10]
8000467c:	80 00       	ld.sh	r0,r0[0x0]
8000467e:	73 d0       	ld.w	r0,r9[0x74]
80004680:	80 00       	ld.sh	r0,r0[0x0]
80004682:	71 d8       	ld.w	r8,r8[0x74]
80004684:	80 00       	ld.sh	r0,r0[0x0]
80004686:	78 a8       	ld.w	r8,r12[0x28]
80004688:	00 00       	add	r0,r0
8000468a:	cc 28       	rjmp	8000480e <canif_fixed_baudrate+0x6>

8000468c <calculate_slip>:

float calculate_slip(fsm_ecu_data_t *ecu_data) {
8000468c:	d4 01       	pushm	lr
	float slip, v_r, v_f;
	
	if (ecu_data->speed_sens_alive[2] == 0) {
8000468e:	f9 39 00 94 	ld.ub	r9,r12[148]
80004692:	30 08       	mov	r8,0
80004694:	f0 09 18 00 	cp.b	r9,r8
80004698:	c0 31       	brne	8000469e <calculate_slip+0x12>
		//No measurement from rear wheel
		return ecu_data->slip_target;
8000469a:	79 ec       	ld.w	r12,r12[0x78]
8000469c:	d8 02       	popm	pc
	} else {
		v_r = (float)(ecu_data->WRR_sens & 0xFF);
8000469e:	f9 08 00 62 	ld.sh	r8,r12[98]
	}
	
	//Select measurement - new 26/7
	if ((ecu_data->speed_sens_alive[0] == 1) && (ecu_data->speed_sens_alive[1] == 1)) {
800046a2:	f9 19 00 92 	ld.uh	r9,r12[146]
800046a6:	e0 49 01 01 	cp.w	r9,257
800046aa:	c1 01       	brne	800046ca <calculate_slip+0x3e>
		float v1 = (float)(ecu_data->WFL_sens & 0xFF);
		float v2 = (float)(ecu_data->WFR_sens & 0xFF);
		v_f = (v1+v2)/2;
800046ac:	f9 3a 00 5d 	ld.ub	r10,r12[93]
800046b0:	e5 a6 0a 0a 	cop	cp0,cr10,cr0,cr10,0x4c
800046b4:	f9 39 00 5f 	ld.ub	r9,r12[95]
800046b8:	e5 a6 09 09 	cop	cp0,cr9,cr0,cr9,0x4c
800046bc:	e5 a0 09 a9 	cop	cp0,cr9,cr10,cr9,0x40
800046c0:	fc 1a 3f 00 	movh	r10,0x3f00
800046c4:	e5 a2 09 9a 	cop	cp0,cr9,cr9,cr10,0x44
800046c8:	c1 28       	rjmp	800046ec <calculate_slip+0x60>
	} else if ((ecu_data->speed_sens_alive[0] == 1) && (ecu_data->speed_sens_alive[1] == 0)){
800046ca:	e0 49 01 00 	cp.w	r9,256
800046ce:	c0 61       	brne	800046da <calculate_slip+0x4e>
		v_f = (float)(ecu_data->WFL_sens & 0xFF);
800046d0:	f9 39 00 5d 	ld.ub	r9,r12[93]
800046d4:	e5 a6 09 09 	cop	cp0,cr9,cr0,cr9,0x4c
800046d8:	c0 a8       	rjmp	800046ec <calculate_slip+0x60>
	} else if ((ecu_data->speed_sens_alive[0] == 0) && (ecu_data->speed_sens_alive[1] == 1)) {
800046da:	58 19       	cp.w	r9,1
800046dc:	c0 61       	brne	800046e8 <calculate_slip+0x5c>
		v_f = (float)(ecu_data->WFR_sens & 0xFF);
800046de:	f9 39 00 5f 	ld.ub	r9,r12[95]
800046e2:	e5 a6 09 09 	cop	cp0,cr9,cr0,cr9,0x4c
800046e6:	c0 38       	rjmp	800046ec <calculate_slip+0x60>
	} else {
		//No measurement
		return ecu_data->slip_target;
800046e8:	79 ec       	ld.w	r12,r12[0x78]
800046ea:	d8 02       	popm	pc
	
	if (ecu_data->speed_sens_alive[2] == 0) {
		//No measurement from rear wheel
		return ecu_data->slip_target;
	} else {
		v_r = (float)(ecu_data->WRR_sens & 0xFF);
800046ec:	5c 58       	castu.b	r8
800046ee:	e5 a6 08 08 	cop	cp0,cr8,cr0,cr8,0x4c
	
	//Actual speed is v*2.574 (average sensor),
	//but the constant will be mathematically cancelled when
	//calculating slip 
	
	if (v_r > 1) {
800046f2:	fc 1a 3f 80 	movh	r10,0x3f80
800046f6:	e5 ac 00 8a 	cop	cp0,cr0,cr8,cr10,0x58
800046fa:	e0 8c 00 0a 	brvs	8000470e <calculate_slip+0x82>
800046fe:	e0 8a 00 08 	brle	8000470e <calculate_slip+0x82>
		slip = (v_r - v_f)/v_r;
80004702:	10 9b       	mov	r11,r8
80004704:	e5 a1 0c 89 	cop	cp0,cr12,cr8,cr9,0x42
80004708:	f0 1f 00 03 	mcall	80004714 <calculate_slip+0x88>
8000470c:	d8 02       	popm	pc
	} else {
		slip = ecu_data->slip_target; //Feed zero error to traction controller
8000470e:	79 ec       	ld.w	r12,r12[0x78]
	}
	return slip;
}
80004710:	d8 02       	popm	pc
80004712:	00 00       	add	r0,r0
80004714:	80 00       	ld.sh	r0,r0[0x0]
80004716:	76 e8       	ld.w	r8,r11[0x38]

80004718 <traction_control>:
#include "queue_handles.h"
#include "fsm_ecu.h"
#include "fsm_ecu_functions.h"
#include "fsm_control.h"

void traction_control(fsm_ecu_data_t* ecu_data) {
80004718:	d4 21       	pushm	r4-r7,lr
8000471a:	18 97       	mov	r7,r12
	static float e_prev			= 0;
	static float e_filter_prev	= 0;
	static float e_filter_pprev	= 0;
	float torque_limit			= 0;
	
	if (ecu_data->slip_target > 0) {
8000471c:	79 e6       	ld.w	r6,r12[0x78]
8000471e:	30 08       	mov	r8,0
80004720:	e5 ac 00 68 	cop	cp0,cr0,cr6,cr8,0x58
80004724:	e0 8c 00 3f 	brvs	800047a2 <traction_control+0x8a>
80004728:	e0 8a 00 3d 	brle	800047a2 <traction_control+0x8a>
		float Kp = ecu_data->Kp;
8000472c:	79 b4       	ld.w	r4,r12[0x6c]
		float Ki = ecu_data->Ki;
8000472e:	79 c5       	ld.w	r5,r12[0x70]
		float Kd = ecu_data->Kd;
		float slip_target = ecu_data->slip_target;
		float d_filter_gain = ecu_data->d_filter_gain;
		
		//Calculate slip and error
		e = 100*(calculate_slip(ecu_data) - slip_target); //Slip is a percentage value
80004730:	f0 1f 00 1f 	mcall	800047ac <traction_control+0x94>
80004734:	e5 a1 06 c6 	cop	cp0,cr6,cr12,cr6,0x42
80004738:	fc 1b 42 c8 	movh	r11,0x42c8
8000473c:	e5 a2 06 6b 	cop	cp0,cr6,cr6,cr11,0x44
80004740:	49 c8       	lddpc	r8,800047b0 <traction_control+0x98>
80004742:	91 06       	st.w	r8[0x0],r6
		
		//e_filter = (1-d_filter_gain)*e_filter_prev + d_filter_gain*e;
		//float d_action = Kd/Ts*(e_filter - 2*e_filter_prev + e_filter_pprev);
		
		delta_u = Kp*(e-e_prev) + Ki*Ts*e; //PI
80004744:	49 c8       	lddpc	r8,800047b4 <traction_control+0x9c>
80004746:	70 09       	ld.w	r9,r8[0x0]
80004748:	e5 a1 09 69 	cop	cp0,cr9,cr6,cr9,0x42
8000474c:	e0 6a d7 0a 	mov	r10,55050
80004750:	ea 1a 3c a3 	orh	r10,0x3ca3
80004754:	e5 a2 05 5a 	cop	cp0,cr5,cr5,cr10,0x44
80004758:	e5 a2 05 65 	cop	cp0,cr5,cr6,cr5,0x44
8000475c:	e1 a5 04 94 	cop	cp0,cr4,cr9,cr4,0xa
80004760:	49 69       	lddpc	r9,800047b8 <traction_control+0xa0>
80004762:	93 04       	st.w	r9[0x0],r4
		e_prev = e;
80004764:	91 06       	st.w	r8[0x0],r6
		//e_filter_pprev = e_filter_prev;
		//e_filter_prev  = e_filter;
		ecu_data->control_u += delta_u;
		ecu_data->control_u = max(0, min(50, ecu_data->control_u));
80004766:	6e 7c       	ld.w	r12,r7[0x1c]
80004768:	e5 a0 0c 4c 	cop	cp0,cr12,cr4,cr12,0x40
8000476c:	e5 ab 0c 0c 	cop	cp0,cr12,cr0,cr12,0x56
80004770:	33 28       	mov	r8,50
80004772:	f0 0c 0d 4c 	min	r12,r8,r12
80004776:	30 08       	mov	r8,0
80004778:	f0 0c 0c 4c 	max	r12,r8,r12
8000477c:	e5 a6 0c 0c 	cop	cp0,cr12,cr0,cr12,0x4c
80004780:	8f 7c       	st.w	r7[0x1c],r12
		
		torque_limit = 100 - ecu_data->control_u;
		torque_limit = MAX_TORQUE*torque_limit/100;
80004782:	e5 a1 0c bc 	cop	cp0,cr12,cr11,cr12,0x42
		ecu_data->traction_control_limit = (int16_t)torque_limit;
80004786:	e0 68 f0 00 	mov	r8,61440
8000478a:	ea 18 46 ff 	orh	r8,0x46ff
8000478e:	e5 a2 0c c8 	cop	cp0,cr12,cr12,cr8,0x44
80004792:	f0 1f 00 0b 	mcall	800047bc <traction_control+0xa4>
80004796:	e5 ab 0c 0c 	cop	cp0,cr12,cr0,cr12,0x56
8000479a:	ef 5c 00 18 	st.h	r7[24],r12
		asm("nop");
8000479e:	d7 03       	nop
800047a0:	d8 22       	popm	r4-r7,pc
	} else {
		ecu_data->traction_control_limit = MAX_TORQUE;
800047a2:	e0 68 7f f8 	mov	r8,32760
800047a6:	f9 58 00 18 	st.h	r12[24],r8
800047aa:	d8 22       	popm	r4-r7,pc
800047ac:	80 00       	ld.sh	r0,r0[0x0]
800047ae:	46 8c       	lddsp	r12,sp[0x1a0]
800047b0:	00 00       	add	r0,r0
800047b2:	cc 24       	brge	80004736 <traction_control+0x1e>
800047b4:	00 00       	add	r0,r0
800047b6:	cc 1c       	rcall	80004938 <can0_int_tx_handler+0x8>
800047b8:	00 00       	add	r0,r0
800047ba:	cc 20       	breq	8000473e <traction_control+0x26>
800047bc:	80 00       	ld.sh	r0,r0[0x0]
800047be:	76 e8       	ld.w	r8,r11[0x38]

800047c0 <canif_clear_all_mob>:
#include "preprocessor.h"
#include "canif.h"

void canif_clear_all_mob(uint8_t ch,
		uint8_t nb_mob)
{
800047c0:	eb cd 40 fc 	pushm	r2-r7,lr
	uint8_t mob_number;

	for (mob_number = 0; mob_number < nb_mob; mob_number++) {
800047c4:	58 0b       	cp.w	r11,0
800047c6:	c1 f0       	breq	80004804 <canif_clear_all_mob+0x44>

#include "compiler.h"
#include "preprocessor.h"
#include "canif.h"

void canif_clear_all_mob(uint8_t ch,
800047c8:	f6 c3 00 01 	sub	r3,r11,1
800047cc:	5c 53       	castu.b	r3
800047ce:	2f f3       	sub	r3,-1
800047d0:	a5 63       	lsl	r3,0x4
800047d2:	30 08       	mov	r8,0
		uint8_t nb_mob)
{
	uint8_t mob_number;

	for (mob_number = 0; mob_number < nb_mob; mob_number++) {
		CANIF_clr_mob(ch,mob_number)
800047d4:	fc 7a 1c 00 	mov	r10,-189440
800047d8:	a7 6c       	lsl	r12,0x6
800047da:	f8 c9 ff ff 	sub	r9,r12,-1
800047de:	10 9b       	mov	r11,r8
800047e0:	30 04       	mov	r4,0
800047e2:	30 05       	mov	r5,0
800047e4:	f4 09 03 3e 	ld.w	lr,r10[r9<<0x3]
800047e8:	fc 08 09 0b 	st.w	lr[r8],r11
800047ec:	f4 09 03 3e 	ld.w	lr,r10[r9<<0x3]
800047f0:	10 0e       	add	lr,r8
800047f2:	9d 1b       	st.w	lr[0x4],r11
800047f4:	f4 09 03 3e 	ld.w	lr,r10[r9<<0x3]
800047f8:	10 0e       	add	lr,r8
800047fa:	fc e5 00 08 	st.d	lr[8],r4
800047fe:	2f 08       	sub	r8,-16
void canif_clear_all_mob(uint8_t ch,
		uint8_t nb_mob)
{
	uint8_t mob_number;

	for (mob_number = 0; mob_number < nb_mob; mob_number++) {
80004800:	06 38       	cp.w	r8,r3
80004802:	cf 11       	brne	800047e4 <canif_clear_all_mob+0x24>
80004804:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc

80004808 <canif_fixed_baudrate>:
	return MOB_NOT_COMPLETED;
}

uint8_t canif_fixed_baudrate(uint8_t ch)
{
  CANIF_conf_bt(ch);
80004808:	a9 7c       	lsl	r12,0x9
8000480a:	e2 2c e3 f4 	sub	r12,189428
8000480e:	78 08       	ld.w	r8,r12[0x0]
80004810:	e4 18 ff e7 	andh	r8,0xffe7
80004814:	99 08       	st.w	r12[0x0],r8
80004816:	78 08       	ld.w	r8,r12[0x0]
80004818:	b3 b8       	sbr	r8,0x13
8000481a:	99 08       	st.w	r12[0x0],r8
8000481c:	78 08       	ld.w	r8,r12[0x0]
8000481e:	e4 18 ff f8 	andh	r8,0xfff8
80004822:	99 08       	st.w	r12[0x0],r8
80004824:	78 08       	ld.w	r8,r12[0x0]
80004826:	b1 b8       	sbr	r8,0x11
80004828:	99 08       	st.w	r12[0x0],r8
8000482a:	78 08       	ld.w	r8,r12[0x0]
8000482c:	e0 18 ff c0 	andl	r8,0xffc0
80004830:	99 08       	st.w	r12[0x0],r8
80004832:	78 08       	ld.w	r8,r12[0x0]
80004834:	a1 a8       	sbr	r8,0x0
80004836:	99 08       	st.w	r12[0x0],r8
80004838:	78 08       	ld.w	r8,r12[0x0]
8000483a:	e0 18 c7 ff 	andl	r8,0xc7ff
8000483e:	99 08       	st.w	r12[0x0],r8
80004840:	78 08       	ld.w	r8,r12[0x0]
80004842:	ab b8       	sbr	r8,0xb
80004844:	99 08       	st.w	r12[0x0],r8
80004846:	78 08       	ld.w	r8,r12[0x0]
80004848:	e0 18 f8 ff 	andl	r8,0xf8ff
8000484c:	99 08       	st.w	r12[0x0],r8
8000484e:	78 08       	ld.w	r8,r12[0x0]
80004850:	a9 a8       	sbr	r8,0x8
80004852:	99 08       	st.w	r12[0x0],r8
  return 1;
}
80004854:	5e ff       	retal	1

80004856 <scif_stop_gclk>:
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;
80004856:	fe 78 08 00 	mov	r8,-63488
8000485a:	f8 c9 ff e7 	sub	r9,r12,-25
8000485e:	f0 09 03 2a 	ld.w	r10,r8[r9<<0x2]
80004862:	a1 ca       	cbr	r10,0x0
80004864:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80004868:	e0 78 86 a0 	mov	r8,100000

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
8000486c:	fe 7a 08 00 	mov	r10,-63488
80004870:	12 9c       	mov	r12,r9
80004872:	c0 48       	rjmp	8000487a <scif_stop_gclk+0x24>
  {
    if(--timeout == 0)
80004874:	20 18       	sub	r8,1
80004876:	c0 21       	brne	8000487a <scif_stop_gclk+0x24>
80004878:	5e fe       	retal	-1

  // Stop the generic clock.
  AVR32_SCIF.gcctrl[gclk] &= ~AVR32_SCIF_GCCTRL_CEN_MASK;

  // Wait until the generic clock is actually stopped.
  while(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
8000487a:	f4 0c 03 29 	ld.w	r9,r10[r12<<0x2]
8000487e:	f3 d9 c0 01 	bfextu	r9,r9,0x0,0x1
80004882:	cf 91       	brne	80004874 <scif_stop_gclk+0x1e>
80004884:	5e fd       	retal	0
80004886:	d7 03       	nop

80004888 <scif_gc_setup>:
  return PASS;
}


long int scif_gc_setup(unsigned int gclk, scif_gcctrl_oscsel_t clk_src, unsigned int diven, unsigned int divfactor)
{
80004888:	d4 21       	pushm	r4-r7,lr
8000488a:	18 97       	mov	r7,r12
8000488c:	16 95       	mov	r5,r11
8000488e:	14 96       	mov	r6,r10
  bool restart_gc = false;


  // Change the division factor to conform to the equation: fgclk = fsrc/divfactor = fsrc/(2*(div+1))
  divfactor = (divfactor>>1) -1;
80004890:	a1 99       	lsr	r9,0x1
80004892:	f2 c4 00 01 	sub	r4,r9,1
      return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, disable it before changing its setup.
  if(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK)
80004896:	f8 c9 ff e7 	sub	r9,r12,-25
8000489a:	fe 78 08 00 	mov	r8,-63488
8000489e:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800048a2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800048a6:	c0 50       	breq	800048b0 <scif_gc_setup+0x28>
  {
    restart_gc = true;
    if(scif_stop_gclk(gclk) < 0)
800048a8:	f0 1f 00 18 	mcall	80004908 <scif_gc_setup+0x80>
800048ac:	c1 44       	brge	800048d4 <scif_gc_setup+0x4c>
800048ae:	dc 2a       	popm	r4-r7,pc,r12=-1
      return -1;  // Could not stop the generic clock.
  }

  // Setup the generic clock.
  AVR32_SCIF.gcctrl[gclk] = ((divfactor << AVR32_SCIF_GCCTRL_DIV_OFFSET)&AVR32_SCIF_GCCTRL_DIV_MASK)
800048b0:	a1 76       	lsl	r6,0x1
800048b2:	e2 16 00 02 	andl	r6,0x2,COH
800048b6:	a9 65       	lsl	r5,0x8
800048b8:	e2 15 0f 00 	andl	r5,0xf00,COH
800048bc:	0a 46       	or	r6,r5
800048be:	b1 64       	lsl	r4,0x10
800048c0:	e6 14 00 ff 	andh	r4,0xff,COH
800048c4:	ed e4 10 04 	or	r4,r6,r4
800048c8:	2e 77       	sub	r7,-25
800048ca:	fe 78 08 00 	mov	r8,-63488
800048ce:	f0 07 09 24 	st.w	r8[r7<<0x2],r4
800048d2:	d8 2a       	popm	r4-r7,pc,r12=0
800048d4:	ec 09 15 01 	lsl	r9,r6,0x1
800048d8:	e2 19 00 02 	andl	r9,0x2,COH
800048dc:	ea 08 15 08 	lsl	r8,r5,0x8
800048e0:	e2 18 0f 00 	andl	r8,0xf00,COH
800048e4:	10 49       	or	r9,r8
800048e6:	e8 08 15 10 	lsl	r8,r4,0x10
800048ea:	e6 18 00 ff 	andh	r8,0xff,COH
800048ee:	10 49       	or	r9,r8
800048f0:	fe 78 08 00 	mov	r8,-63488
800048f4:	2e 77       	sub	r7,-25
800048f6:	f0 07 09 29 	st.w	r8[r7<<0x2],r9
                            |((diven << AVR32_SCIF_GCCTRL_DIVEN_OFFSET)&AVR32_SCIF_GCCTRL_DIVEN_MASK)
                            |((clk_src << AVR32_SCIF_GCCTRL_OSCSEL_OFFSET)&AVR32_SCIF_GCCTRL_OSCSEL_MASK);

  // Restart the gc if it previously was enabled.
  if(true == restart_gc)
    AVR32_SCIF.gcctrl[gclk] |= AVR32_SCIF_GCCTRL_CEN_MASK ;
800048fa:	f0 07 03 29 	ld.w	r9,r8[r7<<0x2]
800048fe:	a1 a9       	sbr	r9,0x0
80004900:	f0 07 09 29 	st.w	r8[r7<<0x2],r9
80004904:	d8 2a       	popm	r4-r7,pc,r12=0
80004906:	00 00       	add	r0,r0
80004908:	80 00       	ld.sh	r0,r0[0x0]
8000490a:	48 56       	lddpc	r6,8000491c <scif_gc_enable+0x10>

8000490c <scif_gc_enable>:
    return -1;
  }
#endif  // AVR32SFW_INPUT_CHECK

  // If the generic clock is already enabled, do nothing.
  if(!(AVR32_SCIF.gcctrl[gclk] & AVR32_SCIF_GCCTRL_CEN_MASK))
8000490c:	f8 c9 ff e7 	sub	r9,r12,-25
80004910:	fe 78 08 00 	mov	r8,-63488
80004914:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80004918:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000491c:	c0 91       	brne	8000492e <scif_gc_enable+0x22>
    AVR32_SCIF.gcctrl[gclk] |= AVR32_SCIF_GCCTRL_CEN_MASK;
8000491e:	fe 78 08 00 	mov	r8,-63488
80004922:	12 9c       	mov	r12,r9
80004924:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80004928:	a1 a9       	sbr	r9,0x0
8000492a:	f0 0c 09 29 	st.w	r8[r12<<0x2],r9

  return PASS;

}
8000492e:	5e fd       	retal	0

80004930 <can0_int_tx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_tx_handler(void)
{
80004930:	d4 01       	pushm	lr
  U8 handle;
  handle = CANIF_mob_get_mob_txok(0);
80004932:	fc 78 1c 00 	mov	r8,-189440
80004936:	70 cc       	ld.w	r12,r8[0x30]
80004938:	f9 dc c2 06 	bfextu	r12,r12,0x10,0x6
  if (handle != 0x20)
8000493c:	32 08       	mov	r8,32
8000493e:	f0 0c 18 00 	cp.b	r12,r8
80004942:	c0 f0       	breq	80004960 <can0_int_tx_handler+0x30>
  {
    CANIF_mob_clear_txok_status(0,handle);
80004944:	30 19       	mov	r9,1
80004946:	f2 0c 09 49 	lsl	r9,r9,r12
8000494a:	fc 78 1c 00 	mov	r8,-189440
8000494e:	f1 49 00 54 	st.w	r8[84],r9
    CANIF_mob_clear_status(0,handle); //   and reset MOb status
80004952:	f8 0c 00 18 	add	r8,r12,r12<<0x1
80004956:	a3 68       	lsl	r8,0x2
80004958:	e2 28 e3 a0 	sub	r8,189344
8000495c:	30 f9       	mov	r9,15
8000495e:	91 09       	st.w	r8[0x0],r9
  }
  can_lib_params.can_msg_callback_channel0(handle,CAN_STATUS_COMPLETED);
80004960:	48 38       	lddpc	r8,8000496c <can0_int_tx_handler+0x3c>
80004962:	70 08       	ld.w	r8,r8[0x0]
80004964:	30 0b       	mov	r11,0
80004966:	5d 18       	icall	r8
}
80004968:	d4 02       	popm	lr
8000496a:	d6 03       	rete
8000496c:	00 00       	add	r0,r0
8000496e:	cc 2c       	rcall	80004af2 <can1_int_wakeup_handler+0x12>

80004970 <can0_int_rx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_rx_handler(void)
{
80004970:	d4 01       	pushm	lr
  U8 handle;
  handle = CANIF_mob_get_mob_rxok(0) ;
80004972:	fc 78 1c 00 	mov	r8,-189440
80004976:	70 cc       	ld.w	r12,r8[0x30]
80004978:	f9 dc c1 06 	bfextu	r12,r12,0x8,0x6
  if (handle != 0x20)
8000497c:	32 08       	mov	r8,32
8000497e:	f0 0c 18 00 	cp.b	r12,r8
80004982:	c0 f0       	breq	800049a0 <can0_int_rx_handler+0x30>
  {
    CANIF_mob_clear_rxok_status(0,handle);
80004984:	30 19       	mov	r9,1
80004986:	f2 0c 09 49 	lsl	r9,r9,r12
8000498a:	fc 78 1c 00 	mov	r8,-189440
8000498e:	f1 49 00 4c 	st.w	r8[76],r9
    CANIF_mob_clear_status(0,handle); //   and reset MOb status
80004992:	f8 0c 00 18 	add	r8,r12,r12<<0x1
80004996:	a3 68       	lsl	r8,0x2
80004998:	e2 28 e3 a0 	sub	r8,189344
8000499c:	30 f9       	mov	r9,15
8000499e:	91 09       	st.w	r8[0x0],r9
  }
  can_lib_params.can_msg_callback_channel0(handle,CAN_STATUS_COMPLETED);
800049a0:	48 38       	lddpc	r8,800049ac <can0_int_rx_handler+0x3c>
800049a2:	70 08       	ld.w	r8,r8[0x0]
800049a4:	30 0b       	mov	r11,0
800049a6:	5d 18       	icall	r8
}
800049a8:	d4 02       	popm	lr
800049aa:	d6 03       	rete
800049ac:	00 00       	add	r0,r0
800049ae:	cc 2c       	rcall	80004b32 <can_tx+0x2e>

800049b0 <can0_int_busoff_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_busoff_handler(void)
{
800049b0:	d4 01       	pushm	lr
    CANIF_clr_interrupt_status(0);
800049b2:	fc 78 1c 00 	mov	r8,-189440
800049b6:	70 b9       	ld.w	r9,r8[0x2c]
800049b8:	91 a9       	st.w	r8[0x28],r9
    can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_BUSOFF);
800049ba:	48 58       	lddpc	r8,800049cc <can0_int_busoff_handler+0x1c>
800049bc:	70 08       	ld.w	r8,r8[0x0]
800049be:	30 4b       	mov	r11,4
800049c0:	e0 6c 00 ff 	mov	r12,255
800049c4:	5d 18       	icall	r8
}
800049c6:	d4 02       	popm	lr
800049c8:	d6 03       	rete
800049ca:	00 00       	add	r0,r0
800049cc:	00 00       	add	r0,r0
800049ce:	cc 2c       	rcall	80004b52 <can_tx+0x4e>

800049d0 <can0_int_cerr_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_cerr_handler(void)
{
800049d0:	d4 01       	pushm	lr
  CANIF_clr_interrupt_status(0);
800049d2:	fc 78 1c 00 	mov	r8,-189440
800049d6:	70 b9       	ld.w	r9,r8[0x2c]
800049d8:	91 a9       	st.w	r8[0x28],r9
  can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_ERROR);
800049da:	48 58       	lddpc	r8,800049ec <can0_int_cerr_handler+0x1c>
800049dc:	70 08       	ld.w	r8,r8[0x0]
800049de:	30 2b       	mov	r11,2
800049e0:	e0 6c 00 ff 	mov	r12,255
800049e4:	5d 18       	icall	r8
}
800049e6:	d4 02       	popm	lr
800049e8:	d6 03       	rete
800049ea:	00 00       	add	r0,r0
800049ec:	00 00       	add	r0,r0
800049ee:	cc 2c       	rcall	80004b72 <can_tx+0x6e>

800049f0 <can0_int_wakeup_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can0_int_wakeup_handler(void)
{
800049f0:	d4 01       	pushm	lr
  CANIF_clr_interrupt_status(0);
800049f2:	fc 78 1c 00 	mov	r8,-189440
800049f6:	70 b9       	ld.w	r9,r8[0x2c]
800049f8:	91 a9       	st.w	r8[0x28],r9
  can_lib_params.can_msg_callback_channel0(0xFF,CAN_STATUS_WAKEUP);
800049fa:	48 58       	lddpc	r8,80004a0c <can0_int_wakeup_handler+0x1c>
800049fc:	70 08       	ld.w	r8,r8[0x0]
800049fe:	30 3b       	mov	r11,3
80004a00:	e0 6c 00 ff 	mov	r12,255
80004a04:	5d 18       	icall	r8
}
80004a06:	d4 02       	popm	lr
80004a08:	d6 03       	rete
80004a0a:	00 00       	add	r0,r0
80004a0c:	00 00       	add	r0,r0
80004a0e:	cc 2c       	rcall	80004b92 <can_tx+0x8e>

80004a10 <can1_int_tx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_tx_handler(void)
{
80004a10:	d4 01       	pushm	lr
  U8 handle;
  handle = CANIF_mob_get_mob_txok(1) ;
80004a12:	fc 78 1c 00 	mov	r8,-189440
80004a16:	f0 fc 02 30 	ld.w	r12,r8[560]
80004a1a:	f9 dc c2 06 	bfextu	r12,r12,0x10,0x6
  if (handle != 0x20)
80004a1e:	32 08       	mov	r8,32
80004a20:	f0 0c 18 00 	cp.b	r12,r8
80004a24:	c0 f0       	breq	80004a42 <can1_int_tx_handler+0x32>
  {
    CANIF_mob_clear_txok_status(1,handle);
80004a26:	30 19       	mov	r9,1
80004a28:	f2 0c 09 49 	lsl	r9,r9,r12
80004a2c:	fc 78 1c 00 	mov	r8,-189440
80004a30:	f1 49 02 54 	st.w	r8[596],r9
    CANIF_mob_clear_status(1,handle); //   and reset MOb status
80004a34:	f8 0c 00 18 	add	r8,r12,r12<<0x1
80004a38:	a3 68       	lsl	r8,0x2
80004a3a:	e2 28 e1 a0 	sub	r8,188832
80004a3e:	30 f9       	mov	r9,15
80004a40:	91 09       	st.w	r8[0x0],r9
  }
  can_lib_params.can_msg_callback_channel1(handle,CAN_STATUS_COMPLETED);
80004a42:	48 48       	lddpc	r8,80004a50 <can1_int_tx_handler+0x40>
80004a44:	70 18       	ld.w	r8,r8[0x4]
80004a46:	30 0b       	mov	r11,0
80004a48:	5d 18       	icall	r8
}
80004a4a:	d4 02       	popm	lr
80004a4c:	d6 03       	rete
80004a4e:	00 00       	add	r0,r0
80004a50:	00 00       	add	r0,r0
80004a52:	cc 2c       	rcall	80004bd6 <can_tx+0xd2>

80004a54 <can1_int_rx_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_rx_handler(void)
{
80004a54:	d4 01       	pushm	lr
  U8 handle;
  handle = CANIF_mob_get_mob_rxok(1) ;
80004a56:	fc 78 1c 00 	mov	r8,-189440
80004a5a:	f0 fc 02 30 	ld.w	r12,r8[560]
80004a5e:	f9 dc c1 06 	bfextu	r12,r12,0x8,0x6
  if (handle != 0x20)
80004a62:	32 08       	mov	r8,32
80004a64:	f0 0c 18 00 	cp.b	r12,r8
80004a68:	c0 f0       	breq	80004a86 <can1_int_rx_handler+0x32>
  {
    CANIF_mob_clear_rxok_status(1,handle);
80004a6a:	30 19       	mov	r9,1
80004a6c:	f2 0c 09 49 	lsl	r9,r9,r12
80004a70:	fc 78 1c 00 	mov	r8,-189440
80004a74:	f1 49 02 4c 	st.w	r8[588],r9
    CANIF_mob_clear_status(1,handle); //   and reset MOb status
80004a78:	f8 0c 00 18 	add	r8,r12,r12<<0x1
80004a7c:	a3 68       	lsl	r8,0x2
80004a7e:	e2 28 e1 a0 	sub	r8,188832
80004a82:	30 f9       	mov	r9,15
80004a84:	91 09       	st.w	r8[0x0],r9
  }
  can_lib_params.can_msg_callback_channel1(handle,CAN_STATUS_COMPLETED);
80004a86:	48 48       	lddpc	r8,80004a94 <can1_int_rx_handler+0x40>
80004a88:	70 18       	ld.w	r8,r8[0x4]
80004a8a:	30 0b       	mov	r11,0
80004a8c:	5d 18       	icall	r8
}
80004a8e:	d4 02       	popm	lr
80004a90:	d6 03       	rete
80004a92:	00 00       	add	r0,r0
80004a94:	00 00       	add	r0,r0
80004a96:	cc 2c       	rcall	80004c1a <can_tx+0x116>

80004a98 <can1_int_busoff_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_busoff_handler(void)
{
80004a98:	d4 01       	pushm	lr
    CANIF_clr_interrupt_status(1);
80004a9a:	fc 78 1c 00 	mov	r8,-189440
80004a9e:	f0 f9 02 2c 	ld.w	r9,r8[556]
80004aa2:	f1 49 02 28 	st.w	r8[552],r9
    can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_BUSOFF);
80004aa6:	48 58       	lddpc	r8,80004ab8 <can1_int_busoff_handler+0x20>
80004aa8:	70 18       	ld.w	r8,r8[0x4]
80004aaa:	30 4b       	mov	r11,4
80004aac:	e0 6c 00 ff 	mov	r12,255
80004ab0:	5d 18       	icall	r8
}
80004ab2:	d4 02       	popm	lr
80004ab4:	d6 03       	rete
80004ab6:	00 00       	add	r0,r0
80004ab8:	00 00       	add	r0,r0
80004aba:	cc 2c       	rcall	80004c3e <can_rx+0x14>

80004abc <can1_int_cerr_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_cerr_handler(void)
{
80004abc:	d4 01       	pushm	lr
  CANIF_clr_interrupt_status(1);
80004abe:	fc 78 1c 00 	mov	r8,-189440
80004ac2:	f0 f9 02 2c 	ld.w	r9,r8[556]
80004ac6:	f1 49 02 28 	st.w	r8[552],r9
  can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_ERROR);
80004aca:	48 58       	lddpc	r8,80004adc <can1_int_cerr_handler+0x20>
80004acc:	70 18       	ld.w	r8,r8[0x4]
80004ace:	30 2b       	mov	r11,2
80004ad0:	e0 6c 00 ff 	mov	r12,255
80004ad4:	5d 18       	icall	r8
}
80004ad6:	d4 02       	popm	lr
80004ad8:	d6 03       	rete
80004ada:	00 00       	add	r0,r0
80004adc:	00 00       	add	r0,r0
80004ade:	cc 2c       	rcall	80004c62 <can_rx+0x38>

80004ae0 <can1_int_wakeup_handler>:
__attribute__((__interrupt__))
#elif defined (__ICCAVR32__)
__interrupt
#endif
static void can1_int_wakeup_handler(void)
{
80004ae0:	d4 01       	pushm	lr
  CANIF_clr_interrupt_status(1);
80004ae2:	fc 78 1c 00 	mov	r8,-189440
80004ae6:	f0 f9 02 2c 	ld.w	r9,r8[556]
80004aea:	f1 49 02 28 	st.w	r8[552],r9
  can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_WAKEUP);
80004aee:	48 58       	lddpc	r8,80004b00 <can1_int_wakeup_handler+0x20>
80004af0:	70 18       	ld.w	r8,r8[0x4]
80004af2:	30 3b       	mov	r11,3
80004af4:	e0 6c 00 ff 	mov	r12,255
80004af8:	5d 18       	icall	r8
}
80004afa:	d4 02       	popm	lr
80004afc:	d6 03       	rete
80004afe:	00 00       	add	r0,r0
80004b00:	00 00       	add	r0,r0
80004b02:	cc 2c       	rcall	80004c86 <can_rx+0x5c>

80004b04 <can_tx>:
U8 can_tx( U8 ch,
           U8 handle,
           U8 dlc,
           U8 req_type,
           const can_msg_t *can_msg)
{
80004b04:	eb cd 40 f8 	pushm	r3-r7,lr
    if ((ch > 1) ||
80004b08:	30 1e       	mov	lr,1
80004b0a:	f8 0e 18 00 	cp.b	lr,r12
80004b0e:	f9 be 02 00 	movhs	lr,0
80004b12:	30 17       	mov	r7,1
80004b14:	30 f6       	mov	r6,15
80004b16:	f6 06 18 00 	cp.b	r6,r11
80004b1a:	f9 b7 02 00 	movhs	r7,0
80004b1e:	0e 96       	mov	r6,r7
80004b20:	0c 4e       	or	lr,r6
80004b22:	30 06       	mov	r6,0
80004b24:	ec 0e 18 00 	cp.b	lr,r6
80004b28:	c7 d1       	brne	80004c22 <can_tx+0x11e>
80004b2a:	30 8e       	mov	lr,8
80004b2c:	fc 0a 18 00 	cp.b	r10,lr
80004b30:	e0 8b 00 79 	brhi	80004c22 <can_tx+0x11e>
        (handle > (NB_MOB_CHANNEL-1)) ||
        (dlc > 8))
        return  CAN_CMD_REFUSED;

    if (can_msg->ide_bit){
80004b34:	70 0e       	ld.w	lr,r8[0x0]
80004b36:	e6 1e 20 00 	andh	lr,0x2000,COH
80004b3a:	c1 40       	breq	80004b62 <can_tx+0x5e>
             CANIF_set_ext_id(ch,
80004b3c:	f6 0e 15 04 	lsl	lr,r11,0x4
80004b40:	fc 77 1c 00 	mov	r7,-189440
80004b44:	f8 06 15 06 	lsl	r6,r12,0x6
80004b48:	2f f6       	sub	r6,-1
80004b4a:	ee 06 03 35 	ld.w	r5,r7[r6<<0x3]
80004b4e:	70 04       	ld.w	r4,r8[0x0]
80004b50:	bd b4       	sbr	r4,0x1d
80004b52:	fc 05 09 04 	st.w	lr[r5],r4
                            handle,
                            can_msg->id);

             CANIF_set_ext_idmask(ch,
80004b56:	ee 06 03 37 	ld.w	r7,r7[r6<<0x3]
80004b5a:	0e 0e       	add	lr,r7
80004b5c:	70 17       	ld.w	r7,r8[0x4]
80004b5e:	9d 17       	st.w	lr[0x4],r7
80004b60:	c1 28       	rjmp	80004b84 <can_tx+0x80>
                                handle,
                                can_msg->id_mask);
    }
    else {
             CANIF_set_std_id(ch,
80004b62:	f6 0e 15 04 	lsl	lr,r11,0x4
80004b66:	fc 77 1c 00 	mov	r7,-189440
80004b6a:	f8 06 15 06 	lsl	r6,r12,0x6
80004b6e:	2f f6       	sub	r6,-1
80004b70:	ee 06 03 35 	ld.w	r5,r7[r6<<0x3]
80004b74:	70 04       	ld.w	r4,r8[0x0]
80004b76:	fc 05 09 04 	st.w	lr[r5],r4
                            handle,
                            can_msg->id);
             CANIF_set_std_idmask(ch,
80004b7a:	ee 06 03 37 	ld.w	r7,r7[r6<<0x3]
80004b7e:	0e 0e       	add	lr,r7
80004b80:	70 17       	ld.w	r7,r8[0x4]
80004b82:	9d 17       	st.w	lr[0x4],r7
                                handle,
                                can_msg->id_mask);
    }
    CANIF_mob_clr_dlc(ch,handle);
80004b84:	16 97       	mov	r7,r11
80004b86:	f8 0e 15 09 	lsl	lr,r12,0x9
80004b8a:	2f 8e       	sub	lr,-8
80004b8c:	f6 0b 00 16 	add	r6,r11,r11<<0x1
80004b90:	fc 06 00 2e 	add	lr,lr,r6<<0x2
80004b94:	e2 2e e3 ac 	sub	lr,189356
80004b98:	7c 06       	ld.w	r6,lr[0x0]
80004b9a:	e0 16 ff f0 	andl	r6,0xfff0
80004b9e:	9d 06       	st.w	lr[0x0],r6
    CANIF_mob_set_dlc(ch,handle,dlc);
80004ba0:	7c 06       	ld.w	r6,lr[0x0]
80004ba2:	ed ea 10 0a 	or	r10,r6,r10
80004ba6:	9d 0a       	st.w	lr[0x0],r10
    if (req_type == CAN_REMOTE_FRAME){
80004ba8:	30 1a       	mov	r10,1
80004baa:	f4 09 18 00 	cp.b	r9,r10
80004bae:	c1 b1       	brne	80004be4 <can_tx+0xe0>
            CANIF_set_rtr(ch,handle);
80004bb0:	f6 09 15 04 	lsl	r9,r11,0x4
80004bb4:	fc 7a 1c 00 	mov	r10,-189440
80004bb8:	f8 05 15 06 	lsl	r5,r12,0x6
80004bbc:	2f f5       	sub	r5,-1
80004bbe:	f4 05 03 34 	ld.w	r4,r10[r5<<0x3]
80004bc2:	f2 04 03 03 	ld.w	r3,r9[r4]
80004bc6:	30 16       	mov	r6,1
80004bc8:	e7 d6 d3 c1 	bfins	r3,r6,0x1e,0x1
80004bcc:	f2 04 09 03 	st.w	r9[r4],r3
            CANIF_set_rtrmask(ch,handle);
80004bd0:	f4 05 03 3a 	ld.w	r10,r10[r5<<0x3]
80004bd4:	14 09       	add	r9,r10
80004bd6:	72 1a       	ld.w	r10,r9[0x4]
80004bd8:	f5 d6 d3 c1 	bfins	r10,r6,0x1e,0x1
80004bdc:	93 1a       	st.w	r9[0x4],r10
            CANIF_mob_set_automode(ch,handle);
80004bde:	7c 09       	ld.w	r9,lr[0x0]
80004be0:	a5 b9       	sbr	r9,0x5
80004be2:	9d 09       	st.w	lr[0x0],r9
    }
    CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
80004be4:	fc 79 1c 00 	mov	r9,-189440
80004be8:	f8 0a 15 06 	lsl	r10,r12,0x6
80004bec:	2f fa       	sub	r10,-1
80004bee:	f2 0a 03 3a 	ld.w	r10,r9[r10<<0x3]
80004bf2:	a5 6b       	lsl	r11,0x4
80004bf4:	14 0b       	add	r11,r10
80004bf6:	f0 e4 00 08 	ld.d	r4,r8[8]
80004bfa:	f6 e5 00 08 	st.d	r11[8],r4
    CANIF_config_tx(ch,handle);
80004bfe:	7c 08       	ld.w	r8,lr[0x0]
80004c00:	a5 a8       	sbr	r8,0x4
80004c02:	9d 08       	st.w	lr[0x0],r8
    CANIF_mob_enable(ch,handle);
80004c04:	30 18       	mov	r8,1
80004c06:	f0 07 09 48 	lsl	r8,r8,r7
80004c0a:	f8 0a 15 09 	lsl	r10,r12,0x9
80004c0e:	f2 0a 00 0a 	add	r10,r9,r10
80004c12:	2c ca       	sub	r10,-52
80004c14:	95 08       	st.w	r10[0x0],r8
#ifdef CAN_LIB_UNDER_INTERRUPT
    CANIF_mob_enable_interrupt(ch,handle);
80004c16:	a9 7c       	lsl	r12,0x9
80004c18:	2c 0c       	sub	r12,-64
80004c1a:	18 09       	add	r9,r12
80004c1c:	93 08       	st.w	r9[0x0],r8
80004c1e:	e3 cf 80 f8 	ldm	sp++,r3-r7,pc,r12=0
#endif
    return CAN_CMD_ACCEPTED;
80004c22:	e0 6c 00 ff 	mov	r12,255
}
80004c26:	e3 cd 80 f8 	ldm	sp++,r3-r7,pc

80004c2a <can_rx>:

U8 can_rx( U8 ch,
           U8 handle,
           U8 req_type,
           const can_msg_t *can_msg)
{
80004c2a:	eb cd 40 e0 	pushm	r5-r7,lr
    if ((ch > 1) ||
80004c2e:	30 18       	mov	r8,1
80004c30:	f8 08 18 00 	cp.b	r8,r12
80004c34:	f9 b8 02 00 	movhs	r8,0
80004c38:	30 1e       	mov	lr,1
80004c3a:	30 f7       	mov	r7,15
80004c3c:	f6 07 18 00 	cp.b	r7,r11
80004c40:	f9 be 02 00 	movhs	lr,0
80004c44:	1c 48       	or	r8,lr
80004c46:	30 07       	mov	r7,0
80004c48:	ee 08 18 00 	cp.b	r8,r7
80004c4c:	c0 50       	breq	80004c56 <can_rx+0x2c>
80004c4e:	e0 6c 00 ff 	mov	r12,255
80004c52:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
        (handle > (NB_MOB_CHANNEL-1)))
        return  CAN_CMD_REFUSED;
    if (can_msg->ide_bit){
80004c56:	72 08       	ld.w	r8,r9[0x0]
80004c58:	e6 18 20 00 	andh	r8,0x2000,COH
80004c5c:	c1 40       	breq	80004c84 <can_rx+0x5a>
    	CANIF_set_ext_id(ch,
80004c5e:	f6 08 15 04 	lsl	r8,r11,0x4
80004c62:	fc 7e 1c 00 	mov	lr,-189440
80004c66:	f8 07 15 06 	lsl	r7,r12,0x6
80004c6a:	2f f7       	sub	r7,-1
80004c6c:	fc 07 03 36 	ld.w	r6,lr[r7<<0x3]
80004c70:	72 05       	ld.w	r5,r9[0x0]
80004c72:	bd b5       	sbr	r5,0x1d
80004c74:	f0 06 09 05 	st.w	r8[r6],r5
                      handle,
                      can_msg->id);
        CANIF_set_ext_idmask(ch,
80004c78:	fc 07 03 3e 	ld.w	lr,lr[r7<<0x3]
80004c7c:	1c 08       	add	r8,lr
80004c7e:	72 1e       	ld.w	lr,r9[0x4]
80004c80:	91 1e       	st.w	r8[0x4],lr
80004c82:	c1 28       	rjmp	80004ca6 <can_rx+0x7c>
                          handle,
                          can_msg->id_mask);
    }
    else {
    	CANIF_set_std_id(ch,
80004c84:	f6 08 15 04 	lsl	r8,r11,0x4
80004c88:	fc 7e 1c 00 	mov	lr,-189440
80004c8c:	f8 07 15 06 	lsl	r7,r12,0x6
80004c90:	2f f7       	sub	r7,-1
80004c92:	fc 07 03 36 	ld.w	r6,lr[r7<<0x3]
80004c96:	72 05       	ld.w	r5,r9[0x0]
80004c98:	f0 06 09 05 	st.w	r8[r6],r5
                      handle,
                      can_msg->id);
        CANIF_set_std_idmask(ch,
80004c9c:	fc 07 03 3e 	ld.w	lr,lr[r7<<0x3]
80004ca0:	1c 08       	add	r8,lr
80004ca2:	72 1e       	ld.w	lr,r9[0x4]
80004ca4:	91 1e       	st.w	r8[0x4],lr
                          handle,
                          can_msg->id_mask);
    }
    if (req_type == CAN_REMOTE_FRAME){
80004ca6:	30 18       	mov	r8,1
80004ca8:	f0 0a 18 00 	cp.b	r10,r8
80004cac:	c2 a1       	brne	80004d00 <can_rx+0xd6>
            CANIF_set_rtr(ch,handle);
80004cae:	f6 08 15 04 	lsl	r8,r11,0x4
80004cb2:	fc 7e 1c 00 	mov	lr,-189440
80004cb6:	f8 0a 15 06 	lsl	r10,r12,0x6
80004cba:	2f fa       	sub	r10,-1
80004cbc:	fc 0a 03 37 	ld.w	r7,lr[r10<<0x3]
80004cc0:	f0 07 03 06 	ld.w	r6,r8[r7]
80004cc4:	30 15       	mov	r5,1
80004cc6:	ed d5 d3 c1 	bfins	r6,r5,0x1e,0x1
80004cca:	f0 07 09 06 	st.w	r8[r7],r6
            CANIF_set_rtrmask(ch,handle);
80004cce:	fc 0a 03 37 	ld.w	r7,lr[r10<<0x3]
80004cd2:	f0 07 00 07 	add	r7,r8,r7
80004cd6:	6e 16       	ld.w	r6,r7[0x4]
80004cd8:	ed d5 d3 c1 	bfins	r6,r5,0x1e,0x1
80004cdc:	8f 16       	st.w	r7[0x4],r6
            CANIF_mob_set_automode(ch,handle);
80004cde:	f6 0b 00 17 	add	r7,r11,r11<<0x1
80004ce2:	a3 67       	lsl	r7,0x2
80004ce4:	ee 0a 00 37 	add	r7,r7,r10<<0x3
80004ce8:	e2 27 e3 ac 	sub	r7,189356
80004cec:	6e 06       	ld.w	r6,r7[0x0]
80004cee:	a5 b6       	sbr	r6,0x5
80004cf0:	8f 06       	st.w	r7[0x0],r6
            CANIF_set_data(ch,handle,((can_msg_t *)can_msg)->data.u64);
80004cf2:	fc 0a 03 3a 	ld.w	r10,lr[r10<<0x3]
80004cf6:	14 08       	add	r8,r10
80004cf8:	f2 e6 00 08 	ld.d	r6,r9[8]
80004cfc:	f0 e7 00 08 	st.d	r8[8],r6
    }
    CANIF_config_rx(ch,handle);
80004d00:	f8 08 15 09 	lsl	r8,r12,0x9
80004d04:	2f 88       	sub	r8,-8
80004d06:	f6 0b 00 19 	add	r9,r11,r11<<0x1
80004d0a:	f0 09 00 28 	add	r8,r8,r9<<0x2
80004d0e:	e2 28 e3 ac 	sub	r8,189356
80004d12:	70 09       	ld.w	r9,r8[0x0]
80004d14:	a5 c9       	cbr	r9,0x4
80004d16:	91 09       	st.w	r8[0x0],r9
    CANIF_mob_enable(ch,handle);
80004d18:	30 18       	mov	r8,1
80004d1a:	f0 0b 09 4b 	lsl	r11,r8,r11
80004d1e:	f8 08 15 09 	lsl	r8,r12,0x9
80004d22:	e2 28 e3 cc 	sub	r8,189388
80004d26:	91 0b       	st.w	r8[0x0],r11
#ifdef CAN_LIB_UNDER_INTERRUPT
    CANIF_mob_enable_interrupt(ch,handle);
80004d28:	a9 7c       	lsl	r12,0x9
80004d2a:	e2 2c e3 c0 	sub	r12,189376
80004d2e:	99 0b       	st.w	r12[0x0],r11
80004d30:	e3 cf 80 e0 	ldm	sp++,r5-r7,pc,r12=0

80004d34 <can_get_mob_data>:
}

Union64 can_get_mob_data( U8 ch ,
                           U8 handle)
{
    return ((CANIF_mob_get_ptr_data(ch,handle)->data));
80004d34:	a7 6c       	lsl	r12,0x6
80004d36:	2f fc       	sub	r12,-1
80004d38:	fc 78 1c 00 	mov	r8,-189440
80004d3c:	f0 0c 03 38 	ld.w	r8,r8[r12<<0x3]
80004d40:	a5 6b       	lsl	r11,0x4
80004d42:	f6 08 00 08 	add	r8,r11,r8
}
80004d46:	70 2b       	ld.w	r11,r8[0x8]
80004d48:	70 3a       	ld.w	r10,r8[0xc]
80004d4a:	5e fc       	retal	r12

80004d4c <can_get_mob_dlc>:

U8 can_get_mob_dlc( U8 ch ,
                    U8 handle)
{
    return (CANIF_mob_get_dlc(ch,handle));
80004d4c:	a9 7c       	lsl	r12,0x9
80004d4e:	2f 8c       	sub	r12,-8
80004d50:	f6 0b 00 1b 	add	r11,r11,r11<<0x1
80004d54:	f8 0b 00 2c 	add	r12,r12,r11<<0x2
80004d58:	e2 2c e3 ac 	sub	r12,189356
80004d5c:	78 0c       	ld.w	r12,r12[0x0]
}
80004d5e:	f9 dc c0 04 	bfextu	r12,r12,0x0,0x4
80004d62:	5e fc       	retal	r12

80004d64 <can_get_mob_id>:

U32 can_get_mob_id( U8 ch ,
                    U8 handle)
{
    return (CANIF_get_ext_id(ch,handle));
80004d64:	a7 6c       	lsl	r12,0x6
80004d66:	2f fc       	sub	r12,-1
80004d68:	fc 78 1c 00 	mov	r8,-189440
80004d6c:	f0 0c 03 38 	ld.w	r8,r8[r12<<0x3]
80004d70:	a5 6b       	lsl	r11,0x4
80004d72:	f6 08 03 0c 	ld.w	r12,r11[r8]
}
80004d76:	f9 dc c0 1d 	bfextu	r12,r12,0x0,0x1d
80004d7a:	5e fc       	retal	r12

80004d7c <can_enable_interrupt>:
  CANIF_clr_interrupt_status(1);
  can_lib_params.can_msg_callback_channel1(0xFF,CAN_STATUS_WAKEUP);
}

U8 can_enable_interrupt(U8 ch)
{
80004d7c:	d4 01       	pushm	lr
  if ((ch > 1))
80004d7e:	30 18       	mov	r8,1
80004d80:	f0 0c 18 00 	cp.b	r12,r8
80004d84:	e0 88 00 05 	brls	80004d8e <can_enable_interrupt+0x12>
80004d88:	e0 6c 00 ff 	mov	r12,255
80004d8c:	d8 02       	popm	pc
        return  CAN_CMD_REFUSED;

  if (ch==0)
80004d8e:	58 0c       	cp.w	r12,0
80004d90:	c2 51       	brne	80004dda <can_enable_interrupt+0x5e>
  {
    INTC_register_interrupt(&can0_int_tx_handler, AVR32_CANIF_TXOK_IRQ_0, CAN0_INT_TX_LEVEL);
80004d92:	30 0a       	mov	r10,0
80004d94:	e0 6b 01 23 	mov	r11,291
80004d98:	4a 6c       	lddpc	r12,80004e30 <can_enable_interrupt+0xb4>
80004d9a:	f0 1f 00 27 	mcall	80004e34 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can0_int_rx_handler, AVR32_CANIF_RXOK_IRQ_0, CAN0_INT_RX_LEVEL);
80004d9e:	30 0a       	mov	r10,0
80004da0:	e0 6b 01 22 	mov	r11,290
80004da4:	4a 5c       	lddpc	r12,80004e38 <can_enable_interrupt+0xbc>
80004da6:	f0 1f 00 24 	mcall	80004e34 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can0_int_busoff_handler, AVR32_CANIF_BUS_OFF_IRQ_0, CAN0_INT_BOFF_LEVEL);
80004daa:	30 0a       	mov	r10,0
80004dac:	e0 6b 01 20 	mov	r11,288
80004db0:	4a 3c       	lddpc	r12,80004e3c <can_enable_interrupt+0xc0>
80004db2:	f0 1f 00 21 	mcall	80004e34 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can0_int_cerr_handler, AVR32_CANIF_ERROR_IRQ_0, CAN0_INT_ERR_LEVEL);
80004db6:	30 0a       	mov	r10,0
80004db8:	e0 6b 01 21 	mov	r11,289
80004dbc:	4a 1c       	lddpc	r12,80004e40 <can_enable_interrupt+0xc4>
80004dbe:	f0 1f 00 1e 	mcall	80004e34 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can0_int_wakeup_handler, AVR32_CANIF_WAKE_UP_IRQ_0, CAN0_INT_WAKE_UP_LEVEL);
80004dc2:	30 0a       	mov	r10,0
80004dc4:	e0 6b 01 24 	mov	r11,292
80004dc8:	49 fc       	lddpc	r12,80004e44 <can_enable_interrupt+0xc8>
80004dca:	f0 1f 00 1b 	mcall	80004e34 <can_enable_interrupt+0xb8>
    CANIF_enable_interrupt(ch);
80004dce:	e0 69 01 c9 	mov	r9,457
80004dd2:	fc 78 1c 00 	mov	r8,-189440
80004dd6:	91 79       	st.w	r8[0x1c],r9
80004dd8:	d8 0a       	popm	pc,r12=0
  }
  else if (ch == 1)
80004dda:	30 18       	mov	r8,1
80004ddc:	f0 0c 18 00 	cp.b	r12,r8
80004de0:	c0 20       	breq	80004de4 <can_enable_interrupt+0x68>
80004de2:	d8 0a       	popm	pc,r12=0
  {
    INTC_register_interrupt(&can1_int_tx_handler, AVR32_CANIF_TXOK_IRQ_1, CAN1_INT_TX_LEVEL);
80004de4:	30 0a       	mov	r10,0
80004de6:	e0 6b 01 28 	mov	r11,296
80004dea:	49 8c       	lddpc	r12,80004e48 <can_enable_interrupt+0xcc>
80004dec:	f0 1f 00 12 	mcall	80004e34 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can1_int_rx_handler, AVR32_CANIF_RXOK_IRQ_1, CAN1_INT_RX_LEVEL);
80004df0:	30 0a       	mov	r10,0
80004df2:	e0 6b 01 27 	mov	r11,295
80004df6:	49 6c       	lddpc	r12,80004e4c <can_enable_interrupt+0xd0>
80004df8:	f0 1f 00 0f 	mcall	80004e34 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can1_int_busoff_handler, AVR32_CANIF_BUS_OFF_IRQ_1, CAN1_INT_BOFF_LEVEL);
80004dfc:	30 0a       	mov	r10,0
80004dfe:	e0 6b 01 25 	mov	r11,293
80004e02:	49 4c       	lddpc	r12,80004e50 <can_enable_interrupt+0xd4>
80004e04:	f0 1f 00 0c 	mcall	80004e34 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can1_int_cerr_handler, AVR32_CANIF_ERROR_IRQ_1, CAN1_INT_ERR_LEVEL);
80004e08:	30 0a       	mov	r10,0
80004e0a:	e0 6b 01 26 	mov	r11,294
80004e0e:	49 2c       	lddpc	r12,80004e54 <can_enable_interrupt+0xd8>
80004e10:	f0 1f 00 09 	mcall	80004e34 <can_enable_interrupt+0xb8>
    INTC_register_interrupt(&can1_int_wakeup_handler, AVR32_CANIF_WAKE_UP_IRQ_1, CAN1_INT_WAKE_UP_LEVEL);
80004e14:	30 0a       	mov	r10,0
80004e16:	e0 6b 01 29 	mov	r11,297
80004e1a:	49 0c       	lddpc	r12,80004e58 <can_enable_interrupt+0xdc>
80004e1c:	f0 1f 00 06 	mcall	80004e34 <can_enable_interrupt+0xb8>
    CANIF_enable_interrupt(ch);
80004e20:	e0 69 01 c9 	mov	r9,457
80004e24:	fc 78 1c 00 	mov	r8,-189440
80004e28:	f1 49 02 1c 	st.w	r8[540],r9
80004e2c:	d8 0a       	popm	pc,r12=0
80004e2e:	00 00       	add	r0,r0
80004e30:	80 00       	ld.sh	r0,r0[0x0]
80004e32:	49 30       	lddpc	r0,80004e7c <can_init+0x20>
80004e34:	80 00       	ld.sh	r0,r0[0x0]
80004e36:	69 ec       	ld.w	r12,r4[0x78]
80004e38:	80 00       	ld.sh	r0,r0[0x0]
80004e3a:	49 70       	lddpc	r0,80004e94 <can_init+0x38>
80004e3c:	80 00       	ld.sh	r0,r0[0x0]
80004e3e:	49 b0       	lddpc	r0,80004ea8 <can_init+0x4c>
80004e40:	80 00       	ld.sh	r0,r0[0x0]
80004e42:	49 d0       	lddpc	r0,80004eb4 <can_init+0x58>
80004e44:	80 00       	ld.sh	r0,r0[0x0]
80004e46:	49 f0       	lddpc	r0,80004ec0 <can_init+0x64>
80004e48:	80 00       	ld.sh	r0,r0[0x0]
80004e4a:	4a 10       	lddpc	r0,80004ecc <can_init+0x70>
80004e4c:	80 00       	ld.sh	r0,r0[0x0]
80004e4e:	4a 54       	lddpc	r4,80004ee0 <can_init+0x84>
80004e50:	80 00       	ld.sh	r0,r0[0x0]
80004e52:	4a 98       	lddpc	r8,80004ef4 <can_init+0x98>
80004e54:	80 00       	ld.sh	r0,r0[0x0]
80004e56:	4a bc       	lddpc	r12,80004f00 <can_init+0xa4>
80004e58:	80 00       	ld.sh	r0,r0[0x0]
80004e5a:	4a e0       	lddpc	r0,80004f10 <can_init+0xb4>

80004e5c <can_init>:

U8 can_init(U8 ch,
            U32 can_msg_ram_add,
            U8 operating_mode,
            void (*can_msg_callback_channel) (U8 handle, U8 event))
{
80004e5c:	d4 21       	pushm	r4-r7,lr
80004e5e:	18 96       	mov	r6,r12
80004e60:	14 95       	mov	r5,r10
80004e62:	12 94       	mov	r4,r9
   if ( ch > 1)
80004e64:	30 18       	mov	r8,1
80004e66:	f0 0c 18 00 	cp.b	r12,r8
80004e6a:	e0 8b 00 91 	brhi	80004f8c <can_init+0x130>
         return  CAN_CMD_REFUSED;

   // Initialize CAN channel
   CANIF_set_reset(ch);
80004e6e:	18 97       	mov	r7,r12
80004e70:	f8 08 15 09 	lsl	r8,r12,0x9
80004e74:	e2 28 e3 f0 	sub	r8,189424
80004e78:	30 19       	mov	r9,1
80004e7a:	91 09       	st.w	r8[0x0],r9
   while(CANIF_channel_enable_status(ch));
80004e7c:	f8 09 15 09 	lsl	r9,r12,0x9
80004e80:	e2 29 e3 ec 	sub	r9,189420
80004e84:	72 08       	ld.w	r8,r9[0x0]
80004e86:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004e8a:	cf d1       	brne	80004e84 <can_init+0x28>
   CANIF_clr_reset(ch);
80004e8c:	ee 08 15 09 	lsl	r8,r7,0x9
80004e90:	e2 28 e3 f0 	sub	r8,189424
80004e94:	30 09       	mov	r9,0
80004e96:	91 09       	st.w	r8[0x0],r9

   CANIF_set_ram_add(ch,(unsigned long) can_msg_ram_add);
80004e98:	ee 09 15 06 	lsl	r9,r7,0x6
80004e9c:	2f f9       	sub	r9,-1
80004e9e:	fc 78 1c 00 	mov	r8,-189440
80004ea2:	f0 09 09 3b 	st.w	r8[r9<<0x3],r11
   if ((CANIF_bit_timing(ch))==0) return (0);
80004ea6:	0e 9c       	mov	r12,r7
80004ea8:	f0 1f 00 3f 	mcall	80004fa4 <can_init+0x148>
80004eac:	c7 20       	breq	80004f90 <can_init+0x134>
   switch(operating_mode)
80004eae:	30 18       	mov	r8,1
80004eb0:	f0 05 18 00 	cp.b	r5,r8
80004eb4:	c1 50       	breq	80004ede <can_init+0x82>
80004eb6:	c0 63       	brcs	80004ec2 <can_init+0x66>
80004eb8:	30 28       	mov	r8,2
80004eba:	f0 05 18 00 	cp.b	r5,r8
80004ebe:	c2 d1       	brne	80004f18 <can_init+0xbc>
80004ec0:	c1 e8       	rjmp	80004efc <can_init+0xa0>
   {
    case CANIF_CHANNEL_MODE_NORMAL:
      CANIF_set_channel_mode(ch,0);
80004ec2:	ee 08 15 09 	lsl	r8,r7,0x9
80004ec6:	e2 28 e3 f4 	sub	r8,189428
80004eca:	70 09       	ld.w	r9,r8[0x0]
80004ecc:	e4 19 fc ff 	andh	r9,0xfcff
80004ed0:	91 09       	st.w	r8[0x0],r9
80004ed2:	70 09       	ld.w	r9,r8[0x0]
80004ed4:	91 09       	st.w	r8[0x0],r9
      CANIF_clr_overrun_mode(ch);
80004ed6:	70 09       	ld.w	r9,r8[0x0]
80004ed8:	bb c9       	cbr	r9,0x1a
80004eda:	91 09       	st.w	r8[0x0],r9
      break;
80004edc:	c1 e8       	rjmp	80004f18 <can_init+0xbc>
    case CANIF_CHANNEL_MODE_LISTENING:
      CANIF_set_channel_mode(ch,1);
80004ede:	ee 08 15 09 	lsl	r8,r7,0x9
80004ee2:	e2 28 e3 f4 	sub	r8,189428
80004ee6:	70 09       	ld.w	r9,r8[0x0]
80004ee8:	e4 19 fc ff 	andh	r9,0xfcff
80004eec:	91 09       	st.w	r8[0x0],r9
80004eee:	70 09       	ld.w	r9,r8[0x0]
80004ef0:	b9 a9       	sbr	r9,0x18
80004ef2:	91 09       	st.w	r8[0x0],r9
      CANIF_set_overrun_mode(ch);
80004ef4:	70 09       	ld.w	r9,r8[0x0]
80004ef6:	bb a9       	sbr	r9,0x1a
80004ef8:	91 09       	st.w	r8[0x0],r9
      break;
80004efa:	c0 f8       	rjmp	80004f18 <can_init+0xbc>
    case CANIF_CHANNEL_MODE_LOOPBACK:
      CANIF_set_channel_mode(ch,2);
80004efc:	ee 08 15 09 	lsl	r8,r7,0x9
80004f00:	e2 28 e3 f4 	sub	r8,189428
80004f04:	70 09       	ld.w	r9,r8[0x0]
80004f06:	e4 19 fc ff 	andh	r9,0xfcff
80004f0a:	91 09       	st.w	r8[0x0],r9
80004f0c:	70 09       	ld.w	r9,r8[0x0]
80004f0e:	b9 b9       	sbr	r9,0x19
80004f10:	91 09       	st.w	r8[0x0],r9
      CANIF_clr_overrun_mode(ch);
80004f12:	70 09       	ld.w	r9,r8[0x0]
80004f14:	bb c9       	cbr	r9,0x1a
80004f16:	91 09       	st.w	r8[0x0],r9
      break;
   }
   canif_clear_all_mob(ch,NB_MOB_CHANNEL);
80004f18:	31 0b       	mov	r11,16
80004f1a:	0e 9c       	mov	r12,r7
80004f1c:	f0 1f 00 23 	mcall	80004fa8 <can_init+0x14c>
   CANIF_enable(ch);
80004f20:	ee 08 15 09 	lsl	r8,r7,0x9
80004f24:	e2 28 e3 f0 	sub	r8,189424
80004f28:	70 09       	ld.w	r9,r8[0x0]
80004f2a:	a1 b9       	sbr	r9,0x1
80004f2c:	91 09       	st.w	r8[0x0],r9
 *
 * \return the converted number of CPU cycles.
 */
__always_inline static uint32_t cpu_us_2_cy(unsigned long us, unsigned long fcpu_hz)
{
  return ((unsigned long long)us * fcpu_hz + 999999) / 1000000;
80004f2e:	ee 78 42 40 	mov	r8,1000000
80004f32:	30 09       	mov	r9,0
80004f34:	e0 6a be 3f 	mov	r10,48703
80004f38:	ea 1a 93 76 	orh	r10,0x9376
80004f3c:	30 1b       	mov	r11,1
80004f3e:	f0 1f 00 1c 	mcall	80004fac <can_init+0x150>
 * \param  delay:   (input) delay in CPU cycles before timeout.
 * \param  cpu_time: (output) internal information used by the timer API.
 */
__always_inline static void cpu_set_timeout(unsigned long delay, t_cpu_time *cpu_time)
{
  cpu_time->delay_start_cycle = Get_system_register(AVR32_COUNT);
80004f42:	e1 b8 00 42 	mfsr	r8,0x108
  cpu_time->delay_end_cycle   = cpu_time->delay_start_cycle + delay;
80004f46:	f0 0a 00 0a 	add	r10,r8,r10
 *
 * \return true if timeout occurred, otherwise false.
 */
__always_inline static unsigned long cpu_is_timeout(t_cpu_time *cpu_time)
{
  unsigned long current_cycle_count = Get_system_register(AVR32_COUNT);
80004f4a:	e1 b9 00 42 	mfsr	r9,0x108
  // Test if the timeout as already occurred.
  else if (cpu_time->timer_state == CPU_TIMER_STATE_REACHED)
    return true;

  // If the ending cycle count of this timeout is wrapped, ...
  else if (cpu_time->delay_start_cycle > cpu_time->delay_end_cycle)
80004f4e:	14 38       	cp.w	r8,r10
80004f50:	e0 88 00 08 	brls	80004f60 <can_init+0x104>
  {
    if (current_cycle_count < cpu_time->delay_start_cycle && current_cycle_count > cpu_time->delay_end_cycle)
80004f54:	12 38       	cp.w	r8,r9
80004f56:	fe 98 ff fa 	brls	80004f4a <can_init+0xee>
80004f5a:	12 3a       	cp.w	r10,r9
80004f5c:	c1 b3       	brcs	80004f92 <can_init+0x136>
80004f5e:	cf 6b       	rjmp	80004f4a <can_init+0xee>
    }
    return false;
  }
  else
  {
    if (current_cycle_count < cpu_time->delay_start_cycle || current_cycle_count > cpu_time->delay_end_cycle)
80004f60:	12 38       	cp.w	r8,r9
80004f62:	e0 8b 00 18 	brhi	80004f92 <can_init+0x136>
80004f66:	12 3a       	cp.w	r10,r9
80004f68:	c1 53       	brcs	80004f92 <can_init+0x136>
80004f6a:	cf 0b       	rjmp	80004f4a <can_init+0xee>
            return CAN_CMD_REFUSED;
   }
#endif

#ifdef CAN_LIB_UNDER_INTERRUPT
   switch(ch)
80004f6c:	58 06       	cp.w	r6,0
80004f6e:	c0 60       	breq	80004f7a <can_init+0x11e>
80004f70:	30 18       	mov	r8,1
80004f72:	f0 06 18 00 	cp.b	r6,r8
80004f76:	c0 71       	brne	80004f84 <can_init+0x128>
80004f78:	c0 48       	rjmp	80004f80 <can_init+0x124>
   {
    case 0:
        can_lib_params.can_msg_callback_channel0     = can_msg_callback_channel;
80004f7a:	48 e8       	lddpc	r8,80004fb0 <can_init+0x154>
80004f7c:	91 04       	st.w	r8[0x0],r4
        break;
80004f7e:	c0 38       	rjmp	80004f84 <can_init+0x128>
    case 1:
        can_lib_params.can_msg_callback_channel1     = can_msg_callback_channel;
80004f80:	48 c8       	lddpc	r8,80004fb0 <can_init+0x154>
80004f82:	91 14       	st.w	r8[0x4],r4
        break;
   }
    can_enable_interrupt(ch);
80004f84:	0e 9c       	mov	r12,r7
80004f86:	f0 1f 00 0c 	mcall	80004fb4 <can_init+0x158>
80004f8a:	d8 2a       	popm	r4-r7,pc,r12=0
#endif

   return CAN_CMD_ACCEPTED;
80004f8c:	e0 6c 00 ff 	mov	r12,255
}
80004f90:	d8 22       	popm	r4-r7,pc
 * - 3x bits of interframe.
 */
#define DELAY_HZ         (BAUDRATE_HZ/141.0)   /*Compute Maximum delay time*/
#define DELAY            (1000000 / DELAY_HZ)  /*Compute Delay in s*/
   delay_us(DELAY);
   if(!CANIF_channel_enable_status(ch)) {
80004f92:	ee 08 15 09 	lsl	r8,r7,0x9
80004f96:	e2 28 e3 ec 	sub	r8,189420
80004f9a:	70 08       	ld.w	r8,r8[0x0]
80004f9c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004fa0:	ce 61       	brne	80004f6c <can_init+0x110>
80004fa2:	cf 5b       	rjmp	80004f8c <can_init+0x130>
80004fa4:	80 00       	ld.sh	r0,r0[0x0]
80004fa6:	48 08       	lddpc	r8,80004fa4 <can_init+0x148>
80004fa8:	80 00       	ld.sh	r0,r0[0x0]
80004faa:	47 c0       	lddsp	r0,sp[0x1f0]
80004fac:	80 00       	ld.sh	r0,r0[0x0]
80004fae:	79 32       	ld.w	r2,r12[0x4c]
80004fb0:	00 00       	add	r0,r0
80004fb2:	cc 2c       	rcall	80005136 <can_out_callback_channel1+0x17e>
80004fb4:	80 00       	ld.sh	r0,r0[0x0]
80004fb6:	4d 7c       	lddpc	r12,80005110 <can_out_callback_channel1+0x158>

80004fb8 <can_out_callback_channel1>:
		mob_rx_bspd.can_msg);
	} 
}

/* Call Back called by can_drv, channel 1 */
void can_out_callback_channel1(U8 handle, U8 event){
80004fb8:	d4 21       	pushm	r4-r7,lr
80004fba:	20 6d       	sub	sp,24
80004fbc:	16 94       	mov	r4,r11
	if (handle == mob_rx_speed_sens_fl.handle) {
80004fbe:	fe f8 03 66 	ld.w	r8,pc[870]
80004fc2:	11 87       	ld.ub	r7,r8[0x0]
80004fc4:	f8 07 18 00 	cp.b	r7,r12
80004fc8:	c2 f1       	brne	80005026 <can_out_callback_channel1+0x6e>
		mob_rx_speed_sens_fl.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80004fca:	fe f5 03 5a 	ld.w	r5,pc[858]
80004fce:	6a 16       	ld.w	r6,r5[0x4]
80004fd0:	0e 9b       	mov	r11,r7
80004fd2:	30 1c       	mov	r12,1
80004fd4:	f0 1f 00 d5 	mcall	80005328 <can_out_callback_channel1+0x370>
80004fd8:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_speed_sens_fl.can_msg->id		= can_get_mob_id(CAN_BUS_1, handle);
80004fdc:	6a 16       	ld.w	r6,r5[0x4]
80004fde:	0e 9b       	mov	r11,r7
80004fe0:	30 1c       	mov	r12,1
80004fe2:	f0 1f 00 d3 	mcall	8000532c <can_out_callback_channel1+0x374>
80004fe6:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_speed_sens_fl.dlc				= can_get_mob_dlc(CAN_BUS_1, handle);
80004fe8:	0e 9b       	mov	r11,r7
80004fea:	30 1c       	mov	r12,1
80004fec:	f0 1f 00 d1 	mcall	80005330 <can_out_callback_channel1+0x378>
80004ff0:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_speed_sens_fl.status				= event;
80004ff4:	eb 64 00 0a 	st.b	r5[10],r4
		
		xQueueOverwriteFromISR(queue_wheel_fl, &mob_rx_speed_sens_fl.can_msg->data.u16[0], NULL);
80004ff8:	6a 1b       	ld.w	r11,r5[0x4]
80004ffa:	30 29       	mov	r9,2
80004ffc:	30 0a       	mov	r10,0
80004ffe:	2f 8b       	sub	r11,-8
80005000:	fe f8 03 34 	ld.w	r8,pc[820]
80005004:	70 0c       	ld.w	r12,r8[0x0]
80005006:	f0 1f 00 cd 	mcall	80005338 <can_out_callback_channel1+0x380>
		/* Empty message field */
		mob_rx_speed_sens_fl.can_msg->data.u64 = 0x0LL;
8000500a:	6a 18       	ld.w	r8,r5[0x4]
8000500c:	30 0a       	mov	r10,0
8000500e:	30 0b       	mov	r11,0
80005010:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
80005014:	6a 19       	ld.w	r9,r5[0x4]
80005016:	eb 3a 00 09 	ld.ub	r10,r5[9]
8000501a:	0b 8b       	ld.ub	r11,r5[0x0]
8000501c:	30 1c       	mov	r12,1
8000501e:	f0 1f 00 c8 	mcall	8000533c <can_out_callback_channel1+0x384>
80005022:	e0 8f 01 7f 	bral	80005320 <can_out_callback_channel1+0x368>
		mob_rx_speed_sens_fl.handle,
		mob_rx_speed_sens_fl.req_type,
		mob_rx_speed_sens_fl.can_msg);
		
	} else if (handle == mob_rx_speed_sens_fr.handle) {
80005026:	fe f8 03 1a 	ld.w	r8,pc[794]
8000502a:	11 87       	ld.ub	r7,r8[0x0]
8000502c:	f8 07 18 00 	cp.b	r7,r12
80005030:	c2 f1       	brne	8000508e <can_out_callback_channel1+0xd6>
		mob_rx_speed_sens_fr.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80005032:	fe f5 03 0e 	ld.w	r5,pc[782]
80005036:	6a 16       	ld.w	r6,r5[0x4]
80005038:	0e 9b       	mov	r11,r7
8000503a:	30 1c       	mov	r12,1
8000503c:	f0 1f 00 bb 	mcall	80005328 <can_out_callback_channel1+0x370>
80005040:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_speed_sens_fr.can_msg->id		= can_get_mob_id(CAN_BUS_1, handle);
80005044:	6a 16       	ld.w	r6,r5[0x4]
80005046:	0e 9b       	mov	r11,r7
80005048:	30 1c       	mov	r12,1
8000504a:	f0 1f 00 b9 	mcall	8000532c <can_out_callback_channel1+0x374>
8000504e:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_speed_sens_fr.dlc				= can_get_mob_dlc(CAN_BUS_1, handle);
80005050:	0e 9b       	mov	r11,r7
80005052:	30 1c       	mov	r12,1
80005054:	f0 1f 00 b7 	mcall	80005330 <can_out_callback_channel1+0x378>
80005058:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_speed_sens_fr.status				= event;
8000505c:	eb 64 00 0a 	st.b	r5[10],r4
		
		xQueueOverwriteFromISR(queue_wheel_fr, &mob_rx_speed_sens_fr.can_msg->data.u16[0], NULL);
80005060:	6a 1b       	ld.w	r11,r5[0x4]
80005062:	30 29       	mov	r9,2
80005064:	30 0a       	mov	r10,0
80005066:	2f 8b       	sub	r11,-8
80005068:	fe f8 02 dc 	ld.w	r8,pc[732]
8000506c:	70 0c       	ld.w	r12,r8[0x0]
8000506e:	f0 1f 00 b3 	mcall	80005338 <can_out_callback_channel1+0x380>
		/* Empty message field */
		mob_rx_speed_sens_fr.can_msg->data.u64 = 0x0LL;
80005072:	6a 18       	ld.w	r8,r5[0x4]
80005074:	30 0a       	mov	r10,0
80005076:	30 0b       	mov	r11,0
80005078:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
8000507c:	6a 19       	ld.w	r9,r5[0x4]
8000507e:	eb 3a 00 09 	ld.ub	r10,r5[9]
80005082:	0b 8b       	ld.ub	r11,r5[0x0]
80005084:	30 1c       	mov	r12,1
80005086:	f0 1f 00 ae 	mcall	8000533c <can_out_callback_channel1+0x384>
8000508a:	e0 8f 01 4b 	bral	80005320 <can_out_callback_channel1+0x368>
		mob_rx_speed_sens_fr.handle,
		mob_rx_speed_sens_fr.req_type,
		mob_rx_speed_sens_fr.can_msg);
	} else if (handle == mob_rx_speed_sens_rl.handle) {
8000508e:	fe f8 02 ba 	ld.w	r8,pc[698]
80005092:	11 87       	ld.ub	r7,r8[0x0]
80005094:	f8 07 18 00 	cp.b	r7,r12
80005098:	c2 e1       	brne	800050f4 <can_out_callback_channel1+0x13c>
		mob_rx_speed_sens_rl.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
8000509a:	fe f5 02 ae 	ld.w	r5,pc[686]
8000509e:	6a 16       	ld.w	r6,r5[0x4]
800050a0:	0e 9b       	mov	r11,r7
800050a2:	30 1c       	mov	r12,1
800050a4:	f0 1f 00 a1 	mcall	80005328 <can_out_callback_channel1+0x370>
800050a8:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_speed_sens_rl.can_msg->id			= can_get_mob_id(CAN_BUS_1, handle);
800050ac:	6a 16       	ld.w	r6,r5[0x4]
800050ae:	0e 9b       	mov	r11,r7
800050b0:	30 1c       	mov	r12,1
800050b2:	f0 1f 00 9f 	mcall	8000532c <can_out_callback_channel1+0x374>
800050b6:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_speed_sens_rl.dlc					= can_get_mob_dlc(CAN_BUS_1, handle);
800050b8:	0e 9b       	mov	r11,r7
800050ba:	30 1c       	mov	r12,1
800050bc:	f0 1f 00 9d 	mcall	80005330 <can_out_callback_channel1+0x378>
800050c0:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_speed_sens_rl.status				= event;
800050c4:	eb 64 00 0a 	st.b	r5[10],r4

		xQueueOverwriteFromISR(queue_wheel_rl, &mob_rx_speed_sens_rl.can_msg->data.u16[0], NULL);
800050c8:	6a 1b       	ld.w	r11,r5[0x4]
800050ca:	30 29       	mov	r9,2
800050cc:	30 0a       	mov	r10,0
800050ce:	2f 8b       	sub	r11,-8
800050d0:	fe f8 02 7c 	ld.w	r8,pc[636]
800050d4:	70 0c       	ld.w	r12,r8[0x0]
800050d6:	f0 1f 00 99 	mcall	80005338 <can_out_callback_channel1+0x380>
	
		/* Empty message field */
		mob_rx_speed_sens_rl.can_msg->data.u64 = 0x0LL;
800050da:	6a 18       	ld.w	r8,r5[0x4]
800050dc:	30 0a       	mov	r10,0
800050de:	30 0b       	mov	r11,0
800050e0:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_1, 
800050e4:	6a 19       	ld.w	r9,r5[0x4]
800050e6:	eb 3a 00 09 	ld.ub	r10,r5[9]
800050ea:	0b 8b       	ld.ub	r11,r5[0x0]
800050ec:	30 1c       	mov	r12,1
800050ee:	f0 1f 00 94 	mcall	8000533c <can_out_callback_channel1+0x384>
800050f2:	c1 79       	rjmp	80005320 <can_out_callback_channel1+0x368>
		mob_rx_speed_sens_rl.handle,
		mob_rx_speed_sens_rl.req_type,
		mob_rx_speed_sens_rl.can_msg);
		
	} else if (handle == mob_rx_speed_sens_rr.handle) {
800050f4:	fe f8 02 5c 	ld.w	r8,pc[604]
800050f8:	11 87       	ld.ub	r7,r8[0x0]
800050fa:	f8 07 18 00 	cp.b	r7,r12
800050fe:	c2 e1       	brne	8000515a <can_out_callback_channel1+0x1a2>
		mob_rx_speed_sens_rr.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80005100:	fe f5 02 50 	ld.w	r5,pc[592]
80005104:	6a 16       	ld.w	r6,r5[0x4]
80005106:	0e 9b       	mov	r11,r7
80005108:	30 1c       	mov	r12,1
8000510a:	f0 1f 00 88 	mcall	80005328 <can_out_callback_channel1+0x370>
8000510e:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_speed_sens_rr.can_msg->id		= can_get_mob_id(CAN_BUS_1, handle);
80005112:	6a 16       	ld.w	r6,r5[0x4]
80005114:	0e 9b       	mov	r11,r7
80005116:	30 1c       	mov	r12,1
80005118:	f0 1f 00 85 	mcall	8000532c <can_out_callback_channel1+0x374>
8000511c:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_speed_sens_rr.dlc				= can_get_mob_dlc(CAN_BUS_1, handle);
8000511e:	0e 9b       	mov	r11,r7
80005120:	30 1c       	mov	r12,1
80005122:	f0 1f 00 84 	mcall	80005330 <can_out_callback_channel1+0x378>
80005126:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_speed_sens_rr.status				= event;
8000512a:	eb 64 00 0a 	st.b	r5[10],r4

		xQueueOverwriteFromISR(queue_wheel_rr, &mob_rx_speed_sens_rr.can_msg->data.u16[0], NULL);
8000512e:	6a 1b       	ld.w	r11,r5[0x4]
80005130:	30 29       	mov	r9,2
80005132:	30 0a       	mov	r10,0
80005134:	2f 8b       	sub	r11,-8
80005136:	fe f8 02 1e 	ld.w	r8,pc[542]
8000513a:	70 0c       	ld.w	r12,r8[0x0]
8000513c:	f0 1f 00 7f 	mcall	80005338 <can_out_callback_channel1+0x380>
		
		/* Empty message field */
		mob_rx_speed_sens_rr.can_msg->data.u64 = 0x0LL;
80005140:	6a 18       	ld.w	r8,r5[0x4]
80005142:	30 0a       	mov	r10,0
80005144:	30 0b       	mov	r11,0
80005146:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
8000514a:	6a 19       	ld.w	r9,r5[0x4]
8000514c:	eb 3a 00 09 	ld.ub	r10,r5[9]
80005150:	0b 8b       	ld.ub	r11,r5[0x0]
80005152:	30 1c       	mov	r12,1
80005154:	f0 1f 00 7a 	mcall	8000533c <can_out_callback_channel1+0x384>
80005158:	ce 48       	rjmp	80005320 <can_out_callback_channel1+0x368>
		mob_rx_speed_sens_rr.handle,
		mob_rx_speed_sens_rr.req_type,
		mob_rx_speed_sens_rr.can_msg);
	
	}	else if (handle == mob_rx_trq_sens1.handle) {
8000515a:	fe f8 01 fe 	ld.w	r8,pc[510]
8000515e:	11 87       	ld.ub	r7,r8[0x0]
80005160:	f8 07 18 00 	cp.b	r7,r12
80005164:	c3 51       	brne	800051ce <can_out_callback_channel1+0x216>
		mob_rx_trq_sens1.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80005166:	4f d5       	lddpc	r5,80005358 <can_out_callback_channel1+0x3a0>
80005168:	6a 16       	ld.w	r6,r5[0x4]
8000516a:	0e 9b       	mov	r11,r7
8000516c:	30 1c       	mov	r12,1
8000516e:	f0 1f 00 6f 	mcall	80005328 <can_out_callback_channel1+0x370>
80005172:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_trq_sens1.can_msg->id			= can_get_mob_id(CAN_BUS_1, handle);
80005176:	6a 16       	ld.w	r6,r5[0x4]
80005178:	0e 9b       	mov	r11,r7
8000517a:	30 1c       	mov	r12,1
8000517c:	f0 1f 00 6c 	mcall	8000532c <can_out_callback_channel1+0x374>
80005180:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_trq_sens1.dlc					= can_get_mob_dlc(CAN_BUS_1, handle);
80005182:	0e 9b       	mov	r11,r7
80005184:	30 1c       	mov	r12,1
80005186:	f0 1f 00 6b 	mcall	80005330 <can_out_callback_channel1+0x378>
8000518a:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_trq_sens1.status					= event;
8000518e:	eb 64 00 0a 	st.b	r5[10],r4
		
		xQueueOverwriteFromISR(queue_trq_sens1, &mob_rx_trq_sens1.can_msg->data.s16[0], NULL);
80005192:	6a 1b       	ld.w	r11,r5[0x4]
80005194:	30 29       	mov	r9,2
80005196:	30 0a       	mov	r10,0
80005198:	2f 8b       	sub	r11,-8
8000519a:	4f 18       	lddpc	r8,8000535c <can_out_callback_channel1+0x3a4>
8000519c:	70 0c       	ld.w	r12,r8[0x0]
8000519e:	f0 1f 00 67 	mcall	80005338 <can_out_callback_channel1+0x380>
		xQueueOverwriteFromISR(queue_trq_sens1_err, &mob_rx_trq_sens1.can_msg->data.u8[2], NULL);
800051a2:	6a 1b       	ld.w	r11,r5[0x4]
800051a4:	30 29       	mov	r9,2
800051a6:	30 0a       	mov	r10,0
800051a8:	2f 6b       	sub	r11,-10
800051aa:	4e e8       	lddpc	r8,80005360 <can_out_callback_channel1+0x3a8>
800051ac:	70 0c       	ld.w	r12,r8[0x0]
800051ae:	f0 1f 00 63 	mcall	80005338 <can_out_callback_channel1+0x380>
		asm("nop");
800051b2:	d7 03       	nop
		/* Empty message field */
		mob_rx_trq_sens1.can_msg->data.u64 = 0x0LL;
800051b4:	6a 18       	ld.w	r8,r5[0x4]
800051b6:	30 0a       	mov	r10,0
800051b8:	30 0b       	mov	r11,0
800051ba:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_1, 
800051be:	6a 19       	ld.w	r9,r5[0x4]
800051c0:	eb 3a 00 09 	ld.ub	r10,r5[9]
800051c4:	0b 8b       	ld.ub	r11,r5[0x0]
800051c6:	30 1c       	mov	r12,1
800051c8:	f0 1f 00 5d 	mcall	8000533c <can_out_callback_channel1+0x384>
800051cc:	ca a8       	rjmp	80005320 <can_out_callback_channel1+0x368>
		mob_rx_trq_sens1.handle,
		mob_rx_trq_sens1.req_type,
		mob_rx_trq_sens1.can_msg);
	
	} else if (handle == mob_rx_bms_precharge.handle) {
800051ce:	4e 68       	lddpc	r8,80005364 <can_out_callback_channel1+0x3ac>
800051d0:	11 87       	ld.ub	r7,r8[0x0]
800051d2:	f8 07 18 00 	cp.b	r7,r12
800051d6:	c3 31       	brne	8000523c <can_out_callback_channel1+0x284>
		mob_rx_bms_precharge.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
800051d8:	4e 35       	lddpc	r5,80005364 <can_out_callback_channel1+0x3ac>
800051da:	6a 16       	ld.w	r6,r5[0x4]
800051dc:	0e 9b       	mov	r11,r7
800051de:	30 1c       	mov	r12,1
800051e0:	f0 1f 00 52 	mcall	80005328 <can_out_callback_channel1+0x370>
800051e4:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_bms_precharge.can_msg->id		= can_get_mob_id(CAN_BUS_1, handle);
800051e8:	6a 16       	ld.w	r6,r5[0x4]
800051ea:	0e 9b       	mov	r11,r7
800051ec:	30 1c       	mov	r12,1
800051ee:	f0 1f 00 50 	mcall	8000532c <can_out_callback_channel1+0x374>
800051f2:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_bms_precharge.dlc				= can_get_mob_dlc(CAN_BUS_1, handle);
800051f4:	0e 9b       	mov	r11,r7
800051f6:	30 1c       	mov	r12,1
800051f8:	f0 1f 00 4e 	mcall	80005330 <can_out_callback_channel1+0x378>
800051fc:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_bms_precharge.status				= event;
80005200:	eb 64 00 0a 	st.b	r5[10],r4
		
		bms_can_msg_t bms_can_msg;
		bms_can_msg.data.u64 = mob_rx_bms_precharge.can_msg->data.u64;
80005204:	6a 18       	ld.w	r8,r5[0x4]
80005206:	f0 ea 00 08 	ld.d	r10,r8[8]
8000520a:	fa eb 00 0c 	st.d	sp[12],r10
		bms_can_msg.id = mob_rx_bms_precharge.can_msg->id;
8000520e:	70 08       	ld.w	r8,r8[0x0]
80005210:	50 58       	stdsp	sp[0x14],r8
		xQueueSendToBackFromISR(queue_bms_rx, &bms_can_msg, NULL);
80005212:	30 09       	mov	r9,0
80005214:	12 9a       	mov	r10,r9
80005216:	fa cb ff f4 	sub	r11,sp,-12
8000521a:	4d 48       	lddpc	r8,80005368 <can_out_callback_channel1+0x3b0>
8000521c:	70 0c       	ld.w	r12,r8[0x0]
8000521e:	f0 1f 00 47 	mcall	80005338 <can_out_callback_channel1+0x380>
		/* Empty message field */
		mob_rx_bms_precharge.can_msg->data.u64 = 0x0LL;
80005222:	6a 18       	ld.w	r8,r5[0x4]
80005224:	30 0a       	mov	r10,0
80005226:	30 0b       	mov	r11,0
80005228:	f0 eb 00 08 	st.d	r8[8],r10
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
8000522c:	6a 19       	ld.w	r9,r5[0x4]
8000522e:	eb 3a 00 09 	ld.ub	r10,r5[9]
80005232:	0b 8b       	ld.ub	r11,r5[0x0]
80005234:	30 1c       	mov	r12,1
80005236:	f0 1f 00 42 	mcall	8000533c <can_out_callback_channel1+0x384>
8000523a:	c7 38       	rjmp	80005320 <can_out_callback_channel1+0x368>
		mob_rx_bms_precharge.handle,
		mob_rx_bms_precharge.req_type,
		mob_rx_bms_precharge.can_msg);
		
	} else if (handle == mob_rx_bms_battvolt.handle) {
8000523c:	4c c8       	lddpc	r8,8000536c <can_out_callback_channel1+0x3b4>
8000523e:	11 87       	ld.ub	r7,r8[0x0]
80005240:	f8 07 18 00 	cp.b	r7,r12
80005244:	c3 21       	brne	800052a8 <can_out_callback_channel1+0x2f0>
		mob_rx_bms_battvolt.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
80005246:	4c a5       	lddpc	r5,8000536c <can_out_callback_channel1+0x3b4>
80005248:	6a 16       	ld.w	r6,r5[0x4]
8000524a:	0e 9b       	mov	r11,r7
8000524c:	30 1c       	mov	r12,1
8000524e:	f0 1f 00 37 	mcall	80005328 <can_out_callback_channel1+0x370>
80005252:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_bms_battvolt.can_msg->id			= can_get_mob_id(CAN_BUS_1, handle);
80005256:	6a 16       	ld.w	r6,r5[0x4]
80005258:	0e 9b       	mov	r11,r7
8000525a:	30 1c       	mov	r12,1
8000525c:	f0 1f 00 34 	mcall	8000532c <can_out_callback_channel1+0x374>
80005260:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_bms_battvolt.dlc					= can_get_mob_dlc(CAN_BUS_1, handle);
80005262:	0e 9b       	mov	r11,r7
80005264:	30 1c       	mov	r12,1
80005266:	f0 1f 00 33 	mcall	80005330 <can_out_callback_channel1+0x378>
8000526a:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_bms_battvolt.status				= event;
8000526e:	eb 64 00 0a 	st.b	r5[10],r4
		
		bms_can_msg_t bms_can_msg;
		bms_can_msg.data.u64 = mob_rx_bms_battvolt.can_msg->data.u64;
80005272:	6a 18       	ld.w	r8,r5[0x4]
80005274:	f0 ea 00 08 	ld.d	r10,r8[8]
80005278:	fa eb 00 00 	st.d	sp[0],r10
		bms_can_msg.id = mob_rx_bms_battvolt.can_msg->id;
8000527c:	70 08       	ld.w	r8,r8[0x0]
8000527e:	50 28       	stdsp	sp[0x8],r8
		
		xQueueSendToBackFromISR(queue_bms_rx, &bms_can_msg, NULL);
80005280:	30 09       	mov	r9,0
80005282:	12 9a       	mov	r10,r9
80005284:	1a 9b       	mov	r11,sp
80005286:	4b 98       	lddpc	r8,80005368 <can_out_callback_channel1+0x3b0>
80005288:	70 0c       	ld.w	r12,r8[0x0]
8000528a:	f0 1f 00 2c 	mcall	80005338 <can_out_callback_channel1+0x380>
		/* Empty message field */
		mob_rx_bms_battvolt.can_msg->data.u64 = 0x0LL;
8000528e:	6a 18       	ld.w	r8,r5[0x4]
80005290:	30 0a       	mov	r10,0
80005292:	30 0b       	mov	r11,0
80005294:	f0 eb 00 08 	st.d	r8[8],r10
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
80005298:	6a 19       	ld.w	r9,r5[0x4]
8000529a:	eb 3a 00 09 	ld.ub	r10,r5[9]
8000529e:	0b 8b       	ld.ub	r11,r5[0x0]
800052a0:	30 1c       	mov	r12,1
800052a2:	f0 1f 00 27 	mcall	8000533c <can_out_callback_channel1+0x384>
800052a6:	c3 d8       	rjmp	80005320 <can_out_callback_channel1+0x368>
		mob_rx_bms_battvolt.handle,
		mob_rx_bms_battvolt.req_type,
		mob_rx_bms_battvolt.can_msg);	
	} else if (handle == mob_brk.handle) {
800052a8:	4b 28       	lddpc	r8,80005370 <can_out_callback_channel1+0x3b8>
800052aa:	11 87       	ld.ub	r7,r8[0x0]
800052ac:	f8 07 18 00 	cp.b	r7,r12
800052b0:	c3 81       	brne	80005320 <can_out_callback_channel1+0x368>
		mob_brk.can_msg->data.u64	= can_get_mob_data(CAN_BUS_1, handle).u64;
800052b2:	4b 05       	lddpc	r5,80005370 <can_out_callback_channel1+0x3b8>
800052b4:	6a 16       	ld.w	r6,r5[0x4]
800052b6:	0e 9b       	mov	r11,r7
800052b8:	30 1c       	mov	r12,1
800052ba:	f0 1f 00 1c 	mcall	80005328 <can_out_callback_channel1+0x370>
800052be:	ec eb 00 08 	st.d	r6[8],r10
		mob_brk.can_msg->id			= can_get_mob_id(CAN_BUS_1, handle);
800052c2:	6a 16       	ld.w	r6,r5[0x4]
800052c4:	0e 9b       	mov	r11,r7
800052c6:	30 1c       	mov	r12,1
800052c8:	f0 1f 00 19 	mcall	8000532c <can_out_callback_channel1+0x374>
800052cc:	8d 0c       	st.w	r6[0x0],r12
		mob_brk.dlc					= can_get_mob_dlc(CAN_BUS_1, handle);
800052ce:	0e 9b       	mov	r11,r7
800052d0:	30 1c       	mov	r12,1
800052d2:	f0 1f 00 18 	mcall	80005330 <can_out_callback_channel1+0x378>
800052d6:	eb 6c 00 08 	st.b	r5[8],r12
		mob_brk.status				= event;
800052da:	eb 64 00 0a 	st.b	r5[10],r4
		
		if (mob_brk.can_msg->id == (CANR_FCN_DATA_ID | CANR_GRP_SENS_BRK_ID | CANR_MODULE_ID0_ID)) {
800052de:	6a 1b       	ld.w	r11,r5[0x4]
800052e0:	76 08       	ld.w	r8,r11[0x0]
800052e2:	e0 48 06 18 	cp.w	r8,1560
800052e6:	c0 91       	brne	800052f8 <can_out_callback_channel1+0x340>
			xQueueSendToBackFromISR( queue_brake_front, &mob_brk.can_msg->data.u16[0], NULL );
800052e8:	30 09       	mov	r9,0
800052ea:	12 9a       	mov	r10,r9
800052ec:	2f 8b       	sub	r11,-8
800052ee:	4a 28       	lddpc	r8,80005374 <can_out_callback_channel1+0x3bc>
800052f0:	70 0c       	ld.w	r12,r8[0x0]
800052f2:	f0 1f 00 12 	mcall	80005338 <can_out_callback_channel1+0x380>
800052f6:	c0 88       	rjmp	80005306 <can_out_callback_channel1+0x34e>
		} else {
			xQueueSendToBackFromISR( queue_brake_rear, &mob_brk.can_msg->data.u16[0], NULL );
800052f8:	30 09       	mov	r9,0
800052fa:	12 9a       	mov	r10,r9
800052fc:	2f 8b       	sub	r11,-8
800052fe:	49 f8       	lddpc	r8,80005378 <can_out_callback_channel1+0x3c0>
80005300:	70 0c       	ld.w	r12,r8[0x0]
80005302:	f0 1f 00 0e 	mcall	80005338 <can_out_callback_channel1+0x380>
		}
		/* Empty message field */
		mob_brk.can_msg->data.u64 = 0x0LL;
80005306:	49 b8       	lddpc	r8,80005370 <can_out_callback_channel1+0x3b8>
80005308:	70 19       	ld.w	r9,r8[0x4]
8000530a:	30 0a       	mov	r10,0
8000530c:	30 0b       	mov	r11,0
8000530e:	f2 eb 00 08 	st.d	r9[8],r10
		/* Prepare message reception */
		can_rx(CAN_BUS_1,
80005312:	70 19       	ld.w	r9,r8[0x4]
80005314:	f1 3a 00 09 	ld.ub	r10,r8[9]
80005318:	11 8b       	ld.ub	r11,r8[0x0]
8000531a:	30 1c       	mov	r12,1
8000531c:	f0 1f 00 08 	mcall	8000533c <can_out_callback_channel1+0x384>
		mob_brk.handle,
		mob_brk.req_type,
		mob_brk.can_msg);
	}
}
80005320:	2f ad       	sub	sp,-24
80005322:	d8 22       	popm	r4-r7,pc
80005324:	00 00       	add	r0,r0
80005326:	00 20       	rsub	r0,r0
80005328:	80 00       	ld.sh	r0,r0[0x0]
8000532a:	4d 34       	lddpc	r4,80005474 <can_out_callback_channel0+0xf8>
8000532c:	80 00       	ld.sh	r0,r0[0x0]
8000532e:	4d 64       	lddpc	r4,80005484 <can_out_callback_channel0+0x108>
80005330:	80 00       	ld.sh	r0,r0[0x0]
80005332:	4d 4c       	lddpc	r12,80005480 <can_out_callback_channel0+0x104>
80005334:	00 00       	add	r0,r0
80005336:	cf 78       	rjmp	80005524 <can_out_callback_channel0+0x1a8>
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	2c 6c       	sub	r12,-58
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	4c 2a       	lddpc	r10,80005444 <can_out_callback_channel0+0xc8>
80005340:	00 00       	add	r0,r0
80005342:	01 a0       	ld.ub	r0,r0[0x2]
80005344:	00 00       	add	r0,r0
80005346:	cf 70       	breq	80005334 <can_out_callback_channel1+0x37c>
80005348:	00 00       	add	r0,r0
8000534a:	00 14       	sub	r4,r0
8000534c:	00 00       	add	r0,r0
8000534e:	cf 84       	brge	8000533e <can_out_callback_channel1+0x386>
80005350:	00 00       	add	r0,r0
80005352:	00 38       	cp.w	r8,r0
80005354:	00 00       	add	r0,r0
80005356:	cf 6c       	rcall	80005542 <can_out_callback_channel0+0x1c6>
80005358:	00 00       	add	r0,r0
8000535a:	01 b8       	ld.ub	r8,r0[0x3]
8000535c:	00 00       	add	r0,r0
8000535e:	cf 88       	rjmp	8000554e <can_out_callback_channel0+0x1d2>
80005360:	00 00       	add	r0,r0
80005362:	cf 74       	brge	80005350 <can_out_callback_channel1+0x398>
80005364:	00 00       	add	r0,r0
80005366:	00 ac       	st.w	r0++,r12
80005368:	00 00       	add	r0,r0
8000536a:	cf 54       	brge	80005354 <can_out_callback_channel1+0x39c>
8000536c:	00 00       	add	r0,r0
8000536e:	01 34       	ld.ub	r4,r0++
80005370:	00 00       	add	r0,r0
80005372:	01 58       	ld.sh	r8,--r0
80005374:	00 00       	add	r0,r0
80005376:	cf 90       	breq	80005368 <can_out_callback_channel1+0x3b0>
80005378:	00 00       	add	r0,r0
8000537a:	cf 68       	rjmp	80005566 <can_out_callback_channel0+0x1ea>

8000537c <can_out_callback_channel0>:
		, mob_rx_bspd.can_msg
	);
	asm("nop");
}

void can_out_callback_channel0(U8 handle, U8 event){
8000537c:	d4 21       	pushm	r4-r7,lr
8000537e:	20 6d       	sub	sp,24
80005380:	16 94       	mov	r4,r11
	if (handle == mob_rx_dash_pri.handle) {
80005382:	4e d8       	lddpc	r8,80005534 <can_out_callback_channel0+0x1b8>
80005384:	11 87       	ld.ub	r7,r8[0x0]
80005386:	f8 07 18 00 	cp.b	r7,r12
8000538a:	c3 41       	brne	800053f2 <can_out_callback_channel0+0x76>
		mob_rx_dash_pri.can_msg->data.u64	= can_get_mob_data(CAN_BUS_0, handle).u64;
8000538c:	4e a5       	lddpc	r5,80005534 <can_out_callback_channel0+0x1b8>
8000538e:	6a 16       	ld.w	r6,r5[0x4]
80005390:	0e 9b       	mov	r11,r7
80005392:	30 0c       	mov	r12,0
80005394:	f0 1f 00 69 	mcall	80005538 <can_out_callback_channel0+0x1bc>
80005398:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_dash_pri.can_msg->id			= can_get_mob_id(CAN_BUS_0, handle);
8000539c:	6a 16       	ld.w	r6,r5[0x4]
8000539e:	0e 9b       	mov	r11,r7
800053a0:	30 0c       	mov	r12,0
800053a2:	f0 1f 00 67 	mcall	8000553c <can_out_callback_channel0+0x1c0>
800053a6:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_dash_pri.dlc					= can_get_mob_dlc(CAN_BUS_0, handle);
800053a8:	0e 9b       	mov	r11,r7
800053aa:	30 0c       	mov	r12,0
800053ac:	f0 1f 00 65 	mcall	80005540 <can_out_callback_channel0+0x1c4>
800053b0:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_dash_pri.status				= event;
800053b4:	eb 64 00 0a 	st.b	r5[10],r4
		
		dash_can_msg_t dash_can_msg;
		
		dash_can_msg.data.u64 = mob_rx_dash_pri.can_msg->data.u64;
800053b8:	6a 18       	ld.w	r8,r5[0x4]
800053ba:	f0 ea 00 08 	ld.d	r10,r8[8]
800053be:	fa eb 00 0c 	st.d	sp[12],r10
		dash_can_msg.id = mob_rx_dash_pri.can_msg->id;
800053c2:	70 08       	ld.w	r8,r8[0x0]
800053c4:	fb 58 00 14 	st.h	sp[20],r8
		xQueueSendToBackFromISR(queue_dash_msg, &dash_can_msg, NULL);
800053c8:	30 09       	mov	r9,0
800053ca:	12 9a       	mov	r10,r9
800053cc:	fa cb ff f4 	sub	r11,sp,-12
800053d0:	4d d8       	lddpc	r8,80005544 <can_out_callback_channel0+0x1c8>
800053d2:	70 0c       	ld.w	r12,r8[0x0]
800053d4:	f0 1f 00 5d 	mcall	80005548 <can_out_callback_channel0+0x1cc>
		/* Empty message field */
		mob_rx_dash_pri.can_msg->data.u64 = 0x0LL;
800053d8:	6a 18       	ld.w	r8,r5[0x4]
800053da:	30 0a       	mov	r10,0
800053dc:	30 0b       	mov	r11,0
800053de:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_0,
800053e2:	6a 19       	ld.w	r9,r5[0x4]
800053e4:	eb 3a 00 09 	ld.ub	r10,r5[9]
800053e8:	0b 8b       	ld.ub	r11,r5[0x0]
800053ea:	30 0c       	mov	r12,0
800053ec:	f0 1f 00 58 	mcall	8000554c <can_out_callback_channel0+0x1d0>
800053f0:	c9 f8       	rjmp	8000552e <can_out_callback_channel0+0x1b2>
		mob_rx_dash_pri.handle,
		mob_rx_dash_pri.req_type,
		mob_rx_dash_pri.can_msg);
		
	} else if (handle == mob_rx_dash_data.handle) {
800053f2:	4d 88       	lddpc	r8,80005550 <can_out_callback_channel0+0x1d4>
800053f4:	11 87       	ld.ub	r7,r8[0x0]
800053f6:	f8 07 18 00 	cp.b	r7,r12
800053fa:	c3 21       	brne	8000545e <can_out_callback_channel0+0xe2>
		mob_rx_dash_data.can_msg->data.u64	= can_get_mob_data(CAN_BUS_0, handle).u64;
800053fc:	4d 55       	lddpc	r5,80005550 <can_out_callback_channel0+0x1d4>
800053fe:	6a 16       	ld.w	r6,r5[0x4]
80005400:	0e 9b       	mov	r11,r7
80005402:	30 0c       	mov	r12,0
80005404:	f0 1f 00 4d 	mcall	80005538 <can_out_callback_channel0+0x1bc>
80005408:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_dash_data.can_msg->id			= can_get_mob_id(CAN_BUS_0, handle);
8000540c:	6a 16       	ld.w	r6,r5[0x4]
8000540e:	0e 9b       	mov	r11,r7
80005410:	30 0c       	mov	r12,0
80005412:	f0 1f 00 4b 	mcall	8000553c <can_out_callback_channel0+0x1c0>
80005416:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_dash_data.dlc					= can_get_mob_dlc(CAN_BUS_0, handle);
80005418:	0e 9b       	mov	r11,r7
8000541a:	30 0c       	mov	r12,0
8000541c:	f0 1f 00 49 	mcall	80005540 <can_out_callback_channel0+0x1c4>
80005420:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_dash_data.status				= event;
80005424:	eb 64 00 0a 	st.b	r5[10],r4
		
		dash_can_msg_t dash_can_msg;
		
		dash_can_msg.data.u64 = mob_rx_dash_data.can_msg->data.u64;
80005428:	6a 18       	ld.w	r8,r5[0x4]
8000542a:	f0 ea 00 08 	ld.d	r10,r8[8]
8000542e:	fa eb 00 00 	st.d	sp[0],r10
		dash_can_msg.id = mob_rx_dash_data.can_msg->id;
80005432:	70 08       	ld.w	r8,r8[0x0]
80005434:	ba 48       	st.h	sp[0x8],r8
		xQueueSendToBackFromISR(queue_dash_msg, &dash_can_msg, NULL);
80005436:	30 09       	mov	r9,0
80005438:	12 9a       	mov	r10,r9
8000543a:	1a 9b       	mov	r11,sp
8000543c:	4c 28       	lddpc	r8,80005544 <can_out_callback_channel0+0x1c8>
8000543e:	70 0c       	ld.w	r12,r8[0x0]
80005440:	f0 1f 00 42 	mcall	80005548 <can_out_callback_channel0+0x1cc>
		/* Empty message field */
		mob_rx_dash_data.can_msg->data.u64 = 0x0LL;
80005444:	6a 18       	ld.w	r8,r5[0x4]
80005446:	30 0a       	mov	r10,0
80005448:	30 0b       	mov	r11,0
8000544a:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_0, 
8000544e:	6a 19       	ld.w	r9,r5[0x4]
80005450:	eb 3a 00 09 	ld.ub	r10,r5[9]
80005454:	0b 8b       	ld.ub	r11,r5[0x0]
80005456:	30 0c       	mov	r12,0
80005458:	f0 1f 00 3d 	mcall	8000554c <can_out_callback_channel0+0x1d0>
8000545c:	c6 98       	rjmp	8000552e <can_out_callback_channel0+0x1b2>
		mob_rx_dash_data.handle,
		mob_rx_dash_data.req_type,
		mob_rx_dash_data.can_msg);
		
	} else if (handle == mob_rx_trq_sens0.handle) {
8000545e:	4b e8       	lddpc	r8,80005554 <can_out_callback_channel0+0x1d8>
80005460:	11 87       	ld.ub	r7,r8[0x0]
80005462:	f8 07 18 00 	cp.b	r7,r12
80005466:	c3 51       	brne	800054d0 <can_out_callback_channel0+0x154>
		mob_rx_trq_sens0.can_msg->data.u64	= can_get_mob_data(CAN_BUS_0, handle).u64;
80005468:	4b b5       	lddpc	r5,80005554 <can_out_callback_channel0+0x1d8>
8000546a:	6a 16       	ld.w	r6,r5[0x4]
8000546c:	0e 9b       	mov	r11,r7
8000546e:	30 0c       	mov	r12,0
80005470:	f0 1f 00 32 	mcall	80005538 <can_out_callback_channel0+0x1bc>
80005474:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_trq_sens0.can_msg->id		= can_get_mob_id(CAN_BUS_0, handle);
80005478:	6a 16       	ld.w	r6,r5[0x4]
8000547a:	0e 9b       	mov	r11,r7
8000547c:	30 0c       	mov	r12,0
8000547e:	f0 1f 00 30 	mcall	8000553c <can_out_callback_channel0+0x1c0>
80005482:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_trq_sens0.dlc				= can_get_mob_dlc(CAN_BUS_0, handle);
80005484:	0e 9b       	mov	r11,r7
80005486:	30 0c       	mov	r12,0
80005488:	f0 1f 00 2e 	mcall	80005540 <can_out_callback_channel0+0x1c4>
8000548c:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_trq_sens0.status				= event;
80005490:	eb 64 00 0a 	st.b	r5[10],r4
	
		xQueueOverwriteFromISR(queue_trq_sens0, &mob_rx_trq_sens0.can_msg->data.s16[0], NULL);
80005494:	6a 1b       	ld.w	r11,r5[0x4]
80005496:	30 29       	mov	r9,2
80005498:	30 0a       	mov	r10,0
8000549a:	2f 8b       	sub	r11,-8
8000549c:	4a f8       	lddpc	r8,80005558 <can_out_callback_channel0+0x1dc>
8000549e:	70 0c       	ld.w	r12,r8[0x0]
800054a0:	f0 1f 00 2a 	mcall	80005548 <can_out_callback_channel0+0x1cc>
		xQueueOverwriteFromISR(queue_trq_sens0_err, &mob_rx_trq_sens0.can_msg->data.u8[2], NULL);
800054a4:	6a 1b       	ld.w	r11,r5[0x4]
800054a6:	30 29       	mov	r9,2
800054a8:	30 0a       	mov	r10,0
800054aa:	2f 6b       	sub	r11,-10
800054ac:	4a c8       	lddpc	r8,8000555c <can_out_callback_channel0+0x1e0>
800054ae:	70 0c       	ld.w	r12,r8[0x0]
800054b0:	f0 1f 00 26 	mcall	80005548 <can_out_callback_channel0+0x1cc>
		asm("nop");
800054b4:	d7 03       	nop
		/* Empty message field */
		mob_rx_trq_sens0.can_msg->data.u64 = 0x0LL;
800054b6:	6a 18       	ld.w	r8,r5[0x4]
800054b8:	30 0a       	mov	r10,0
800054ba:	30 0b       	mov	r11,0
800054bc:	f0 eb 00 08 	st.d	r8[8],r10
		
		/* Prepare message reception */
		can_rx(CAN_BUS_0, 
800054c0:	6a 19       	ld.w	r9,r5[0x4]
800054c2:	eb 3a 00 09 	ld.ub	r10,r5[9]
800054c6:	0b 8b       	ld.ub	r11,r5[0x0]
800054c8:	30 0c       	mov	r12,0
800054ca:	f0 1f 00 21 	mcall	8000554c <can_out_callback_channel0+0x1d0>
800054ce:	c3 08       	rjmp	8000552e <can_out_callback_channel0+0x1b2>
		mob_rx_trq_sens0.handle,
		mob_rx_trq_sens0.req_type,
		mob_rx_trq_sens0.can_msg);
		
	}	else if (handle == mob_rx_bspd.handle) {
800054d0:	4a 48       	lddpc	r8,80005560 <can_out_callback_channel0+0x1e4>
800054d2:	11 87       	ld.ub	r7,r8[0x0]
800054d4:	f8 07 18 00 	cp.b	r7,r12
800054d8:	c2 b1       	brne	8000552e <can_out_callback_channel0+0x1b2>
		mob_rx_bspd.can_msg->data.u64	= can_get_mob_data(CAN_BUS_0, handle).u64;
800054da:	4a 25       	lddpc	r5,80005560 <can_out_callback_channel0+0x1e4>
800054dc:	6a 16       	ld.w	r6,r5[0x4]
800054de:	0e 9b       	mov	r11,r7
800054e0:	30 0c       	mov	r12,0
800054e2:	f0 1f 00 16 	mcall	80005538 <can_out_callback_channel0+0x1bc>
800054e6:	ec eb 00 08 	st.d	r6[8],r10
		mob_rx_bspd.can_msg->id			= can_get_mob_id(CAN_BUS_0, handle);
800054ea:	6a 16       	ld.w	r6,r5[0x4]
800054ec:	0e 9b       	mov	r11,r7
800054ee:	30 0c       	mov	r12,0
800054f0:	f0 1f 00 13 	mcall	8000553c <can_out_callback_channel0+0x1c0>
800054f4:	8d 0c       	st.w	r6[0x0],r12
		mob_rx_bspd.dlc					= can_get_mob_dlc(CAN_BUS_0, handle);
800054f6:	0e 9b       	mov	r11,r7
800054f8:	30 0c       	mov	r12,0
800054fa:	f0 1f 00 12 	mcall	80005540 <can_out_callback_channel0+0x1c4>
800054fe:	eb 6c 00 08 	st.b	r5[8],r12
		mob_rx_bspd.status				= event;
80005502:	eb 64 00 0a 	st.b	r5[10],r4
		
		xQueueOverwriteFromISR( queue_bspd, &mob_rx_bspd.can_msg->data.u8[0], NULL );
80005506:	6a 1b       	ld.w	r11,r5[0x4]
80005508:	30 29       	mov	r9,2
8000550a:	30 0a       	mov	r10,0
8000550c:	2f 8b       	sub	r11,-8
8000550e:	49 68       	lddpc	r8,80005564 <can_out_callback_channel0+0x1e8>
80005510:	70 0c       	ld.w	r12,r8[0x0]
80005512:	f0 1f 00 0e 	mcall	80005548 <can_out_callback_channel0+0x1cc>
		/* Empty message field */
		mob_rx_bspd.can_msg->data.u64 = 0x0LL;
80005516:	6a 18       	ld.w	r8,r5[0x4]
80005518:	30 0a       	mov	r10,0
8000551a:	30 0b       	mov	r11,0
8000551c:	f0 eb 00 08 	st.d	r8[8],r10
		/* Prepare message reception */
		can_rx(CAN_BUS_0,
80005520:	6a 19       	ld.w	r9,r5[0x4]
80005522:	eb 3a 00 09 	ld.ub	r10,r5[9]
80005526:	0b 8b       	ld.ub	r11,r5[0x0]
80005528:	30 0c       	mov	r12,0
8000552a:	f0 1f 00 09 	mcall	8000554c <can_out_callback_channel0+0x1d0>
		mob_rx_bspd.handle,
		mob_rx_bspd.req_type,
		mob_rx_bspd.can_msg);
	} 
}
8000552e:	2f ad       	sub	sp,-24
80005530:	d8 22       	popm	r4-r7,pc
80005532:	00 00       	add	r0,r0
80005534:	00 00       	add	r0,r0
80005536:	01 4c       	ld.w	r12,--r0
80005538:	80 00       	ld.sh	r0,r0[0x0]
8000553a:	4d 34       	lddpc	r4,80005684 <ecu_can_init+0x11c>
8000553c:	80 00       	ld.sh	r0,r0[0x0]
8000553e:	4d 64       	lddpc	r4,80005694 <ecu_can_init+0x12c>
80005540:	80 00       	ld.sh	r0,r0[0x0]
80005542:	4d 4c       	lddpc	r12,80005690 <ecu_can_init+0x128>
80005544:	00 00       	add	r0,r0
80005546:	cf 7c       	rcall	80005734 <vListInitialise+0x10>
80005548:	80 00       	ld.sh	r0,r0[0x0]
8000554a:	2c 6c       	sub	r12,-58
8000554c:	80 00       	ld.sh	r0,r0[0x0]
8000554e:	4c 2a       	lddpc	r10,80005654 <ecu_can_init+0xec>
80005550:	00 00       	add	r0,r0
80005552:	01 84       	ld.ub	r4,r0[0x0]
80005554:	00 00       	add	r0,r0
80005556:	01 ac       	ld.ub	r12,r0[0x2]
80005558:	00 00       	add	r0,r0
8000555a:	cf 60       	breq	80005546 <can_out_callback_channel0+0x1ca>
8000555c:	00 00       	add	r0,r0
8000555e:	cf 8c       	rcall	8000574e <vListInsertEnd+0x10>
80005560:	00 00       	add	r0,r0
80005562:	00 2c       	rsub	r12,r0
80005564:	00 00       	add	r0,r0
80005566:	cf 80       	breq	80005556 <can_out_callback_channel0+0x1da>

80005568 <ecu_can_init>:
/* Allocate CAN mobs */
volatile can_msg_t mob_ram_ch0[NB_MOB_CHANNEL] __attribute__ ((section (".hsb_ram_loc")));
volatile can_msg_t mob_ram_ch1[NB_MOB_CHANNEL] __attribute__ ((section (".hsb_ram_loc")));


void ecu_can_init(void) {
80005568:	d4 31       	pushm	r0-r7,lr
	/* Setup the generic clock for CAN output */
	scif_gc_setup(
8000556a:	30 09       	mov	r9,0
8000556c:	12 9a       	mov	r10,r9
8000556e:	30 3b       	mov	r11,3
80005570:	30 1c       	mov	r12,1
80005572:	f0 1f 00 53 	mcall	800056bc <ecu_can_init+0x154>
		SCIF_GCCTRL_OSC0,
		AVR32_SCIF_GC_NO_DIV_CLOCK,
		0
	);
	/* Now enable the generic clock input for the CAN module */
	scif_gc_enable(AVR32_SCIF_GCLK_CANIF);
80005576:	30 1c       	mov	r12,1
80005578:	f0 1f 00 52 	mcall	800056c0 <ecu_can_init+0x158>
		{CAN1_RX_PIN, CAN1_RX_FUNCTION},
		{CAN1_TX_PIN, CAN1_TX_FUNCTION}
	};
	
	/* Assign GPIO to CAN. */
	gpio_enable_module(CAN_GPIO_MAP, sizeof(CAN_GPIO_MAP) / sizeof(CAN_GPIO_MAP[0]));
8000557c:	30 4b       	mov	r11,4
8000557e:	4d 2c       	lddpc	r12,800056c4 <ecu_can_init+0x15c>
80005580:	f0 1f 00 52 	mcall	800056c8 <ecu_can_init+0x160>
	

	/* Initialize interrupt vectors. */
	INTC_init_interrupts();
80005584:	f0 1f 00 52 	mcall	800056cc <ecu_can_init+0x164>
	
	/* Allocate channel message box */
	mob_rx_speed_sens_fl.handle	= 0;
80005588:	4d 27       	lddpc	r7,800056d0 <ecu_can_init+0x168>
8000558a:	30 08       	mov	r8,0
8000558c:	ae 88       	st.b	r7[0x0],r8
	mob_rx_speed_sens_fr.handle	= 1;
8000558e:	4d 25       	lddpc	r5,800056d4 <ecu_can_init+0x16c>
80005590:	30 18       	mov	r8,1
80005592:	aa 88       	st.b	r5[0x0],r8
	mob_rx_speed_sens_rl.handle	= 2;
80005594:	4d 14       	lddpc	r4,800056d8 <ecu_can_init+0x170>
80005596:	30 28       	mov	r8,2
80005598:	a8 88       	st.b	r4[0x0],r8
	mob_rx_speed_sens_rr.handle	= 3;
8000559a:	4d 13       	lddpc	r3,800056dc <ecu_can_init+0x174>
8000559c:	30 38       	mov	r8,3
8000559e:	a6 88       	st.b	r3[0x0],r8
	mob_rx_dash_pri.handle		= 4;
800055a0:	4d 02       	lddpc	r2,800056e0 <ecu_can_init+0x178>
800055a2:	30 48       	mov	r8,4
800055a4:	a4 88       	st.b	r2[0x0],r8
	mob_tx_dash.handle			= 5;
800055a6:	30 59       	mov	r9,5
800055a8:	4c f8       	lddpc	r8,800056e4 <ecu_can_init+0x17c>
800055aa:	b0 89       	st.b	r8[0x0],r9
	mob_rx_trq_sens0.handle		= 6;
800055ac:	4c f0       	lddpc	r0,800056e8 <ecu_can_init+0x180>
800055ae:	30 68       	mov	r8,6
800055b0:	a0 88       	st.b	r0[0x0],r8
	mob_rx_trq_sens1.handle     = 7;
800055b2:	30 78       	mov	r8,7
800055b4:	4c e9       	lddpc	r9,800056ec <ecu_can_init+0x184>
800055b6:	b2 88       	st.b	r9[0x0],r8
	mob_ecu_slow_data.handle	= 8;
800055b8:	30 89       	mov	r9,8
800055ba:	4c e8       	lddpc	r8,800056f0 <ecu_can_init+0x188>
800055bc:	b0 89       	st.b	r8[0x0],r9
	mob_rx_bms_precharge.handle	= 9;
800055be:	30 98       	mov	r8,9
800055c0:	4c d9       	lddpc	r9,800056f4 <ecu_can_init+0x18c>
800055c2:	b2 88       	st.b	r9[0x0],r8
	mob_brk.handle				= 10;
800055c4:	30 a8       	mov	r8,10
800055c6:	4c d9       	lddpc	r9,800056f8 <ecu_can_init+0x190>
800055c8:	b2 88       	st.b	r9[0x0],r8
	mob_ecu_fast_data.handle	= 11;
800055ca:	30 b9       	mov	r9,11
800055cc:	4c c8       	lddpc	r8,800056fc <ecu_can_init+0x194>
800055ce:	b0 89       	st.b	r8[0x0],r9
	mob_rx_bms_battvolt.handle  = 12;
800055d0:	30 c8       	mov	r8,12
800055d2:	4c c9       	lddpc	r9,80005700 <ecu_can_init+0x198>
800055d4:	b2 88       	st.b	r9[0x0],r8
	mob_rx_bspd.handle			= 13;
800055d6:	30 d8       	mov	r8,13
800055d8:	4c b9       	lddpc	r9,80005704 <ecu_can_init+0x19c>
800055da:	b2 88       	st.b	r9[0x0],r8
	mob_rx_dash_data.handle		= 14;
800055dc:	4c b1       	lddpc	r1,80005708 <ecu_can_init+0x1a0>
800055de:	30 e8       	mov	r8,14
800055e0:	a2 88       	st.b	r1[0x0],r8
	mob_slip_current.handle     = 15;
800055e2:	30 f9       	mov	r9,15
800055e4:	4c a8       	lddpc	r8,8000570c <ecu_can_init+0x1a4>
800055e6:	b0 89       	st.b	r8[0x0],r9


	/* Initialize CAN channels */
	can_init(CAN_BUS_0, ((uint32_t)&mob_ram_ch0[0]), CANIF_CHANNEL_MODE_NORMAL,	can_out_callback_channel0);
800055e8:	4c a6       	lddpc	r6,80005710 <ecu_can_init+0x1a8>
800055ea:	4c b9       	lddpc	r9,80005714 <ecu_can_init+0x1ac>
800055ec:	30 0a       	mov	r10,0
800055ee:	0c 9b       	mov	r11,r6
800055f0:	14 9c       	mov	r12,r10
800055f2:	f0 1f 00 4a 	mcall	80005718 <ecu_can_init+0x1b0>
	can_init(CAN_BUS_1, ((uint32_t)&mob_ram_ch1[0]), CANIF_CHANNEL_MODE_NORMAL,	can_out_callback_channel1);
800055f6:	4c a9       	lddpc	r9,8000571c <ecu_can_init+0x1b4>
800055f8:	30 0a       	mov	r10,0
800055fa:	ec cb ff 00 	sub	r11,r6,-256
800055fe:	30 1c       	mov	r12,1
80005600:	f0 1f 00 46 	mcall	80005718 <ecu_can_init+0x1b0>
	
	
	/* Prepare for message reception */	
	can_rx(
80005604:	6e 19       	ld.w	r9,r7[0x4]
80005606:	ef 3a 00 09 	ld.ub	r10,r7[9]
8000560a:	0f 8b       	ld.ub	r11,r7[0x0]
8000560c:	30 1c       	mov	r12,1
8000560e:	f0 1f 00 45 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_rx_speed_sens_fl.handle
		, mob_rx_speed_sens_fl.req_type
		, mob_rx_speed_sens_fl.can_msg
	);
	
	can_rx(
80005612:	6a 19       	ld.w	r9,r5[0x4]
80005614:	eb 3a 00 09 	ld.ub	r10,r5[9]
80005618:	0b 8b       	ld.ub	r11,r5[0x0]
8000561a:	30 1c       	mov	r12,1
8000561c:	f0 1f 00 41 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_rx_speed_sens_fr.req_type
		, mob_rx_speed_sens_fr.can_msg
	);
	
	
	can_rx(
80005620:	68 19       	ld.w	r9,r4[0x4]
80005622:	e9 3a 00 09 	ld.ub	r10,r4[9]
80005626:	09 8b       	ld.ub	r11,r4[0x0]
80005628:	30 1c       	mov	r12,1
8000562a:	f0 1f 00 3e 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_rx_speed_sens_rl.handle
		, mob_rx_speed_sens_rl.req_type
		, mob_rx_speed_sens_rl.can_msg
	);
	
	can_rx(
8000562e:	66 19       	ld.w	r9,r3[0x4]
80005630:	e7 3a 00 09 	ld.ub	r10,r3[9]
80005634:	07 8b       	ld.ub	r11,r3[0x0]
80005636:	30 1c       	mov	r12,1
80005638:	f0 1f 00 3a 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_rx_speed_sens_rr.handle
		, mob_rx_speed_sens_rr.req_type
		, mob_rx_speed_sens_rr.can_msg
	);
	
	can_rx(
8000563c:	64 19       	ld.w	r9,r2[0x4]
8000563e:	e5 3a 00 09 	ld.ub	r10,r2[9]
80005642:	05 8b       	ld.ub	r11,r2[0x0]
80005644:	30 0c       	mov	r12,0
80005646:	f0 1f 00 37 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_rx_dash_pri.handle
		, mob_rx_dash_pri.req_type
		, mob_rx_dash_pri.can_msg
	);
	
	can_rx(
8000564a:	62 19       	ld.w	r9,r1[0x4]
8000564c:	e3 3a 00 09 	ld.ub	r10,r1[9]
80005650:	03 8b       	ld.ub	r11,r1[0x0]
80005652:	30 0c       	mov	r12,0
80005654:	f0 1f 00 33 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_rx_dash_data.handle
		, mob_rx_dash_data.req_type
		, mob_rx_dash_data.can_msg
	);
	
	can_rx(
80005658:	60 19       	ld.w	r9,r0[0x4]
8000565a:	e1 3a 00 09 	ld.ub	r10,r0[9]
8000565e:	01 8b       	ld.ub	r11,r0[0x0]
80005660:	30 0c       	mov	r12,0
80005662:	f0 1f 00 30 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_rx_trq_sens0.handle
		, mob_rx_trq_sens0.req_type
		, mob_rx_trq_sens0.can_msg
	);

	can_rx(
80005666:	4a 28       	lddpc	r8,800056ec <ecu_can_init+0x184>
80005668:	70 19       	ld.w	r9,r8[0x4]
8000566a:	f1 3a 00 09 	ld.ub	r10,r8[9]
8000566e:	11 8b       	ld.ub	r11,r8[0x0]
80005670:	30 1c       	mov	r12,1
80005672:	f0 1f 00 2c 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_rx_trq_sens1.req_type
		, mob_rx_trq_sens1.can_msg
	);

	
	can_rx(
80005676:	4a 08       	lddpc	r8,800056f4 <ecu_can_init+0x18c>
80005678:	70 19       	ld.w	r9,r8[0x4]
8000567a:	f1 3a 00 09 	ld.ub	r10,r8[9]
8000567e:	11 8b       	ld.ub	r11,r8[0x0]
80005680:	30 1c       	mov	r12,1
80005682:	f0 1f 00 28 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_rx_bms_precharge.handle
		, mob_rx_bms_precharge.req_type
		, mob_rx_bms_precharge.can_msg
	);
	
	can_rx(
80005686:	49 f8       	lddpc	r8,80005700 <ecu_can_init+0x198>
80005688:	70 19       	ld.w	r9,r8[0x4]
8000568a:	f1 3a 00 09 	ld.ub	r10,r8[9]
8000568e:	11 8b       	ld.ub	r11,r8[0x0]
80005690:	30 1c       	mov	r12,1
80005692:	f0 1f 00 24 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_rx_bms_battvolt.handle
		, mob_rx_bms_battvolt.req_type
		, mob_rx_bms_battvolt.can_msg
	);
	
	can_rx(
80005696:	49 98       	lddpc	r8,800056f8 <ecu_can_init+0x190>
80005698:	70 19       	ld.w	r9,r8[0x4]
8000569a:	f1 3a 00 09 	ld.ub	r10,r8[9]
8000569e:	11 8b       	ld.ub	r11,r8[0x0]
800056a0:	30 1c       	mov	r12,1
800056a2:	f0 1f 00 20 	mcall	80005720 <ecu_can_init+0x1b8>
		, mob_brk.handle
		, mob_brk.req_type
		, mob_brk.can_msg
	);
	
	can_rx(
800056a6:	49 88       	lddpc	r8,80005704 <ecu_can_init+0x19c>
800056a8:	70 19       	ld.w	r9,r8[0x4]
800056aa:	f1 3a 00 09 	ld.ub	r10,r8[9]
800056ae:	11 8b       	ld.ub	r11,r8[0x0]
800056b0:	30 0c       	mov	r12,0
800056b2:	f0 1f 00 1c 	mcall	80005720 <ecu_can_init+0x1b8>
		CAN_BUS_0
		, mob_rx_bspd.handle
		, mob_rx_bspd.req_type
		, mob_rx_bspd.can_msg
	);
	asm("nop");
800056b6:	d7 03       	nop
}
800056b8:	d8 32       	popm	r0-r7,pc
800056ba:	00 00       	add	r0,r0
800056bc:	80 00       	ld.sh	r0,r0[0x0]
800056be:	48 88       	lddpc	r8,800056dc <ecu_can_init+0x174>
800056c0:	80 00       	ld.sh	r0,r0[0x0]
800056c2:	49 0c       	lddpc	r12,80005700 <ecu_can_init+0x198>
800056c4:	80 00       	ld.sh	r0,r0[0x0]
800056c6:	80 50       	ld.sh	r0,r0[0xa]
800056c8:	80 00       	ld.sh	r0,r0[0x0]
800056ca:	68 30       	ld.w	r0,r4[0xc]
800056cc:	80 00       	ld.sh	r0,r0[0x0]
800056ce:	6a 6c       	ld.w	r12,r5[0x18]
800056d0:	00 00       	add	r0,r0
800056d2:	00 20       	rsub	r0,r0
800056d4:	00 00       	add	r0,r0
800056d6:	01 a0       	ld.ub	r0,r0[0x2]
800056d8:	00 00       	add	r0,r0
800056da:	00 14       	sub	r4,r0
800056dc:	00 00       	add	r0,r0
800056de:	00 38       	cp.w	r8,r0
800056e0:	00 00       	add	r0,r0
800056e2:	01 4c       	ld.w	r12,--r0
800056e4:	00 00       	add	r0,r0
800056e6:	00 a0       	st.w	r0++,r0
800056e8:	00 00       	add	r0,r0
800056ea:	01 ac       	ld.ub	r12,r0[0x2]
800056ec:	00 00       	add	r0,r0
800056ee:	01 b8       	ld.ub	r8,r0[0x3]
800056f0:	00 00       	add	r0,r0
800056f2:	01 40       	ld.w	r0,--r0
800056f4:	00 00       	add	r0,r0
800056f6:	00 ac       	st.w	r0++,r12
800056f8:	00 00       	add	r0,r0
800056fa:	01 58       	ld.sh	r8,--r0
800056fc:	00 00       	add	r0,r0
800056fe:	00 64       	and	r4,r0
80005700:	00 00       	add	r0,r0
80005702:	01 34       	ld.ub	r4,r0++
80005704:	00 00       	add	r0,r0
80005706:	00 2c       	rsub	r12,r0
80005708:	00 00       	add	r0,r0
8000570a:	01 84       	ld.ub	r4,r0[0x0]
8000570c:	00 00       	add	r0,r0
8000570e:	00 e8       	st.h	--r0,r8
80005710:	00 00       	add	r0,r0
80005712:	02 00       	add	r0,r1
80005714:	80 00       	ld.sh	r0,r0[0x0]
80005716:	53 7c       	stdsp	sp[0xdc],r12
80005718:	80 00       	ld.sh	r0,r0[0x0]
8000571a:	4e 5c       	lddpc	r12,800058ac <xPortStartScheduler+0x54>
8000571c:	80 00       	ld.sh	r0,r0[0x0]
8000571e:	4f b8       	lddpc	r8,80005908 <SCALLYield+0x58>
80005720:	80 00       	ld.sh	r0,r0[0x0]
80005722:	4c 2a       	lddpc	r10,80005828 <pxPortInitialiseStack+0x74>

80005724 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
80005724:	f8 c8 ff f8 	sub	r8,r12,-8
80005728:	99 18       	st.w	r12[0x4],r8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
8000572a:	3f f9       	mov	r9,-1
8000572c:	99 29       	st.w	r12[0x8],r9

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
8000572e:	99 38       	st.w	r12[0xc],r8
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
80005730:	99 48       	st.w	r12[0x10],r8

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
80005732:	30 08       	mov	r8,0
80005734:	99 08       	st.w	r12[0x0],r8
}
80005736:	5e fc       	retal	r12

80005738 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80005738:	30 08       	mov	r8,0
8000573a:	99 48       	st.w	r12[0x10],r8
}
8000573c:	5e fc       	retal	r12

8000573e <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
8000573e:	78 18       	ld.w	r8,r12[0x4]

	pxNewListItem->pxNext = pxIndex->pxNext;
80005740:	70 19       	ld.w	r9,r8[0x4]
80005742:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxPrevious = pxList->pxIndex;
80005744:	78 19       	ld.w	r9,r12[0x4]
80005746:	97 29       	st.w	r11[0x8],r9
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
80005748:	70 19       	ld.w	r9,r8[0x4]
8000574a:	93 2b       	st.w	r9[0x8],r11
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
8000574c:	91 1b       	st.w	r8[0x4],r11
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
8000574e:	99 1b       	st.w	r12[0x4],r11

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005750:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005752:	78 08       	ld.w	r8,r12[0x0]
80005754:	2f f8       	sub	r8,-1
80005756:	99 08       	st.w	r12[0x0],r8
}
80005758:	5e fc       	retal	r12

8000575a <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
8000575a:	76 0a       	ld.w	r10,r11[0x0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
8000575c:	5b fa       	cp.w	r10,-1
8000575e:	c0 31       	brne	80005764 <vListInsert+0xa>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
80005760:	78 48       	ld.w	r8,r12[0x10]
80005762:	c0 c8       	rjmp	8000577a <vListInsert+0x20>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
80005764:	f8 c8 ff f8 	sub	r8,r12,-8
80005768:	70 19       	ld.w	r9,r8[0x4]
8000576a:	72 09       	ld.w	r9,r9[0x0]
8000576c:	12 3a       	cp.w	r10,r9
8000576e:	c0 63       	brcs	8000577a <vListInsert+0x20>
80005770:	70 18       	ld.w	r8,r8[0x4]
80005772:	70 19       	ld.w	r9,r8[0x4]
80005774:	72 09       	ld.w	r9,r9[0x0]
80005776:	12 3a       	cp.w	r10,r9
80005778:	cf c2       	brcc	80005770 <vListInsert+0x16>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8000577a:	70 19       	ld.w	r9,r8[0x4]
8000577c:	97 19       	st.w	r11[0x4],r9
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
8000577e:	93 2b       	st.w	r9[0x8],r11
	pxNewListItem->pxPrevious = pxIterator;
80005780:	97 28       	st.w	r11[0x8],r8
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
80005782:	91 1b       	st.w	r8[0x4],r11

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80005784:	97 4c       	st.w	r11[0x10],r12

	( pxList->uxNumberOfItems )++;
80005786:	78 08       	ld.w	r8,r12[0x0]
80005788:	2f f8       	sub	r8,-1
8000578a:	99 08       	st.w	r12[0x0],r8
}
8000578c:	5e fc       	retal	r12

8000578e <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8000578e:	78 18       	ld.w	r8,r12[0x4]
80005790:	78 29       	ld.w	r9,r12[0x8]
80005792:	91 29       	st.w	r8[0x8],r9
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80005794:	78 28       	ld.w	r8,r12[0x8]
80005796:	78 19       	ld.w	r9,r12[0x4]
80005798:	91 19       	st.w	r8[0x4],r9

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
8000579a:	78 48       	ld.w	r8,r12[0x10]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
8000579c:	70 19       	ld.w	r9,r8[0x4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8000579e:	18 39       	cp.w	r9,r12
800057a0:	f9 f9 00 02 	ld.weq	r9,r12[0x8]
800057a4:	f1 f9 0a 01 	st.weq	r8[0x4],r9
	}

	pxItemToRemove->pvContainer = NULL;
800057a8:	30 09       	mov	r9,0
800057aa:	99 49       	st.w	r12[0x10],r9
	( pxList->uxNumberOfItems )--;
800057ac:	70 09       	ld.w	r9,r8[0x0]
800057ae:	20 19       	sub	r9,1
800057b0:	91 09       	st.w	r8[0x0],r9
}
800057b2:	5e fc       	retal	r12

800057b4 <pxPortInitialiseStack>:
	/* Setup the initial stack of the task.  The stack is set exactly as
	expected by the portRESTORE_CONTEXT() macro. */

	/* When the task starts, it will expect to find the function parameter in R12. */
	pxTopOfStack--;
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x08080808;					/* R8 */
800057b4:	e0 68 08 08 	mov	r8,2056
800057b8:	ea 18 08 08 	orh	r8,0x808
800057bc:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x09090909;					/* R9 */
800057be:	e0 68 09 09 	mov	r8,2313
800057c2:	ea 18 09 09 	orh	r8,0x909
800057c6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0A0A0A0A;					/* R10 */
800057c8:	e0 68 0a 0a 	mov	r8,2570
800057cc:	ea 18 0a 0a 	orh	r8,0xa0a
800057d0:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x0B0B0B0B;					/* R11 */
800057d2:	e0 68 0b 0b 	mov	r8,2827
800057d6:	ea 18 0b 0b 	orh	r8,0xb0b
800057da:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pvParameters;					/* R12 */
800057dc:	18 da       	st.w	--r12,r10
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xDEADBEEF;					/* R14/LR */
800057de:	e0 68 be ef 	mov	r8,48879
800057e2:	ea 18 de ad 	orh	r8,0xdead
800057e6:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) pxCode + portINSTRUCTION_SIZE; /* R15/PC */
800057e8:	18 db       	st.w	--r12,r11
	*pxTopOfStack-- = ( portSTACK_TYPE ) portINITIAL_SR;				/* SR */
800057ea:	fc 18 00 40 	movh	r8,0x40
800057ee:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0xFF0000FF;					/* R0 */
800057f0:	e0 68 00 ff 	mov	r8,255
800057f4:	ea 18 ff 00 	orh	r8,0xff00
800057f8:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x01010101;					/* R1 */
800057fa:	e0 68 01 01 	mov	r8,257
800057fe:	ea 18 01 01 	orh	r8,0x101
80005802:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x02020202;					/* R2 */
80005804:	e0 68 02 02 	mov	r8,514
80005808:	ea 18 02 02 	orh	r8,0x202
8000580c:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x03030303;					/* R3 */
8000580e:	e0 68 03 03 	mov	r8,771
80005812:	ea 18 03 03 	orh	r8,0x303
80005816:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x04040404;					/* R4 */
80005818:	e0 68 04 04 	mov	r8,1028
8000581c:	ea 18 04 04 	orh	r8,0x404
80005820:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x05050505;					/* R5 */
80005822:	e0 68 05 05 	mov	r8,1285
80005826:	ea 18 05 05 	orh	r8,0x505
8000582a:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x06060606;					/* R6 */
8000582c:	e0 68 06 06 	mov	r8,1542
80005830:	ea 18 06 06 	orh	r8,0x606
80005834:	18 d8       	st.w	--r12,r8
	*pxTopOfStack-- = ( portSTACK_TYPE ) 0x07070707;					/* R7 */
80005836:	e0 68 07 07 	mov	r8,1799
8000583a:	ea 18 07 07 	orh	r8,0x707
8000583e:	18 d8       	st.w	--r12,r8
	*pxTopOfStack = ( portSTACK_TYPE ) portNO_CRITICAL_NESTING;			/* ulCriticalNesting */
80005840:	30 08       	mov	r8,0
80005842:	18 d8       	st.w	--r12,r8

	return pxTopOfStack;
}
80005844:	5e fc       	retal	r12
80005846:	d7 03       	nop

80005848 <vPortEnterCritical>:
be saved to the stack.  Instead the critical section nesting level is stored
in a variable, which is then saved as part of the stack context. */
__attribute__((__noinline__)) void vPortEnterCritical( void )
{
	/* Disable interrupts */
	portDISABLE_INTERRUPTS();
80005848:	d3 03       	ssrf	0x10

	/* Now interrupts are disabled ulCriticalNesting can be accessed
	 directly.  Increment ulCriticalNesting to keep a count of how many times
	 portENTER_CRITICAL() has been called. */
	ulCriticalNesting++;
8000584a:	48 38       	lddpc	r8,80005854 <vPortEnterCritical+0xc>
8000584c:	70 09       	ld.w	r9,r8[0x0]
8000584e:	2f f9       	sub	r9,-1
80005850:	91 09       	st.w	r8[0x0],r9
}
80005852:	5e fc       	retal	r12
80005854:	00 00       	add	r0,r0
80005856:	01 dc       	ld.ub	r12,r0[0x5]

80005858 <xPortStartScheduler>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
80005858:	d4 01       	pushm	lr
	};

#endif

	/* Disable all interrupt/exception. */
	portDISABLE_INTERRUPTS();
8000585a:	d3 03       	ssrf	0x10
		/* Start the timer/counter. */
		tc_start(tc, configTICK_TC_CHANNEL);
	}
	#else
	{
		INTC_register_interrupt(&vTick, AVR32_CORE_COMPARE_IRQ, AVR32_INTC_INT0);
8000585c:	30 0a       	mov	r10,0
8000585e:	14 9b       	mov	r11,r10
80005860:	49 2c       	lddpc	r12,800058a8 <xPortStartScheduler+0x50>
80005862:	f0 1f 00 13 	mcall	800058ac <xPortStartScheduler+0x54>
/* Schedule the COUNT&COMPARE match interrupt in (configCPU_CLOCK_HZ/configTICK_RATE_HZ)
clock cycles from now. */
#if( configTICK_USE_TC==0 )
	static void prvScheduleFirstTick(void)
	{
		Set_system_register(AVR32_COMPARE, configCPU_CLOCK_HZ/configTICK_RATE_HZ);
80005866:	e0 68 bb 80 	mov	r8,48000
8000586a:	e3 b8 00 43 	mtsr	0x10c,r8
		Set_system_register(AVR32_COUNT, 0);
8000586e:	30 08       	mov	r8,0
80005870:	e3 b8 00 42 	mtsr	0x108,r8
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();

	/* Start the first task. */
	portRESTORE_CONTEXT();
80005874:	e0 68 cd 04 	mov	r8,52484
80005878:	ea 18 00 00 	orh	r8,0x0
8000587c:	70 00       	ld.w	r0,r8[0x0]
8000587e:	60 0d       	ld.w	sp,r0[0x0]
80005880:	1b 00       	ld.w	r0,sp++
80005882:	e0 68 01 dc 	mov	r8,476
80005886:	ea 18 00 00 	orh	r8,0x0
8000588a:	91 00       	st.w	r8[0x0],r0
8000588c:	e3 cd 00 ff 	ldm	sp++,r0-r7
80005890:	2f ed       	sub	sp,-8
80005892:	e3 cd 5f 00 	ldm	sp++,r8-r12,lr
80005896:	fa f0 ff e0 	ld.w	r0,sp[-32]
8000589a:	e3 b0 00 00 	mtsr	0x0,r0
8000589e:	fa f0 ff dc 	ld.w	r0,sp[-36]
800058a2:	fa ff ff e4 	ld.w	pc,sp[-28]

	/* Should not get here! */
	return 0;
}
800058a6:	d8 0a       	popm	pc,r12=0
800058a8:	80 00       	ld.sh	r0,r0[0x0]
800058aa:	59 74       	cp.w	r4,23
800058ac:	80 00       	ld.sh	r0,r0[0x0]
800058ae:	69 ec       	ld.w	r12,r4[0x78]

800058b0 <SCALLYield>:
/*-----------------------------------------------------------*/
__attribute__((__naked__)) void SCALLYield( void );
__attribute__((__naked__)) void SCALLYield( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_SCALL();
800058b0:	20 6d       	sub	sp,24
800058b2:	eb cd 00 ff 	pushm	r0-r7
800058b6:	fa c7 ff c0 	sub	r7,sp,-64
800058ba:	ee f0 ff f8 	ld.w	r0,r7[-8]
800058be:	ef 40 ff e0 	st.w	r7[-32],r0
800058c2:	ee f0 ff fc 	ld.w	r0,r7[-4]
800058c6:	ef 40 ff e4 	st.w	r7[-28],r0
800058ca:	eb c7 5f 00 	stm	--r7,r8-r12,lr
800058ce:	e0 68 01 dc 	mov	r8,476
800058d2:	ea 18 00 00 	orh	r8,0x0
800058d6:	70 00       	ld.w	r0,r8[0x0]
800058d8:	1a d0       	st.w	--sp,r0
800058da:	f0 1f 00 1a 	mcall	80005940 <LABEL_RET_SCALL_260+0x14>
800058de:	e0 68 cd 04 	mov	r8,52484
800058e2:	ea 18 00 00 	orh	r8,0x0
800058e6:	70 00       	ld.w	r0,r8[0x0]
800058e8:	81 0d       	st.w	r0[0x0],sp
	vTaskSwitchContext();
800058ea:	f0 1f 00 17 	mcall	80005944 <LABEL_RET_SCALL_260+0x18>
	portRESTORE_CONTEXT_SCALL();
800058ee:	e0 68 cd 04 	mov	r8,52484
800058f2:	ea 18 00 00 	orh	r8,0x0
800058f6:	70 00       	ld.w	r0,r8[0x0]
800058f8:	60 0d       	ld.w	sp,r0[0x0]
800058fa:	1b 00       	ld.w	r0,sp++
800058fc:	e0 68 01 dc 	mov	r8,476
80005900:	ea 18 00 00 	orh	r8,0x0
80005904:	91 00       	st.w	r8[0x0],r0
80005906:	fa c7 ff d8 	sub	r7,sp,-40
8000590a:	e3 c7 5f 00 	ldm	r7++,r8-r12,lr
8000590e:	ee f0 ff e0 	ld.w	r0,r7[-32]
80005912:	e0 61 01 dc 	mov	r1,476
80005916:	ea 11 00 00 	orh	r1,0x0
8000591a:	62 02       	ld.w	r2,r1[0x0]
8000591c:	58 02       	cp.w	r2,0
8000591e:	c0 70       	breq	8000592c <LABEL_RET_SCALL_260>
80005920:	e4 c2 00 01 	sub	r2,r2,1
80005924:	83 02       	st.w	r1[0x0],r2
80005926:	58 02       	cp.w	r2,0
80005928:	c0 21       	brne	8000592c <LABEL_RET_SCALL_260>
8000592a:	b1 c0       	cbr	r0,0x10

8000592c <LABEL_RET_SCALL_260>:
8000592c:	ef 40 ff f8 	st.w	r7[-8],r0
80005930:	ee f0 ff e4 	ld.w	r0,r7[-28]
80005934:	ef 40 ff fc 	st.w	r7[-4],r0
80005938:	e3 cd 00 ff 	ldm	sp++,r0-r7
8000593c:	2f ad       	sub	sp,-24
8000593e:	d6 13       	rets
80005940:	80 00       	ld.sh	r0,r0[0x0]
80005942:	58 48       	cp.w	r8,4
80005944:	80 00       	ld.sh	r0,r0[0x0]
80005946:	5a 08       	cp.w	r8,-32

80005948 <prvClearCcInt>:
		Set_system_register(AVR32_COUNT, 0);
	}

	__attribute__((__noinline__)) static void prvClearCcInt(void)
	{
		Set_system_register(AVR32_COMPARE, Get_system_register(AVR32_COMPARE));
80005948:	e1 b8 00 43 	mfsr	r8,0x10c
8000594c:	e3 b8 00 43 	mtsr	0x10c,r8
	}
80005950:	5e fc       	retal	r12
80005952:	d7 03       	nop

80005954 <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

__attribute__((__noinline__)) void vPortExitCritical( void )
{
	if(ulCriticalNesting > portNO_CRITICAL_NESTING)
80005954:	48 78       	lddpc	r8,80005970 <vPortExitCritical+0x1c>
80005956:	70 08       	ld.w	r8,r8[0x0]
80005958:	58 08       	cp.w	r8,0
8000595a:	5e 0c       	reteq	r12
	{
		ulCriticalNesting--;
8000595c:	48 58       	lddpc	r8,80005970 <vPortExitCritical+0x1c>
8000595e:	70 09       	ld.w	r9,r8[0x0]
80005960:	20 19       	sub	r9,1
80005962:	91 09       	st.w	r8[0x0],r9
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
80005964:	70 08       	ld.w	r8,r8[0x0]
80005966:	58 08       	cp.w	r8,0
80005968:	5e 1c       	retne	r12
		{
			/* Enable all interrupt/exception. */
			portENABLE_INTERRUPTS();
8000596a:	d5 03       	csrf	0x10
8000596c:	5e fc       	retal	r12
8000596e:	00 00       	add	r0,r0
80005970:	00 00       	add	r0,r0
80005972:	01 dc       	ld.ub	r12,r0[0x5]

80005974 <vTick>:
/* The preemptive scheduler is defined as "naked" as the full context is saved
on entry as part of the context switch. */
__attribute__((__naked__)) static void vTick( void )
{
	/* Save the context of the interrupted task. */
	portSAVE_CONTEXT_OS_INT();
80005974:	eb cd 00 ff 	pushm	r0-r7
80005978:	e0 68 01 dc 	mov	r8,476
8000597c:	ea 18 00 00 	orh	r8,0x0
80005980:	70 00       	ld.w	r0,r8[0x0]
80005982:	1a d0       	st.w	--sp,r0
80005984:	7a 90       	ld.w	r0,sp[0x24]
80005986:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
8000598a:	58 10       	cp.w	r0,1
8000598c:	e0 8b 00 08 	brhi	8000599c <LABEL_INT_SKIP_SAVE_CONTEXT_234>
80005990:	e0 68 cd 04 	mov	r8,52484
80005994:	ea 18 00 00 	orh	r8,0x0
80005998:	70 00       	ld.w	r0,r8[0x0]
8000599a:	81 0d       	st.w	r0[0x0],sp

8000599c <LABEL_INT_SKIP_SAVE_CONTEXT_234>:
	#if( configTICK_USE_TC==1 )
		/* Clear the interrupt flag. */
		prvClearTcInt();
	#else
		/* Clear the interrupt flag. */
		prvClearCcInt();
8000599c:	f0 1f 00 12 	mcall	800059e4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x14>
	#endif

	/* Because FreeRTOS is not supposed to run with nested interrupts, put all OS
	calls in a critical section . */
	portENTER_CRITICAL();
800059a0:	f0 1f 00 12 	mcall	800059e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
		vTaskIncrementTick();
800059a4:	f0 1f 00 12 	mcall	800059ec <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x1c>
	portEXIT_CRITICAL();
800059a8:	f0 1f 00 12 	mcall	800059f0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>

	/* Restore the context of the "elected task". */
	portRESTORE_CONTEXT_OS_INT();
800059ac:	7a 90       	ld.w	r0,sp[0x24]
800059ae:	e1 d0 c2 c3 	bfextu	r0,r0,0x16,0x3
800059b2:	58 10       	cp.w	r0,1
800059b4:	e0 8b 00 0e 	brhi	800059d0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>
800059b8:	f0 1f 00 0c 	mcall	800059e8 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x18>
800059bc:	f0 1f 00 0e 	mcall	800059f4 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x24>
800059c0:	f0 1f 00 0c 	mcall	800059f0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251+0x20>
800059c4:	e0 68 cd 04 	mov	r8,52484
800059c8:	ea 18 00 00 	orh	r8,0x0
800059cc:	70 00       	ld.w	r0,r8[0x0]
800059ce:	60 0d       	ld.w	sp,r0[0x0]

800059d0 <LABEL_INT_SKIP_RESTORE_CONTEXT_251>:
800059d0:	1b 00       	ld.w	r0,sp++
800059d2:	e0 68 01 dc 	mov	r8,476
800059d6:	ea 18 00 00 	orh	r8,0x0
800059da:	91 00       	st.w	r8[0x0],r0
800059dc:	e3 cd 00 ff 	ldm	sp++,r0-r7
800059e0:	d6 03       	rete
800059e2:	00 00       	add	r0,r0
800059e4:	80 00       	ld.sh	r0,r0[0x0]
800059e6:	59 48       	cp.w	r8,20
800059e8:	80 00       	ld.sh	r0,r0[0x0]
800059ea:	58 48       	cp.w	r8,4
800059ec:	80 00       	ld.sh	r0,r0[0x0]
800059ee:	5b bc       	cp.w	r12,-5
800059f0:	80 00       	ld.sh	r0,r0[0x0]
800059f2:	59 54       	cp.w	r4,21
800059f4:	80 00       	ld.sh	r0,r0[0x0]
800059f6:	5a 08       	cp.w	r8,-32

800059f8 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
800059f8:	48 38       	lddpc	r8,80005a04 <vTaskSuspendAll+0xc>
800059fa:	70 09       	ld.w	r9,r8[0x0]
800059fc:	2f f9       	sub	r9,-1
800059fe:	91 09       	st.w	r8[0x0],r9
}
80005a00:	5e fc       	retal	r12
80005a02:	00 00       	add	r0,r0
80005a04:	00 00       	add	r0,r0
80005a06:	cd 34       	brge	800059ac <LABEL_INT_SKIP_SAVE_CONTEXT_234+0x10>

80005a08 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
80005a08:	49 a8       	lddpc	r8,80005a70 <vTaskSwitchContext+0x68>
80005a0a:	70 08       	ld.w	r8,r8[0x0]
80005a0c:	58 08       	cp.w	r8,0
80005a0e:	c0 b1       	brne	80005a24 <vTaskSwitchContext+0x1c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005a10:	49 98       	lddpc	r8,80005a74 <vTaskSwitchContext+0x6c>
80005a12:	70 08       	ld.w	r8,r8[0x0]
80005a14:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005a18:	49 89       	lddpc	r9,80005a78 <vTaskSwitchContext+0x70>
80005a1a:	f2 08 03 28 	ld.w	r8,r9[r8<<0x2]
80005a1e:	58 08       	cp.w	r8,0
80005a20:	c0 60       	breq	80005a2c <vTaskSwitchContext+0x24>
80005a22:	c1 18       	rjmp	80005a44 <vTaskSwitchContext+0x3c>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
80005a24:	30 19       	mov	r9,1
80005a26:	49 68       	lddpc	r8,80005a7c <vTaskSwitchContext+0x74>
80005a28:	91 09       	st.w	r8[0x0],r9
80005a2a:	5e fc       	retal	r12

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005a2c:	49 28       	lddpc	r8,80005a74 <vTaskSwitchContext+0x6c>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005a2e:	49 3a       	lddpc	r10,80005a78 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
80005a30:	70 09       	ld.w	r9,r8[0x0]
80005a32:	20 19       	sub	r9,1
80005a34:	91 09       	st.w	r8[0x0],r9

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
80005a36:	70 09       	ld.w	r9,r8[0x0]
80005a38:	f2 09 00 29 	add	r9,r9,r9<<0x2
80005a3c:	f4 09 03 29 	ld.w	r9,r10[r9<<0x2]
80005a40:	58 09       	cp.w	r9,0
80005a42:	cf 70       	breq	80005a30 <vTaskSwitchContext+0x28>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
80005a44:	48 c8       	lddpc	r8,80005a74 <vTaskSwitchContext+0x6c>
80005a46:	70 08       	ld.w	r8,r8[0x0]
80005a48:	f0 08 00 28 	add	r8,r8,r8<<0x2
80005a4c:	48 b9       	lddpc	r9,80005a78 <vTaskSwitchContext+0x70>
80005a4e:	f2 08 00 28 	add	r8,r9,r8<<0x2
80005a52:	70 19       	ld.w	r9,r8[0x4]
80005a54:	72 19       	ld.w	r9,r9[0x4]
80005a56:	91 19       	st.w	r8[0x4],r9
80005a58:	f0 ca ff f8 	sub	r10,r8,-8
80005a5c:	14 39       	cp.w	r9,r10
80005a5e:	f3 f9 00 01 	ld.weq	r9,r9[0x4]
80005a62:	f1 f9 0a 01 	st.weq	r8[0x4],r9
80005a66:	70 18       	ld.w	r8,r8[0x4]
80005a68:	70 39       	ld.w	r9,r8[0xc]
80005a6a:	48 68       	lddpc	r8,80005a80 <vTaskSwitchContext+0x78>
80005a6c:	91 09       	st.w	r8[0x0],r9
80005a6e:	5e fc       	retal	r12
80005a70:	00 00       	add	r0,r0
80005a72:	cd 34       	brge	80005a18 <vTaskSwitchContext+0x10>
80005a74:	00 00       	add	r0,r0
80005a76:	cd 6c       	rcall	80005c22 <vTaskIncrementTick+0x66>
80005a78:	00 00       	add	r0,r0
80005a7a:	cc 50       	breq	80005a04 <vTaskSuspendAll+0xc>
80005a7c:	00 00       	add	r0,r0
80005a7e:	cd 54       	brge	80005a28 <vTaskSwitchContext+0x20>
80005a80:	00 00       	add	r0,r0
80005a82:	cd 04       	brge	80005a22 <vTaskSwitchContext+0x1a>

80005a84 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80005a84:	48 48       	lddpc	r8,80005a94 <vTaskSetTimeOutState+0x10>
80005a86:	70 08       	ld.w	r8,r8[0x0]
80005a88:	99 08       	st.w	r12[0x0],r8
	pxTimeOut->xTimeOnEntering = xTickCount;
80005a8a:	48 48       	lddpc	r8,80005a98 <vTaskSetTimeOutState+0x14>
80005a8c:	70 08       	ld.w	r8,r8[0x0]
80005a8e:	99 18       	st.w	r12[0x4],r8
}
80005a90:	5e fc       	retal	r12
80005a92:	00 00       	add	r0,r0
80005a94:	00 00       	add	r0,r0
80005a96:	cc 48       	rjmp	80005c1e <vTaskIncrementTick+0x62>
80005a98:	00 00       	add	r0,r0
80005a9a:	cd 30       	breq	80005a40 <vTaskSwitchContext+0x38>

80005a9c <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
80005a9c:	30 19       	mov	r9,1
80005a9e:	48 28       	lddpc	r8,80005aa4 <vTaskMissedYield+0x8>
80005aa0:	91 09       	st.w	r8[0x0],r9
}
80005aa2:	5e fc       	retal	r12
80005aa4:	00 00       	add	r0,r0
80005aa6:	cd 54       	brge	80005a50 <vTaskSwitchContext+0x48>

80005aa8 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
80005aa8:	eb cd 40 c0 	pushm	r6-r7,lr
80005aac:	18 97       	mov	r7,r12
80005aae:	16 96       	mov	r6,r11
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
80005ab0:	f0 1f 00 15 	mcall	80005b04 <xTaskCheckForTimeOut+0x5c>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
80005ab4:	6c 08       	ld.w	r8,r6[0x0]
80005ab6:	5b f8       	cp.w	r8,-1
80005ab8:	c0 31       	brne	80005abe <xTaskCheckForTimeOut+0x16>
80005aba:	30 07       	mov	r7,0
80005abc:	c1 f8       	rjmp	80005afa <xTaskCheckForTimeOut+0x52>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
80005abe:	49 39       	lddpc	r9,80005b08 <xTaskCheckForTimeOut+0x60>
80005ac0:	72 09       	ld.w	r9,r9[0x0]
80005ac2:	6e 0a       	ld.w	r10,r7[0x0]
80005ac4:	12 3a       	cp.w	r10,r9
80005ac6:	c0 70       	breq	80005ad4 <xTaskCheckForTimeOut+0x2c>
80005ac8:	49 19       	lddpc	r9,80005b0c <xTaskCheckForTimeOut+0x64>
80005aca:	72 09       	ld.w	r9,r9[0x0]
80005acc:	6e 1a       	ld.w	r10,r7[0x4]
80005ace:	12 3a       	cp.w	r10,r9
80005ad0:	e0 88 00 14 	brls	80005af8 <xTaskCheckForTimeOut+0x50>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
80005ad4:	48 e9       	lddpc	r9,80005b0c <xTaskCheckForTimeOut+0x64>
80005ad6:	72 0a       	ld.w	r10,r9[0x0]
80005ad8:	6e 19       	ld.w	r9,r7[0x4]
80005ada:	12 1a       	sub	r10,r9
80005adc:	14 38       	cp.w	r8,r10
80005ade:	e0 88 00 0d 	brls	80005af8 <xTaskCheckForTimeOut+0x50>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
80005ae2:	48 ba       	lddpc	r10,80005b0c <xTaskCheckForTimeOut+0x64>
80005ae4:	74 0a       	ld.w	r10,r10[0x0]
80005ae6:	14 19       	sub	r9,r10
80005ae8:	f2 08 00 08 	add	r8,r9,r8
80005aec:	8d 08       	st.w	r6[0x0],r8
			vTaskSetTimeOutState( pxTimeOut );
80005aee:	0e 9c       	mov	r12,r7
80005af0:	f0 1f 00 08 	mcall	80005b10 <xTaskCheckForTimeOut+0x68>
80005af4:	30 07       	mov	r7,0
80005af6:	c0 28       	rjmp	80005afa <xTaskCheckForTimeOut+0x52>
80005af8:	30 17       	mov	r7,1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
80005afa:	f0 1f 00 07 	mcall	80005b14 <xTaskCheckForTimeOut+0x6c>

	return xReturn;
}
80005afe:	0e 9c       	mov	r12,r7
80005b00:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b04:	80 00       	ld.sh	r0,r0[0x0]
80005b06:	58 48       	cp.w	r8,4
80005b08:	00 00       	add	r0,r0
80005b0a:	cc 48       	rjmp	80005c92 <vTaskIncrementTick+0xd6>
80005b0c:	00 00       	add	r0,r0
80005b0e:	cd 30       	breq	80005ab4 <xTaskCheckForTimeOut+0xc>
80005b10:	80 00       	ld.sh	r0,r0[0x0]
80005b12:	5a 84       	cp.w	r4,-24
80005b14:	80 00       	ld.sh	r0,r0[0x0]
80005b16:	59 54       	cp.w	r4,21

80005b18 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
80005b18:	eb cd 40 80 	pushm	r7,lr
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
80005b1c:	f0 1f 00 05 	mcall	80005b30 <xTaskGetTickCount+0x18>
	{
		xTicks = xTickCount;
80005b20:	48 58       	lddpc	r8,80005b34 <xTaskGetTickCount+0x1c>
80005b22:	70 07       	ld.w	r7,r8[0x0]
	}
	taskEXIT_CRITICAL();
80005b24:	f0 1f 00 05 	mcall	80005b38 <xTaskGetTickCount+0x20>

	return xTicks;
}
80005b28:	0e 9c       	mov	r12,r7
80005b2a:	e3 cd 80 80 	ldm	sp++,r7,pc
80005b2e:	00 00       	add	r0,r0
80005b30:	80 00       	ld.sh	r0,r0[0x0]
80005b32:	58 48       	cp.w	r8,4
80005b34:	00 00       	add	r0,r0
80005b36:	cd 30       	breq	80005adc <xTaskCheckForTimeOut+0x34>
80005b38:	80 00       	ld.sh	r0,r0[0x0]
80005b3a:	59 54       	cp.w	r4,21

80005b3c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
80005b3c:	eb cd 40 c0 	pushm	r6-r7,lr
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80005b40:	78 38       	ld.w	r8,r12[0xc]
80005b42:	70 37       	ld.w	r7,r8[0xc]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
80005b44:	ee c6 ff e8 	sub	r6,r7,-24
80005b48:	0c 9c       	mov	r12,r6
80005b4a:	f0 1f 00 16 	mcall	80005ba0 <xTaskRemoveFromEventList+0x64>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005b4e:	49 68       	lddpc	r8,80005ba4 <xTaskRemoveFromEventList+0x68>
80005b50:	70 08       	ld.w	r8,r8[0x0]
80005b52:	58 08       	cp.w	r8,0
80005b54:	c1 71       	brne	80005b82 <xTaskRemoveFromEventList+0x46>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
80005b56:	ee c6 ff fc 	sub	r6,r7,-4
80005b5a:	0c 9c       	mov	r12,r6
80005b5c:	f0 1f 00 11 	mcall	80005ba0 <xTaskRemoveFromEventList+0x64>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
80005b60:	6e bc       	ld.w	r12,r7[0x2c]
80005b62:	49 28       	lddpc	r8,80005ba8 <xTaskRemoveFromEventList+0x6c>
80005b64:	70 08       	ld.w	r8,r8[0x0]
80005b66:	10 3c       	cp.w	r12,r8
80005b68:	e0 88 00 04 	brls	80005b70 <xTaskRemoveFromEventList+0x34>
80005b6c:	48 f8       	lddpc	r8,80005ba8 <xTaskRemoveFromEventList+0x6c>
80005b6e:	91 0c       	st.w	r8[0x0],r12
80005b70:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005b74:	0c 9b       	mov	r11,r6
80005b76:	48 e8       	lddpc	r8,80005bac <xTaskRemoveFromEventList+0x70>
80005b78:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
80005b7c:	f0 1f 00 0d 	mcall	80005bb0 <xTaskRemoveFromEventList+0x74>
80005b80:	c0 58       	rjmp	80005b8a <xTaskRemoveFromEventList+0x4e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80005b82:	0c 9b       	mov	r11,r6
80005b84:	48 cc       	lddpc	r12,80005bb4 <xTaskRemoveFromEventList+0x78>
80005b86:	f0 1f 00 0b 	mcall	80005bb0 <xTaskRemoveFromEventList+0x74>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005b8a:	48 c8       	lddpc	r8,80005bb8 <xTaskRemoveFromEventList+0x7c>
80005b8c:	70 08       	ld.w	r8,r8[0x0]
80005b8e:	6e bc       	ld.w	r12,r7[0x2c]
80005b90:	70 b8       	ld.w	r8,r8[0x2c]
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80005b92:	10 3c       	cp.w	r12,r8
80005b94:	f9 bc 02 01 	movhs	r12,1
80005b98:	f9 bc 03 00 	movlo	r12,0
80005b9c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ba0:	80 00       	ld.sh	r0,r0[0x0]
80005ba2:	57 8e       	stdsp	sp[0x1e0],lr
80005ba4:	00 00       	add	r0,r0
80005ba6:	cd 34       	brge	80005b4c <xTaskRemoveFromEventList+0x10>
80005ba8:	00 00       	add	r0,r0
80005baa:	cd 6c       	rcall	80005d56 <xTaskResumeAll+0x86>
80005bac:	00 00       	add	r0,r0
80005bae:	cc 50       	breq	80005b38 <xTaskGetTickCount+0x20>
80005bb0:	80 00       	ld.sh	r0,r0[0x0]
80005bb2:	57 3e       	stdsp	sp[0x1cc],lr
80005bb4:	00 00       	add	r0,r0
80005bb6:	cd 08       	rjmp	80005d56 <xTaskResumeAll+0x86>
80005bb8:	00 00       	add	r0,r0
80005bba:	cd 04       	brge	80005b5a <xTaskRemoveFromEventList+0x1e>

80005bbc <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
80005bbc:	eb cd 40 fc 	pushm	r2-r7,lr
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005bc0:	4b 98       	lddpc	r8,80005ca4 <vTaskIncrementTick+0xe8>
80005bc2:	70 08       	ld.w	r8,r8[0x0]
80005bc4:	58 08       	cp.w	r8,0
80005bc6:	c6 91       	brne	80005c98 <vTaskIncrementTick+0xdc>
	{
		++xTickCount;
80005bc8:	4b 88       	lddpc	r8,80005ca8 <vTaskIncrementTick+0xec>
80005bca:	70 09       	ld.w	r9,r8[0x0]
80005bcc:	2f f9       	sub	r9,-1
80005bce:	91 09       	st.w	r8[0x0],r9
		if( xTickCount == ( portTickType ) 0 )
80005bd0:	70 08       	ld.w	r8,r8[0x0]
80005bd2:	58 08       	cp.w	r8,0
80005bd4:	c1 a1       	brne	80005c08 <vTaskIncrementTick+0x4c>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
80005bd6:	4b 68       	lddpc	r8,80005cac <vTaskIncrementTick+0xf0>
80005bd8:	70 0a       	ld.w	r10,r8[0x0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
80005bda:	4b 69       	lddpc	r9,80005cb0 <vTaskIncrementTick+0xf4>
80005bdc:	72 0b       	ld.w	r11,r9[0x0]
80005bde:	91 0b       	st.w	r8[0x0],r11
			pxOverflowDelayedTaskList = pxTemp;
80005be0:	93 0a       	st.w	r9[0x0],r10
			xNumOfOverflows++;
80005be2:	4b 59       	lddpc	r9,80005cb4 <vTaskIncrementTick+0xf8>
80005be4:	72 0a       	ld.w	r10,r9[0x0]
80005be6:	2f fa       	sub	r10,-1
80005be8:	93 0a       	st.w	r9[0x0],r10

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80005bea:	70 08       	ld.w	r8,r8[0x0]
80005bec:	70 08       	ld.w	r8,r8[0x0]
80005bee:	58 08       	cp.w	r8,0
80005bf0:	c0 51       	brne	80005bfa <vTaskIncrementTick+0x3e>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
80005bf2:	3f f9       	mov	r9,-1
80005bf4:	4b 18       	lddpc	r8,80005cb8 <vTaskIncrementTick+0xfc>
80005bf6:	91 09       	st.w	r8[0x0],r9
80005bf8:	c0 88       	rjmp	80005c08 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80005bfa:	4a d8       	lddpc	r8,80005cac <vTaskIncrementTick+0xf0>
80005bfc:	70 08       	ld.w	r8,r8[0x0]
80005bfe:	70 38       	ld.w	r8,r8[0xc]
80005c00:	70 38       	ld.w	r8,r8[0xc]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
80005c02:	70 19       	ld.w	r9,r8[0x4]
80005c04:	4a d8       	lddpc	r8,80005cb8 <vTaskIncrementTick+0xfc>
80005c06:	91 09       	st.w	r8[0x0],r9
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
80005c08:	4a 88       	lddpc	r8,80005ca8 <vTaskIncrementTick+0xec>
80005c0a:	70 09       	ld.w	r9,r8[0x0]
80005c0c:	4a b8       	lddpc	r8,80005cb8 <vTaskIncrementTick+0xfc>
80005c0e:	70 08       	ld.w	r8,r8[0x0]
80005c10:	10 39       	cp.w	r9,r8
80005c12:	c4 73       	brcs	80005ca0 <vTaskIncrementTick+0xe4>
80005c14:	4a 68       	lddpc	r8,80005cac <vTaskIncrementTick+0xf0>
80005c16:	70 08       	ld.w	r8,r8[0x0]
80005c18:	70 08       	ld.w	r8,r8[0x0]
80005c1a:	58 08       	cp.w	r8,0
80005c1c:	c0 c0       	breq	80005c34 <vTaskIncrementTick+0x78>
80005c1e:	4a 48       	lddpc	r8,80005cac <vTaskIncrementTick+0xf0>
80005c20:	70 08       	ld.w	r8,r8[0x0]
80005c22:	70 38       	ld.w	r8,r8[0xc]
80005c24:	70 37       	ld.w	r7,r8[0xc]
80005c26:	6e 18       	ld.w	r8,r7[0x4]
80005c28:	4a 09       	lddpc	r9,80005ca8 <vTaskIncrementTick+0xec>
80005c2a:	72 09       	ld.w	r9,r9[0x0]
80005c2c:	12 38       	cp.w	r8,r9
80005c2e:	e0 88 00 14 	brls	80005c56 <vTaskIncrementTick+0x9a>
80005c32:	c0 e8       	rjmp	80005c4e <vTaskIncrementTick+0x92>
80005c34:	3f f9       	mov	r9,-1
80005c36:	4a 18       	lddpc	r8,80005cb8 <vTaskIncrementTick+0xfc>
80005c38:	91 09       	st.w	r8[0x0],r9
80005c3a:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005c3e:	6a 08       	ld.w	r8,r5[0x0]
80005c40:	70 38       	ld.w	r8,r8[0xc]
80005c42:	70 37       	ld.w	r7,r8[0xc]
80005c44:	6e 18       	ld.w	r8,r7[0x4]
80005c46:	64 09       	ld.w	r9,r2[0x0]
80005c48:	12 38       	cp.w	r8,r9
80005c4a:	e0 88 00 0a 	brls	80005c5e <vTaskIncrementTick+0xa2>
80005c4e:	49 b9       	lddpc	r9,80005cb8 <vTaskIncrementTick+0xfc>
80005c50:	93 08       	st.w	r9[0x0],r8
80005c52:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005c56:	49 a4       	lddpc	r4,80005cbc <vTaskIncrementTick+0x100>
80005c58:	49 a3       	lddpc	r3,80005cc0 <vTaskIncrementTick+0x104>
80005c5a:	49 55       	lddpc	r5,80005cac <vTaskIncrementTick+0xf0>
80005c5c:	49 32       	lddpc	r2,80005ca8 <vTaskIncrementTick+0xec>
80005c5e:	ee c6 ff fc 	sub	r6,r7,-4
80005c62:	0c 9c       	mov	r12,r6
80005c64:	f0 1f 00 18 	mcall	80005cc4 <vTaskIncrementTick+0x108>
80005c68:	6e a8       	ld.w	r8,r7[0x28]
80005c6a:	58 08       	cp.w	r8,0
80005c6c:	c0 50       	breq	80005c76 <vTaskIncrementTick+0xba>
80005c6e:	ee cc ff e8 	sub	r12,r7,-24
80005c72:	f0 1f 00 15 	mcall	80005cc4 <vTaskIncrementTick+0x108>
80005c76:	6e bc       	ld.w	r12,r7[0x2c]
80005c78:	68 08       	ld.w	r8,r4[0x0]
80005c7a:	10 3c       	cp.w	r12,r8
80005c7c:	e9 fc ba 00 	st.whi	r4[0x0],r12
80005c80:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005c84:	0c 9b       	mov	r11,r6
80005c86:	e6 0c 00 2c 	add	r12,r3,r12<<0x2
80005c8a:	f0 1f 00 10 	mcall	80005cc8 <vTaskIncrementTick+0x10c>
80005c8e:	6a 08       	ld.w	r8,r5[0x0]
80005c90:	70 08       	ld.w	r8,r8[0x0]
80005c92:	58 08       	cp.w	r8,0
80005c94:	cd 51       	brne	80005c3e <vTaskIncrementTick+0x82>
80005c96:	cc fb       	rjmp	80005c34 <vTaskIncrementTick+0x78>
	}
	else
	{
		++uxMissedTicks;
80005c98:	48 d8       	lddpc	r8,80005ccc <vTaskIncrementTick+0x110>
80005c9a:	70 09       	ld.w	r9,r8[0x0]
80005c9c:	2f f9       	sub	r9,-1
80005c9e:	91 09       	st.w	r8[0x0],r9
80005ca0:	e3 cd 80 fc 	ldm	sp++,r2-r7,pc
80005ca4:	00 00       	add	r0,r0
80005ca6:	cd 34       	brge	80005c4c <vTaskIncrementTick+0x90>
80005ca8:	00 00       	add	r0,r0
80005caa:	cd 30       	breq	80005c50 <vTaskIncrementTick+0x94>
80005cac:	00 00       	add	r0,r0
80005cae:	cc 3c       	rcall	80005e34 <vTaskDelayUntil+0x20>
80005cb0:	00 00       	add	r0,r0
80005cb2:	cc 4c       	rcall	80005e3a <vTaskDelayUntil+0x26>
80005cb4:	00 00       	add	r0,r0
80005cb6:	cc 48       	rjmp	80005e3e <vTaskDelayUntil+0x2a>
80005cb8:	00 00       	add	r0,r0
80005cba:	01 e0       	ld.ub	r0,r0[0x6]
80005cbc:	00 00       	add	r0,r0
80005cbe:	cd 6c       	rcall	80005e6a <vTaskDelayUntil+0x56>
80005cc0:	00 00       	add	r0,r0
80005cc2:	cc 50       	breq	80005c4c <vTaskIncrementTick+0x90>
80005cc4:	80 00       	ld.sh	r0,r0[0x0]
80005cc6:	57 8e       	stdsp	sp[0x1e0],lr
80005cc8:	80 00       	ld.sh	r0,r0[0x0]
80005cca:	57 3e       	stdsp	sp[0x1cc],lr
80005ccc:	00 00       	add	r0,r0
80005cce:	cc 34       	brge	80005c54 <vTaskIncrementTick+0x98>

80005cd0 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
80005cd0:	eb cd 40 fe 	pushm	r1-r7,lr
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
80005cd4:	f0 1f 00 2c 	mcall	80005d84 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;
80005cd8:	4a c8       	lddpc	r8,80005d88 <xTaskResumeAll+0xb8>
80005cda:	70 09       	ld.w	r9,r8[0x0]
80005cdc:	20 19       	sub	r9,1
80005cde:	91 09       	st.w	r8[0x0],r9

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
80005ce0:	70 08       	ld.w	r8,r8[0x0]
80005ce2:	58 08       	cp.w	r8,0
80005ce4:	c4 91       	brne	80005d76 <xTaskResumeAll+0xa6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
80005ce6:	4a a8       	lddpc	r8,80005d8c <xTaskResumeAll+0xbc>
80005ce8:	70 08       	ld.w	r8,r8[0x0]
80005cea:	58 08       	cp.w	r8,0
80005cec:	c4 50       	breq	80005d76 <xTaskResumeAll+0xa6>
80005cee:	30 04       	mov	r4,0
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005cf0:	4a 85       	lddpc	r5,80005d90 <xTaskResumeAll+0xc0>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
80005cf2:	4a 93       	lddpc	r3,80005d94 <xTaskResumeAll+0xc4>
80005cf4:	4a 92       	lddpc	r2,80005d98 <xTaskResumeAll+0xc8>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005cf6:	4a a1       	lddpc	r1,80005d9c <xTaskResumeAll+0xcc>
80005cf8:	c1 e8       	rjmp	80005d34 <xTaskResumeAll+0x64>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
80005cfa:	6a 38       	ld.w	r8,r5[0xc]
80005cfc:	70 37       	ld.w	r7,r8[0xc]
					vListRemove( &( pxTCB->xEventListItem ) );
80005cfe:	ee cc ff e8 	sub	r12,r7,-24
80005d02:	f0 1f 00 28 	mcall	80005da0 <xTaskResumeAll+0xd0>
					vListRemove( &( pxTCB->xGenericListItem ) );
80005d06:	ee c6 ff fc 	sub	r6,r7,-4
80005d0a:	0c 9c       	mov	r12,r6
80005d0c:	f0 1f 00 25 	mcall	80005da0 <xTaskResumeAll+0xd0>
					prvAddTaskToReadyQueue( pxTCB );
80005d10:	6e bc       	ld.w	r12,r7[0x2c]
80005d12:	66 08       	ld.w	r8,r3[0x0]
80005d14:	10 3c       	cp.w	r12,r8
80005d16:	e7 fc ba 00 	st.whi	r3[0x0],r12
80005d1a:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
80005d1e:	0c 9b       	mov	r11,r6
80005d20:	e4 0c 00 2c 	add	r12,r2,r12<<0x2
80005d24:	f0 1f 00 20 	mcall	80005da4 <xTaskResumeAll+0xd4>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80005d28:	62 08       	ld.w	r8,r1[0x0]
80005d2a:	6e b9       	ld.w	r9,r7[0x2c]
80005d2c:	70 b8       	ld.w	r8,r8[0x2c]
80005d2e:	10 39       	cp.w	r9,r8
80005d30:	f9 b4 02 01 	movhs	r4,1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
80005d34:	6a 08       	ld.w	r8,r5[0x0]
80005d36:	58 08       	cp.w	r8,0
80005d38:	ce 11       	brne	80005cfa <xTaskResumeAll+0x2a>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005d3a:	49 c8       	lddpc	r8,80005da8 <xTaskResumeAll+0xd8>
80005d3c:	70 08       	ld.w	r8,r8[0x0]
80005d3e:	58 08       	cp.w	r8,0
80005d40:	c0 f0       	breq	80005d5e <xTaskResumeAll+0x8e>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005d42:	49 a8       	lddpc	r8,80005da8 <xTaskResumeAll+0xd8>
80005d44:	70 08       	ld.w	r8,r8[0x0]
80005d46:	58 08       	cp.w	r8,0
80005d48:	c1 10       	breq	80005d6a <xTaskResumeAll+0x9a>
					{
						vTaskIncrementTick();
						--uxMissedTicks;
80005d4a:	49 87       	lddpc	r7,80005da8 <xTaskResumeAll+0xd8>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
80005d4c:	f0 1f 00 18 	mcall	80005dac <xTaskResumeAll+0xdc>
						--uxMissedTicks;
80005d50:	6e 08       	ld.w	r8,r7[0x0]
80005d52:	20 18       	sub	r8,1
80005d54:	8f 08       	st.w	r7[0x0],r8
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
80005d56:	6e 08       	ld.w	r8,r7[0x0]
80005d58:	58 08       	cp.w	r8,0
80005d5a:	cf 91       	brne	80005d4c <xTaskResumeAll+0x7c>
80005d5c:	c0 78       	rjmp	80005d6a <xTaskResumeAll+0x9a>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
80005d5e:	58 14       	cp.w	r4,1
80005d60:	c0 50       	breq	80005d6a <xTaskResumeAll+0x9a>
80005d62:	49 48       	lddpc	r8,80005db0 <xTaskResumeAll+0xe0>
80005d64:	70 08       	ld.w	r8,r8[0x0]
80005d66:	58 18       	cp.w	r8,1
80005d68:	c0 71       	brne	80005d76 <xTaskResumeAll+0xa6>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
80005d6a:	30 09       	mov	r9,0
80005d6c:	49 18       	lddpc	r8,80005db0 <xTaskResumeAll+0xe0>
80005d6e:	91 09       	st.w	r8[0x0],r9
					portYIELD_WITHIN_API();
80005d70:	d7 33       	scall
80005d72:	30 17       	mov	r7,1
80005d74:	c0 28       	rjmp	80005d78 <xTaskResumeAll+0xa8>
80005d76:	30 07       	mov	r7,0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
80005d78:	f0 1f 00 0f 	mcall	80005db4 <xTaskResumeAll+0xe4>

	return xAlreadyYielded;
}
80005d7c:	0e 9c       	mov	r12,r7
80005d7e:	e3 cd 80 fe 	ldm	sp++,r1-r7,pc
80005d82:	00 00       	add	r0,r0
80005d84:	80 00       	ld.sh	r0,r0[0x0]
80005d86:	58 48       	cp.w	r8,4
80005d88:	00 00       	add	r0,r0
80005d8a:	cd 34       	brge	80005d30 <xTaskResumeAll+0x60>
80005d8c:	00 00       	add	r0,r0
80005d8e:	cd 50       	breq	80005d38 <xTaskResumeAll+0x68>
80005d90:	00 00       	add	r0,r0
80005d92:	cd 08       	rjmp	80005f32 <prvIdleTask+0x46>
80005d94:	00 00       	add	r0,r0
80005d96:	cd 6c       	rcall	80005f42 <prvIdleTask+0x56>
80005d98:	00 00       	add	r0,r0
80005d9a:	cc 50       	breq	80005d24 <xTaskResumeAll+0x54>
80005d9c:	00 00       	add	r0,r0
80005d9e:	cd 04       	brge	80005d3e <xTaskResumeAll+0x6e>
80005da0:	80 00       	ld.sh	r0,r0[0x0]
80005da2:	57 8e       	stdsp	sp[0x1e0],lr
80005da4:	80 00       	ld.sh	r0,r0[0x0]
80005da6:	57 3e       	stdsp	sp[0x1cc],lr
80005da8:	00 00       	add	r0,r0
80005daa:	cc 34       	brge	80005d30 <xTaskResumeAll+0x60>
80005dac:	80 00       	ld.sh	r0,r0[0x0]
80005dae:	5b bc       	cp.w	r12,-5
80005db0:	00 00       	add	r0,r0
80005db2:	cd 54       	brge	80005d5c <xTaskResumeAll+0x8c>
80005db4:	80 00       	ld.sh	r0,r0[0x0]
80005db6:	59 54       	cp.w	r4,21

80005db8 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
80005db8:	eb cd 40 80 	pushm	r7,lr
80005dbc:	18 97       	mov	r7,r12
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
80005dbe:	49 08       	lddpc	r8,80005dfc <prvAddCurrentTaskToDelayedList+0x44>
80005dc0:	70 08       	ld.w	r8,r8[0x0]
80005dc2:	91 1c       	st.w	r8[0x4],r12

	if( xTimeToWake < xTickCount )
80005dc4:	48 f8       	lddpc	r8,80005e00 <prvAddCurrentTaskToDelayedList+0x48>
80005dc6:	70 08       	ld.w	r8,r8[0x0]
80005dc8:	10 3c       	cp.w	r12,r8
80005dca:	c0 a2       	brcc	80005dde <prvAddCurrentTaskToDelayedList+0x26>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005dcc:	48 c8       	lddpc	r8,80005dfc <prvAddCurrentTaskToDelayedList+0x44>
80005dce:	70 0b       	ld.w	r11,r8[0x0]
80005dd0:	48 d8       	lddpc	r8,80005e04 <prvAddCurrentTaskToDelayedList+0x4c>
80005dd2:	70 0c       	ld.w	r12,r8[0x0]
80005dd4:	2f cb       	sub	r11,-4
80005dd6:	f0 1f 00 0d 	mcall	80005e08 <prvAddCurrentTaskToDelayedList+0x50>
80005dda:	e3 cd 80 80 	ldm	sp++,r7,pc
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005dde:	48 88       	lddpc	r8,80005dfc <prvAddCurrentTaskToDelayedList+0x44>
80005de0:	70 0b       	ld.w	r11,r8[0x0]
80005de2:	48 b8       	lddpc	r8,80005e0c <prvAddCurrentTaskToDelayedList+0x54>
80005de4:	70 0c       	ld.w	r12,r8[0x0]
80005de6:	2f cb       	sub	r11,-4
80005de8:	f0 1f 00 08 	mcall	80005e08 <prvAddCurrentTaskToDelayedList+0x50>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
80005dec:	48 98       	lddpc	r8,80005e10 <prvAddCurrentTaskToDelayedList+0x58>
80005dee:	70 08       	ld.w	r8,r8[0x0]
80005df0:	10 37       	cp.w	r7,r8
80005df2:	c0 32       	brcc	80005df8 <prvAddCurrentTaskToDelayedList+0x40>
		{
			xNextTaskUnblockTime = xTimeToWake;
80005df4:	48 78       	lddpc	r8,80005e10 <prvAddCurrentTaskToDelayedList+0x58>
80005df6:	91 07       	st.w	r8[0x0],r7
80005df8:	e3 cd 80 80 	ldm	sp++,r7,pc
80005dfc:	00 00       	add	r0,r0
80005dfe:	cd 04       	brge	80005d9e <xTaskResumeAll+0xce>
80005e00:	00 00       	add	r0,r0
80005e02:	cd 30       	breq	80005da8 <xTaskResumeAll+0xd8>
80005e04:	00 00       	add	r0,r0
80005e06:	cc 4c       	rcall	80005f8e <xTaskGenericCreate+0x22>
80005e08:	80 00       	ld.sh	r0,r0[0x0]
80005e0a:	57 5a       	stdsp	sp[0x1d4],r10
80005e0c:	00 00       	add	r0,r0
80005e0e:	cc 3c       	rcall	80005f94 <xTaskGenericCreate+0x28>
80005e10:	00 00       	add	r0,r0
80005e12:	01 e0       	ld.ub	r0,r0[0x6]

80005e14 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
80005e14:	eb cd 40 c0 	pushm	r6-r7,lr
80005e18:	18 96       	mov	r6,r12
80005e1a:	16 97       	mov	r7,r11
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0 ) );

		vTaskSuspendAll();
80005e1c:	f0 1f 00 18 	mcall	80005e7c <vTaskDelayUntil+0x68>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80005e20:	6c 08       	ld.w	r8,r6[0x0]
80005e22:	10 07       	add	r7,r8

			if( xTickCount < *pxPreviousWakeTime )
80005e24:	49 79       	lddpc	r9,80005e80 <vTaskDelayUntil+0x6c>
80005e26:	72 09       	ld.w	r9,r9[0x0]
80005e28:	12 38       	cp.w	r8,r9
80005e2a:	e0 88 00 0c 	brls	80005e42 <vTaskDelayUntil+0x2e>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
80005e2e:	0e 38       	cp.w	r8,r7
80005e30:	e0 88 00 22 	brls	80005e74 <vTaskDelayUntil+0x60>
80005e34:	49 38       	lddpc	r8,80005e80 <vTaskDelayUntil+0x6c>
80005e36:	70 08       	ld.w	r8,r8[0x0]
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005e38:	8d 07       	st.w	r6[0x0],r7

			if( xShouldDelay != pdFALSE )
80005e3a:	10 37       	cp.w	r7,r8
80005e3c:	e0 88 00 14 	brls	80005e64 <vTaskDelayUntil+0x50>
80005e40:	c0 a8       	rjmp	80005e54 <vTaskDelayUntil+0x40>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
80005e42:	0e 38       	cp.w	r8,r7
80005e44:	e0 8b 00 16 	brhi	80005e70 <vTaskDelayUntil+0x5c>
80005e48:	48 e8       	lddpc	r8,80005e80 <vTaskDelayUntil+0x6c>
80005e4a:	70 08       	ld.w	r8,r8[0x0]
80005e4c:	10 37       	cp.w	r7,r8
80005e4e:	e0 8b 00 11 	brhi	80005e70 <vTaskDelayUntil+0x5c>
80005e52:	c1 18       	rjmp	80005e74 <vTaskDelayUntil+0x60>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005e54:	48 c8       	lddpc	r8,80005e84 <vTaskDelayUntil+0x70>
80005e56:	70 0c       	ld.w	r12,r8[0x0]
80005e58:	2f cc       	sub	r12,-4
80005e5a:	f0 1f 00 0c 	mcall	80005e88 <vTaskDelayUntil+0x74>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
80005e5e:	0e 9c       	mov	r12,r7
80005e60:	f0 1f 00 0b 	mcall	80005e8c <vTaskDelayUntil+0x78>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80005e64:	f0 1f 00 0b 	mcall	80005e90 <vTaskDelayUntil+0x7c>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
80005e68:	c0 81       	brne	80005e78 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
80005e6a:	d7 33       	scall
80005e6c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80005e70:	8d 07       	st.w	r6[0x0],r7
80005e72:	cf 1b       	rjmp	80005e54 <vTaskDelayUntil+0x40>
80005e74:	8d 07       	st.w	r6[0x0],r7
80005e76:	cf 7b       	rjmp	80005e64 <vTaskDelayUntil+0x50>
80005e78:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005e7c:	80 00       	ld.sh	r0,r0[0x0]
80005e7e:	59 f8       	cp.w	r8,31
80005e80:	00 00       	add	r0,r0
80005e82:	cd 30       	breq	80005e28 <vTaskDelayUntil+0x14>
80005e84:	00 00       	add	r0,r0
80005e86:	cd 04       	brge	80005e26 <vTaskDelayUntil+0x12>
80005e88:	80 00       	ld.sh	r0,r0[0x0]
80005e8a:	57 8e       	stdsp	sp[0x1e0],lr
80005e8c:	80 00       	ld.sh	r0,r0[0x0]
80005e8e:	5d b8       	*unknown*
80005e90:	80 00       	ld.sh	r0,r0[0x0]
80005e92:	5c d0       	com	r0

80005e94 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
80005e94:	eb cd 40 c0 	pushm	r6-r7,lr
80005e98:	16 96       	mov	r6,r11
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
80005e9a:	48 e7       	lddpc	r7,80005ed0 <vTaskPlaceOnEventList+0x3c>
80005e9c:	6e 0b       	ld.w	r11,r7[0x0]
80005e9e:	2e 8b       	sub	r11,-24
80005ea0:	f0 1f 00 0d 	mcall	80005ed4 <vTaskPlaceOnEventList+0x40>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005ea4:	6e 0c       	ld.w	r12,r7[0x0]
80005ea6:	2f cc       	sub	r12,-4
80005ea8:	f0 1f 00 0c 	mcall	80005ed8 <vTaskPlaceOnEventList+0x44>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
80005eac:	5b f6       	cp.w	r6,-1
80005eae:	c0 81       	brne	80005ebe <vTaskPlaceOnEventList+0x2a>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
80005eb0:	6e 0b       	ld.w	r11,r7[0x0]
80005eb2:	2f cb       	sub	r11,-4
80005eb4:	48 ac       	lddpc	r12,80005edc <vTaskPlaceOnEventList+0x48>
80005eb6:	f0 1f 00 0b 	mcall	80005ee0 <vTaskPlaceOnEventList+0x4c>
80005eba:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
80005ebe:	48 a8       	lddpc	r8,80005ee4 <vTaskPlaceOnEventList+0x50>
80005ec0:	70 0c       	ld.w	r12,r8[0x0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
80005ec2:	ec 0c 00 0c 	add	r12,r6,r12
80005ec6:	f0 1f 00 09 	mcall	80005ee8 <vTaskPlaceOnEventList+0x54>
80005eca:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005ece:	00 00       	add	r0,r0
80005ed0:	00 00       	add	r0,r0
80005ed2:	cd 04       	brge	80005e72 <vTaskDelayUntil+0x5e>
80005ed4:	80 00       	ld.sh	r0,r0[0x0]
80005ed6:	57 5a       	stdsp	sp[0x1d4],r10
80005ed8:	80 00       	ld.sh	r0,r0[0x0]
80005eda:	57 8e       	stdsp	sp[0x1e0],lr
80005edc:	00 00       	add	r0,r0
80005ede:	cd 58       	rjmp	80006088 <xTaskGenericCreate+0x11c>
80005ee0:	80 00       	ld.sh	r0,r0[0x0]
80005ee2:	57 3e       	stdsp	sp[0x1cc],lr
80005ee4:	00 00       	add	r0,r0
80005ee6:	cd 30       	breq	80005e8c <vTaskDelayUntil+0x78>
80005ee8:	80 00       	ld.sh	r0,r0[0x0]
80005eea:	5d b8       	*unknown*

80005eec <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80005eec:	eb cd 40 f8 	pushm	r3-r7,lr
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005ef0:	49 57       	lddpc	r7,80005f44 <prvIdleTask+0x58>
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005ef2:	49 64       	lddpc	r4,80005f48 <prvIdleTask+0x5c>

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
					vListRemove( &( pxTCB->xGenericListItem ) );
					--uxCurrentNumberOfTasks;
80005ef4:	49 63       	lddpc	r3,80005f4c <prvIdleTask+0x60>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005ef6:	49 75       	lddpc	r5,80005f50 <prvIdleTask+0x64>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
80005ef8:	6e 08       	ld.w	r8,r7[0x0]
80005efa:	58 08       	cp.w	r8,0
80005efc:	c1 e0       	breq	80005f38 <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
80005efe:	f0 1f 00 16 	mcall	80005f54 <prvIdleTask+0x68>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80005f02:	68 06       	ld.w	r6,r4[0x0]
			xTaskResumeAll();
80005f04:	f0 1f 00 15 	mcall	80005f58 <prvIdleTask+0x6c>

			if( xListIsEmpty == pdFALSE )
80005f08:	58 06       	cp.w	r6,0
80005f0a:	c1 70       	breq	80005f38 <prvIdleTask+0x4c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
80005f0c:	f0 1f 00 14 	mcall	80005f5c <prvIdleTask+0x70>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
80005f10:	68 38       	ld.w	r8,r4[0xc]
80005f12:	70 36       	ld.w	r6,r8[0xc]
					vListRemove( &( pxTCB->xGenericListItem ) );
80005f14:	ec cc ff fc 	sub	r12,r6,-4
80005f18:	f0 1f 00 12 	mcall	80005f60 <prvIdleTask+0x74>
					--uxCurrentNumberOfTasks;
80005f1c:	66 08       	ld.w	r8,r3[0x0]
80005f1e:	20 18       	sub	r8,1
80005f20:	87 08       	st.w	r3[0x0],r8
					--uxTasksDeleted;
80005f22:	6e 08       	ld.w	r8,r7[0x0]
80005f24:	20 18       	sub	r8,1
80005f26:	8f 08       	st.w	r7[0x0],r8
				}
				taskEXIT_CRITICAL();
80005f28:	f0 1f 00 0f 	mcall	80005f64 <prvIdleTask+0x78>

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
80005f2c:	6c cc       	ld.w	r12,r6[0x30]
80005f2e:	f0 1f 00 0f 	mcall	80005f68 <prvIdleTask+0x7c>
		vPortFree( pxTCB );
80005f32:	0c 9c       	mov	r12,r6
80005f34:	f0 1f 00 0d 	mcall	80005f68 <prvIdleTask+0x7c>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
80005f38:	6a 08       	ld.w	r8,r5[0x0]
80005f3a:	58 18       	cp.w	r8,1
80005f3c:	fe 98 ff de 	brls	80005ef8 <prvIdleTask+0xc>
			{
				taskYIELD();
80005f40:	d7 33       	scall
80005f42:	cd bb       	rjmp	80005ef8 <prvIdleTask+0xc>
80005f44:	00 00       	add	r0,r0
80005f46:	cc 44       	brge	80005ece <vTaskPlaceOnEventList+0x3a>
80005f48:	00 00       	add	r0,r0
80005f4a:	cc f0       	breq	80005ee8 <vTaskPlaceOnEventList+0x54>
80005f4c:	00 00       	add	r0,r0
80005f4e:	cd 50       	breq	80005ef8 <prvIdleTask+0xc>
80005f50:	00 00       	add	r0,r0
80005f52:	cc 50       	breq	80005edc <vTaskPlaceOnEventList+0x48>
80005f54:	80 00       	ld.sh	r0,r0[0x0]
80005f56:	59 f8       	cp.w	r8,31
80005f58:	80 00       	ld.sh	r0,r0[0x0]
80005f5a:	5c d0       	com	r0
80005f5c:	80 00       	ld.sh	r0,r0[0x0]
80005f5e:	58 48       	cp.w	r8,4
80005f60:	80 00       	ld.sh	r0,r0[0x0]
80005f62:	57 8e       	stdsp	sp[0x1e0],lr
80005f64:	80 00       	ld.sh	r0,r0[0x0]
80005f66:	59 54       	cp.w	r4,21
80005f68:	80 00       	ld.sh	r0,r0[0x0]
80005f6a:	2b 5c       	sub	r12,-75

80005f6c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
80005f6c:	d4 31       	pushm	r0-r7,lr
80005f6e:	20 1d       	sub	sp,4
80005f70:	fa c4 ff d8 	sub	r4,sp,-40
80005f74:	50 0c       	stdsp	sp[0x0],r12
80005f76:	16 91       	mov	r1,r11
80005f78:	14 97       	mov	r7,r10
80005f7a:	12 90       	mov	r0,r9
80005f7c:	10 93       	mov	r3,r8
80005f7e:	68 02       	ld.w	r2,r4[0x0]
80005f80:	68 16       	ld.w	r6,r4[0x4]
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
80005f82:	34 4c       	mov	r12,68
80005f84:	f0 1f 00 5b 	mcall	800060f0 <xTaskGenericCreate+0x184>
80005f88:	18 95       	mov	r5,r12

	if( pxNewTCB != NULL )
80005f8a:	c0 31       	brne	80005f90 <xTaskGenericCreate+0x24>
80005f8c:	3f fc       	mov	r12,-1
80005f8e:	ca d8       	rjmp	800060e8 <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
80005f90:	58 06       	cp.w	r6,0
80005f92:	e0 81 00 ad 	brne	800060ec <xTaskGenericCreate+0x180>
80005f96:	0e 9c       	mov	r12,r7
80005f98:	5c 7c       	castu.h	r12
80005f9a:	a3 6c       	lsl	r12,0x2
80005f9c:	f0 1f 00 55 	mcall	800060f0 <xTaskGenericCreate+0x184>
80005fa0:	18 96       	mov	r6,r12
80005fa2:	8b cc       	st.w	r5[0x30],r12

		if( pxNewTCB->pxStack == NULL )
80005fa4:	c0 61       	brne	80005fb0 <xTaskGenericCreate+0x44>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
80005fa6:	0a 9c       	mov	r12,r5
80005fa8:	f0 1f 00 53 	mcall	800060f4 <xTaskGenericCreate+0x188>
80005fac:	3f fc       	mov	r12,-1
80005fae:	c9 d8       	rjmp	800060e8 <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
80005fb0:	5c 77       	castu.h	r7
80005fb2:	ee 0a 15 02 	lsl	r10,r7,0x2
80005fb6:	e0 6b 00 a5 	mov	r11,165
80005fba:	0c 9c       	mov	r12,r6
80005fbc:	f0 1f 00 4f 	mcall	800060f8 <xTaskGenericCreate+0x18c>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
80005fc0:	ee c6 00 01 	sub	r6,r7,1
80005fc4:	6a c8       	ld.w	r8,r5[0x30]
80005fc6:	f0 06 00 26 	add	r6,r8,r6<<0x2
80005fca:	e0 16 ff fc 	andl	r6,0xfffc
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
80005fce:	31 0a       	mov	r10,16
80005fd0:	02 9b       	mov	r11,r1
80005fd2:	ea cc ff cc 	sub	r12,r5,-52
80005fd6:	f0 1f 00 4a 	mcall	800060fc <xTaskGenericCreate+0x190>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
80005fda:	30 08       	mov	r8,0
80005fdc:	eb 68 00 43 	st.b	r5[67],r8
80005fe0:	58 73       	cp.w	r3,7
80005fe2:	e6 07 17 80 	movls	r7,r3
80005fe6:	f9 b7 0b 07 	movhi	r7,7
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
80005fea:	8b b7       	st.w	r5[0x2c],r7
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
80005fec:	ea c4 ff fc 	sub	r4,r5,-4
80005ff0:	08 9c       	mov	r12,r4
80005ff2:	f0 1f 00 44 	mcall	80006100 <xTaskGenericCreate+0x194>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
80005ff6:	ea cc ff e8 	sub	r12,r5,-24
80005ffa:	f0 1f 00 42 	mcall	80006100 <xTaskGenericCreate+0x194>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
80005ffe:	8b 45       	st.w	r5[0x10],r5

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
80006000:	ee 07 11 08 	rsub	r7,r7,8
80006004:	8b 67       	st.w	r5[0x18],r7
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
80006006:	8b 95       	st.w	r5[0x24],r5
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80006008:	00 9a       	mov	r10,r0
8000600a:	40 0b       	lddsp	r11,sp[0x0]
8000600c:	0c 9c       	mov	r12,r6
8000600e:	f0 1f 00 3e 	mcall	80006104 <xTaskGenericCreate+0x198>
80006012:	8b 0c       	st.w	r5[0x0],r12
		if( ( void * ) pxCreatedTask != NULL )
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
80006014:	58 02       	cp.w	r2,0
80006016:	e5 f5 1a 00 	st.wne	r2[0x0],r5
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
8000601a:	f0 1f 00 3c 	mcall	80006108 <xTaskGenericCreate+0x19c>
		{
			uxCurrentNumberOfTasks++;
8000601e:	4b c8       	lddpc	r8,8000610c <xTaskGenericCreate+0x1a0>
80006020:	70 09       	ld.w	r9,r8[0x0]
80006022:	2f f9       	sub	r9,-1
80006024:	91 09       	st.w	r8[0x0],r9
			if( pxCurrentTCB == NULL )
80006026:	4b b8       	lddpc	r8,80006110 <xTaskGenericCreate+0x1a4>
80006028:	70 08       	ld.w	r8,r8[0x0]
8000602a:	58 08       	cp.w	r8,0
8000602c:	c2 61       	brne	80006078 <xTaskGenericCreate+0x10c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
8000602e:	4b 98       	lddpc	r8,80006110 <xTaskGenericCreate+0x1a4>
80006030:	91 05       	st.w	r8[0x0],r5

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
80006032:	4b 78       	lddpc	r8,8000610c <xTaskGenericCreate+0x1a0>
80006034:	70 08       	ld.w	r8,r8[0x0]
80006036:	58 18       	cp.w	r8,1
80006038:	c2 b1       	brne	8000608e <xTaskGenericCreate+0x122>
8000603a:	4b 77       	lddpc	r7,80006114 <xTaskGenericCreate+0x1a8>

/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
8000603c:	ee c6 ff 60 	sub	r6,r7,-160
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
80006040:	0e 9c       	mov	r12,r7
80006042:	f0 1f 00 36 	mcall	80006118 <xTaskGenericCreate+0x1ac>
80006046:	2e c7       	sub	r7,-20

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
80006048:	0c 37       	cp.w	r7,r6
8000604a:	cf b1       	brne	80006040 <xTaskGenericCreate+0xd4>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
8000604c:	4b 47       	lddpc	r7,8000611c <xTaskGenericCreate+0x1b0>
8000604e:	0e 9c       	mov	r12,r7
80006050:	f0 1f 00 32 	mcall	80006118 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
80006054:	4b 36       	lddpc	r6,80006120 <xTaskGenericCreate+0x1b4>
80006056:	0c 9c       	mov	r12,r6
80006058:	f0 1f 00 30 	mcall	80006118 <xTaskGenericCreate+0x1ac>
	vListInitialise( ( xList * ) &xPendingReadyList );
8000605c:	4b 2c       	lddpc	r12,80006124 <xTaskGenericCreate+0x1b8>
8000605e:	f0 1f 00 2f 	mcall	80006118 <xTaskGenericCreate+0x1ac>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
80006062:	4b 2c       	lddpc	r12,80006128 <xTaskGenericCreate+0x1bc>
80006064:	f0 1f 00 2d 	mcall	80006118 <xTaskGenericCreate+0x1ac>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
80006068:	4b 1c       	lddpc	r12,8000612c <xTaskGenericCreate+0x1c0>
8000606a:	f0 1f 00 2c 	mcall	80006118 <xTaskGenericCreate+0x1ac>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
8000606e:	4b 18       	lddpc	r8,80006130 <xTaskGenericCreate+0x1c4>
80006070:	91 07       	st.w	r8[0x0],r7
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80006072:	4b 18       	lddpc	r8,80006134 <xTaskGenericCreate+0x1c8>
80006074:	91 06       	st.w	r8[0x0],r6
80006076:	c0 c8       	rjmp	8000608e <xTaskGenericCreate+0x122>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
80006078:	4b 08       	lddpc	r8,80006138 <xTaskGenericCreate+0x1cc>
8000607a:	70 08       	ld.w	r8,r8[0x0]
8000607c:	58 08       	cp.w	r8,0
8000607e:	c0 81       	brne	8000608e <xTaskGenericCreate+0x122>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
80006080:	4a 48       	lddpc	r8,80006110 <xTaskGenericCreate+0x1a4>
80006082:	70 08       	ld.w	r8,r8[0x0]
80006084:	70 b8       	ld.w	r8,r8[0x2c]
80006086:	10 33       	cp.w	r3,r8
80006088:	c0 33       	brcs	8000608e <xTaskGenericCreate+0x122>
					{
						pxCurrentTCB = pxNewTCB;
8000608a:	4a 28       	lddpc	r8,80006110 <xTaskGenericCreate+0x1a4>
8000608c:	91 05       	st.w	r8[0x0],r5
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
8000608e:	6a b8       	ld.w	r8,r5[0x2c]
80006090:	4a b9       	lddpc	r9,8000613c <xTaskGenericCreate+0x1d0>
80006092:	72 09       	ld.w	r9,r9[0x0]
80006094:	12 38       	cp.w	r8,r9
80006096:	e0 88 00 04 	brls	8000609e <xTaskGenericCreate+0x132>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
8000609a:	4a 99       	lddpc	r9,8000613c <xTaskGenericCreate+0x1d0>
8000609c:	93 08       	st.w	r9[0x0],r8
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
8000609e:	4a 98       	lddpc	r8,80006140 <xTaskGenericCreate+0x1d4>
800060a0:	70 09       	ld.w	r9,r8[0x0]
800060a2:	2f f9       	sub	r9,-1
800060a4:	91 09       	st.w	r8[0x0],r9

			prvAddTaskToReadyQueue( pxNewTCB );
800060a6:	6a b8       	ld.w	r8,r5[0x2c]
800060a8:	4a 79       	lddpc	r9,80006144 <xTaskGenericCreate+0x1d8>
800060aa:	72 09       	ld.w	r9,r9[0x0]
800060ac:	12 38       	cp.w	r8,r9
800060ae:	e0 88 00 04 	brls	800060b6 <xTaskGenericCreate+0x14a>
800060b2:	4a 59       	lddpc	r9,80006144 <xTaskGenericCreate+0x1d8>
800060b4:	93 08       	st.w	r9[0x0],r8
800060b6:	6a bc       	ld.w	r12,r5[0x2c]
800060b8:	f8 0c 00 2c 	add	r12,r12,r12<<0x2
800060bc:	08 9b       	mov	r11,r4
800060be:	49 68       	lddpc	r8,80006114 <xTaskGenericCreate+0x1a8>
800060c0:	f0 0c 00 2c 	add	r12,r8,r12<<0x2
800060c4:	f0 1f 00 21 	mcall	80006148 <xTaskGenericCreate+0x1dc>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
800060c8:	f0 1f 00 21 	mcall	8000614c <xTaskGenericCreate+0x1e0>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
800060cc:	49 b8       	lddpc	r8,80006138 <xTaskGenericCreate+0x1cc>
800060ce:	70 08       	ld.w	r8,r8[0x0]
800060d0:	58 08       	cp.w	r8,0
800060d2:	c0 a0       	breq	800060e6 <xTaskGenericCreate+0x17a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
800060d4:	48 f8       	lddpc	r8,80006110 <xTaskGenericCreate+0x1a4>
800060d6:	70 08       	ld.w	r8,r8[0x0]
800060d8:	70 b8       	ld.w	r8,r8[0x2c]
800060da:	10 33       	cp.w	r3,r8
800060dc:	e0 88 00 05 	brls	800060e6 <xTaskGenericCreate+0x17a>
			{
				portYIELD_WITHIN_API();
800060e0:	d7 33       	scall
800060e2:	30 1c       	mov	r12,1
800060e4:	c0 28       	rjmp	800060e8 <xTaskGenericCreate+0x17c>
800060e6:	30 1c       	mov	r12,1
			}
		}
	}

	return xReturn;
}
800060e8:	2f fd       	sub	sp,-4
800060ea:	d8 32       	popm	r0-r7,pc
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
800060ec:	99 c6       	st.w	r12[0x30],r6
800060ee:	c6 1b       	rjmp	80005fb0 <xTaskGenericCreate+0x44>
800060f0:	80 00       	ld.sh	r0,r0[0x0]
800060f2:	2b 60       	sub	r0,-74
800060f4:	80 00       	ld.sh	r0,r0[0x0]
800060f6:	2b 5c       	sub	r12,-75
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	7c de       	ld.w	lr,lr[0x34]
800060fc:	80 00       	ld.sh	r0,r0[0x0]
800060fe:	7c ec       	ld.w	r12,lr[0x38]
80006100:	80 00       	ld.sh	r0,r0[0x0]
80006102:	57 38       	stdsp	sp[0x1cc],r8
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	57 b4       	stdsp	sp[0x1ec],r4
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	58 48       	cp.w	r8,4
8000610c:	00 00       	add	r0,r0
8000610e:	cd 50       	breq	800060b8 <xTaskGenericCreate+0x14c>
80006110:	00 00       	add	r0,r0
80006112:	cd 04       	brge	800060b2 <xTaskGenericCreate+0x146>
80006114:	00 00       	add	r0,r0
80006116:	cc 50       	breq	800060a0 <xTaskGenericCreate+0x134>
80006118:	80 00       	ld.sh	r0,r0[0x0]
8000611a:	57 24       	stdsp	sp[0x1c8],r4
8000611c:	00 00       	add	r0,r0
8000611e:	cd 1c       	rcall	800062c0 <wdt_scheduler+0x34>
80006120:	00 00       	add	r0,r0
80006122:	cd 38       	rjmp	800062c8 <wdt_scheduler+0x3c>
80006124:	00 00       	add	r0,r0
80006126:	cd 08       	rjmp	800062c6 <wdt_scheduler+0x3a>
80006128:	00 00       	add	r0,r0
8000612a:	cc f0       	breq	800060c8 <xTaskGenericCreate+0x15c>
8000612c:	00 00       	add	r0,r0
8000612e:	cd 58       	rjmp	800062d8 <wdt_scheduler+0x4c>
80006130:	00 00       	add	r0,r0
80006132:	cc 3c       	rcall	800062b8 <wdt_scheduler+0x2c>
80006134:	00 00       	add	r0,r0
80006136:	cc 4c       	rcall	800062be <wdt_scheduler+0x32>
80006138:	00 00       	add	r0,r0
8000613a:	cc 40       	breq	800060c2 <xTaskGenericCreate+0x156>
8000613c:	00 00       	add	r0,r0
8000613e:	cc 38       	rjmp	800062c4 <wdt_scheduler+0x38>
80006140:	00 00       	add	r0,r0
80006142:	cd 4c       	rcall	800062ea <wdt_scheduler+0x5e>
80006144:	00 00       	add	r0,r0
80006146:	cd 6c       	rcall	800062f2 <wdt_scheduler+0x66>
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	57 3e       	stdsp	sp[0x1cc],lr
8000614c:	80 00       	ld.sh	r0,r0[0x0]
8000614e:	59 54       	cp.w	r4,21

80006150 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
80006150:	d4 01       	pushm	lr
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
80006152:	30 09       	mov	r9,0
80006154:	1a d9       	st.w	--sp,r9
80006156:	1a d9       	st.w	--sp,r9
80006158:	1a d9       	st.w	--sp,r9
8000615a:	12 98       	mov	r8,r9
8000615c:	e0 6a 01 00 	mov	r10,256
80006160:	48 9b       	lddpc	r11,80006184 <vTaskStartScheduler+0x34>
80006162:	48 ac       	lddpc	r12,80006188 <vTaskStartScheduler+0x38>
80006164:	f0 1f 00 0a 	mcall	8000618c <vTaskStartScheduler+0x3c>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
80006168:	2f dd       	sub	sp,-12
8000616a:	58 1c       	cp.w	r12,1
8000616c:	c0 a1       	brne	80006180 <vTaskStartScheduler+0x30>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
8000616e:	d3 03       	ssrf	0x10

		xSchedulerRunning = pdTRUE;
80006170:	30 19       	mov	r9,1
80006172:	48 88       	lddpc	r8,80006190 <vTaskStartScheduler+0x40>
80006174:	91 09       	st.w	r8[0x0],r9
		xTickCount = ( portTickType ) 0;
80006176:	30 09       	mov	r9,0
80006178:	48 78       	lddpc	r8,80006194 <vTaskStartScheduler+0x44>
8000617a:	91 09       	st.w	r8[0x0],r9
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
8000617c:	f0 1f 00 07 	mcall	80006198 <vTaskStartScheduler+0x48>
80006180:	d8 02       	popm	pc
80006182:	00 00       	add	r0,r0
80006184:	80 00       	ld.sh	r0,r0[0x0]
80006186:	80 70       	ld.sh	r0,r0[0xe]
80006188:	80 00       	ld.sh	r0,r0[0x0]
8000618a:	5e ec       	retqs	r12
8000618c:	80 00       	ld.sh	r0,r0[0x0]
8000618e:	5f 6c       	srmi	r12
80006190:	00 00       	add	r0,r0
80006192:	cc 40       	breq	8000611a <xTaskGenericCreate+0x1ae>
80006194:	00 00       	add	r0,r0
80006196:	cd 30       	breq	8000613c <xTaskGenericCreate+0x1d0>
80006198:	80 00       	ld.sh	r0,r0[0x0]
8000619a:	58 58       	cp.w	r8,5

8000619c <get_and_send_periodic_data>:
		fsm_ecu_init(&ecu_data);
		wdt_enable(&opt);
	}
}

uint16_t get_and_send_periodic_data(fsm_ecu_data_t *ecu_data, uint16_t data_timer) {
8000619c:	eb cd 40 c0 	pushm	r6-r7,lr
800061a0:	18 96       	mov	r6,r12
800061a2:	16 97       	mov	r7,r11
	if ((data_timer % TIMER_10_HZ) == 0) {
800061a4:	16 98       	mov	r8,r11
800061a6:	5c 78       	castu.h	r8
800061a8:	e0 6b cc cd 	mov	r11,52429
800061ac:	ea 1b cc cc 	orh	r11,0xcccc
800061b0:	f0 0b 06 4a 	mulu.d	r10,r8,r11
800061b4:	f6 09 16 02 	lsr	r9,r11,0x2
800061b8:	f2 09 00 29 	add	r9,r9,r9<<0x2
800061bc:	12 18       	sub	r8,r9
800061be:	30 0a       	mov	r10,0
800061c0:	f4 08 19 00 	cp.h	r8,r10
800061c4:	c1 21       	brne	800061e8 <get_and_send_periodic_data+0x4c>
		ecu_can_inverter_read_reg(VDC_REG);
800061c6:	e0 6c 00 eb 	mov	r12,235
800061ca:	f0 1f 00 2b 	mcall	80006274 <get_and_send_periodic_data+0xd8>
		ecu_can_inverter_read_reg(RPM_REG);
800061ce:	33 0c       	mov	r12,48
800061d0:	f0 1f 00 29 	mcall	80006274 <get_and_send_periodic_data+0xd8>
		ecu_can_send_fast_data(ecu_data->inverter_vdc, ecu_data->ecu_error, ecu_data->rpm, ecu_data->trq_cmd);
800061d4:	ed 09 00 16 	ld.sh	r9,r6[22]
800061d8:	ed 1a 00 40 	ld.uh	r10,r6[64]
800061dc:	ed 1b 00 5a 	ld.uh	r11,r6[90]
800061e0:	ed 1c 00 3e 	ld.uh	r12,r6[62]
800061e4:	f0 1f 00 25 	mcall	80006278 <get_and_send_periodic_data+0xdc>
	}
	
	if ((data_timer % TIMER_2_HZ) == 0) {
800061e8:	0e 98       	mov	r8,r7
800061ea:	5c 78       	castu.h	r8
800061ec:	e0 6b 85 1f 	mov	r11,34079
800061f0:	ea 1b 51 eb 	orh	r11,0x51eb
800061f4:	f0 0b 06 4a 	mulu.d	r10,r8,r11
800061f8:	f6 09 16 03 	lsr	r9,r11,0x3
800061fc:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006200:	f2 09 00 29 	add	r9,r9,r9<<0x2
80006204:	12 18       	sub	r8,r9
80006206:	30 0a       	mov	r10,0
80006208:	f4 08 19 00 	cp.h	r8,r10
8000620c:	c0 b1       	brne	80006222 <get_and_send_periodic_data+0x86>
		if (ecu_data->state == STATE_ERROR) {
8000620e:	6c 08       	ld.w	r8,r6[0x0]
80006210:	58 88       	cp.w	r8,8
80006212:	c0 51       	brne	8000621c <get_and_send_periodic_data+0x80>
			ecu_can_send_alive(1);
80006214:	30 1c       	mov	r12,1
80006216:	f0 1f 00 1a 	mcall	8000627c <get_and_send_periodic_data+0xe0>
8000621a:	c0 48       	rjmp	80006222 <get_and_send_periodic_data+0x86>
			} else {
			ecu_can_send_alive(0);
8000621c:	30 0c       	mov	r12,0
8000621e:	f0 1f 00 18 	mcall	8000627c <get_and_send_periodic_data+0xe0>
		}
	}
	
	if ((data_timer % TIMER_1_HZ) == 0) {
80006222:	0e 98       	mov	r8,r7
80006224:	5c 78       	castu.h	r8
80006226:	e0 6b 85 1f 	mov	r11,34079
8000622a:	ea 1b 51 eb 	orh	r11,0x51eb
8000622e:	f0 0b 06 4a 	mulu.d	r10,r8,r11
80006232:	f6 09 16 04 	lsr	r9,r11,0x4
80006236:	f2 09 10 32 	mul	r9,r9,50
8000623a:	12 18       	sub	r8,r9
8000623c:	30 09       	mov	r9,0
8000623e:	f2 08 19 00 	cp.h	r8,r9
80006242:	c1 51       	brne	8000626c <get_and_send_periodic_data+0xd0>
		ecu_can_inverter_read_reg(MOTOR_TEMP_REG);
80006244:	34 9c       	mov	r12,73
80006246:	f0 1f 00 0c 	mcall	80006274 <get_and_send_periodic_data+0xd8>
		ecu_can_inverter_read_reg(IGBT_TEMP_REG);
8000624a:	34 ac       	mov	r12,74
8000624c:	f0 1f 00 0a 	mcall	80006274 <get_and_send_periodic_data+0xd8>
		ecu_can_send_slow_data(ecu_data->motor_temp, ecu_data->inverter_temp, ecu_data->config_max_trq);
80006250:	ed 3a 00 69 	ld.ub	r10,r6[105]
80006254:	ed 1b 00 44 	ld.uh	r11,r6[68]
80006258:	ed 1c 00 42 	ld.uh	r12,r6[66]
8000625c:	f0 1f 00 09 	mcall	80006280 <get_and_send_periodic_data+0xe4>
		save_state(&mcp2515_spiModule, ecu_data);
80006260:	0c 9b       	mov	r11,r6
80006262:	48 9c       	lddpc	r12,80006284 <get_and_send_periodic_data+0xe8>
80006264:	f0 1f 00 09 	mcall	80006288 <get_and_send_periodic_data+0xec>
		data_timer = 0;
		asm("nop");
80006268:	d7 03       	nop
8000626a:	30 07       	mov	r7,0
	}
	return data_timer;
8000626c:	0e 9c       	mov	r12,r7
8000626e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006272:	00 00       	add	r0,r0
80006274:	80 00       	ld.sh	r0,r0[0x0]
80006276:	2a 94       	sub	r4,-87
80006278:	80 00       	ld.sh	r0,r0[0x0]
8000627a:	2a 58       	sub	r8,-91
8000627c:	80 00       	ld.sh	r0,r0[0x0]
8000627e:	28 c0       	sub	r0,-116
80006280:	80 00       	ld.sh	r0,r0[0x0]
80006282:	2a 1c       	sub	r12,-95
80006284:	00 00       	add	r0,r0
80006286:	d0 2c       	*unknown*
80006288:	80 00       	ld.sh	r0,r0[0x0]
8000628a:	31 b8       	mov	r8,27

8000628c <wdt_scheduler>:
		portEXIT_CRITICAL();
	}
}


void wdt_scheduler(void) {
8000628c:	d4 01       	pushm	lr
	// Watchdog reset
	if(AVR32_PM.RCAUSE.wdt) {
8000628e:	fe 78 04 00 	mov	r8,-64512
80006292:	f0 f8 01 80 	ld.w	r8,r8[384]
80006296:	e2 18 00 08 	andl	r8,0x8,COH
8000629a:	c0 b0       	breq	800062b0 <wdt_scheduler+0x24>
		power_on_reset = 0;
8000629c:	30 09       	mov	r9,0
8000629e:	49 38       	lddpc	r8,800062e8 <wdt_scheduler+0x5c>
800062a0:	b0 89       	st.b	r8[0x0],r9
		load_state(&mcp2515_spiModule, &ecu_data);
800062a2:	49 3b       	lddpc	r11,800062ec <wdt_scheduler+0x60>
800062a4:	49 3c       	lddpc	r12,800062f0 <wdt_scheduler+0x64>
800062a6:	f0 1f 00 14 	mcall	800062f4 <wdt_scheduler+0x68>
		wdt_reenable();
800062aa:	f0 1f 00 14 	mcall	800062f8 <wdt_scheduler+0x6c>
800062ae:	d8 02       	popm	pc
	} else if (AVR32_PM.RCAUSE.por) {
800062b0:	fe 78 04 00 	mov	r8,-64512
800062b4:	f0 f8 01 80 	ld.w	r8,r8[384]
800062b8:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800062bc:	c0 b0       	breq	800062d2 <wdt_scheduler+0x46>
		power_on_reset = 1;
800062be:	30 19       	mov	r9,1
800062c0:	48 a8       	lddpc	r8,800062e8 <wdt_scheduler+0x5c>
800062c2:	b0 89       	st.b	r8[0x0],r9
		fsm_ecu_init(&ecu_data);
800062c4:	48 ac       	lddpc	r12,800062ec <wdt_scheduler+0x60>
800062c6:	f0 1f 00 0e 	mcall	800062fc <wdt_scheduler+0x70>
		wdt_enable(&opt);
800062ca:	48 ec       	lddpc	r12,80006300 <wdt_scheduler+0x74>
800062cc:	f0 1f 00 0e 	mcall	80006304 <wdt_scheduler+0x78>
800062d0:	d8 02       	popm	pc
	} else {
		power_on_reset = 0;
800062d2:	30 09       	mov	r9,0
800062d4:	48 58       	lddpc	r8,800062e8 <wdt_scheduler+0x5c>
800062d6:	b0 89       	st.b	r8[0x0],r9
		fsm_ecu_init(&ecu_data);
800062d8:	48 5c       	lddpc	r12,800062ec <wdt_scheduler+0x60>
800062da:	f0 1f 00 09 	mcall	800062fc <wdt_scheduler+0x70>
		wdt_enable(&opt);
800062de:	48 9c       	lddpc	r12,80006300 <wdt_scheduler+0x74>
800062e0:	f0 1f 00 09 	mcall	80006304 <wdt_scheduler+0x78>
800062e4:	d8 02       	popm	pc
800062e6:	00 00       	add	r0,r0
800062e8:	00 00       	add	r0,r0
800062ea:	cd 78       	rjmp	80006498 <main+0x190>
800062ec:	00 00       	add	r0,r0
800062ee:	cf 94       	brge	800062e0 <wdt_scheduler+0x54>
800062f0:	00 00       	add	r0,r0
800062f2:	d0 2c       	*unknown*
800062f4:	80 00       	ld.sh	r0,r0[0x0]
800062f6:	30 ac       	mov	r12,10
800062f8:	80 00       	ld.sh	r0,r0[0x0]
800062fa:	21 e8       	sub	r8,30
800062fc:	80 00       	ld.sh	r0,r0[0x0]
800062fe:	35 28       	mov	r8,82
80006300:	00 00       	add	r0,r0
80006302:	01 e8       	ld.ub	r8,r0[0x6]
80006304:	80 00       	ld.sh	r0,r0[0x0]
80006306:	22 28       	sub	r8,34

80006308 <main>:
struct spi_device spi_init_module(void);
void wdt_scheduler(void);
uint16_t get_and_send_periodic_data(fsm_ecu_data_t *ecu_data, uint16_t data_timer);


int main(void){	
80006308:	eb cd 40 e0 	pushm	r5-r7,lr
	board_init();
8000630c:	f0 1f 00 50 	mcall	8000644c <main+0x144>
	spi_init_pins();
80006310:	f0 1f 00 50 	mcall	80006450 <main+0x148>
	mcp2515_spiModule = spi_init_module();
80006314:	f0 1f 00 50 	mcall	80006454 <main+0x14c>
80006318:	4d 08       	lddpc	r8,80006458 <main+0x150>
8000631a:	b0 8c       	st.b	r8[0x0],r12
	queue_from_inverter	= xQueueCreate(QUEUE_INVERTER_RX_LEN, sizeof(inverter_can_msg_t));
8000631c:	30 0a       	mov	r10,0
8000631e:	30 cb       	mov	r11,12
80006320:	30 5c       	mov	r12,5
80006322:	f0 1f 00 4f 	mcall	8000645c <main+0x154>
80006326:	4c f8       	lddpc	r8,80006460 <main+0x158>
80006328:	91 0c       	st.w	r8[0x0],r12
	queue_to_inverter	= xQueueCreate(QUEUE_INVERTER_RX_LEN+5, sizeof(inverter_can_msg_t));
8000632a:	30 0a       	mov	r10,0
8000632c:	30 cb       	mov	r11,12
8000632e:	30 ac       	mov	r12,10
80006330:	f0 1f 00 4b 	mcall	8000645c <main+0x154>
80006334:	4c c8       	lddpc	r8,80006464 <main+0x15c>
80006336:	91 0c       	st.w	r8[0x0],r12
	queue_wheel_fl		= xQueueCreate(1, sizeof(uint16_t));	
80006338:	30 0a       	mov	r10,0
8000633a:	30 2b       	mov	r11,2
8000633c:	30 1c       	mov	r12,1
8000633e:	f0 1f 00 48 	mcall	8000645c <main+0x154>
80006342:	4c a8       	lddpc	r8,80006468 <main+0x160>
80006344:	91 0c       	st.w	r8[0x0],r12
	queue_wheel_fr		= xQueueCreate(1, sizeof(uint16_t));	
80006346:	30 0a       	mov	r10,0
80006348:	30 2b       	mov	r11,2
8000634a:	30 1c       	mov	r12,1
8000634c:	f0 1f 00 44 	mcall	8000645c <main+0x154>
80006350:	4c 78       	lddpc	r8,8000646c <main+0x164>
80006352:	91 0c       	st.w	r8[0x0],r12
	queue_wheel_rl		= xQueueCreate(1, sizeof(uint16_t));	
80006354:	30 0a       	mov	r10,0
80006356:	30 2b       	mov	r11,2
80006358:	30 1c       	mov	r12,1
8000635a:	f0 1f 00 41 	mcall	8000645c <main+0x154>
8000635e:	4c 58       	lddpc	r8,80006470 <main+0x168>
80006360:	91 0c       	st.w	r8[0x0],r12
	queue_wheel_rr		= xQueueCreate(1, sizeof(uint16_t));
80006362:	30 0a       	mov	r10,0
80006364:	30 2b       	mov	r11,2
80006366:	30 1c       	mov	r12,1
80006368:	f0 1f 00 3d 	mcall	8000645c <main+0x154>
8000636c:	4c 28       	lddpc	r8,80006474 <main+0x16c>
8000636e:	91 0c       	st.w	r8[0x0],r12
	//queue_traction_control = xQueueCreate(1, sizeof(int16_t));
	queue_dash_msg		= xQueueCreate(QUEUE_DASH_MSG_LEN, sizeof(dash_can_msg_t));	
80006370:	30 0a       	mov	r10,0
80006372:	30 cb       	mov	r11,12
80006374:	30 5c       	mov	r12,5
80006376:	f0 1f 00 3a 	mcall	8000645c <main+0x154>
8000637a:	4c 08       	lddpc	r8,80006478 <main+0x170>
8000637c:	91 0c       	st.w	r8[0x0],r12
	queue_trq_sens0		= xQueueCreate(1, sizeof(int16_t));
8000637e:	30 0a       	mov	r10,0
80006380:	30 2b       	mov	r11,2
80006382:	30 1c       	mov	r12,1
80006384:	f0 1f 00 36 	mcall	8000645c <main+0x154>
80006388:	4b d8       	lddpc	r8,8000647c <main+0x174>
8000638a:	91 0c       	st.w	r8[0x0],r12
	queue_trq_sens1		= xQueueCreate(1, sizeof(int16_t));
8000638c:	30 0a       	mov	r10,0
8000638e:	30 2b       	mov	r11,2
80006390:	30 1c       	mov	r12,1
80006392:	f0 1f 00 33 	mcall	8000645c <main+0x154>
80006396:	4b b8       	lddpc	r8,80006480 <main+0x178>
80006398:	91 0c       	st.w	r8[0x0],r12
	queue_bms_rx		= xQueueCreate(QUEUE_BMS_RX_LEN, sizeof(bms_can_msg_t));
8000639a:	30 0a       	mov	r10,0
8000639c:	30 cb       	mov	r11,12
8000639e:	30 5c       	mov	r12,5
800063a0:	f0 1f 00 2f 	mcall	8000645c <main+0x154>
800063a4:	4b 88       	lddpc	r8,80006484 <main+0x17c>
800063a6:	91 0c       	st.w	r8[0x0],r12
	queue_brake_front	= xQueueCreate(2, sizeof(uint16_t));
800063a8:	30 0a       	mov	r10,0
800063aa:	30 2b       	mov	r11,2
800063ac:	16 9c       	mov	r12,r11
800063ae:	f0 1f 00 2c 	mcall	8000645c <main+0x154>
800063b2:	4b 68       	lddpc	r8,80006488 <main+0x180>
800063b4:	91 0c       	st.w	r8[0x0],r12
	queue_brake_rear	= xQueueCreate(2, sizeof(uint16_t));
800063b6:	30 0a       	mov	r10,0
800063b8:	30 2b       	mov	r11,2
800063ba:	16 9c       	mov	r12,r11
800063bc:	f0 1f 00 28 	mcall	8000645c <main+0x154>
800063c0:	4b 38       	lddpc	r8,8000648c <main+0x184>
800063c2:	91 0c       	st.w	r8[0x0],r12
	queue_bspd			= xQueueCreate(1, sizeof(uint8_t));
800063c4:	30 0a       	mov	r10,0
800063c6:	30 1b       	mov	r11,1
800063c8:	16 9c       	mov	r12,r11
800063ca:	f0 1f 00 25 	mcall	8000645c <main+0x154>
800063ce:	4b 18       	lddpc	r8,80006490 <main+0x188>
800063d0:	91 0c       	st.w	r8[0x0],r12
	queue_trq_sens0_err = xQueueCreate(1, sizeof(uint8_t));
800063d2:	30 0a       	mov	r10,0
800063d4:	30 1b       	mov	r11,1
800063d6:	16 9c       	mov	r12,r11
800063d8:	f0 1f 00 21 	mcall	8000645c <main+0x154>
800063dc:	4a e8       	lddpc	r8,80006494 <main+0x18c>
800063de:	91 0c       	st.w	r8[0x0],r12
	queue_trq_sens1_err = xQueueCreate(1, sizeof(uint8_t));
800063e0:	30 0a       	mov	r10,0
800063e2:	30 1b       	mov	r11,1
800063e4:	16 9c       	mov	r12,r11
800063e6:	f0 1f 00 1e 	mcall	8000645c <main+0x154>
800063ea:	4a c8       	lddpc	r8,80006498 <main+0x190>
800063ec:	91 0c       	st.w	r8[0x0],r12
	
	xTaskCreate(
800063ee:	4a c5       	lddpc	r5,8000649c <main+0x194>
800063f0:	30 07       	mov	r7,0
800063f2:	1a d7       	st.w	--sp,r7
800063f4:	1a d7       	st.w	--sp,r7
800063f6:	4a b6       	lddpc	r6,800064a0 <main+0x198>
800063f8:	1a d6       	st.w	--sp,r6
800063fa:	30 18       	mov	r8,1
800063fc:	0a 99       	mov	r9,r5
800063fe:	e0 6a 01 00 	mov	r10,256
80006402:	4a 9b       	lddpc	r11,800064a4 <main+0x19c>
80006404:	4a 9c       	lddpc	r12,800064a8 <main+0x1a0>
80006406:	f0 1f 00 2a 	mcall	800064ac <main+0x1a4>
		, (void *) &task_check_alive[0]
		, TASK_MAIN_PRIORITY
		, (xTaskHandle *) &task_handles[0]
	);
	
 	xTaskCreate(
8000640a:	1a d7       	st.w	--sp,r7
8000640c:	1a d7       	st.w	--sp,r7
8000640e:	2f c6       	sub	r6,-4
80006410:	1a d6       	st.w	--sp,r6
80006412:	30 18       	mov	r8,1
80006414:	ea c9 ff fc 	sub	r9,r5,-4
80006418:	e0 6a 01 00 	mov	r10,256
8000641c:	4a 5b       	lddpc	r11,800064b0 <main+0x1a8>
8000641e:	4a 6c       	lddpc	r12,800064b4 <main+0x1ac>
80006420:	f0 1f 00 23 	mcall	800064ac <main+0x1a4>
 		, (void *) &task_check_alive[1]
 		, TASK_SPI_CAN_PRIORITY
 		, (xTaskHandle *) &task_handles[1]
 	);
	 	 
	xTaskCreate(
80006424:	1a d7       	st.w	--sp,r7
80006426:	1a d7       	st.w	--sp,r7
80006428:	1a d7       	st.w	--sp,r7
8000642a:	30 28       	mov	r8,2
8000642c:	0e 99       	mov	r9,r7
8000642e:	e0 6a 01 00 	mov	r10,256
80006432:	4a 2b       	lddpc	r11,800064b8 <main+0x1b0>
80006434:	4a 2c       	lddpc	r12,800064bc <main+0x1b4>
80006436:	f0 1f 00 1e 	mcall	800064ac <main+0x1a4>
	 	, TASK_WATCHDOG_PRIORITY
	 	, NULL
	);
		
	#ifdef USE_WDT
		wdt_scheduler();
8000643a:	2f 7d       	sub	sp,-36
8000643c:	f0 1f 00 21 	mcall	800064c0 <main+0x1b8>
	#else
		fsm_ecu_init(&ecu_data);
	#endif
	vTaskStartScheduler();
80006440:	f0 1f 00 21 	mcall	800064c4 <main+0x1bc>
}
80006444:	0e 9c       	mov	r12,r7
80006446:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
8000644a:	00 00       	add	r0,r0
8000644c:	80 00       	ld.sh	r0,r0[0x0]
8000644e:	6d c0       	ld.w	r0,r6[0x70]
80006450:	80 00       	ld.sh	r0,r0[0x0]
80006452:	35 14       	mov	r4,81
80006454:	80 00       	ld.sh	r0,r0[0x0]
80006456:	34 8c       	mov	r12,72
80006458:	00 00       	add	r0,r0
8000645a:	d0 2c       	*unknown*
8000645c:	80 00       	ld.sh	r0,r0[0x0]
8000645e:	30 04       	mov	r4,0
80006460:	00 00       	add	r0,r0
80006462:	cf 58       	rjmp	8000664c <task_spi_can+0xcc>
80006464:	00 00       	add	r0,r0
80006466:	cf 64       	brge	80006452 <main+0x14a>
80006468:	00 00       	add	r0,r0
8000646a:	cf 78       	rjmp	80006658 <task_spi_can+0xd8>
8000646c:	00 00       	add	r0,r0
8000646e:	cf 70       	breq	8000645c <main+0x154>
80006470:	00 00       	add	r0,r0
80006472:	cf 84       	brge	80006462 <main+0x15a>
80006474:	00 00       	add	r0,r0
80006476:	cf 6c       	rcall	80006662 <task_spi_can+0xe2>
80006478:	00 00       	add	r0,r0
8000647a:	cf 7c       	rcall	80006668 <task_spi_can+0xe8>
8000647c:	00 00       	add	r0,r0
8000647e:	cf 60       	breq	8000646a <main+0x162>
80006480:	00 00       	add	r0,r0
80006482:	cf 88       	rjmp	80006672 <task_spi_can+0xf2>
80006484:	00 00       	add	r0,r0
80006486:	cf 54       	brge	80006470 <main+0x168>
80006488:	00 00       	add	r0,r0
8000648a:	cf 90       	breq	8000647c <main+0x174>
8000648c:	00 00       	add	r0,r0
8000648e:	cf 68       	rjmp	8000667a <task_spi_can+0xfa>
80006490:	00 00       	add	r0,r0
80006492:	cf 80       	breq	80006482 <main+0x17a>
80006494:	00 00       	add	r0,r0
80006496:	cf 8c       	rcall	80006686 <task_spi_can+0x106>
80006498:	00 00       	add	r0,r0
8000649a:	cf 74       	brge	80006488 <main+0x180>
8000649c:	00 00       	add	r0,r0
8000649e:	cd 7c       	rcall	8000664c <task_spi_can+0xcc>
800064a0:	00 00       	add	r0,r0
800064a2:	cd 70       	breq	80006450 <main+0x148>
800064a4:	80 00       	ld.sh	r0,r0[0x0]
800064a6:	80 78       	ld.sh	r8,r0[0xe]
800064a8:	80 00       	ld.sh	r0,r0[0x0]
800064aa:	66 e8       	ld.w	r8,r3[0x38]
800064ac:	80 00       	ld.sh	r0,r0[0x0]
800064ae:	5f 6c       	srmi	r12
800064b0:	80 00       	ld.sh	r0,r0[0x0]
800064b2:	80 84       	ld.uh	r4,r0[0x0]
800064b4:	80 00       	ld.sh	r0,r0[0x0]
800064b6:	65 80       	ld.w	r0,r2[0x60]
800064b8:	80 00       	ld.sh	r0,r0[0x0]
800064ba:	80 90       	ld.uh	r0,r0[0x2]
800064bc:	80 00       	ld.sh	r0,r0[0x0]
800064be:	64 c8       	ld.w	r8,r2[0x30]
800064c0:	80 00       	ld.sh	r0,r0[0x0]
800064c2:	62 8c       	ld.w	r12,r1[0x20]
800064c4:	80 00       	ld.sh	r0,r0[0x0]
800064c6:	61 50       	ld.w	r0,r0[0x54]

800064c8 <task_watchdog>:


static portTASK_FUNCTION(task_watchdog, pvParameters) {
800064c8:	d4 31       	pushm	r0-r7,lr
800064ca:	20 1d       	sub	sp,4
	portTickType first_run = xTaskGetTickCount();
800064cc:	f0 1f 00 22 	mcall	80006554 <task_watchdog+0x8c>
800064d0:	fa c2 ff fc 	sub	r2,sp,-4
800064d4:	04 dc       	st.w	--r2,r12
	short task;
	static uint8_t seppuku = 0;
	static uint8_t por_timer = 0;
	while (1) {
		vTaskDelayUntil(&first_run, TASK_WATCHDOG_PERIOD);
800064d6:	33 c1       	mov	r1,60
		 * Check if tasks update their flags. If not, restart ECU by not
		 * clearing the watchdog timer.
		 */
		portENTER_CRITICAL();
		for (task = 0; task < NUMBER_OF_TASKS-1; task++) {
			if (task_check_alive[task] == pdFALSE) {
800064d8:	4a 07       	lddpc	r7,80006558 <task_watchdog+0x90>
				seppuku++;
800064da:	4a 16       	lddpc	r6,8000655c <task_watchdog+0x94>
				gpio_set_pin_high(LED1);	
			}
			/* Task has well-behaved. Reset flag and wait for next round. */
			task_check_alive[task] = pdFALSE;
800064dc:	30 05       	mov	r5,0
		}
		
		if (power_on_reset == 1) {
800064de:	4a 10       	lddpc	r0,80006560 <task_watchdog+0x98>
800064e0:	30 13       	mov	r3,1
		} else {
			por_timer = 0;
		}
		
		if (por_timer < 10) {
			if (!seppuku) {
800064e2:	30 04       	mov	r4,0
	portTickType first_run = xTaskGetTickCount();
	short task;
	static uint8_t seppuku = 0;
	static uint8_t por_timer = 0;
	while (1) {
		vTaskDelayUntil(&first_run, TASK_WATCHDOG_PERIOD);
800064e4:	02 9b       	mov	r11,r1
800064e6:	1a 9c       	mov	r12,sp
800064e8:	f0 1f 00 1f 	mcall	80006564 <task_watchdog+0x9c>
		/* Perform routine work.
		 * Check if tasks update their flags. If not, restart ECU by not
		 * clearing the watchdog timer.
		 */
		portENTER_CRITICAL();
800064ec:	f0 1f 00 1f 	mcall	80006568 <task_watchdog+0xa0>
		for (task = 0; task < NUMBER_OF_TASKS-1; task++) {
			if (task_check_alive[task] == pdFALSE) {
800064f0:	6e 08       	ld.w	r8,r7[0x0]
800064f2:	58 08       	cp.w	r8,0
800064f4:	c0 71       	brne	80006502 <task_watchdog+0x3a>
				seppuku++;
800064f6:	0d 88       	ld.ub	r8,r6[0x0]
800064f8:	2f f8       	sub	r8,-1
800064fa:	ac 88       	st.b	r6[0x0],r8
				gpio_set_pin_high(LED1);	
800064fc:	35 3c       	mov	r12,83
800064fe:	f0 1f 00 1c 	mcall	8000656c <task_watchdog+0xa4>
			}
			/* Task has well-behaved. Reset flag and wait for next round. */
			task_check_alive[task] = pdFALSE;
80006502:	8f 05       	st.w	r7[0x0],r5
		 * Check if tasks update their flags. If not, restart ECU by not
		 * clearing the watchdog timer.
		 */
		portENTER_CRITICAL();
		for (task = 0; task < NUMBER_OF_TASKS-1; task++) {
			if (task_check_alive[task] == pdFALSE) {
80006504:	6e 18       	ld.w	r8,r7[0x4]
80006506:	58 08       	cp.w	r8,0
80006508:	c0 71       	brne	80006516 <task_watchdog+0x4e>
				seppuku++;
8000650a:	0d 88       	ld.ub	r8,r6[0x0]
8000650c:	2f f8       	sub	r8,-1
8000650e:	ac 88       	st.b	r6[0x0],r8
				gpio_set_pin_high(LED1);	
80006510:	35 3c       	mov	r12,83
80006512:	f0 1f 00 17 	mcall	8000656c <task_watchdog+0xa4>
			}
			/* Task has well-behaved. Reset flag and wait for next round. */
			task_check_alive[task] = pdFALSE;
80006516:	8f 15       	st.w	r7[0x4],r5
		}
		
		if (power_on_reset == 1) {
80006518:	01 88       	ld.ub	r8,r0[0x0]
8000651a:	e6 08 18 00 	cp.b	r8,r3
8000651e:	c0 b1       	brne	80006534 <task_watchdog+0x6c>
			por_timer++;
80006520:	49 49       	lddpc	r9,80006570 <task_watchdog+0xa8>
80006522:	13 88       	ld.ub	r8,r9[0x0]
80006524:	2f f8       	sub	r8,-1
80006526:	b2 88       	st.b	r9[0x0],r8
		} else {
			por_timer = 0;
		}
		
		if (por_timer < 10) {
80006528:	30 99       	mov	r9,9
8000652a:	f2 08 18 00 	cp.b	r8,r9
8000652e:	e0 8b 00 0d 	brhi	80006548 <task_watchdog+0x80>
80006532:	c0 38       	rjmp	80006538 <task_watchdog+0x70>
		}
		
		if (power_on_reset == 1) {
			por_timer++;
		} else {
			por_timer = 0;
80006534:	48 f8       	lddpc	r8,80006570 <task_watchdog+0xa8>
80006536:	b0 84       	st.b	r8[0x0],r4
		}
		
		if (por_timer < 10) {
			if (!seppuku) {
80006538:	0d 88       	ld.ub	r8,r6[0x0]
8000653a:	e8 08 18 00 	cp.b	r8,r4
8000653e:	c0 41       	brne	80006546 <task_watchdog+0x7e>
				/* Clear watchdog timer */
				wdt_clear();
80006540:	f0 1f 00 0d 	mcall	80006574 <task_watchdog+0xac>
80006544:	c0 28       	rjmp	80006548 <task_watchdog+0x80>
			} else {
				asm("nop");
80006546:	d7 03       	nop
			}
		}
		portEXIT_CRITICAL();
80006548:	f0 1f 00 0c 	mcall	80006578 <task_watchdog+0xb0>
		gpio_toggle_pin(LED2);
8000654c:	35 2c       	mov	r12,82
8000654e:	f0 1f 00 0c 	mcall	8000657c <task_watchdog+0xb4>
	}
80006552:	cc 9b       	rjmp	800064e4 <task_watchdog+0x1c>
80006554:	80 00       	ld.sh	r0,r0[0x0]
80006556:	5b 18       	cp.w	r8,-15
80006558:	00 00       	add	r0,r0
8000655a:	cd 7c       	rcall	80006708 <task_main+0x20>
8000655c:	00 00       	add	r0,r0
8000655e:	cd 79       	rjmp	8000690c <gpio_configure_pin+0xac>
80006560:	00 00       	add	r0,r0
80006562:	cd 78       	rjmp	80006710 <task_main+0x28>
80006564:	80 00       	ld.sh	r0,r0[0x0]
80006566:	5e 14       	retne	r4
80006568:	80 00       	ld.sh	r0,r0[0x0]
8000656a:	58 48       	cp.w	r8,4
8000656c:	80 00       	ld.sh	r0,r0[0x0]
8000656e:	69 a6       	ld.w	r6,r4[0x68]
80006570:	00 00       	add	r0,r0
80006572:	cd 84       	brge	80006522 <task_watchdog+0x5a>
80006574:	80 00       	ld.sh	r0,r0[0x0]
80006576:	22 04       	sub	r4,32
80006578:	80 00       	ld.sh	r0,r0[0x0]
8000657a:	59 54       	cp.w	r4,21
8000657c:	80 00       	ld.sh	r0,r0[0x0]
8000657e:	69 d2       	ld.w	r2,r4[0x74]

80006580 <task_spi_can>:
		portEXIT_CRITICAL();	
		gpio_toggle_pin(LED4);
	}
}
	
static portTASK_FUNCTION(task_spi_can, pvParameters) {
80006580:	d4 31       	pushm	r0-r7,lr
80006582:	20 4d       	sub	sp,16
80006584:	18 92       	mov	r2,r12
	volatile signed portBASE_TYPE *pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
	portTickType first_run = xTaskGetTickCount();
80006586:	f0 1f 00 4a 	mcall	800066ac <task_spi_can+0x12c>
8000658a:	fa c3 ff f0 	sub	r3,sp,-16
8000658e:	06 dc       	st.w	--r3,r12
	inverter_can_msg_t inverter_can_msg;
	mcp2515_init (&mcp2515_spiModule);
80006590:	4c 8c       	lddpc	r12,800066b0 <task_spi_can+0x130>
80006592:	f0 1f 00 49 	mcall	800066b4 <task_spi_can+0x134>
	
	while(1) {
		vTaskDelayUntil(&first_run, TASK_SPI_CAN_PERIOD);
80006596:	30 51       	mov	r1,5
80006598:	36 e0       	mov	r0,110
		if (gpio_pin_is_low(INT1)) { // Data has been received. Start reception of data
			//portENTER_CRITICAL(); // unsure if this is necessary?
			
			uint8_t canintfRegister;
			canintfRegister = mcp2515_readRegister(&mcp2515_spiModule,CANINTF); // read the interrupt register
8000659a:	4c 67       	lddpc	r7,800066b0 <task_spi_can+0x130>
				
			}
			
			if ( messageReceivedOnBuffer1){
				inverter_can_msg.data.u64 = 0x00L;
				inverter_can_msg.dlc = mcp2515_getReceivedMessage(&mcp2515_spiModule,1,inverter_can_msg.data.u8,6);
8000659c:	30 14       	mov	r4,1
	portTickType first_run = xTaskGetTickCount();
	inverter_can_msg_t inverter_can_msg;
	mcp2515_init (&mcp2515_spiModule);
	
	while(1) {
		vTaskDelayUntil(&first_run, TASK_SPI_CAN_PERIOD);
8000659e:	02 9b       	mov	r11,r1
800065a0:	06 9c       	mov	r12,r3
800065a2:	f0 1f 00 46 	mcall	800066b8 <task_spi_can+0x138>
800065a6:	00 9c       	mov	r12,r0
800065a8:	f0 1f 00 45 	mcall	800066bc <task_spi_can+0x13c>
		if (gpio_pin_is_low(INT1)) { // Data has been received. Start reception of data
800065ac:	c3 31       	brne	80006612 <task_spi_can+0x92>
			//portENTER_CRITICAL(); // unsure if this is necessary?
			
			uint8_t canintfRegister;
			canintfRegister = mcp2515_readRegister(&mcp2515_spiModule,CANINTF); // read the interrupt register
800065ae:	32 cb       	mov	r11,44
800065b0:	0e 9c       	mov	r12,r7
800065b2:	f0 1f 00 44 	mcall	800066c0 <task_spi_can+0x140>
			
			bool messageReceivedOnBuffer0 = canintfRegister & ( 1 << RX0IF);	// determine where messages have come from
800065b6:	18 96       	mov	r6,r12
			bool messageReceivedOnBuffer1 = canintfRegister & ( 1 << RX1IF);
			
			if ( messageReceivedOnBuffer0){
800065b8:	f1 dc c0 01 	bfextu	r8,r12,0x0,0x1
800065bc:	c1 60       	breq	800065e8 <task_spi_can+0x68>
				gpio_toggle_pin(LED3);
800065be:	35 1c       	mov	r12,81
800065c0:	f0 1f 00 41 	mcall	800066c4 <task_spi_can+0x144>
				inverter_can_msg.data.u64 = 0x00L;
800065c4:	30 08       	mov	r8,0
800065c6:	30 09       	mov	r9,0
800065c8:	fa e9 00 00 	st.d	sp[0],r8
				inverter_can_msg.dlc = mcp2515_getReceivedMessage(&mcp2515_spiModule,0,inverter_can_msg.data.u8,6);
800065cc:	30 69       	mov	r9,6
800065ce:	1a 9a       	mov	r10,sp
800065d0:	30 0b       	mov	r11,0
800065d2:	0e 9c       	mov	r12,r7
800065d4:	f0 1f 00 3d 	mcall	800066c8 <task_spi_can+0x148>
800065d8:	50 2c       	stdsp	sp[0x8],r12
				xQueueSendToBack( queue_from_inverter, &inverter_can_msg, 0 );
800065da:	30 09       	mov	r9,0
800065dc:	12 9a       	mov	r10,r9
800065de:	1a 9b       	mov	r11,sp
800065e0:	4b b8       	lddpc	r8,800066cc <task_spi_can+0x14c>
800065e2:	70 0c       	ld.w	r12,r8[0x0]
800065e4:	f0 1f 00 3b 	mcall	800066d0 <task_spi_can+0x150>
				
			}
			
			if ( messageReceivedOnBuffer1){
800065e8:	e2 16 00 02 	andl	r6,0x2,COH
800065ec:	c1 30       	breq	80006612 <task_spi_can+0x92>
				inverter_can_msg.data.u64 = 0x00L;
800065ee:	30 08       	mov	r8,0
800065f0:	30 09       	mov	r9,0
800065f2:	fa e9 00 00 	st.d	sp[0],r8
				inverter_can_msg.dlc = mcp2515_getReceivedMessage(&mcp2515_spiModule,1,inverter_can_msg.data.u8,6);
800065f6:	30 69       	mov	r9,6
800065f8:	1a 9a       	mov	r10,sp
800065fa:	08 9b       	mov	r11,r4
800065fc:	0e 9c       	mov	r12,r7
800065fe:	f0 1f 00 33 	mcall	800066c8 <task_spi_can+0x148>
80006602:	50 2c       	stdsp	sp[0x8],r12
				xQueueSendToBack( queue_from_inverter, &inverter_can_msg, 0 );
80006604:	30 09       	mov	r9,0
80006606:	12 9a       	mov	r10,r9
80006608:	1a 9b       	mov	r11,sp
8000660a:	4b 18       	lddpc	r8,800066cc <task_spi_can+0x14c>
8000660c:	70 0c       	ld.w	r12,r8[0x0]
8000660e:	f0 1f 00 31 	mcall	800066d0 <task_spi_can+0x150>
			
			//portEXIT_CRITICAL();
		}
		

		uint8_t TXBuffer0controlReg = mcp2515_readRegister(&mcp2515_spiModule, TXB0CTRL);	//check if transmit register 0 is ready to receive new data
80006612:	33 0b       	mov	r11,48
80006614:	0e 9c       	mov	r12,r7
80006616:	f0 1f 00 2b 	mcall	800066c0 <task_spi_can+0x140>
8000661a:	18 95       	mov	r5,r12
		bool TXbuffer0Empty = !(TXBuffer0controlReg & (1 << TXREQ));
		uint8_t TXBuffer1controlReg = mcp2515_readRegister(&mcp2515_spiModule, TXB1CTRL); //check if transmit register 1 is ready to receive new data
8000661c:	34 0b       	mov	r11,64
8000661e:	0e 9c       	mov	r12,r7
80006620:	f0 1f 00 28 	mcall	800066c0 <task_spi_can+0x140>
80006624:	18 96       	mov	r6,r12
		bool TXbuffer1Empty = !(TXBuffer1controlReg & ( 1 << TXREQ));
		
		bool messageSent = false;	
				
		if ( TXbuffer0Empty && !messageSent){
80006626:	e2 15 00 08 	andl	r5,0x8,COH
8000662a:	c1 a1       	brne	8000665e <task_spi_can+0xde>
			inverter_can_msg.dlc = 0;
8000662c:	30 0a       	mov	r10,0
8000662e:	50 2a       	stdsp	sp[0x8],r10
			inverter_can_msg.data.u64 = 0x00L;
80006630:	30 08       	mov	r8,0
80006632:	30 09       	mov	r9,0
80006634:	fa e9 00 00 	st.d	sp[0],r8
			
			if ( xQueueReceive(queue_to_inverter, &inverter_can_msg,0) == pdTRUE){
80006638:	14 99       	mov	r9,r10
8000663a:	1a 9b       	mov	r11,sp
8000663c:	4a 68       	lddpc	r8,800066d4 <task_spi_can+0x154>
8000663e:	70 0c       	ld.w	r12,r8[0x0]
80006640:	f0 1f 00 26 	mcall	800066d8 <task_spi_can+0x158>
80006644:	58 1c       	cp.w	r12,1
80006646:	c0 c1       	brne	8000665e <task_spi_can+0xde>
				mcp2515_sendCanMessage(&mcp2515_spiModule,inverter_can_msg.dlc,inverter_can_msg.data.u8,INVERTER_ADDR_RX,0);
80006648:	30 08       	mov	r8,0
8000664a:	e0 69 01 00 	mov	r9,256
8000664e:	1a 9a       	mov	r10,sp
80006650:	fb 3b 00 0b 	ld.ub	r11,sp[11]
80006654:	0e 9c       	mov	r12,r7
80006656:	f0 1f 00 22 	mcall	800066dc <task_spi_can+0x15c>
8000665a:	08 98       	mov	r8,r4
8000665c:	c0 28       	rjmp	80006660 <task_spi_can+0xe0>
8000665e:	30 08       	mov	r8,0
				messageSent = true;
			}
		}
		
		if ( TXbuffer1Empty && !messageSent){
80006660:	e2 16 00 08 	andl	r6,0x8,COH
80006664:	c1 a1       	brne	80006698 <task_spi_can+0x118>
80006666:	58 08       	cp.w	r8,0
80006668:	c1 81       	brne	80006698 <task_spi_can+0x118>
			inverter_can_msg.dlc = 0;
8000666a:	30 0a       	mov	r10,0
8000666c:	50 2a       	stdsp	sp[0x8],r10
			inverter_can_msg.data.u64 = 0x00L;
8000666e:	30 08       	mov	r8,0
80006670:	30 09       	mov	r9,0
80006672:	fa e9 00 00 	st.d	sp[0],r8
			
			if (xQueueReceive(queue_to_inverter, & inverter_can_msg,0) == pdTRUE){
80006676:	14 99       	mov	r9,r10
80006678:	1a 9b       	mov	r11,sp
8000667a:	49 78       	lddpc	r8,800066d4 <task_spi_can+0x154>
8000667c:	70 0c       	ld.w	r12,r8[0x0]
8000667e:	f0 1f 00 17 	mcall	800066d8 <task_spi_can+0x158>
80006682:	58 1c       	cp.w	r12,1
80006684:	c0 a1       	brne	80006698 <task_spi_can+0x118>
				mcp2515_sendCanMessage(&mcp2515_spiModule,inverter_can_msg.dlc,inverter_can_msg.data.u8,INVERTER_ADDR_RX,1);
80006686:	08 98       	mov	r8,r4
80006688:	e0 69 01 00 	mov	r9,256
8000668c:	1a 9a       	mov	r10,sp
8000668e:	fb 3b 00 0b 	ld.ub	r11,sp[11]
80006692:	0e 9c       	mov	r12,r7
80006694:	f0 1f 00 12 	mcall	800066dc <task_spi_can+0x15c>
				messageSent = true;
			}
		}
		gpio_toggle_pin(LED3);
80006698:	35 1c       	mov	r12,81
8000669a:	f0 1f 00 0b 	mcall	800066c4 <task_spi_can+0x144>
		portENTER_CRITICAL();
8000669e:	f0 1f 00 11 	mcall	800066e0 <task_spi_can+0x160>
		*pxTaskHasExecuted = pdTRUE;
800066a2:	85 04       	st.w	r2[0x0],r4
		portEXIT_CRITICAL();
800066a4:	f0 1f 00 10 	mcall	800066e4 <task_spi_can+0x164>
	}
800066a8:	c7 bb       	rjmp	8000659e <task_spi_can+0x1e>
800066aa:	00 00       	add	r0,r0
800066ac:	80 00       	ld.sh	r0,r0[0x0]
800066ae:	5b 18       	cp.w	r8,-15
800066b0:	00 00       	add	r0,r0
800066b2:	d0 2c       	*unknown*
800066b4:	80 00       	ld.sh	r0,r0[0x0]
800066b6:	33 2c       	mov	r12,50
800066b8:	80 00       	ld.sh	r0,r0[0x0]
800066ba:	5e 14       	retne	r4
800066bc:	80 00       	ld.sh	r0,r0[0x0]
800066be:	69 90       	ld.w	r0,r4[0x64]
800066c0:	80 00       	ld.sh	r0,r0[0x0]
800066c2:	32 48       	mov	r8,36
800066c4:	80 00       	ld.sh	r0,r0[0x0]
800066c6:	69 d2       	ld.w	r2,r4[0x74]
800066c8:	80 00       	ld.sh	r0,r0[0x0]
800066ca:	33 a8       	mov	r8,58
800066cc:	00 00       	add	r0,r0
800066ce:	cf 58       	rjmp	800068b8 <gpio_configure_pin+0x58>
800066d0:	80 00       	ld.sh	r0,r0[0x0]
800066d2:	2e 88       	sub	r8,-24
800066d4:	00 00       	add	r0,r0
800066d6:	cf 64       	brge	800066c2 <task_spi_can+0x142>
800066d8:	80 00       	ld.sh	r0,r0[0x0]
800066da:	2d 6c       	sub	r12,-42
800066dc:	80 00       	ld.sh	r0,r0[0x0]
800066de:	34 00       	mov	r0,64
800066e0:	80 00       	ld.sh	r0,r0[0x0]
800066e2:	58 48       	cp.w	r8,4
800066e4:	80 00       	ld.sh	r0,r0[0x0]
800066e6:	59 54       	cp.w	r4,21

800066e8 <task_main>:
		gpio_toggle_pin(LED2);
	}
}


static portTASK_FUNCTION( task_main, pvParameters ) {	
800066e8:	eb cd 40 fe 	pushm	r1-r7,lr
800066ec:	20 1d       	sub	sp,4
800066ee:	18 94       	mov	r4,r12
	volatile signed portBASE_TYPE *pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
	ecu_can_inverter_disable_drive();
800066f0:	f0 1f 00 14 	mcall	80006740 <task_main+0x58>
	portTickType first_run = xTaskGetTickCount();
800066f4:	f0 1f 00 14 	mcall	80006744 <task_main+0x5c>
800066f8:	fa c5 ff fc 	sub	r5,sp,-4
800066fc:	0a dc       	st.w	--r5,r12
	while(1) {
		vTaskDelayUntil(&first_run, TASK_MAIN_PERIOD);
800066fe:	31 43       	mov	r3,20
		/* Run state machine */
		ecu_data.state = fsm_ecu_run_state(ecu_data.state, &ecu_data);
80006700:	49 26       	lddpc	r6,80006748 <task_main+0x60>
		data_timer = get_and_send_periodic_data(&ecu_data, data_timer);
80006702:	49 37       	lddpc	r7,8000674c <task_main+0x64>
	
		portENTER_CRITICAL();
		data_timer++;
		*pxTaskHasExecuted = pdTRUE;
80006704:	30 12       	mov	r2,1
		portEXIT_CRITICAL();	
		gpio_toggle_pin(LED4);
80006706:	35 01       	mov	r1,80
static portTASK_FUNCTION( task_main, pvParameters ) {	
	volatile signed portBASE_TYPE *pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
	ecu_can_inverter_disable_drive();
	portTickType first_run = xTaskGetTickCount();
	while(1) {
		vTaskDelayUntil(&first_run, TASK_MAIN_PERIOD);
80006708:	06 9b       	mov	r11,r3
8000670a:	1a 9c       	mov	r12,sp
8000670c:	f0 1f 00 11 	mcall	80006750 <task_main+0x68>
		/* Run state machine */
		ecu_data.state = fsm_ecu_run_state(ecu_data.state, &ecu_data);
80006710:	0c 9b       	mov	r11,r6
80006712:	6c 0c       	ld.w	r12,r6[0x0]
80006714:	f0 1f 00 10 	mcall	80006754 <task_main+0x6c>
80006718:	8d 0c       	st.w	r6[0x0],r12
		data_timer = get_and_send_periodic_data(&ecu_data, data_timer);
8000671a:	8e 0b       	ld.sh	r11,r7[0x0]
8000671c:	5c 7b       	castu.h	r11
8000671e:	0c 9c       	mov	r12,r6
80006720:	f0 1f 00 0e 	mcall	80006758 <task_main+0x70>
80006724:	ae 0c       	st.h	r7[0x0],r12
	
		portENTER_CRITICAL();
80006726:	f0 1f 00 0e 	mcall	8000675c <task_main+0x74>
		data_timer++;
8000672a:	8e 08       	ld.sh	r8,r7[0x0]
8000672c:	2f f8       	sub	r8,-1
8000672e:	ae 08       	st.h	r7[0x0],r8
		*pxTaskHasExecuted = pdTRUE;
80006730:	89 02       	st.w	r4[0x0],r2
		portEXIT_CRITICAL();	
80006732:	f0 1f 00 0c 	mcall	80006760 <task_main+0x78>
		gpio_toggle_pin(LED4);
80006736:	02 9c       	mov	r12,r1
80006738:	f0 1f 00 0b 	mcall	80006764 <task_main+0x7c>
8000673c:	ce 6b       	rjmp	80006708 <task_main+0x20>
8000673e:	00 00       	add	r0,r0
80006740:	80 00       	ld.sh	r0,r0[0x0]
80006742:	2b 38       	sub	r8,-77
80006744:	80 00       	ld.sh	r0,r0[0x0]
80006746:	5b 18       	cp.w	r8,-15
80006748:	00 00       	add	r0,r0
8000674a:	cf 94       	brge	8000673c <task_main+0x54>
8000674c:	00 00       	add	r0,r0
8000674e:	01 e4       	ld.ub	r4,r0[0x6]
80006750:	80 00       	ld.sh	r0,r0[0x0]
80006752:	5e 14       	retne	r4
80006754:	80 00       	ld.sh	r0,r0[0x0]
80006756:	36 14       	mov	r4,97
80006758:	80 00       	ld.sh	r0,r0[0x0]
8000675a:	61 9c       	ld.w	r12,r0[0x64]
8000675c:	80 00       	ld.sh	r0,r0[0x0]
8000675e:	58 48       	cp.w	r8,4
80006760:	80 00       	ld.sh	r0,r0[0x0]
80006762:	59 54       	cp.w	r4,21
80006764:	80 00       	ld.sh	r0,r0[0x0]
80006766:	69 d2       	ld.w	r2,r4[0x74]

80006768 <flashc_set_wait_state>:
}


void flashc_set_wait_state(unsigned int wait_state)
{
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
80006768:	fe 68 00 00 	mov	r8,-131072
8000676c:	70 09       	ld.w	r9,r8[0x0]
	u_avr32_flashc_fcr.FCR.fws = wait_state;
8000676e:	f3 dc d0 c1 	bfins	r9,r12,0x6,0x1
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
80006772:	91 09       	st.w	r8[0x0],r9
}
80006774:	5e fc       	retal	r12
80006776:	d7 03       	nop

80006778 <flashc_set_bus_freq>:


void flashc_set_bus_freq(unsigned int cpu_f_hz)
{
80006778:	d4 01       	pushm	lr
	if (cpu_f_hz >= AVR32_FLASHC_FWS_0_MAX_FREQ) {
8000677a:	e0 68 8a 3f 	mov	r8,35391
8000677e:	ea 18 01 f7 	orh	r8,0x1f7
80006782:	10 3c       	cp.w	r12,r8
80006784:	e0 88 00 06 	brls	80006790 <flashc_set_bus_freq+0x18>
		// Set 1 WS.
		flashc_set_wait_state(1);
80006788:	30 1c       	mov	r12,1
8000678a:	f0 1f 00 04 	mcall	80006798 <flashc_set_bus_freq+0x20>
8000678e:	d8 02       	popm	pc
	} else {
		// Set 0 WS.
		flashc_set_wait_state(0);
80006790:	30 0c       	mov	r12,0
80006792:	f0 1f 00 02 	mcall	80006798 <flashc_set_bus_freq+0x20>
80006796:	d8 02       	popm	pc
80006798:	80 00       	ld.sh	r0,r0[0x0]
8000679a:	67 68       	ld.w	r8,r3[0x58]

8000679c <gpio_enable_module_pin>:
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
8000679c:	f8 08 16 05 	lsr	r8,r12,0x5
800067a0:	a9 78       	lsl	r8,0x9
800067a2:	e0 28 e0 00 	sub	r8,57344

	/* Enable the correct function. */
	switch (function) {
800067a6:	58 7b       	cp.w	r11,7
800067a8:	e0 8b 00 05 	brhi	800067b2 <gpio_enable_module_pin+0x16>
800067ac:	4a 09       	lddpc	r9,8000682c <gpio_enable_module_pin+0x90>
800067ae:	f2 0b 03 2f 	ld.w	pc,r9[r11<<0x2]
800067b2:	5e ff       	retal	1
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800067b4:	30 19       	mov	r9,1
800067b6:	f2 0c 09 49 	lsl	r9,r9,r12
800067ba:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800067bc:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
800067be:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
800067c0:	c3 18       	rjmp	80006822 <gpio_enable_module_pin+0x86>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800067c2:	30 19       	mov	r9,1
800067c4:	f2 0c 09 49 	lsl	r9,r9,r12
800067c8:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800067ca:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
800067cc:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
800067ce:	c2 a8       	rjmp	80006822 <gpio_enable_module_pin+0x86>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800067d0:	30 19       	mov	r9,1
800067d2:	f2 0c 09 49 	lsl	r9,r9,r12
800067d6:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800067d8:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
800067da:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
800067dc:	c2 38       	rjmp	80006822 <gpio_enable_module_pin+0x86>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800067de:	30 19       	mov	r9,1
800067e0:	f2 0c 09 49 	lsl	r9,r9,r12
800067e4:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
800067e6:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
800067e8:	91 e9       	st.w	r8[0x38],r9
#endif
		break;
800067ea:	c1 c8       	rjmp	80006822 <gpio_enable_module_pin+0x86>

#if (AVR32_GPIO_H_VERSION >= 210)
	case 4: /* E function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
800067ec:	30 19       	mov	r9,1
800067ee:	f2 0c 09 49 	lsl	r9,r9,r12
800067f2:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
800067f4:	91 a9       	st.w	r8[0x28],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
800067f6:	91 d9       	st.w	r8[0x34],r9
		break;
800067f8:	c1 58       	rjmp	80006822 <gpio_enable_module_pin+0x86>

	case 5: /* F function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
800067fa:	30 19       	mov	r9,1
800067fc:	f2 0c 09 49 	lsl	r9,r9,r12
80006800:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80006802:	91 a9       	st.w	r8[0x28],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80006804:	91 d9       	st.w	r8[0x34],r9
		break;
80006806:	c0 e8       	rjmp	80006822 <gpio_enable_module_pin+0x86>

	case 6: /* G function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80006808:	30 19       	mov	r9,1
8000680a:	f2 0c 09 49 	lsl	r9,r9,r12
8000680e:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80006810:	91 99       	st.w	r8[0x24],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80006812:	91 d9       	st.w	r8[0x34],r9
		break;
80006814:	c0 78       	rjmp	80006822 <gpio_enable_module_pin+0x86>

	case 7: /* H function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80006816:	30 19       	mov	r9,1
80006818:	f2 0c 09 49 	lsl	r9,r9,r12
8000681c:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
8000681e:	91 99       	st.w	r8[0x24],r9
		gpio_port->pmr2s = 1 << (pin & 0x1F);
80006820:	91 d9       	st.w	r8[0x34],r9
	default:
		return GPIO_INVALID_ARGUMENT;
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80006822:	30 19       	mov	r9,1
80006824:	f2 0c 09 4c 	lsl	r12,r9,r12
80006828:	91 2c       	st.w	r8[0x8],r12
8000682a:	5e fd       	retal	0
8000682c:	80 00       	ld.sh	r0,r0[0x0]
8000682e:	80 9c       	ld.uh	r12,r0[0x2]

80006830 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80006830:	d4 21       	pushm	r4-r7,lr
80006832:	18 97       	mov	r7,r12
80006834:	16 94       	mov	r4,r11
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80006836:	58 0b       	cp.w	r11,0
80006838:	c0 31       	brne	8000683e <gpio_enable_module+0xe>
8000683a:	30 05       	mov	r5,0
8000683c:	c0 d8       	rjmp	80006856 <gpio_enable_module+0x26>
8000683e:	30 06       	mov	r6,0
80006840:	0c 95       	mov	r5,r6
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80006842:	6e 1b       	ld.w	r11,r7[0x4]
80006844:	6e 0c       	ld.w	r12,r7[0x0]
80006846:	f0 1f 00 06 	mcall	8000685c <gpio_enable_module+0x2c>
8000684a:	18 45       	or	r5,r12
		gpiomap++;
8000684c:	2f 87       	sub	r7,-8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
8000684e:	2f f6       	sub	r6,-1
80006850:	0c 34       	cp.w	r4,r6
80006852:	fe 9b ff f8 	brhi	80006842 <gpio_enable_module+0x12>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
}
80006856:	0a 9c       	mov	r12,r5
80006858:	d8 22       	popm	r4-r7,pc
8000685a:	00 00       	add	r0,r0
8000685c:	80 00       	ld.sh	r0,r0[0x0]
8000685e:	67 9c       	ld.w	r12,r3[0x64]

80006860 <gpio_configure_pin>:
 * \param pin The pin number.
 * \param flags The configuration.
 */
void gpio_configure_pin(uint32_t pin, uint32_t flags)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006860:	f8 08 16 05 	lsr	r8,r12,0x5
80006864:	a9 78       	lsl	r8,0x9
80006866:	e0 28 e0 00 	sub	r8,57344

	/* Both pull-up and pull-down set means buskeeper */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	if (flags & GPIO_PULL_DOWN) {
8000686a:	16 99       	mov	r9,r11
8000686c:	e2 19 00 08 	andl	r9,0x8,COH
80006870:	c0 70       	breq	8000687e <gpio_configure_pin+0x1e>
		gpio_port->pders = 1 << (pin & 0x1F);
80006872:	30 19       	mov	r9,1
80006874:	f2 0c 09 49 	lsl	r9,r9,r12
80006878:	f1 49 00 84 	st.w	r8[132],r9
8000687c:	c0 68       	rjmp	80006888 <gpio_configure_pin+0x28>
	} else {
		gpio_port->pderc = 1 << (pin & 0x1F);
8000687e:	30 19       	mov	r9,1
80006880:	f2 0c 09 49 	lsl	r9,r9,r12
80006884:	f1 49 00 88 	st.w	r8[136],r9
	}

#endif
	if (flags & GPIO_PULL_UP) {
80006888:	16 99       	mov	r9,r11
8000688a:	e2 19 00 04 	andl	r9,0x4,COH
8000688e:	c0 70       	breq	8000689c <gpio_configure_pin+0x3c>
		gpio_port->puers = 1 << (pin & 0x1F);
80006890:	30 19       	mov	r9,1
80006892:	f2 0c 09 49 	lsl	r9,r9,r12
80006896:	f1 49 00 74 	st.w	r8[116],r9
8000689a:	c0 68       	rjmp	800068a6 <gpio_configure_pin+0x46>
	} else {
		gpio_port->puerc = 1 << (pin & 0x1F);
8000689c:	30 19       	mov	r9,1
8000689e:	f2 0c 09 49 	lsl	r9,r9,r12
800068a2:	f1 49 00 78 	st.w	r8[120],r9
	}

	/* Enable open-drain mode if requested */
#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	if (flags & GPIO_OPEN_DRAIN) {
800068a6:	16 99       	mov	r9,r11
800068a8:	e2 19 00 40 	andl	r9,0x40,COH
800068ac:	c0 70       	breq	800068ba <gpio_configure_pin+0x5a>
		gpio_port->odmers = 1 << (pin & 0x1F);
800068ae:	30 19       	mov	r9,1
800068b0:	f2 0c 09 49 	lsl	r9,r9,r12
800068b4:	f1 49 00 e4 	st.w	r8[228],r9
800068b8:	c0 68       	rjmp	800068c4 <gpio_configure_pin+0x64>
	} else {
		gpio_port->odmerc = 1 << (pin & 0x1F);
800068ba:	30 19       	mov	r9,1
800068bc:	f2 0c 09 49 	lsl	r9,r9,r12
800068c0:	f1 49 00 e8 	st.w	r8[232],r9
#endif

#if defined(AVR32_GPIO_200_H_INCLUDED) || defined(AVR32_GPIO_210_H_INCLUDED) ||	\
	defined(AVR32_GPIO_212_H_INCLUDED)
	/* Select drive strength */
	if (flags & GPIO_DRIVE_LOW) {
800068c4:	16 99       	mov	r9,r11
800068c6:	e2 19 00 10 	andl	r9,0x10,COH
800068ca:	c0 70       	breq	800068d8 <gpio_configure_pin+0x78>
		gpio_port->odcr0s = 1 << (pin & 0x1F);
800068cc:	30 19       	mov	r9,1
800068ce:	f2 0c 09 49 	lsl	r9,r9,r12
800068d2:	f1 49 01 04 	st.w	r8[260],r9
800068d6:	c0 68       	rjmp	800068e2 <gpio_configure_pin+0x82>
	} else {
		gpio_port->odcr0c = 1 << (pin & 0x1F);
800068d8:	30 19       	mov	r9,1
800068da:	f2 0c 09 49 	lsl	r9,r9,r12
800068de:	f1 49 01 08 	st.w	r8[264],r9
	}

	if (flags & GPIO_DRIVE_HIGH) {
800068e2:	16 99       	mov	r9,r11
800068e4:	e2 19 00 20 	andl	r9,0x20,COH
800068e8:	c0 70       	breq	800068f6 <gpio_configure_pin+0x96>
		gpio_port->odcr1s = 1 << (pin & 0x1F);
800068ea:	30 19       	mov	r9,1
800068ec:	f2 0c 09 49 	lsl	r9,r9,r12
800068f0:	f1 49 01 14 	st.w	r8[276],r9
800068f4:	c0 68       	rjmp	80006900 <gpio_configure_pin+0xa0>
	} else {
		gpio_port->odcr1c = 1 << (pin & 0x1F);
800068f6:	30 19       	mov	r9,1
800068f8:	f2 0c 09 49 	lsl	r9,r9,r12
800068fc:	f1 49 01 18 	st.w	r8[280],r9
	}

#endif

	/* Select interrupt level for group */
	if (flags & GPIO_INTERRUPT) {
80006900:	16 99       	mov	r9,r11
80006902:	e2 19 00 80 	andl	r9,0x80,COH
80006906:	c2 40       	breq	8000694e <gpio_configure_pin+0xee>
		if (flags & GPIO_BOTHEDGES) {
80006908:	16 99       	mov	r9,r11
8000690a:	e2 19 01 80 	andl	r9,0x180,COH
8000690e:	c0 90       	breq	80006920 <gpio_configure_pin+0xc0>
			gpio_port->imr0c = 1 << (pin & 0x1F);
80006910:	30 19       	mov	r9,1
80006912:	f2 0c 09 49 	lsl	r9,r9,r12
80006916:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
8000691a:	f1 49 00 b8 	st.w	r8[184],r9
8000691e:	c1 88       	rjmp	8000694e <gpio_configure_pin+0xee>
		} else if (flags & GPIO_RISING) {
80006920:	16 99       	mov	r9,r11
80006922:	e2 19 02 80 	andl	r9,0x280,COH
80006926:	c0 90       	breq	80006938 <gpio_configure_pin+0xd8>
			gpio_port->imr0s = 1 << (pin & 0x1F);
80006928:	30 19       	mov	r9,1
8000692a:	f2 0c 09 49 	lsl	r9,r9,r12
8000692e:	f1 49 00 a4 	st.w	r8[164],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
80006932:	f1 49 00 b8 	st.w	r8[184],r9
80006936:	c0 c8       	rjmp	8000694e <gpio_configure_pin+0xee>
		} else if (flags & GPIO_FALLING) {
80006938:	16 99       	mov	r9,r11
8000693a:	e2 19 03 80 	andl	r9,0x380,COH
8000693e:	c0 80       	breq	8000694e <gpio_configure_pin+0xee>
			gpio_port->imr0c = 1 << (pin & 0x1F);
80006940:	30 19       	mov	r9,1
80006942:	f2 0c 09 49 	lsl	r9,r9,r12
80006946:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1s = 1 << (pin & 0x1F);
8000694a:	f1 49 00 b4 	st.w	r8[180],r9
		}
	}

	/* Select direction and initial pin state */
	if (flags & GPIO_DIR_OUTPUT) {
8000694e:	f3 db c0 01 	bfextu	r9,r11,0x0,0x1
80006952:	c1 50       	breq	8000697c <gpio_configure_pin+0x11c>
		if (flags & GPIO_INIT_HIGH) {
80006954:	e2 1b 00 02 	andl	r11,0x2,COH
80006958:	c0 70       	breq	80006966 <gpio_configure_pin+0x106>
			gpio_port->ovrs = 1 << (pin & 0x1F);
8000695a:	30 19       	mov	r9,1
8000695c:	f2 0c 09 49 	lsl	r9,r9,r12
80006960:	f1 49 00 54 	st.w	r8[84],r9
80006964:	c0 68       	rjmp	80006970 <gpio_configure_pin+0x110>
		} else {
			gpio_port->ovrc = 1 << (pin & 0x1F);
80006966:	30 19       	mov	r9,1
80006968:	f2 0c 09 49 	lsl	r9,r9,r12
8000696c:	f1 49 00 58 	st.w	r8[88],r9
		}

		gpio_port->oders = 1 << (pin & 0x1F);
80006970:	30 19       	mov	r9,1
80006972:	f2 0c 09 49 	lsl	r9,r9,r12
80006976:	f1 49 00 44 	st.w	r8[68],r9
8000697a:	c0 68       	rjmp	80006986 <gpio_configure_pin+0x126>
	} else {
		gpio_port->oderc = 1 << (pin & 0x1F);
8000697c:	30 19       	mov	r9,1
8000697e:	f2 0c 09 49 	lsl	r9,r9,r12
80006982:	f1 49 00 48 	st.w	r8[72],r9
	}

	/* Enable GPIO */
	gpio_port->gpers = 1 << (pin & 0x1F);
80006986:	30 19       	mov	r9,1
80006988:	f2 0c 09 4c 	lsl	r12,r9,r12
8000698c:	91 1c       	st.w	r8[0x4],r12
}
8000698e:	5e fc       	retal	r12

80006990 <gpio_get_pin_value>:
 *
 * \return The pin value.
 */
bool gpio_get_pin_value(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80006990:	f8 08 16 05 	lsr	r8,r12,0x5
80006994:	a9 78       	lsl	r8,0x9
80006996:	e0 28 e0 00 	sub	r8,57344
	
	return (gpio_port->pvr >> (pin & 0x1F)) & 1;
8000699a:	71 88       	ld.w	r8,r8[0x60]
8000699c:	f0 0c 0a 4c 	lsr	r12,r8,r12
}
800069a0:	f9 dc c0 01 	bfextu	r12,r12,0x0,0x1
800069a4:	5e fc       	retal	r12

800069a6 <gpio_set_pin_high>:
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_set_pin_high(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800069a6:	f8 08 16 05 	lsr	r8,r12,0x5
800069aa:	a9 78       	lsl	r8,0x9
800069ac:	e0 28 e0 00 	sub	r8,57344
	
	/* Value to be driven on the I/O line: 1. */
	gpio_port->ovrs  = 1 << (pin & 0x1F);
800069b0:	30 19       	mov	r9,1
800069b2:	f2 0c 09 4c 	lsl	r12,r9,r12
800069b6:	f1 4c 00 54 	st.w	r8[84],r12
}
800069ba:	5e fc       	retal	r12

800069bc <gpio_set_pin_low>:
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_set_pin_low(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800069bc:	f8 08 16 05 	lsr	r8,r12,0x5
800069c0:	a9 78       	lsl	r8,0x9
800069c2:	e0 28 e0 00 	sub	r8,57344
	
	/* Value to be driven on the I/O line: 0. */
	gpio_port->ovrc  = 1 << (pin & 0x1F);
800069c6:	30 19       	mov	r9,1
800069c8:	f2 0c 09 4c 	lsl	r12,r9,r12
800069cc:	f1 4c 00 58 	st.w	r8[88],r12
}
800069d0:	5e fc       	retal	r12

800069d2 <gpio_toggle_pin>:
 *
 * \note The function \ref gpio_configure_pin must be called before.
 */
void gpio_toggle_pin(uint32_t pin)
{
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
800069d2:	f8 08 16 05 	lsr	r8,r12,0x5
800069d6:	a9 78       	lsl	r8,0x9
800069d8:	e0 28 e0 00 	sub	r8,57344
	
	/* Toggle the I/O line. */
	gpio_port->ovrt  = 1 << (pin & 0x1F);
800069dc:	30 19       	mov	r9,1
800069de:	f2 0c 09 4c 	lsl	r12,r9,r12
800069e2:	f1 4c 00 5c 	st.w	r8[92],r12
}
800069e6:	5e fc       	retal	r12

800069e8 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
800069e8:	c0 08       	rjmp	800069e8 <_unhandled_interrupt>
800069ea:	d7 03       	nop

800069ec <INTC_register_interrupt>:
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
800069ec:	f6 08 16 05 	lsr	r8,r11,0x5

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
800069f0:	49 99       	lddpc	r9,80006a54 <INTC_register_interrupt+0x68>
800069f2:	f2 08 00 39 	add	r9,r9,r8<<0x3
800069f6:	f7 db c0 05 	bfextu	r11,r11,0x0,0x5
800069fa:	72 19       	ld.w	r9,r9[0x4]
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
800069fc:	f2 0b 09 2c 	st.w	r9[r11<<0x2],r12
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80006a00:	58 0a       	cp.w	r10,0
80006a02:	c0 91       	brne	80006a14 <INTC_register_interrupt+0x28>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006a04:	49 59       	lddpc	r9,80006a58 <INTC_register_interrupt+0x6c>
80006a06:	49 6a       	lddpc	r10,80006a5c <INTC_register_interrupt+0x70>
80006a08:	12 1a       	sub	r10,r9
80006a0a:	fe 79 00 00 	mov	r9,-65536
80006a0e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006a12:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT1) {
80006a14:	58 1a       	cp.w	r10,1
80006a16:	c0 a1       	brne	80006a2a <INTC_register_interrupt+0x3e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80006a18:	49 09       	lddpc	r9,80006a58 <INTC_register_interrupt+0x6c>
80006a1a:	49 2a       	lddpc	r10,80006a60 <INTC_register_interrupt+0x74>
80006a1c:	12 1a       	sub	r10,r9
80006a1e:	bf aa       	sbr	r10,0x1e
80006a20:	fe 79 00 00 	mov	r9,-65536
80006a24:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006a28:	5e fc       	retal	r12
	} else if (int_level == AVR32_INTC_INT2) {
80006a2a:	58 2a       	cp.w	r10,2
80006a2c:	c0 a1       	brne	80006a40 <INTC_register_interrupt+0x54>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80006a2e:	48 b9       	lddpc	r9,80006a58 <INTC_register_interrupt+0x6c>
80006a30:	48 da       	lddpc	r10,80006a64 <INTC_register_interrupt+0x78>
80006a32:	12 1a       	sub	r10,r9
80006a34:	bf ba       	sbr	r10,0x1f
80006a36:	fe 79 00 00 	mov	r9,-65536
80006a3a:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006a3e:	5e fc       	retal	r12
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80006a40:	48 69       	lddpc	r9,80006a58 <INTC_register_interrupt+0x6c>
80006a42:	48 aa       	lddpc	r10,80006a68 <INTC_register_interrupt+0x7c>
80006a44:	12 1a       	sub	r10,r9
80006a46:	ea 1a c0 00 	orh	r10,0xc000
80006a4a:	fe 79 00 00 	mov	r9,-65536
80006a4e:	f2 08 09 2a 	st.w	r9[r8<<0x2],r10
80006a52:	5e fc       	retal	r12
80006a54:	80 00       	ld.sh	r0,r0[0x0]
80006a56:	80 bc       	ld.uh	r12,r0[0x6]
80006a58:	80 00       	ld.sh	r0,r0[0x0]
80006a5a:	7e 00       	ld.w	r0,pc[0x0]
80006a5c:	80 00       	ld.sh	r0,r0[0x0]
80006a5e:	7f 04       	ld.w	r4,pc[0x40]
80006a60:	80 00       	ld.sh	r0,r0[0x0]
80006a62:	7f 12       	ld.w	r2,pc[0x44]
80006a64:	80 00       	ld.sh	r0,r0[0x0]
80006a66:	7f 20       	ld.w	r0,pc[0x48]
80006a68:	80 00       	ld.sh	r0,r0[0x0]
80006a6a:	7f 2e       	ld.w	lr,pc[0x48]

80006a6c <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80006a6c:	d4 21       	pushm	r4-r7,lr
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80006a6e:	49 18       	lddpc	r8,80006ab0 <INTC_init_interrupts+0x44>
80006a70:	e3 b8 00 01 	mtsr	0x4,r8
80006a74:	49 0e       	lddpc	lr,80006ab4 <INTC_init_interrupts+0x48>
80006a76:	30 07       	mov	r7,0
80006a78:	0e 94       	mov	r4,r7
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80006a7a:	49 0c       	lddpc	r12,80006ab8 <INTC_init_interrupts+0x4c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006a7c:	49 05       	lddpc	r5,80006abc <INTC_init_interrupts+0x50>
80006a7e:	10 15       	sub	r5,r8
80006a80:	fe 76 00 00 	mov	r6,-65536
80006a84:	c1 18       	rjmp	80006aa6 <INTC_init_interrupts+0x3a>
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80006a86:	08 98       	mov	r8,r4
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80006a88:	7c 1b       	ld.w	r11,lr[0x4]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006a8a:	7c 0a       	ld.w	r10,lr[0x0]
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80006a8c:	f6 08 09 2c 	st.w	r11[r8<<0x2],r12
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80006a90:	2f f8       	sub	r8,-1

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006a92:	10 3a       	cp.w	r10,r8
80006a94:	fe 9b ff fc 	brhi	80006a8c <INTC_init_interrupts+0x20>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80006a98:	ec 07 09 25 	st.w	r6[r7<<0x2],r5
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80006a9c:	2f f7       	sub	r7,-1
80006a9e:	2f 8e       	sub	lr,-8
80006aa0:	e0 47 00 2f 	cp.w	r7,47
80006aa4:	c0 50       	breq	80006aae <INTC_init_interrupts+0x42>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80006aa6:	7c 08       	ld.w	r8,lr[0x0]
80006aa8:	58 08       	cp.w	r8,0
80006aaa:	ce e1       	brne	80006a86 <INTC_init_interrupts+0x1a>
80006aac:	cf 6b       	rjmp	80006a98 <INTC_init_interrupts+0x2c>
80006aae:	d8 22       	popm	r4-r7,pc
80006ab0:	80 00       	ld.sh	r0,r0[0x0]
80006ab2:	7e 00       	ld.w	r0,pc[0x0]
80006ab4:	80 00       	ld.sh	r0,r0[0x0]
80006ab6:	80 bc       	ld.uh	r12,r0[0x6]
80006ab8:	80 00       	ld.sh	r0,r0[0x0]
80006aba:	69 e8       	ld.w	r8,r4[0x78]
80006abc:	80 00       	ld.sh	r0,r0[0x0]
80006abe:	7f 04       	ld.w	r4,pc[0x40]

80006ac0 <_get_interrupt_handler>:
__int_handler _get_interrupt_handler(uint32_t int_level)
{
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80006ac0:	fe 78 00 00 	mov	r8,-65536
80006ac4:	e0 69 00 83 	mov	r9,131
80006ac8:	f2 0c 01 0c 	sub	r12,r9,r12
80006acc:	f0 0c 03 29 	ld.w	r9,r8[r12<<0x2]
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80006ad0:	f2 ca ff c0 	sub	r10,r9,-64
80006ad4:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80006ad8:	58 08       	cp.w	r8,0
80006ada:	c0 21       	brne	80006ade <_get_interrupt_handler+0x1e>
80006adc:	5e fd       	retal	0
		? _int_handler_table[int_grp]._int_line_handler_table[32
80006ade:	f0 08 12 00 	clz	r8,r8
80006ae2:	48 5a       	lddpc	r10,80006af4 <_get_interrupt_handler+0x34>
80006ae4:	f4 09 00 39 	add	r9,r10,r9<<0x3
80006ae8:	f0 08 11 1f 	rsub	r8,r8,31
80006aec:	72 19       	ld.w	r9,r9[0x4]
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80006aee:	f2 08 03 2c 	ld.w	r12,r9[r8<<0x2]
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80006af2:	5e fc       	retal	r12
80006af4:	80 00       	ld.sh	r0,r0[0x0]
80006af6:	80 bc       	ld.uh	r12,r0[0x6]

80006af8 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80006af8:	e0 7d 00 00 	mov	sp,65536

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80006afc:	fe c0 ec fc 	sub	r0,pc,-4868

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80006b00:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80006b04:	d5 53       	csrf	0x15
  cp      r0, r1
80006b06:	30 40       	mov	r0,4
  brhs    idata_load_loop_end
80006b08:	e0 61 04 00 	mov	r1,1024
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80006b0c:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80006b0e:	c0 72       	brcc	80006b1c <idata_load_loop_end>
  cp      r0, r1
80006b10:	fe c2 e8 d8 	sub	r2,pc,-5928

80006b14 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80006b14:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80006b16:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80006b18:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80006b1a:	cf d3       	brcs	80006b14 <idata_load_loop>

80006b1c <idata_load_loop_end>:
  mov     r2, 0
80006b1c:	e0 60 04 00 	mov	r0,1024
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80006b20:	e0 61 d0 30 	mov	r1,53296
  cp      r0, r1
  brlo    udata_clear_loop
80006b24:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80006b26:	c0 62       	brcc	80006b32 <udata_clear_loop_end>
80006b28:	30 02       	mov	r2,0
80006b2a:	30 03       	mov	r3,0

80006b2c <udata_clear_loop>:
80006b2c:	a1 22       	st.d	r0++,r2
80006b2e:	02 30       	cp.w	r0,r1
80006b30:	cf e3       	brcs	80006b2c <udata_clear_loop>

80006b32 <udata_clear_loop_end>:
80006b32:	fe cf 08 2a 	sub	pc,pc,2090
80006b36:	d7 03       	nop

80006b38 <osc_priv_enable_rc120m>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006b38:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006b3c:	d3 03       	ssrf	0x10
void osc_priv_enable_rc120m(void)
{
	irqflags_t flags;

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_RC120MCR;
80006b3e:	fe 78 08 00 	mov	r8,-63488
80006b42:	35 8a       	mov	r10,88
80006b44:	ea 1a aa 00 	orh	r10,0xaa00
80006b48:	91 6a       	st.w	r8[0x18],r10
	AVR32_SCIF.rc120mcr = 1U << AVR32_SCIF_RC120MCR_EN;
80006b4a:	30 1a       	mov	r10,1
80006b4c:	f1 4a 00 58 	st.w	r8[88],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006b50:	12 98       	mov	r8,r9
80006b52:	e6 18 00 01 	andh	r8,0x1,COH
80006b56:	c0 21       	brne	80006b5a <osc_priv_enable_rc120m+0x22>
      cpu_irq_enable();
80006b58:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
80006b5a:	5e fc       	retal	r12

80006b5c <osc_priv_enable_rc8m>:
{
	irqflags_t flags;
	uint32_t   rccr8;
    uint32_t* calibration_bits = (uint32_t*)0x80800200;
	/* Wait for the CALIB field to be updated from fuses after reset */
	while (!(AVR32_SCIF.rccr8 & AVR32_SCIF_RCCR8_FCD_MASK)) {
80006b5c:	fe 79 08 00 	mov	r9,-63488
80006b60:	73 28       	ld.w	r8,r9[0x48]
80006b62:	e6 18 00 01 	andh	r8,0x1,COH
80006b66:	cf d0       	breq	80006b60 <osc_priv_enable_rc8m+0x4>

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006b68:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006b6c:	d3 03       	ssrf	0x10
		/* Do nothing */
	}

	/* Enable the oscillator without touching the CALIB and FCD fields */
	flags = cpu_irq_save();
	rccr8 = AVR32_SCIF.rccr8;
80006b6e:	fe 78 08 00 	mov	r8,-63488
80006b72:	71 2b       	ld.w	r11,r8[0x48]
	rccr8 &= AVR32_SCIF_RCCR8_FCD_MASK | ((*calibration_bits)&AVR32_SCIF_RCCR8_CALIB_MASK);
80006b74:	e0 6a 02 00 	mov	r10,512
80006b78:	ea 1a 80 80 	orh	r10,0x8080
80006b7c:	15 ba       	ld.ub	r10,r10[0x3]
80006b7e:	b1 aa       	sbr	r10,0x10
80006b80:	16 6a       	and	r10,r11
	rccr8 |= 1U << AVR32_SCIF_RCOSC8_EN;
80006b82:	b9 aa       	sbr	r10,0x18
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_RCCR8;
80006b84:	34 8b       	mov	r11,72
80006b86:	ea 1b aa 00 	orh	r11,0xaa00
80006b8a:	91 6b       	st.w	r8[0x18],r11
	AVR32_SCIF.rccr8 = rccr8;
80006b8c:	f1 4a 00 48 	st.w	r8[72],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006b90:	12 98       	mov	r8,r9
80006b92:	e6 18 00 01 	andh	r8,0x1,COH
80006b96:	c0 21       	brne	80006b9a <osc_priv_enable_rc8m+0x3e>
      cpu_irq_enable();
80006b98:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
80006b9a:	5e fc       	retal	r12

80006b9c <osc_priv_enable_osc32>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006b9c:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006ba0:	d3 03       	ssrf	0x10
void osc_priv_enable_osc32(void)
{
	irqflags_t flags;

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_OSCCTRL32;
80006ba2:	fe 78 08 00 	mov	r8,-63488
80006ba6:	34 ca       	mov	r10,76
80006ba8:	ea 1a aa 00 	orh	r10,0xaa00
80006bac:	91 6a       	st.w	r8[0x18],r10
	AVR32_SCIF.oscctrl32 =
80006bae:	e2 6a 01 01 	mov	r10,131329
80006bb2:	f1 4a 00 4c 	st.w	r8[76],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006bb6:	12 98       	mov	r8,r9
80006bb8:	e6 18 00 01 	andh	r8,0x1,COH
80006bbc:	c0 21       	brne	80006bc0 <osc_priv_enable_osc32+0x24>
      cpu_irq_enable();
80006bbe:	d5 03       	csrf	0x10
			(OSC32_STARTUP_VALUE << AVR32_SCIF_OSCCTRL32_STARTUP)
			| (OSC32_MODE_VALUE << AVR32_SCIF_OSCCTRL32_MODE)
			| (1U << AVR32_SCIF_OSCCTRL32_OSC32EN);
	cpu_irq_restore(flags);
}
80006bc0:	5e fc       	retal	r12

80006bc2 <osc_priv_enable_osc0>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006bc2:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006bc6:	d3 03       	ssrf	0x10
void osc_priv_enable_osc0(void)
{
	irqflags_t flags;

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | AVR32_SCIF_OSCCTRL;
80006bc8:	fe 78 08 00 	mov	r8,-63488
80006bcc:	32 4a       	mov	r10,36
80006bce:	ea 1a aa 00 	orh	r10,0xaa00
80006bd2:	91 6a       	st.w	r8[0x18],r10
	AVR32_SCIF.oscctrl[0] =
80006bd4:	e0 7a 0c 07 	mov	r10,68615
80006bd8:	91 9a       	st.w	r8[0x24],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006bda:	12 98       	mov	r8,r9
80006bdc:	e6 18 00 01 	andh	r8,0x1,COH
80006be0:	c0 21       	brne	80006be4 <osc_priv_enable_osc0+0x22>
      cpu_irq_enable();
80006be2:	d5 03       	csrf	0x10
			(OSC0_STARTUP_VALUE << AVR32_SCIF_OSCCTRL_STARTUP)
			| (OSC0_GAIN_VALUE << AVR32_SCIF_OSCCTRL_GAIN)
			| (OSC0_MODE_VALUE << AVR32_SCIF_OSCCTRL_MODE)
			| (1U << AVR32_SCIF_OSCCTRL_OSCEN);
	cpu_irq_restore(flags);
}
80006be4:	5e fc       	retal	r12

80006be6 <pll_enable>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006be6:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006bea:	d3 03       	ssrf	0x10
	irqflags_t flags;

	Assert(pll_id < NR_PLLS);

	flags = cpu_irq_save();
	AVR32_SCIF.unlock = 0xaa000000 | (AVR32_SCIF_PLL + (4 * pll_id));
80006bec:	2f 9b       	sub	r11,-7
80006bee:	f6 0a 15 02 	lsl	r10,r11,0x2
80006bf2:	ea 1a aa 00 	orh	r10,0xaa00
80006bf6:	fe 78 08 00 	mov	r8,-63488
80006bfa:	91 6a       	st.w	r8[0x18],r10
	AVR32_SCIF.pll[pll_id] = cfg->ctrl | (1U << AVR32_SCIF_PLLEN);
80006bfc:	78 0a       	ld.w	r10,r12[0x0]
80006bfe:	a1 aa       	sbr	r10,0x0
80006c00:	f0 0b 09 2a 	st.w	r8[r11<<0x2],r10
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006c04:	12 98       	mov	r8,r9
80006c06:	e6 18 00 01 	andh	r8,0x1,COH
80006c0a:	c0 21       	brne	80006c0e <pll_enable+0x28>
      cpu_irq_enable();
80006c0c:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
80006c0e:	5e fc       	retal	r12

80006c10 <osc_enable>:
extern void osc_priv_enable_rc120m(void);
extern void osc_priv_disable_rc120m(void);
extern bool osc_priv_rc120m_is_ready(void);

static inline void osc_enable(uint8_t id)
{
80006c10:	d4 01       	pushm	lr
	switch (id) {
80006c12:	30 28       	mov	r8,2
80006c14:	f0 0c 18 00 	cp.b	r12,r8
80006c18:	c1 50       	breq	80006c42 <osc_enable+0x32>
80006c1a:	e0 8b 00 05 	brhi	80006c24 <osc_enable+0x14>
80006c1e:	58 0c       	cp.w	r12,0
80006c20:	c1 61       	brne	80006c4c <osc_enable+0x3c>
80006c22:	c0 a8       	rjmp	80006c36 <osc_enable+0x26>
80006c24:	30 38       	mov	r8,3
80006c26:	f0 0c 18 00 	cp.b	r12,r8
80006c2a:	c0 90       	breq	80006c3c <osc_enable+0x2c>
80006c2c:	30 48       	mov	r8,4
80006c2e:	f0 0c 18 00 	cp.b	r12,r8
80006c32:	c0 d1       	brne	80006c4c <osc_enable+0x3c>
80006c34:	c0 a8       	rjmp	80006c48 <osc_enable+0x38>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		osc_priv_enable_osc0();
80006c36:	f0 1f 00 07 	mcall	80006c50 <osc_enable+0x40>
		break;
80006c3a:	d8 02       	popm	pc
		break;
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		osc_priv_enable_osc32();
80006c3c:	f0 1f 00 06 	mcall	80006c54 <osc_enable+0x44>
		break;
80006c40:	d8 02       	popm	pc
#endif

	case OSC_ID_RC8M:
		osc_priv_enable_rc8m();
80006c42:	f0 1f 00 06 	mcall	80006c58 <osc_enable+0x48>
		break;
80006c46:	d8 02       	popm	pc

	case OSC_ID_RC120M:
		osc_priv_enable_rc120m();
80006c48:	f0 1f 00 05 	mcall	80006c5c <osc_enable+0x4c>
80006c4c:	d8 02       	popm	pc
80006c4e:	00 00       	add	r0,r0
80006c50:	80 00       	ld.sh	r0,r0[0x0]
80006c52:	6b c2       	ld.w	r2,r5[0x70]
80006c54:	80 00       	ld.sh	r0,r0[0x0]
80006c56:	6b 9c       	ld.w	r12,r5[0x64]
80006c58:	80 00       	ld.sh	r0,r0[0x0]
80006c5a:	6b 5c       	ld.w	r12,r5[0x54]
80006c5c:	80 00       	ld.sh	r0,r0[0x0]
80006c5e:	6b 38       	ld.w	r8,r5[0x4c]

80006c60 <sysclk_set_source>:

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006c60:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006c64:	d3 03       	ssrf	0x10
	irqflags_t flags;

	Assert(src <= SYSCLK_SRC_RC120M);

	flags = cpu_irq_save();
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_MCCTRL;
80006c66:	fe 78 04 00 	mov	r8,-64512
80006c6a:	fc 1a aa 00 	movh	r10,0xaa00
80006c6e:	f1 4a 00 58 	st.w	r8[88],r10
	AVR32_PM.mcctrl = src;
80006c72:	91 0c       	st.w	r8[0x0],r12
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006c74:	12 98       	mov	r8,r9
80006c76:	e6 18 00 01 	andh	r8,0x1,COH
80006c7a:	c0 21       	brne	80006c7e <sysclk_set_source+0x1e>
      cpu_irq_enable();
80006c7c:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
80006c7e:	5e fc       	retal	r12

80006c80 <sysclk_set_prescalers>:
 * \param pbc_shift The PBC clock will be divided by \f$2^{pbc\_shift}\f$
 */
void sysclk_set_prescalers(unsigned int cpu_shift,
		unsigned int pba_shift, unsigned int pbb_shift,
		unsigned int pbc_shift)
{
80006c80:	eb cd 40 80 	pushm	r7,lr
	uint32_t   pbc_cksel = 0;

	Assert(cpu_shift <= pba_shift);
	Assert(cpu_shift <= pbb_shift);

	if (cpu_shift > 0)
80006c84:	58 0c       	cp.w	r12,0
80006c86:	c0 30       	breq	80006c8c <sysclk_set_prescalers+0xc>
		cpu_cksel = ((cpu_shift - 1) << AVR32_PM_CPUSEL_CPUSEL)
80006c88:	20 1c       	sub	r12,1
80006c8a:	a7 bc       	sbr	r12,0x7
				| (1U << AVR32_PM_CPUDIV);

	if (pba_shift > 0)
80006c8c:	58 0b       	cp.w	r11,0
80006c8e:	c0 30       	breq	80006c94 <sysclk_set_prescalers+0x14>
		pba_cksel = ((pba_shift - 1) << AVR32_PM_PBASEL_PBSEL)
80006c90:	20 1b       	sub	r11,1
80006c92:	a7 bb       	sbr	r11,0x7
				| (1U << AVR32_PM_PBADIV);

	if (pbb_shift > 0)
80006c94:	58 0a       	cp.w	r10,0
80006c96:	c0 30       	breq	80006c9c <sysclk_set_prescalers+0x1c>
		pbb_cksel = ((pbb_shift - 1) << AVR32_PM_PBBSEL_PBSEL)
80006c98:	20 1a       	sub	r10,1
80006c9a:	a7 ba       	sbr	r10,0x7
				| (1U << AVR32_PM_PBBDIV);

	if (pbc_shift > 0)
80006c9c:	58 09       	cp.w	r9,0
80006c9e:	c0 30       	breq	80006ca4 <sysclk_set_prescalers+0x24>
		pbc_cksel = ((pbc_shift - 1) << AVR32_PM_PBCSEL_PBSEL)
80006ca0:	20 19       	sub	r9,1
80006ca2:	a7 b9       	sbr	r9,0x7

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006ca4:	e1 be 00 00 	mfsr	lr,0x0
	cpu_irq_disable();
80006ca8:	d3 03       	ssrf	0x10
				| (1U << AVR32_PM_PBCDIV);

	flags = cpu_irq_save();
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_CPUSEL;
80006caa:	fe 78 04 00 	mov	r8,-64512
80006cae:	30 47       	mov	r7,4
80006cb0:	ea 17 aa 00 	orh	r7,0xaa00
80006cb4:	f1 47 00 58 	st.w	r8[88],r7
	AVR32_PM.cpusel = cpu_cksel;
80006cb8:	91 1c       	st.w	r8[0x4],r12
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_PBASEL;
80006cba:	30 cc       	mov	r12,12
80006cbc:	ea 1c aa 00 	orh	r12,0xaa00
80006cc0:	f1 4c 00 58 	st.w	r8[88],r12
	AVR32_PM.pbasel = pba_cksel;
80006cc4:	91 3b       	st.w	r8[0xc],r11
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_PBBSEL;
80006cc6:	31 0b       	mov	r11,16
80006cc8:	ea 1b aa 00 	orh	r11,0xaa00
80006ccc:	f1 4b 00 58 	st.w	r8[88],r11
	AVR32_PM.pbbsel = pbb_cksel;
80006cd0:	91 4a       	st.w	r8[0x10],r10
	AVR32_PM.unlock = 0xaa000000 | AVR32_PM_PBCSEL;
80006cd2:	31 4a       	mov	r10,20
80006cd4:	ea 1a aa 00 	orh	r10,0xaa00
80006cd8:	f1 4a 00 58 	st.w	r8[88],r10
	AVR32_PM.pbcsel = pbc_cksel;
80006cdc:	91 59       	st.w	r8[0x14],r9
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006cde:	1c 98       	mov	r8,lr
80006ce0:	e6 18 00 01 	andh	r8,0x1,COH
80006ce4:	c0 21       	brne	80006ce8 <sysclk_set_prescalers+0x68>
      cpu_irq_enable();
80006ce6:	d5 03       	csrf	0x10
	cpu_irq_restore(flags);
}
80006ce8:	e3 cd 80 80 	ldm	sp++,r7,pc

80006cec <sysclk_priv_enable_module>:
 * \param bus_id Bus index, given by the \c AVR32_PM_CLK_GRP_xxx definitions.
 * \param module_index Index of the module to be enabled. This is the
 * bit number in the corresponding xxxMASK register.
 */
void sysclk_priv_enable_module(unsigned int bus_id, unsigned int module_index)
{
80006cec:	d4 01       	pushm	lr

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80006cee:	e1 b9 00 00 	mfsr	r9,0x0
	cpu_irq_disable();
80006cf2:	d3 03       	ssrf	0x10
	uint32_t   mask;

	flags = cpu_irq_save();

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80006cf4:	a3 6c       	lsl	r12,0x2
80006cf6:	fe 7a 04 20 	mov	r10,-64480
80006cfa:	f8 0a 00 08 	add	r8,r12,r10
80006cfe:	70 0a       	ld.w	r10,r8[0x0]
	mask |= 1U << module_index;
80006d00:	30 1e       	mov	lr,1
80006d02:	fc 0b 09 4b 	lsl	r11,lr,r11
80006d06:	14 4b       	or	r11,r10
	AVR32_PM.unlock = 0xaa000020 + (4 * bus_id);
80006d08:	32 0a       	mov	r10,32
80006d0a:	ea 1a aa 00 	orh	r10,0xaa00
80006d0e:	14 0c       	add	r12,r10
80006d10:	fe 7a 04 00 	mov	r10,-64512
80006d14:	f5 4c 00 58 	st.w	r10[88],r12
	*(&AVR32_PM.cpumask + bus_id) = mask;
80006d18:	91 0b       	st.w	r8[0x0],r11
static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80006d1a:	12 98       	mov	r8,r9
80006d1c:	e6 18 00 01 	andh	r8,0x1,COH
80006d20:	c0 21       	brne	80006d24 <sysclk_priv_enable_module+0x38>
      cpu_irq_enable();
80006d22:	d5 03       	csrf	0x10

	cpu_irq_restore(flags);
}
80006d24:	d8 02       	popm	pc
80006d26:	d7 03       	nop

80006d28 <sysclk_init>:
}
#endif // CONFIG_USBCLK_SOURCE


void sysclk_init(void)
{
80006d28:	d4 01       	pushm	lr
80006d2a:	20 1d       	sub	sp,4
	/* Set up system clock dividers if different from defaults */
	if ((CONFIG_SYSCLK_CPU_DIV > 0) || (CONFIG_SYSCLK_PBA_DIV > 0) ||
			(CONFIG_SYSCLK_PBB_DIV > 0) || (CONFIG_SYSCLK_PBC_DIV > 0)) {
		sysclk_set_prescalers(CONFIG_SYSCLK_CPU_DIV,
80006d2c:	30 19       	mov	r9,1
80006d2e:	12 9a       	mov	r10,r9
80006d30:	12 9b       	mov	r11,r9
80006d32:	30 0c       	mov	r12,0
80006d34:	f0 1f 00 1e 	mcall	80006dac <sysclk_init+0x84>

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_SCIF.pclksr & (1U << (AVR32_SCIF_PLL0_LOCK + pll_id)));
80006d38:	fe 78 08 00 	mov	r8,-63488
80006d3c:	70 58       	ld.w	r8,r8[0x14]

static inline void pll_enable_config_defaults(unsigned int pll_id)
{
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
80006d3e:	e2 18 00 10 	andl	r8,0x10,COH
80006d42:	c2 91       	brne	80006d94 <sysclk_init+0x6c>
static inline bool osc_is_ready(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_SCIF.pclksr & (1 << AVR32_SCIF_OSC0RDY));
80006d44:	fe 78 08 00 	mov	r8,-63488
80006d48:	70 58       	ld.w	r8,r8[0x14]

static inline void pll_enable_source(enum pll_source src)
{
	switch (src) {
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
80006d4a:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d4e:	c0 a1       	brne	80006d62 <sysclk_init+0x3a>
			osc_enable(OSC_ID_OSC0);
80006d50:	30 0c       	mov	r12,0
80006d52:	f0 1f 00 18 	mcall	80006db0 <sysclk_init+0x88>
80006d56:	fe 79 08 00 	mov	r9,-63488
80006d5a:	72 58       	ld.w	r8,r9[0x14]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
80006d5c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80006d60:	cf d0       	breq	80006d5a <sysclk_init+0x32>
static inline void pll_config_set_option(struct pll_config *cfg,
		unsigned int option)
{
	Assert(option < PLL_NR_OPTIONS);

	cfg->ctrl |= 1U << (AVR32_SCIF_PLLOPT + option);
80006d62:	31 08       	mov	r8,16
80006d64:	a3 b8       	sbr	r8,0x3
80006d66:	50 08       	stdsp	sp[0x0],r8
		pll_config_set_option(cfg, PLL_OPT_VCO_RANGE_LOW);

	Assert(mul > 2 && mul <= 16);
	Assert(div > 0 && div <= 15);

	cfg->ctrl |= ((mul - 1) << AVR32_SCIF_PLLMUL)
80006d68:	10 99       	mov	r9,r8
80006d6a:	ea 19 3f 00 	orh	r9,0x3f00
80006d6e:	e8 19 01 00 	orl	r9,0x100
80006d72:	30 68       	mov	r8,6
80006d74:	20 18       	sub	r8,1
80006d76:	f3 e8 11 08 	or	r8,r9,r8<<0x10
80006d7a:	fa cc ff fc 	sub	r12,sp,-4
80006d7e:	18 d8       	st.w	--r12,r8
#endif
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
80006d80:	30 0b       	mov	r11,0
80006d82:	1a 9c       	mov	r12,sp
80006d84:	f0 1f 00 0c 	mcall	80006db4 <sysclk_init+0x8c>

static inline bool pll_is_locked(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_SCIF.pclksr & (1U << (AVR32_SCIF_PLL0_LOCK + pll_id)));
80006d88:	fe 79 08 00 	mov	r9,-63488
80006d8c:	72 58       	ld.w	r8,r9[0x14]
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
80006d8e:	e2 18 00 10 	andl	r8,0x10,COH
80006d92:	cf d0       	breq	80006d8c <sysclk_init+0x64>

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0: {
		pll_enable_config_defaults(0);
		// Set a flash wait state depending on the new cpu frequency.
		flash_set_bus_freq(sysclk_get_cpu_hz());
80006d94:	e0 6c 6c 00 	mov	r12,27648
80006d98:	ea 1c 02 dc 	orh	r12,0x2dc
80006d9c:	f0 1f 00 07 	mcall	80006db8 <sysclk_init+0x90>
		sysclk_set_source(SYSCLK_SRC_PLL0);
80006da0:	30 3c       	mov	r12,3
80006da2:	f0 1f 00 07 	mcall	80006dbc <sysclk_init+0x94>

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = true;
#endif
}
80006da6:	2f fd       	sub	sp,-4
80006da8:	d8 02       	popm	pc
80006daa:	00 00       	add	r0,r0
80006dac:	80 00       	ld.sh	r0,r0[0x0]
80006dae:	6c 80       	ld.w	r0,r6[0x20]
80006db0:	80 00       	ld.sh	r0,r0[0x0]
80006db2:	6c 10       	ld.w	r0,r6[0x4]
80006db4:	80 00       	ld.sh	r0,r0[0x0]
80006db6:	6b e6       	ld.w	r6,r5[0x78]
80006db8:	80 00       	ld.sh	r0,r0[0x0]
80006dba:	67 78       	ld.w	r8,r3[0x5c]
80006dbc:	80 00       	ld.sh	r0,r0[0x0]
80006dbe:	6c 60       	ld.w	r0,r6[0x18]

80006dc0 <board_init>:
#include <conf_board.h>
#include "ecu_can.h"
#include "mcp2515.h"

void board_init(void)
{
80006dc0:	d4 01       	pushm	lr
	/* This function is meant to contain board-specific initialization code
	 * for, e.g., the I/O pins. The initialization can rely on application-
	 * specific board configuration, found in conf_board.h.
	 */
	#ifdef USE_WDT
		wdt_disable();
80006dc2:	f0 1f 00 25 	mcall	80006e54 <board_init+0x94>
	#endif
	/* Disable all interrupts. */
	Disable_global_interrupt();
80006dc6:	d3 03       	ssrf	0x10
	sysclk_init();
80006dc8:	f0 1f 00 24 	mcall	80006e58 <board_init+0x98>
	delay_init(sysclk_get_cpu_hz());
	
	gpio_configure_pin(LED1,  GPIO_INIT_HIGH|GPIO_DIR_OUTPUT);
80006dcc:	30 3b       	mov	r11,3
80006dce:	35 3c       	mov	r12,83
80006dd0:	f0 1f 00 23 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(LED2,  GPIO_INIT_HIGH|GPIO_DIR_OUTPUT);
80006dd4:	30 3b       	mov	r11,3
80006dd6:	35 2c       	mov	r12,82
80006dd8:	f0 1f 00 21 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(LED3,  GPIO_INIT_HIGH|GPIO_DIR_OUTPUT);
80006ddc:	30 3b       	mov	r11,3
80006dde:	35 1c       	mov	r12,81
80006de0:	f0 1f 00 1f 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(LED4,  GPIO_INIT_HIGH|GPIO_DIR_OUTPUT);
80006de4:	30 3b       	mov	r11,3
80006de6:	35 0c       	mov	r12,80
80006de8:	f0 1f 00 1d 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(AIR_PLUS,GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006dec:	30 1b       	mov	r11,1
80006dee:	30 4c       	mov	r12,4
80006df0:	f0 1f 00 1b 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(FRG_PIN,GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006df4:	30 1b       	mov	r11,1
80006df6:	30 9c       	mov	r12,9
80006df8:	f0 1f 00 19 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(RFE_PIN,GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006dfc:	30 1b       	mov	r11,1
80006dfe:	31 0c       	mov	r12,16
80006e00:	f0 1f 00 17 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(INVERTER_BTB,GPIO_PULL_DOWN|GPIO_DIR_INPUT);
80006e04:	30 8b       	mov	r11,8
80006e06:	37 dc       	mov	r12,125
80006e08:	f0 1f 00 15 	mcall	80006e5c <board_init+0x9c>
	
	
	gpio_configure_pin(INVERTER_DIN1, GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006e0c:	30 1b       	mov	r11,1
80006e0e:	30 5c       	mov	r12,5
80006e10:	f0 1f 00 13 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(INVERTER_DIN2, GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006e14:	30 1b       	mov	r11,1
80006e16:	30 6c       	mov	r12,6
80006e18:	f0 1f 00 11 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(INVERTER_DOUT1,GPIO_PULL_DOWN|GPIO_DIR_INPUT);
80006e1c:	30 8b       	mov	r11,8
80006e1e:	37 5c       	mov	r12,117
80006e20:	f0 1f 00 0f 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(INVERTER_DOUT2,GPIO_PULL_DOWN|GPIO_DIR_INPUT);
80006e24:	30 8b       	mov	r11,8
80006e26:	37 bc       	mov	r12,123
80006e28:	f0 1f 00 0d 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(INVERTER_DOUT3,GPIO_PULL_DOWN|GPIO_DIR_INPUT);
80006e2c:	30 8b       	mov	r11,8
80006e2e:	37 cc       	mov	r12,124
80006e30:	f0 1f 00 0b 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(END1, GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006e34:	30 1b       	mov	r11,1
80006e36:	30 7c       	mov	r12,7
80006e38:	f0 1f 00 09 	mcall	80006e5c <board_init+0x9c>
	gpio_configure_pin(END2, GPIO_INIT_LOW|GPIO_DIR_OUTPUT);
80006e3c:	30 1b       	mov	r11,1
80006e3e:	30 8c       	mov	r12,8
80006e40:	f0 1f 00 07 	mcall	80006e5c <board_init+0x9c>
	
	gpio_configure_pin(INT1, GPIO_DIR_INPUT| GPIO_PULL_UP); 
80006e44:	30 4b       	mov	r11,4
80006e46:	36 ec       	mov	r12,110
80006e48:	f0 1f 00 05 	mcall	80006e5c <board_init+0x9c>
	
	ecu_can_init();
80006e4c:	f0 1f 00 05 	mcall	80006e60 <board_init+0xa0>
	
	Enable_global_interrupt();
80006e50:	d5 03       	csrf	0x10
	
}
80006e52:	d8 02       	popm	pc
80006e54:	80 00       	ld.sh	r0,r0[0x0]
80006e56:	21 d4       	sub	r4,29
80006e58:	80 00       	ld.sh	r0,r0[0x0]
80006e5a:	6d 28       	ld.w	r8,r6[0x48]
80006e5c:	80 00       	ld.sh	r0,r0[0x0]
80006e5e:	68 60       	ld.w	r0,r4[0x18]
80006e60:	80 00       	ld.sh	r0,r0[0x0]
80006e62:	55 68       	stdsp	sp[0x158],r8

80006e64 <__avr32_f64_mul>:
80006e64:	f5 eb 10 1c 	or	r12,r10,r11<<0x1
80006e68:	e0 80 00 dc 	breq	80007020 <__avr32_f64_mul_op1_zero>
80006e6c:	d4 21       	pushm	r4-r7,lr
80006e6e:	f7 e9 20 0e 	eor	lr,r11,r9
80006e72:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80006e76:	30 15       	mov	r5,1
80006e78:	c4 30       	breq	80006efe <__avr32_f64_mul_op1_subnormal>
80006e7a:	ab 6b       	lsl	r11,0xa
80006e7c:	f7 ea 13 6b 	or	r11,r11,r10>>0x16
80006e80:	ab 6a       	lsl	r10,0xa
80006e82:	f7 d5 d3 c2 	bfins	r11,r5,0x1e,0x2
80006e86:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80006e8a:	c5 c0       	breq	80006f42 <__avr32_f64_mul_op2_subnormal>
80006e8c:	a1 78       	lsl	r8,0x1
80006e8e:	5c f9       	rol	r9
80006e90:	f3 d5 d2 ab 	bfins	r9,r5,0x15,0xb
80006e94:	e0 47 07 ff 	cp.w	r7,2047
80006e98:	c7 70       	breq	80006f86 <__avr32_f64_mul_op_nan_or_inf>
80006e9a:	e0 46 07 ff 	cp.w	r6,2047
80006e9e:	c7 40       	breq	80006f86 <__avr32_f64_mul_op_nan_or_inf>
80006ea0:	ee 06 00 0c 	add	r12,r7,r6
80006ea4:	e0 2c 03 fe 	sub	r12,1022
80006ea8:	f6 08 06 44 	mulu.d	r4,r11,r8
80006eac:	f4 09 07 44 	macu.d	r4,r10,r9
80006eb0:	f4 08 06 46 	mulu.d	r6,r10,r8
80006eb4:	f6 09 06 4a 	mulu.d	r10,r11,r9
80006eb8:	08 07       	add	r7,r4
80006eba:	f4 05 00 4a 	adc	r10,r10,r5
80006ebe:	5c 0b       	acr	r11
80006ec0:	ed bb 00 14 	bld	r11,0x14
80006ec4:	c0 50       	breq	80006ece <__avr32_f64_mul+0x6a>
80006ec6:	a1 77       	lsl	r7,0x1
80006ec8:	5c fa       	rol	r10
80006eca:	5c fb       	rol	r11
80006ecc:	20 1c       	sub	r12,1
80006ece:	58 0c       	cp.w	r12,0
80006ed0:	e0 8a 00 6f 	brle	80006fae <__avr32_f64_mul_res_subnormal>
80006ed4:	e0 4c 07 ff 	cp.w	r12,2047
80006ed8:	e0 84 00 9c 	brge	80007010 <__avr32_f64_mul_res_inf>
80006edc:	f7 dc d2 8b 	bfins	r11,r12,0x14,0xb
80006ee0:	ed ea 11 f6 	or	r6,r6,r10<<0x1f
80006ee4:	ef e6 12 17 	or	r7,r7,r6>>0x1
80006ee8:	ee 17 80 00 	eorh	r7,0x8000
80006eec:	f1 b7 04 20 	satu	r7,0x1
80006ef0:	0e 0a       	add	r10,r7
80006ef2:	5c 0b       	acr	r11
80006ef4:	ed be 00 1f 	bld	lr,0x1f
80006ef8:	ef bb 00 1f 	bst	r11,0x1f
80006efc:	d8 22       	popm	r4-r7,pc

80006efe <__avr32_f64_mul_op1_subnormal>:
80006efe:	e4 1b 00 0f 	andh	r11,0xf
80006f02:	f4 0c 12 00 	clz	r12,r10
80006f06:	f6 06 12 00 	clz	r6,r11
80006f0a:	f7 bc 03 e1 	sublo	r12,-31
80006f0e:	f8 06 17 30 	movlo	r6,r12
80006f12:	f7 b6 02 01 	subhs	r6,1
80006f16:	e0 46 00 20 	cp.w	r6,32
80006f1a:	c0 d4       	brge	80006f34 <__avr32_f64_mul_op1_subnormal+0x36>
80006f1c:	ec 0c 11 20 	rsub	r12,r6,32
80006f20:	f6 06 09 4b 	lsl	r11,r11,r6
80006f24:	f4 0c 0a 4c 	lsr	r12,r10,r12
80006f28:	18 4b       	or	r11,r12
80006f2a:	f4 06 09 4a 	lsl	r10,r10,r6
80006f2e:	20 b6       	sub	r6,11
80006f30:	0c 17       	sub	r7,r6
80006f32:	ca ab       	rjmp	80006e86 <__avr32_f64_mul+0x22>
80006f34:	f4 06 09 4b 	lsl	r11,r10,r6
80006f38:	c6 40       	breq	80007000 <__avr32_f64_mul_res_zero>
80006f3a:	30 0a       	mov	r10,0
80006f3c:	20 b6       	sub	r6,11
80006f3e:	0c 17       	sub	r7,r6
80006f40:	ca 3b       	rjmp	80006e86 <__avr32_f64_mul+0x22>

80006f42 <__avr32_f64_mul_op2_subnormal>:
80006f42:	e4 19 00 0f 	andh	r9,0xf
80006f46:	f0 0c 12 00 	clz	r12,r8
80006f4a:	f2 05 12 00 	clz	r5,r9
80006f4e:	f7 bc 03 ea 	sublo	r12,-22
80006f52:	f8 05 17 30 	movlo	r5,r12
80006f56:	f7 b5 02 0a 	subhs	r5,10
80006f5a:	e0 45 00 20 	cp.w	r5,32
80006f5e:	c0 d4       	brge	80006f78 <__avr32_f64_mul_op2_subnormal+0x36>
80006f60:	ea 0c 11 20 	rsub	r12,r5,32
80006f64:	f2 05 09 49 	lsl	r9,r9,r5
80006f68:	f0 0c 0a 4c 	lsr	r12,r8,r12
80006f6c:	18 49       	or	r9,r12
80006f6e:	f0 05 09 48 	lsl	r8,r8,r5
80006f72:	20 25       	sub	r5,2
80006f74:	0a 16       	sub	r6,r5
80006f76:	c8 fb       	rjmp	80006e94 <__avr32_f64_mul+0x30>
80006f78:	f0 05 09 49 	lsl	r9,r8,r5
80006f7c:	c4 20       	breq	80007000 <__avr32_f64_mul_res_zero>
80006f7e:	30 08       	mov	r8,0
80006f80:	20 25       	sub	r5,2
80006f82:	0a 16       	sub	r6,r5
80006f84:	c8 8b       	rjmp	80006e94 <__avr32_f64_mul+0x30>

80006f86 <__avr32_f64_mul_op_nan_or_inf>:
80006f86:	e4 19 00 0f 	andh	r9,0xf
80006f8a:	e4 1b 00 0f 	andh	r11,0xf
80006f8e:	14 4b       	or	r11,r10
80006f90:	10 49       	or	r9,r8
80006f92:	e0 47 07 ff 	cp.w	r7,2047
80006f96:	c0 91       	brne	80006fa8 <__avr32_f64_mul_op1_not_naninf>
80006f98:	58 0b       	cp.w	r11,0
80006f9a:	c3 81       	brne	8000700a <__avr32_f64_mul_res_nan>
80006f9c:	e0 46 07 ff 	cp.w	r6,2047
80006fa0:	c3 81       	brne	80007010 <__avr32_f64_mul_res_inf>
80006fa2:	58 09       	cp.w	r9,0
80006fa4:	c3 60       	breq	80007010 <__avr32_f64_mul_res_inf>
80006fa6:	c3 28       	rjmp	8000700a <__avr32_f64_mul_res_nan>

80006fa8 <__avr32_f64_mul_op1_not_naninf>:
80006fa8:	58 09       	cp.w	r9,0
80006faa:	c3 30       	breq	80007010 <__avr32_f64_mul_res_inf>
80006fac:	c2 f8       	rjmp	8000700a <__avr32_f64_mul_res_nan>

80006fae <__avr32_f64_mul_res_subnormal>:
80006fae:	5c 3c       	neg	r12
80006fb0:	2f fc       	sub	r12,-1
80006fb2:	f1 bc 04 c0 	satu	r12,0x6
80006fb6:	e0 4c 00 20 	cp.w	r12,32
80006fba:	c1 14       	brge	80006fdc <__avr32_f64_mul_res_subnormal+0x2e>
80006fbc:	f8 08 11 20 	rsub	r8,r12,32
80006fc0:	0e 46       	or	r6,r7
80006fc2:	ee 0c 0a 47 	lsr	r7,r7,r12
80006fc6:	f4 08 09 49 	lsl	r9,r10,r8
80006fca:	12 47       	or	r7,r9
80006fcc:	f4 0c 0a 4a 	lsr	r10,r10,r12
80006fd0:	f6 08 09 49 	lsl	r9,r11,r8
80006fd4:	12 4a       	or	r10,r9
80006fd6:	f6 0c 0a 4b 	lsr	r11,r11,r12
80006fda:	c8 3b       	rjmp	80006ee0 <__avr32_f64_mul+0x7c>
80006fdc:	f8 08 11 20 	rsub	r8,r12,32
80006fe0:	f9 b9 00 00 	moveq	r9,0
80006fe4:	c0 30       	breq	80006fea <__avr32_f64_mul_res_subnormal+0x3c>
80006fe6:	f6 08 09 49 	lsl	r9,r11,r8
80006fea:	0e 46       	or	r6,r7
80006fec:	ed ea 10 16 	or	r6,r6,r10<<0x1
80006ff0:	f4 0c 0a 4a 	lsr	r10,r10,r12
80006ff4:	f3 ea 10 07 	or	r7,r9,r10
80006ff8:	f6 0c 0a 4a 	lsr	r10,r11,r12
80006ffc:	30 0b       	mov	r11,0
80006ffe:	c7 1b       	rjmp	80006ee0 <__avr32_f64_mul+0x7c>

80007000 <__avr32_f64_mul_res_zero>:
80007000:	1c 9b       	mov	r11,lr
80007002:	e6 1b 80 00 	andh	r11,0x8000,COH
80007006:	30 0a       	mov	r10,0
80007008:	d8 22       	popm	r4-r7,pc

8000700a <__avr32_f64_mul_res_nan>:
8000700a:	3f fb       	mov	r11,-1
8000700c:	3f fa       	mov	r10,-1
8000700e:	d8 22       	popm	r4-r7,pc

80007010 <__avr32_f64_mul_res_inf>:
80007010:	f0 6b 00 00 	mov	r11,-1048576
80007014:	ed be 00 1f 	bld	lr,0x1f
80007018:	ef bb 00 1f 	bst	r11,0x1f
8000701c:	30 0a       	mov	r10,0
8000701e:	d8 22       	popm	r4-r7,pc

80007020 <__avr32_f64_mul_op1_zero>:
80007020:	f7 e9 20 0b 	eor	r11,r11,r9
80007024:	e6 1b 80 00 	andh	r11,0x8000,COH
80007028:	f9 d9 c2 8b 	bfextu	r12,r9,0x14,0xb
8000702c:	e0 4c 07 ff 	cp.w	r12,2047
80007030:	5e 1c       	retne	r12
80007032:	3f fa       	mov	r10,-1
80007034:	3f fb       	mov	r11,-1
80007036:	5e fc       	retal	r12

80007038 <__avr32_f64_sub_from_add>:
80007038:	ee 19 80 00 	eorh	r9,0x8000

8000703c <__avr32_f64_sub>:
8000703c:	f7 e9 20 0c 	eor	r12,r11,r9
80007040:	e0 86 00 ca 	brmi	800071d4 <__avr32_f64_add_from_sub>
80007044:	eb cd 40 e0 	pushm	r5-r7,lr
80007048:	16 9c       	mov	r12,r11
8000704a:	e6 1c 80 00 	andh	r12,0x8000,COH
8000704e:	bf db       	cbr	r11,0x1f
80007050:	bf d9       	cbr	r9,0x1f
80007052:	10 3a       	cp.w	r10,r8
80007054:	f2 0b 13 00 	cpc	r11,r9
80007058:	c0 92       	brcc	8000706a <__avr32_f64_sub+0x2e>
8000705a:	16 97       	mov	r7,r11
8000705c:	12 9b       	mov	r11,r9
8000705e:	0e 99       	mov	r9,r7
80007060:	14 97       	mov	r7,r10
80007062:	10 9a       	mov	r10,r8
80007064:	0e 98       	mov	r8,r7
80007066:	ee 1c 80 00 	eorh	r12,0x8000
8000706a:	f6 07 16 14 	lsr	r7,r11,0x14
8000706e:	ab 7b       	lsl	r11,0xb
80007070:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80007074:	ab 7a       	lsl	r10,0xb
80007076:	bf bb       	sbr	r11,0x1f
80007078:	f2 06 16 14 	lsr	r6,r9,0x14
8000707c:	c4 40       	breq	80007104 <__avr32_f64_sub_opL_subnormal>
8000707e:	ab 79       	lsl	r9,0xb
80007080:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80007084:	ab 78       	lsl	r8,0xb
80007086:	bf b9       	sbr	r9,0x1f

80007088 <__avr32_f64_sub_opL_subnormal_done>:
80007088:	e0 47 07 ff 	cp.w	r7,2047
8000708c:	c4 f0       	breq	8000712a <__avr32_f64_sub_opH_nan_or_inf>
8000708e:	0e 26       	rsub	r6,r7
80007090:	c1 20       	breq	800070b4 <__avr32_f64_sub_shift_done>
80007092:	ec 05 11 20 	rsub	r5,r6,32
80007096:	e0 46 00 20 	cp.w	r6,32
8000709a:	c7 c2       	brcc	80007192 <__avr32_f64_sub_longshift>
8000709c:	f0 05 09 4e 	lsl	lr,r8,r5
800070a0:	f2 05 09 45 	lsl	r5,r9,r5
800070a4:	f0 06 0a 48 	lsr	r8,r8,r6
800070a8:	f2 06 0a 49 	lsr	r9,r9,r6
800070ac:	0a 48       	or	r8,r5
800070ae:	58 0e       	cp.w	lr,0
800070b0:	5f 1e       	srne	lr
800070b2:	1c 48       	or	r8,lr

800070b4 <__avr32_f64_sub_shift_done>:
800070b4:	10 1a       	sub	r10,r8
800070b6:	f6 09 01 4b 	sbc	r11,r11,r9
800070ba:	f6 06 12 00 	clz	r6,r11
800070be:	c0 e0       	breq	800070da <__avr32_f64_sub_longnormalize_done>
800070c0:	c7 83       	brcs	800071b0 <__avr32_f64_sub_longnormalize>
800070c2:	ec 0e 11 20 	rsub	lr,r6,32
800070c6:	f6 06 09 4b 	lsl	r11,r11,r6
800070ca:	f4 0e 0a 4e 	lsr	lr,r10,lr
800070ce:	1c 4b       	or	r11,lr
800070d0:	f4 06 09 4a 	lsl	r10,r10,r6
800070d4:	0c 17       	sub	r7,r6
800070d6:	e0 8a 00 39 	brle	80007148 <__avr32_f64_sub_subnormal_result>

800070da <__avr32_f64_sub_longnormalize_done>:
800070da:	f4 09 15 15 	lsl	r9,r10,0x15
800070de:	ab 9a       	lsr	r10,0xb
800070e0:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
800070e4:	ab 9b       	lsr	r11,0xb
800070e6:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
800070ea:	18 4b       	or	r11,r12

800070ec <__avr32_f64_sub_round>:
800070ec:	fc 17 80 00 	movh	r7,0x8000
800070f0:	ed ba 00 00 	bld	r10,0x0
800070f4:	f7 b7 01 ff 	subne	r7,-1
800070f8:	0e 39       	cp.w	r9,r7
800070fa:	5f 29       	srhs	r9
800070fc:	12 0a       	add	r10,r9
800070fe:	5c 0b       	acr	r11
80007100:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007104 <__avr32_f64_sub_opL_subnormal>:
80007104:	ab 79       	lsl	r9,0xb
80007106:	f3 e8 13 59 	or	r9,r9,r8>>0x15
8000710a:	ab 78       	lsl	r8,0xb
8000710c:	f3 e8 10 0e 	or	lr,r9,r8
80007110:	f9 b6 01 01 	movne	r6,1
80007114:	ee 0e 11 00 	rsub	lr,r7,0
80007118:	f9 b7 00 01 	moveq	r7,1
8000711c:	ef bb 00 1f 	bst	r11,0x1f
80007120:	f7 ea 10 0e 	or	lr,r11,r10
80007124:	f9 b7 00 00 	moveq	r7,0
80007128:	cb 0b       	rjmp	80007088 <__avr32_f64_sub_opL_subnormal_done>

8000712a <__avr32_f64_sub_opH_nan_or_inf>:
8000712a:	bf db       	cbr	r11,0x1f
8000712c:	f7 ea 10 0e 	or	lr,r11,r10
80007130:	c0 81       	brne	80007140 <__avr32_f64_sub_return_nan>
80007132:	e0 46 07 ff 	cp.w	r6,2047
80007136:	c0 50       	breq	80007140 <__avr32_f64_sub_return_nan>
80007138:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000713c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007140 <__avr32_f64_sub_return_nan>:
80007140:	3f fa       	mov	r10,-1
80007142:	3f fb       	mov	r11,-1
80007144:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007148 <__avr32_f64_sub_subnormal_result>:
80007148:	5c 37       	neg	r7
8000714a:	2f f7       	sub	r7,-1
8000714c:	f1 b7 04 c0 	satu	r7,0x6
80007150:	e0 47 00 20 	cp.w	r7,32
80007154:	c1 14       	brge	80007176 <__avr32_f64_sub_subnormal_result+0x2e>
80007156:	ee 08 11 20 	rsub	r8,r7,32
8000715a:	f4 08 09 49 	lsl	r9,r10,r8
8000715e:	5f 16       	srne	r6
80007160:	f4 07 0a 4a 	lsr	r10,r10,r7
80007164:	0c 4a       	or	r10,r6
80007166:	f6 08 09 49 	lsl	r9,r11,r8
8000716a:	f5 e9 10 0a 	or	r10,r10,r9
8000716e:	f4 07 0a 4b 	lsr	r11,r10,r7
80007172:	30 07       	mov	r7,0
80007174:	cb 3b       	rjmp	800070da <__avr32_f64_sub_longnormalize_done>
80007176:	ee 08 11 40 	rsub	r8,r7,64
8000717a:	f6 08 09 49 	lsl	r9,r11,r8
8000717e:	14 49       	or	r9,r10
80007180:	5f 16       	srne	r6
80007182:	f6 07 0a 4a 	lsr	r10,r11,r7
80007186:	0c 4a       	or	r10,r6
80007188:	30 0b       	mov	r11,0
8000718a:	30 07       	mov	r7,0
8000718c:	ca 7b       	rjmp	800070da <__avr32_f64_sub_longnormalize_done>
8000718e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007192 <__avr32_f64_sub_longshift>:
80007192:	f1 b6 04 c0 	satu	r6,0x6
80007196:	f0 0e 17 00 	moveq	lr,r8
8000719a:	c0 40       	breq	800071a2 <__avr32_f64_sub_longshift+0x10>
8000719c:	f2 05 09 4e 	lsl	lr,r9,r5
800071a0:	10 4e       	or	lr,r8
800071a2:	f2 06 0a 48 	lsr	r8,r9,r6
800071a6:	30 09       	mov	r9,0
800071a8:	58 0e       	cp.w	lr,0
800071aa:	5f 1e       	srne	lr
800071ac:	1c 48       	or	r8,lr
800071ae:	c8 3b       	rjmp	800070b4 <__avr32_f64_sub_shift_done>

800071b0 <__avr32_f64_sub_longnormalize>:
800071b0:	f4 06 12 00 	clz	r6,r10
800071b4:	f9 b7 03 00 	movlo	r7,0
800071b8:	f9 b6 03 00 	movlo	r6,0
800071bc:	f9 bc 03 00 	movlo	r12,0
800071c0:	f7 b6 02 e0 	subhs	r6,-32
800071c4:	f4 06 09 4b 	lsl	r11,r10,r6
800071c8:	30 0a       	mov	r10,0
800071ca:	0c 17       	sub	r7,r6
800071cc:	fe 9a ff be 	brle	80007148 <__avr32_f64_sub_subnormal_result>
800071d0:	c8 5b       	rjmp	800070da <__avr32_f64_sub_longnormalize_done>
800071d2:	d7 03       	nop

800071d4 <__avr32_f64_add_from_sub>:
800071d4:	ee 19 80 00 	eorh	r9,0x8000

800071d8 <__avr32_f64_add>:
800071d8:	f7 e9 20 0c 	eor	r12,r11,r9
800071dc:	fe 96 ff 2e 	brmi	80007038 <__avr32_f64_sub_from_add>
800071e0:	eb cd 40 e0 	pushm	r5-r7,lr
800071e4:	16 9c       	mov	r12,r11
800071e6:	e6 1c 80 00 	andh	r12,0x8000,COH
800071ea:	bf db       	cbr	r11,0x1f
800071ec:	bf d9       	cbr	r9,0x1f
800071ee:	12 3b       	cp.w	r11,r9
800071f0:	c0 72       	brcc	800071fe <__avr32_f64_add+0x26>
800071f2:	16 97       	mov	r7,r11
800071f4:	12 9b       	mov	r11,r9
800071f6:	0e 99       	mov	r9,r7
800071f8:	14 97       	mov	r7,r10
800071fa:	10 9a       	mov	r10,r8
800071fc:	0e 98       	mov	r8,r7
800071fe:	30 0e       	mov	lr,0
80007200:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80007204:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
80007208:	b5 ab       	sbr	r11,0x14
8000720a:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
8000720e:	c6 20       	breq	800072d2 <__avr32_f64_add_op2_subnormal>
80007210:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
80007214:	b5 a9       	sbr	r9,0x14
80007216:	e0 47 07 ff 	cp.w	r7,2047
8000721a:	c2 80       	breq	8000726a <__avr32_f64_add_opH_nan_or_inf>
8000721c:	0e 26       	rsub	r6,r7
8000721e:	c1 20       	breq	80007242 <__avr32_f64_add_shift_done>
80007220:	e0 46 00 36 	cp.w	r6,54
80007224:	c1 52       	brcc	8000724e <__avr32_f64_add_res_of_done>
80007226:	ec 05 11 20 	rsub	r5,r6,32
8000722a:	e0 46 00 20 	cp.w	r6,32
8000722e:	c3 52       	brcc	80007298 <__avr32_f64_add_longshift>
80007230:	f0 05 09 4e 	lsl	lr,r8,r5
80007234:	f2 05 09 45 	lsl	r5,r9,r5
80007238:	f0 06 0a 48 	lsr	r8,r8,r6
8000723c:	f2 06 0a 49 	lsr	r9,r9,r6
80007240:	0a 48       	or	r8,r5

80007242 <__avr32_f64_add_shift_done>:
80007242:	10 0a       	add	r10,r8
80007244:	f6 09 00 4b 	adc	r11,r11,r9
80007248:	ed bb 00 15 	bld	r11,0x15
8000724c:	c3 40       	breq	800072b4 <__avr32_f64_add_res_of>

8000724e <__avr32_f64_add_res_of_done>:
8000724e:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80007252:	18 4b       	or	r11,r12

80007254 <__avr32_f64_add_round>:
80007254:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
80007258:	18 4e       	or	lr,r12
8000725a:	ee 1e 80 00 	eorh	lr,0x8000
8000725e:	f1 be 04 20 	satu	lr,0x1
80007262:	1c 0a       	add	r10,lr
80007264:	5c 0b       	acr	r11
80007266:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000726a <__avr32_f64_add_opH_nan_or_inf>:
8000726a:	b5 cb       	cbr	r11,0x14
8000726c:	f7 ea 10 0e 	or	lr,r11,r10
80007270:	c1 01       	brne	80007290 <__avr32_f64_add_return_nan>
80007272:	e0 46 07 ff 	cp.w	r6,2047
80007276:	c0 30       	breq	8000727c <__avr32_f64_add_opL_nan_or_inf>
80007278:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000727c <__avr32_f64_add_opL_nan_or_inf>:
8000727c:	b5 c9       	cbr	r9,0x14
8000727e:	f3 e8 10 0e 	or	lr,r9,r8
80007282:	c0 71       	brne	80007290 <__avr32_f64_add_return_nan>
80007284:	30 0a       	mov	r10,0
80007286:	fc 1b 7f f0 	movh	r11,0x7ff0
8000728a:	18 4b       	or	r11,r12
8000728c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007290 <__avr32_f64_add_return_nan>:
80007290:	3f fa       	mov	r10,-1
80007292:	3f fb       	mov	r11,-1
80007294:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80007298 <__avr32_f64_add_longshift>:
80007298:	f1 b6 04 c0 	satu	r6,0x6
8000729c:	f0 0e 17 00 	moveq	lr,r8
800072a0:	c0 60       	breq	800072ac <__avr32_f64_add_longshift+0x14>
800072a2:	f2 05 09 4e 	lsl	lr,r9,r5
800072a6:	58 08       	cp.w	r8,0
800072a8:	5f 18       	srne	r8
800072aa:	10 4e       	or	lr,r8
800072ac:	f2 06 0a 48 	lsr	r8,r9,r6
800072b0:	30 09       	mov	r9,0
800072b2:	cc 8b       	rjmp	80007242 <__avr32_f64_add_shift_done>

800072b4 <__avr32_f64_add_res_of>:
800072b4:	fd ee 10 1e 	or	lr,lr,lr<<0x1
800072b8:	a1 9b       	lsr	r11,0x1
800072ba:	5d 0a       	ror	r10
800072bc:	5d 0e       	ror	lr
800072be:	2f f7       	sub	r7,-1
800072c0:	e0 47 07 ff 	cp.w	r7,2047
800072c4:	f9 ba 00 00 	moveq	r10,0
800072c8:	f9 bb 00 00 	moveq	r11,0
800072cc:	f9 be 00 00 	moveq	lr,0
800072d0:	cb fb       	rjmp	8000724e <__avr32_f64_add_res_of_done>

800072d2 <__avr32_f64_add_op2_subnormal>:
800072d2:	30 16       	mov	r6,1
800072d4:	58 07       	cp.w	r7,0
800072d6:	ca 01       	brne	80007216 <__avr32_f64_add+0x3e>
800072d8:	b5 cb       	cbr	r11,0x14
800072da:	10 0a       	add	r10,r8
800072dc:	f6 09 00 4b 	adc	r11,r11,r9
800072e0:	18 4b       	or	r11,r12
800072e2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800072e6:	d7 03       	nop

800072e8 <__avr32_u32_to_f64>:
800072e8:	f8 cb 00 00 	sub	r11,r12,0
800072ec:	30 0c       	mov	r12,0
800072ee:	c0 38       	rjmp	800072f4 <__avr32_s32_to_f64+0x4>

800072f0 <__avr32_s32_to_f64>:
800072f0:	18 9b       	mov	r11,r12
800072f2:	5c 4b       	abs	r11
800072f4:	30 0a       	mov	r10,0
800072f6:	5e 0b       	reteq	r11
800072f8:	d4 01       	pushm	lr
800072fa:	e0 69 04 1e 	mov	r9,1054
800072fe:	f6 08 12 00 	clz	r8,r11
80007302:	c1 70       	breq	80007330 <__avr32_s32_to_f64+0x40>
80007304:	c0 c3       	brcs	8000731c <__avr32_s32_to_f64+0x2c>
80007306:	f0 0e 11 20 	rsub	lr,r8,32
8000730a:	f6 08 09 4b 	lsl	r11,r11,r8
8000730e:	f4 0e 0a 4e 	lsr	lr,r10,lr
80007312:	1c 4b       	or	r11,lr
80007314:	f4 08 09 4a 	lsl	r10,r10,r8
80007318:	10 19       	sub	r9,r8
8000731a:	c0 b8       	rjmp	80007330 <__avr32_s32_to_f64+0x40>
8000731c:	f4 08 12 00 	clz	r8,r10
80007320:	f9 b8 03 00 	movlo	r8,0
80007324:	f7 b8 02 e0 	subhs	r8,-32
80007328:	f4 08 09 4b 	lsl	r11,r10,r8
8000732c:	30 0a       	mov	r10,0
8000732e:	10 19       	sub	r9,r8
80007330:	58 09       	cp.w	r9,0
80007332:	e0 89 00 30 	brgt	80007392 <__avr32_s32_to_f64+0xa2>
80007336:	5c 39       	neg	r9
80007338:	2f f9       	sub	r9,-1
8000733a:	e0 49 00 36 	cp.w	r9,54
8000733e:	c0 43       	brcs	80007346 <__avr32_s32_to_f64+0x56>
80007340:	30 0b       	mov	r11,0
80007342:	30 0a       	mov	r10,0
80007344:	c2 68       	rjmp	80007390 <__avr32_s32_to_f64+0xa0>
80007346:	2f 69       	sub	r9,-10
80007348:	f2 08 11 20 	rsub	r8,r9,32
8000734c:	e0 49 00 20 	cp.w	r9,32
80007350:	c0 b2       	brcc	80007366 <__avr32_s32_to_f64+0x76>
80007352:	f4 08 09 4e 	lsl	lr,r10,r8
80007356:	f6 08 09 48 	lsl	r8,r11,r8
8000735a:	f4 09 0a 4a 	lsr	r10,r10,r9
8000735e:	f6 09 0a 4b 	lsr	r11,r11,r9
80007362:	10 4b       	or	r11,r8
80007364:	c0 88       	rjmp	80007374 <__avr32_s32_to_f64+0x84>
80007366:	f6 08 09 4e 	lsl	lr,r11,r8
8000736a:	14 4e       	or	lr,r10
8000736c:	16 9a       	mov	r10,r11
8000736e:	30 0b       	mov	r11,0
80007370:	f4 09 0a 4a 	lsr	r10,r10,r9
80007374:	ed ba 00 00 	bld	r10,0x0
80007378:	c0 92       	brcc	8000738a <__avr32_s32_to_f64+0x9a>
8000737a:	1c 7e       	tst	lr,lr
8000737c:	c0 41       	brne	80007384 <__avr32_s32_to_f64+0x94>
8000737e:	ed ba 00 01 	bld	r10,0x1
80007382:	c0 42       	brcc	8000738a <__avr32_s32_to_f64+0x9a>
80007384:	2f fa       	sub	r10,-1
80007386:	f7 bb 02 ff 	subhs	r11,-1
8000738a:	5c fc       	rol	r12
8000738c:	5d 0b       	ror	r11
8000738e:	5d 0a       	ror	r10
80007390:	d8 02       	popm	pc
80007392:	e0 68 03 ff 	mov	r8,1023
80007396:	ed ba 00 0b 	bld	r10,0xb
8000739a:	f7 b8 00 ff 	subeq	r8,-1
8000739e:	10 0a       	add	r10,r8
800073a0:	5c 0b       	acr	r11
800073a2:	f7 b9 03 fe 	sublo	r9,-2
800073a6:	e0 49 07 ff 	cp.w	r9,2047
800073aa:	c0 55       	brlt	800073b4 <__avr32_s32_to_f64+0xc4>
800073ac:	30 0a       	mov	r10,0
800073ae:	fc 1b ff e0 	movh	r11,0xffe0
800073b2:	c0 c8       	rjmp	800073ca <__floatsidf_return_op1>
800073b4:	ed bb 00 1f 	bld	r11,0x1f
800073b8:	f7 b9 01 01 	subne	r9,1
800073bc:	ab 9a       	lsr	r10,0xb
800073be:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
800073c2:	a1 7b       	lsl	r11,0x1
800073c4:	ab 9b       	lsr	r11,0xb
800073c6:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

800073ca <__floatsidf_return_op1>:
800073ca:	a1 7c       	lsl	r12,0x1
800073cc:	5d 0b       	ror	r11
800073ce:	d8 02       	popm	pc

800073d0 <__avr32_f64_div>:
800073d0:	eb cd 40 ff 	pushm	r0-r7,lr
800073d4:	f7 e9 20 0e 	eor	lr,r11,r9
800073d8:	f6 07 16 14 	lsr	r7,r11,0x14
800073dc:	a9 7b       	lsl	r11,0x9
800073de:	f7 ea 13 7b 	or	r11,r11,r10>>0x17
800073e2:	a9 7a       	lsl	r10,0x9
800073e4:	bd bb       	sbr	r11,0x1d
800073e6:	e4 1b 3f ff 	andh	r11,0x3fff
800073ea:	ab d7       	cbr	r7,0xb
800073ec:	e0 80 00 cc 	breq	80007584 <__avr32_f64_div_round_subnormal+0x54>
800073f0:	e0 47 07 ff 	cp.w	r7,2047
800073f4:	e0 84 00 b5 	brge	8000755e <__avr32_f64_div_round_subnormal+0x2e>
800073f8:	f2 06 16 14 	lsr	r6,r9,0x14
800073fc:	a9 79       	lsl	r9,0x9
800073fe:	f3 e8 13 79 	or	r9,r9,r8>>0x17
80007402:	a9 78       	lsl	r8,0x9
80007404:	bd b9       	sbr	r9,0x1d
80007406:	e4 19 3f ff 	andh	r9,0x3fff
8000740a:	ab d6       	cbr	r6,0xb
8000740c:	e0 80 00 e2 	breq	800075d0 <__avr32_f64_div_round_subnormal+0xa0>
80007410:	e0 46 07 ff 	cp.w	r6,2047
80007414:	e0 84 00 b2 	brge	80007578 <__avr32_f64_div_round_subnormal+0x48>
80007418:	0c 17       	sub	r7,r6
8000741a:	fe 37 fc 01 	sub	r7,-1023
8000741e:	fc 1c 80 00 	movh	r12,0x8000
80007422:	f8 03 16 01 	lsr	r3,r12,0x1
80007426:	e9 d9 c3 62 	bfextu	r4,r9,0x1b,0x2
8000742a:	5c d4       	com	r4
8000742c:	e7 d4 d3 82 	bfins	r3,r4,0x1c,0x2
80007430:	e6 09 06 44 	mulu.d	r4,r3,r9
80007434:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80007438:	e6 05 06 44 	mulu.d	r4,r3,r5
8000743c:	ea 03 15 02 	lsl	r3,r5,0x2
80007440:	e6 09 06 44 	mulu.d	r4,r3,r9
80007444:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80007448:	e6 05 06 44 	mulu.d	r4,r3,r5
8000744c:	ea 03 15 02 	lsl	r3,r5,0x2
80007450:	e6 09 06 44 	mulu.d	r4,r3,r9
80007454:	f8 05 01 25 	sub	r5,r12,r5<<0x2
80007458:	e6 05 06 44 	mulu.d	r4,r3,r5
8000745c:	ea 03 15 02 	lsl	r3,r5,0x2
80007460:	e6 08 06 40 	mulu.d	r0,r3,r8
80007464:	e4 09 07 40 	macu.d	r0,r2,r9
80007468:	e6 09 06 44 	mulu.d	r4,r3,r9
8000746c:	02 04       	add	r4,r1
8000746e:	5c 05       	acr	r5
80007470:	a3 65       	lsl	r5,0x2
80007472:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
80007476:	a3 64       	lsl	r4,0x2
80007478:	5c 34       	neg	r4
8000747a:	f8 05 01 45 	sbc	r5,r12,r5
8000747e:	e6 04 06 40 	mulu.d	r0,r3,r4
80007482:	e4 05 07 40 	macu.d	r0,r2,r5
80007486:	e6 05 06 44 	mulu.d	r4,r3,r5
8000748a:	02 04       	add	r4,r1
8000748c:	5c 05       	acr	r5
8000748e:	ea 03 15 02 	lsl	r3,r5,0x2
80007492:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
80007496:	e8 02 15 02 	lsl	r2,r4,0x2
8000749a:	e6 08 06 40 	mulu.d	r0,r3,r8
8000749e:	e4 09 07 40 	macu.d	r0,r2,r9
800074a2:	e6 09 06 44 	mulu.d	r4,r3,r9
800074a6:	02 04       	add	r4,r1
800074a8:	5c 05       	acr	r5
800074aa:	a3 65       	lsl	r5,0x2
800074ac:	eb e4 13 e5 	or	r5,r5,r4>>0x1e
800074b0:	a3 64       	lsl	r4,0x2
800074b2:	5c 34       	neg	r4
800074b4:	f8 05 01 45 	sbc	r5,r12,r5
800074b8:	e6 04 06 40 	mulu.d	r0,r3,r4
800074bc:	e4 05 07 40 	macu.d	r0,r2,r5
800074c0:	e6 05 06 44 	mulu.d	r4,r3,r5
800074c4:	02 04       	add	r4,r1
800074c6:	5c 05       	acr	r5
800074c8:	ea 03 15 02 	lsl	r3,r5,0x2
800074cc:	e7 e4 13 e3 	or	r3,r3,r4>>0x1e
800074d0:	e8 02 15 02 	lsl	r2,r4,0x2
800074d4:	e6 0a 06 40 	mulu.d	r0,r3,r10
800074d8:	e4 0b 07 40 	macu.d	r0,r2,r11
800074dc:	e6 0b 06 42 	mulu.d	r2,r3,r11
800074e0:	02 02       	add	r2,r1
800074e2:	5c 03       	acr	r3
800074e4:	ed b3 00 1c 	bld	r3,0x1c
800074e8:	c0 90       	breq	800074fa <__avr32_f64_div+0x12a>
800074ea:	a1 72       	lsl	r2,0x1
800074ec:	5c f3       	rol	r3
800074ee:	20 17       	sub	r7,1
800074f0:	a3 9a       	lsr	r10,0x3
800074f2:	f5 eb 11 da 	or	r10,r10,r11<<0x1d
800074f6:	a3 9b       	lsr	r11,0x3
800074f8:	c0 58       	rjmp	80007502 <__avr32_f64_div+0x132>
800074fa:	a5 8a       	lsr	r10,0x4
800074fc:	f5 eb 11 ca 	or	r10,r10,r11<<0x1c
80007500:	a5 8b       	lsr	r11,0x4
80007502:	58 07       	cp.w	r7,0
80007504:	e0 8a 00 8b 	brle	8000761a <__avr32_f64_div_res_subnormal>
80007508:	e0 12 ff 00 	andl	r2,0xff00
8000750c:	e8 12 00 80 	orl	r2,0x80
80007510:	e6 08 06 40 	mulu.d	r0,r3,r8
80007514:	e4 09 07 40 	macu.d	r0,r2,r9
80007518:	e4 08 06 44 	mulu.d	r4,r2,r8
8000751c:	e6 09 06 48 	mulu.d	r8,r3,r9
80007520:	00 05       	add	r5,r0
80007522:	f0 01 00 48 	adc	r8,r8,r1
80007526:	5c 09       	acr	r9
80007528:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000752c:	58 04       	cp.w	r4,0
8000752e:	5c 25       	cpc	r5

80007530 <__avr32_f64_div_round_subnormal>:
80007530:	f4 08 13 00 	cpc	r8,r10
80007534:	f6 09 13 00 	cpc	r9,r11
80007538:	5f 36       	srlo	r6
8000753a:	f8 06 17 00 	moveq	r6,r12
8000753e:	e4 0a 16 08 	lsr	r10,r2,0x8
80007542:	f5 e3 11 8a 	or	r10,r10,r3<<0x18
80007546:	e6 0b 16 08 	lsr	r11,r3,0x8
8000754a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
8000754e:	ed be 00 1f 	bld	lr,0x1f
80007552:	ef bb 00 1f 	bst	r11,0x1f
80007556:	0c 0a       	add	r10,r6
80007558:	5c 0b       	acr	r11
8000755a:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
8000755e:	e4 1b 00 0f 	andh	r11,0xf
80007562:	14 4b       	or	r11,r10
80007564:	e0 81 00 a7 	brne	800076b2 <__avr32_f64_div_res_subnormal+0x98>
80007568:	f2 06 16 14 	lsr	r6,r9,0x14
8000756c:	ab d6       	cbr	r6,0xb
8000756e:	e0 46 07 ff 	cp.w	r6,2047
80007572:	e0 81 00 a4 	brne	800076ba <__avr32_f64_div_res_subnormal+0xa0>
80007576:	c9 e8       	rjmp	800076b2 <__avr32_f64_div_res_subnormal+0x98>
80007578:	e4 19 00 0f 	andh	r9,0xf
8000757c:	10 49       	or	r9,r8
8000757e:	e0 81 00 9a 	brne	800076b2 <__avr32_f64_div_res_subnormal+0x98>
80007582:	c9 28       	rjmp	800076a6 <__avr32_f64_div_res_subnormal+0x8c>
80007584:	a3 7b       	lsl	r11,0x3
80007586:	f7 ea 13 db 	or	r11,r11,r10>>0x1d
8000758a:	a3 7a       	lsl	r10,0x3
8000758c:	f5 eb 10 04 	or	r4,r10,r11
80007590:	e0 80 00 a0 	breq	800076d0 <__avr32_f64_div_op1_zero>
80007594:	f6 04 12 00 	clz	r4,r11
80007598:	c1 70       	breq	800075c6 <__avr32_f64_div_round_subnormal+0x96>
8000759a:	c0 c3       	brcs	800075b2 <__avr32_f64_div_round_subnormal+0x82>
8000759c:	e8 05 11 20 	rsub	r5,r4,32
800075a0:	f6 04 09 4b 	lsl	r11,r11,r4
800075a4:	f4 05 0a 45 	lsr	r5,r10,r5
800075a8:	0a 4b       	or	r11,r5
800075aa:	f4 04 09 4a 	lsl	r10,r10,r4
800075ae:	08 17       	sub	r7,r4
800075b0:	c0 b8       	rjmp	800075c6 <__avr32_f64_div_round_subnormal+0x96>
800075b2:	f4 04 12 00 	clz	r4,r10
800075b6:	f9 b4 03 00 	movlo	r4,0
800075ba:	f7 b4 02 e0 	subhs	r4,-32
800075be:	f4 04 09 4b 	lsl	r11,r10,r4
800075c2:	30 0a       	mov	r10,0
800075c4:	08 17       	sub	r7,r4
800075c6:	a3 8a       	lsr	r10,0x2
800075c8:	f5 eb 11 ea 	or	r10,r10,r11<<0x1e
800075cc:	a3 8b       	lsr	r11,0x2
800075ce:	c1 1b       	rjmp	800073f0 <__avr32_f64_div+0x20>
800075d0:	a3 79       	lsl	r9,0x3
800075d2:	f3 e8 13 d9 	or	r9,r9,r8>>0x1d
800075d6:	a3 78       	lsl	r8,0x3
800075d8:	f3 e8 10 04 	or	r4,r9,r8
800075dc:	c6 f0       	breq	800076ba <__avr32_f64_div_res_subnormal+0xa0>
800075de:	f2 04 12 00 	clz	r4,r9
800075e2:	c1 70       	breq	80007610 <__avr32_f64_div_round_subnormal+0xe0>
800075e4:	c0 c3       	brcs	800075fc <__avr32_f64_div_round_subnormal+0xcc>
800075e6:	e8 05 11 20 	rsub	r5,r4,32
800075ea:	f2 04 09 49 	lsl	r9,r9,r4
800075ee:	f0 05 0a 45 	lsr	r5,r8,r5
800075f2:	0a 49       	or	r9,r5
800075f4:	f0 04 09 48 	lsl	r8,r8,r4
800075f8:	08 16       	sub	r6,r4
800075fa:	c0 b8       	rjmp	80007610 <__avr32_f64_div_round_subnormal+0xe0>
800075fc:	f0 04 12 00 	clz	r4,r8
80007600:	f9 b4 03 00 	movlo	r4,0
80007604:	f7 b4 02 e0 	subhs	r4,-32
80007608:	f0 04 09 49 	lsl	r9,r8,r4
8000760c:	30 08       	mov	r8,0
8000760e:	08 16       	sub	r6,r4
80007610:	a3 88       	lsr	r8,0x2
80007612:	f1 e9 11 e8 	or	r8,r8,r9<<0x1e
80007616:	a3 89       	lsr	r9,0x2
80007618:	cf ca       	rjmp	80007410 <__avr32_f64_div+0x40>

8000761a <__avr32_f64_div_res_subnormal>:
8000761a:	5c 37       	neg	r7
8000761c:	2f f7       	sub	r7,-1
8000761e:	f1 b7 04 c0 	satu	r7,0x6
80007622:	e0 47 00 20 	cp.w	r7,32
80007626:	c1 54       	brge	80007650 <__avr32_f64_div_res_subnormal+0x36>
80007628:	ee 06 11 20 	rsub	r6,r7,32
8000762c:	e4 07 0a 42 	lsr	r2,r2,r7
80007630:	e6 06 09 4c 	lsl	r12,r3,r6
80007634:	18 42       	or	r2,r12
80007636:	e6 07 0a 43 	lsr	r3,r3,r7
8000763a:	f4 06 09 41 	lsl	r1,r10,r6
8000763e:	f4 07 0a 4a 	lsr	r10,r10,r7
80007642:	f6 06 09 4c 	lsl	r12,r11,r6
80007646:	18 4a       	or	r10,r12
80007648:	f6 07 0a 4b 	lsr	r11,r11,r7
8000764c:	30 00       	mov	r0,0
8000764e:	c1 58       	rjmp	80007678 <__avr32_f64_div_res_subnormal+0x5e>
80007650:	ee 06 11 20 	rsub	r6,r7,32
80007654:	f9 b0 00 00 	moveq	r0,0
80007658:	f9 bc 00 00 	moveq	r12,0
8000765c:	c0 50       	breq	80007666 <__avr32_f64_div_res_subnormal+0x4c>
8000765e:	f4 06 09 40 	lsl	r0,r10,r6
80007662:	f6 06 09 4c 	lsl	r12,r11,r6
80007666:	e6 07 0a 42 	lsr	r2,r3,r7
8000766a:	30 03       	mov	r3,0
8000766c:	f4 07 0a 41 	lsr	r1,r10,r7
80007670:	18 41       	or	r1,r12
80007672:	f6 07 0a 4a 	lsr	r10,r11,r7
80007676:	30 0b       	mov	r11,0
80007678:	e0 12 ff 00 	andl	r2,0xff00
8000767c:	e8 12 00 80 	orl	r2,0x80
80007680:	e6 08 06 46 	mulu.d	r6,r3,r8
80007684:	e4 09 07 46 	macu.d	r6,r2,r9
80007688:	e4 08 06 44 	mulu.d	r4,r2,r8
8000768c:	e6 09 06 48 	mulu.d	r8,r3,r9
80007690:	0c 05       	add	r5,r6
80007692:	f0 07 00 48 	adc	r8,r8,r7
80007696:	5c 09       	acr	r9
80007698:	30 07       	mov	r7,0
8000769a:	f9 d2 c1 01 	bfextu	r12,r2,0x8,0x1
8000769e:	00 34       	cp.w	r4,r0
800076a0:	e2 05 13 00 	cpc	r5,r1
800076a4:	c4 6b       	rjmp	80007530 <__avr32_f64_div_round_subnormal>
800076a6:	1c 9b       	mov	r11,lr
800076a8:	e6 1b 80 00 	andh	r11,0x8000,COH
800076ac:	30 0a       	mov	r10,0
800076ae:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
800076b2:	3f fb       	mov	r11,-1
800076b4:	30 0a       	mov	r10,0
800076b6:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc
800076ba:	f5 eb 10 04 	or	r4,r10,r11
800076be:	c0 90       	breq	800076d0 <__avr32_f64_div_op1_zero>
800076c0:	1c 9b       	mov	r11,lr
800076c2:	e6 1b 80 00 	andh	r11,0x8000,COH
800076c6:	ea 1b 7f f0 	orh	r11,0x7ff0
800076ca:	30 0a       	mov	r10,0
800076cc:	e3 cd 80 ff 	ldm	sp++,r0-r7,pc

800076d0 <__avr32_f64_div_op1_zero>:
800076d0:	f1 e9 10 15 	or	r5,r8,r9<<0x1
800076d4:	ce f0       	breq	800076b2 <__avr32_f64_div_res_subnormal+0x98>
800076d6:	e9 d9 c2 8b 	bfextu	r4,r9,0x14,0xb
800076da:	e0 44 07 ff 	cp.w	r4,2047
800076de:	ce 41       	brne	800076a6 <__avr32_f64_div_res_subnormal+0x8c>
800076e0:	f1 e9 10 c5 	or	r5,r8,r9<<0xc
800076e4:	ce 10       	breq	800076a6 <__avr32_f64_div_res_subnormal+0x8c>
800076e6:	ce 6b       	rjmp	800076b2 <__avr32_f64_div_res_subnormal+0x98>

800076e8 <__avr32_f32_div>:
800076e8:	f7 ec 20 08 	eor	r8,r11,r12
800076ec:	a1 7c       	lsl	r12,0x1
800076ee:	a1 7b       	lsl	r11,0x1
800076f0:	c7 a0       	breq	800077e4 <__divsf_return_op1+0x16>
800076f2:	18 7c       	tst	r12,r12
800076f4:	f9 b9 00 00 	moveq	r9,0
800076f8:	c0 90       	breq	8000770a <__avr32_f32_div+0x22>
800076fa:	f8 09 16 18 	lsr	r9,r12,0x18
800076fe:	c7 e0       	breq	800077fa <__divsf_return_op1+0x2c>
80007700:	e0 49 00 ff 	cp.w	r9,255
80007704:	c6 82       	brcc	800077d4 <__divsf_return_op1+0x6>
80007706:	a7 7c       	lsl	r12,0x7
80007708:	bf bc       	sbr	r12,0x1f
8000770a:	f6 0a 16 18 	lsr	r10,r11,0x18
8000770e:	c7 e0       	breq	8000780a <__divsf_return_op1+0x3c>
80007710:	e0 4a 00 ff 	cp.w	r10,255
80007714:	c6 62       	brcc	800077e0 <__divsf_return_op1+0x12>
80007716:	a7 7b       	lsl	r11,0x7
80007718:	bf bb       	sbr	r11,0x1f
8000771a:	58 09       	cp.w	r9,0
8000771c:	f5 bc 00 00 	subfeq	r12,0
80007720:	5e 0d       	reteq	0
80007722:	1a d5       	st.w	--sp,r5
80007724:	bb 27       	st.d	--sp,r6
80007726:	14 19       	sub	r9,r10
80007728:	28 19       	sub	r9,-127
8000772a:	fc 1a 80 00 	movh	r10,0x8000
8000772e:	a3 8c       	lsr	r12,0x2
80007730:	f6 05 16 02 	lsr	r5,r11,0x2
80007734:	f4 0b 16 01 	lsr	r11,r10,0x1
80007738:	ed d5 c3 62 	bfextu	r6,r5,0x1b,0x2
8000773c:	5c d6       	com	r6
8000773e:	f7 d6 d3 82 	bfins	r11,r6,0x1c,0x2
80007742:	f6 05 06 46 	mulu.d	r6,r11,r5
80007746:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000774a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000774e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007752:	f6 05 06 46 	mulu.d	r6,r11,r5
80007756:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000775a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000775e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007762:	f6 05 06 46 	mulu.d	r6,r11,r5
80007766:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000776a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000776e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007772:	f6 05 06 46 	mulu.d	r6,r11,r5
80007776:	f4 07 01 27 	sub	r7,r10,r7<<0x2
8000777a:	f6 07 06 46 	mulu.d	r6,r11,r7
8000777e:	ee 0b 15 02 	lsl	r11,r7,0x2
80007782:	f6 0c 06 46 	mulu.d	r6,r11,r12
80007786:	a5 8c       	lsr	r12,0x4
80007788:	ed b7 00 1c 	bld	r7,0x1c
8000778c:	c0 40       	breq	80007794 <__avr32_f32_div+0xac>
8000778e:	a1 77       	lsl	r7,0x1
80007790:	20 19       	sub	r9,1
80007792:	a1 7c       	lsl	r12,0x1
80007794:	58 09       	cp.w	r9,0
80007796:	e0 8a 00 42 	brle	8000781a <__avr32_f32_div_res_subnormal>
8000779a:	e0 17 ff e0 	andl	r7,0xffe0
8000779e:	e8 17 00 10 	orl	r7,0x10
800077a2:	ea 07 06 4a 	mulu.d	r10,r5,r7
800077a6:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
800077aa:	58 0a       	cp.w	r10,0

800077ac <__avr32_f32_div_round_subnormal>:
800077ac:	f8 0b 13 00 	cpc	r11,r12
800077b0:	5f 3b       	srlo	r11
800077b2:	ea 0b 17 00 	moveq	r11,r5
800077b6:	ee 0c 16 05 	lsr	r12,r7,0x5
800077ba:	f9 d9 d2 e8 	bfins	r12,r9,0x17,0x8
800077be:	bb 07       	ld.d	r6,sp++
800077c0:	1b 05       	ld.w	r5,sp++
800077c2:	ed b8 00 1f 	bld	r8,0x1f
800077c6:	ef bc 00 1f 	bst	r12,0x1f
800077ca:	16 0c       	add	r12,r11
800077cc:	5e fc       	retal	r12

800077ce <__divsf_return_op1>:
800077ce:	a1 78       	lsl	r8,0x1
800077d0:	5d 0c       	ror	r12
800077d2:	5e fc       	retal	r12
800077d4:	5e 1e       	retne	-1
800077d6:	fc 19 ff 00 	movh	r9,0xff00
800077da:	12 3b       	cp.w	r11,r9
800077dc:	cf 93       	brcs	800077ce <__divsf_return_op1>
800077de:	5e fe       	retal	-1
800077e0:	5e 0d       	reteq	0
800077e2:	5e fe       	retal	-1
800077e4:	18 7c       	tst	r12,r12
800077e6:	5e 0e       	reteq	-1
800077e8:	f8 09 16 18 	lsr	r9,r12,0x18
800077ec:	c0 70       	breq	800077fa <__divsf_return_op1+0x2c>
800077ee:	e0 49 00 ff 	cp.w	r9,255
800077f2:	cf 12       	brcc	800077d4 <__divsf_return_op1+0x6>
800077f4:	fc 1c ff 00 	movh	r12,0xff00
800077f8:	ce bb       	rjmp	800077ce <__divsf_return_op1>
800077fa:	a7 7c       	lsl	r12,0x7
800077fc:	f8 09 12 00 	clz	r9,r12
80007800:	f8 09 09 4c 	lsl	r12,r12,r9
80007804:	f2 09 11 01 	rsub	r9,r9,1
80007808:	c8 1b       	rjmp	8000770a <__avr32_f32_div+0x22>
8000780a:	a7 7b       	lsl	r11,0x7
8000780c:	f6 0a 12 00 	clz	r10,r11
80007810:	f6 0a 09 4b 	lsl	r11,r11,r10
80007814:	f4 0a 11 01 	rsub	r10,r10,1
80007818:	c8 5b       	rjmp	80007722 <__avr32_f32_div+0x3a>

8000781a <__avr32_f32_div_res_subnormal>:
8000781a:	5c 39       	neg	r9
8000781c:	2f f9       	sub	r9,-1
8000781e:	f1 b9 04 a0 	satu	r9,0x5
80007822:	f2 0a 11 20 	rsub	r10,r9,32
80007826:	ee 09 0a 47 	lsr	r7,r7,r9
8000782a:	f8 0a 09 46 	lsl	r6,r12,r10
8000782e:	f8 09 0a 4c 	lsr	r12,r12,r9
80007832:	e0 17 ff e0 	andl	r7,0xffe0
80007836:	e8 17 00 10 	orl	r7,0x10
8000783a:	ea 07 06 4a 	mulu.d	r10,r5,r7
8000783e:	30 09       	mov	r9,0
80007840:	eb d7 c0 a1 	bfextu	r5,r7,0x5,0x1
80007844:	0c 3a       	cp.w	r10,r6
80007846:	cb 3b       	rjmp	800077ac <__avr32_f32_div_round_subnormal>

80007848 <__avr32_f32_to_f64>:
80007848:	f8 0b 15 01 	lsl	r11,r12,0x1
8000784c:	f9 ba 00 00 	moveq	r10,0
80007850:	5e 0b       	reteq	r11
80007852:	f3 db c3 08 	bfextu	r9,r11,0x18,0x8
80007856:	e0 49 00 ff 	cp.w	r9,255
8000785a:	c1 e0       	breq	80007896 <__extendsfdf_return_op1+0x6>
8000785c:	a7 7b       	lsl	r11,0x7
8000785e:	30 0a       	mov	r10,0
80007860:	58 09       	cp.w	r9,0
80007862:	f7 b9 00 ff 	subeq	r9,-1
80007866:	5f 18       	srne	r8
80007868:	f7 e8 11 fb 	or	r11,r11,r8<<0x1f
8000786c:	fe 39 fc 80 	sub	r9,-896
80007870:	f6 08 12 00 	clz	r8,r11
80007874:	10 19       	sub	r9,r8
80007876:	f6 08 09 4b 	lsl	r11,r11,r8
8000787a:	ed bb 00 1f 	bld	r11,0x1f
8000787e:	f7 b9 01 01 	subne	r9,1
80007882:	ab 9a       	lsr	r10,0xb
80007884:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80007888:	a1 7b       	lsl	r11,0x1
8000788a:	ab 9b       	lsr	r11,0xb
8000788c:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80007890 <__extendsfdf_return_op1>:
80007890:	a1 7c       	lsl	r12,0x1
80007892:	5d 0b       	ror	r11
80007894:	5e fb       	retal	r11
80007896:	fc 1a ff e0 	movh	r10,0xffe0
8000789a:	a9 6b       	lsl	r11,0x8
8000789c:	f9 bb 01 ff 	movne	r11,-1
800078a0:	f4 0b 17 00 	moveq	r11,r10
800078a4:	30 0a       	mov	r10,0
800078a6:	cf 5b       	rjmp	80007890 <__extendsfdf_return_op1>

800078a8 <__avr32_f64_to_f32>:
800078a8:	f6 09 15 01 	lsl	r9,r11,0x1
800078ac:	b5 99       	lsr	r9,0x15
800078ae:	5e 0d       	reteq	0
800078b0:	f6 08 15 0a 	lsl	r8,r11,0xa
800078b4:	f1 ea 13 6c 	or	r12,r8,r10>>0x16
800078b8:	ab 6a       	lsl	r10,0xa
800078ba:	5c 3a       	neg	r10
800078bc:	5c fc       	rol	r12
800078be:	e0 49 07 ff 	cp.w	r9,2047
800078c2:	c1 a0       	breq	800078f6 <__truncdfsf_return_op1+0x6>
800078c4:	e0 29 03 80 	sub	r9,896
800078c8:	bf bc       	sbr	r12,0x1f
800078ca:	58 09       	cp.w	r9,0
800078cc:	e0 8a 00 1a 	brle	80007900 <__truncdfsf_return_op1+0x10>
800078d0:	37 fa       	mov	r10,127
800078d2:	ed bc 00 08 	bld	r12,0x8
800078d6:	f7 ba 00 ff 	subeq	r10,-1
800078da:	14 0c       	add	r12,r10
800078dc:	f7 b9 03 fe 	sublo	r9,-2
800078e0:	ed bc 00 1f 	bld	r12,0x1f
800078e4:	f7 b9 01 01 	subne	r9,1
800078e8:	f8 0c 16 07 	lsr	r12,r12,0x7
800078ec:	f9 d9 d3 08 	bfins	r12,r9,0x18,0x8

800078f0 <__truncdfsf_return_op1>:
800078f0:	a1 7b       	lsl	r11,0x1
800078f2:	5d 0c       	ror	r12
800078f4:	5e fc       	retal	r12
800078f6:	bf dc       	cbr	r12,0x1f
800078f8:	5e 1e       	retne	-1
800078fa:	fc 1c 7f 80 	movh	r12,0x7f80
800078fe:	5e fc       	retal	r12
80007900:	f2 09 11 01 	rsub	r9,r9,1
80007904:	59 99       	cp.w	r9,25
80007906:	f9 bc 02 00 	movhs	r12,0
8000790a:	c1 32       	brcc	80007930 <__truncdfsf_return_op1+0x40>
8000790c:	f2 0a 11 20 	rsub	r10,r9,32
80007910:	f8 0a 09 4a 	lsl	r10,r12,r10
80007914:	5f 1a       	srne	r10
80007916:	f8 09 0a 4c 	lsr	r12,r12,r9
8000791a:	14 4c       	or	r12,r10
8000791c:	37 fa       	mov	r10,127
8000791e:	ed bc 00 08 	bld	r12,0x8
80007922:	f7 ba 00 ff 	subeq	r10,-1
80007926:	14 0c       	add	r12,r10
80007928:	f8 0c 16 07 	lsr	r12,r12,0x7
8000792c:	a1 7b       	lsl	r11,0x1
8000792e:	5d 0c       	ror	r12
80007930:	5e fc       	retal	r12

80007932 <__avr32_udiv64>:
80007932:	d4 31       	pushm	r0-r7,lr
80007934:	1a 97       	mov	r7,sp
80007936:	20 3d       	sub	sp,12
80007938:	10 9c       	mov	r12,r8
8000793a:	12 9e       	mov	lr,r9
8000793c:	14 93       	mov	r3,r10
8000793e:	58 09       	cp.w	r9,0
80007940:	e0 81 00 bd 	brne	80007aba <__avr32_udiv64+0x188>
80007944:	16 38       	cp.w	r8,r11
80007946:	e0 88 00 40 	brls	800079c6 <__avr32_udiv64+0x94>
8000794a:	f0 08 12 00 	clz	r8,r8
8000794e:	c0 d0       	breq	80007968 <__avr32_udiv64+0x36>
80007950:	f6 08 09 4b 	lsl	r11,r11,r8
80007954:	f0 09 11 20 	rsub	r9,r8,32
80007958:	f8 08 09 4c 	lsl	r12,r12,r8
8000795c:	f4 09 0a 49 	lsr	r9,r10,r9
80007960:	f4 08 09 43 	lsl	r3,r10,r8
80007964:	f3 eb 10 0b 	or	r11,r9,r11
80007968:	f8 0e 16 10 	lsr	lr,r12,0x10
8000796c:	f5 dc c0 10 	bfextu	r10,r12,0x0,0x10
80007970:	f6 0e 0d 00 	divu	r0,r11,lr
80007974:	e6 0b 16 10 	lsr	r11,r3,0x10
80007978:	00 99       	mov	r9,r0
8000797a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
8000797e:	e0 0a 02 48 	mul	r8,r0,r10
80007982:	10 3b       	cp.w	r11,r8
80007984:	c0 a2       	brcc	80007998 <__avr32_udiv64+0x66>
80007986:	20 19       	sub	r9,1
80007988:	18 0b       	add	r11,r12
8000798a:	18 3b       	cp.w	r11,r12
8000798c:	c0 63       	brcs	80007998 <__avr32_udiv64+0x66>
8000798e:	10 3b       	cp.w	r11,r8
80007990:	f7 b9 03 01 	sublo	r9,1
80007994:	f7 dc e3 0b 	addcs	r11,r11,r12
80007998:	f6 08 01 01 	sub	r1,r11,r8
8000799c:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
800079a0:	e2 0e 0d 00 	divu	r0,r1,lr
800079a4:	e7 e1 11 03 	or	r3,r3,r1<<0x10
800079a8:	00 98       	mov	r8,r0
800079aa:	e0 0a 02 4a 	mul	r10,r0,r10
800079ae:	14 33       	cp.w	r3,r10
800079b0:	c0 82       	brcc	800079c0 <__avr32_udiv64+0x8e>
800079b2:	20 18       	sub	r8,1
800079b4:	18 03       	add	r3,r12
800079b6:	18 33       	cp.w	r3,r12
800079b8:	c0 43       	brcs	800079c0 <__avr32_udiv64+0x8e>
800079ba:	14 33       	cp.w	r3,r10
800079bc:	f7 b8 03 01 	sublo	r8,1
800079c0:	f1 e9 11 08 	or	r8,r8,r9<<0x10
800079c4:	cd f8       	rjmp	80007b82 <__avr32_udiv64+0x250>
800079c6:	58 08       	cp.w	r8,0
800079c8:	c0 51       	brne	800079d2 <__avr32_udiv64+0xa0>
800079ca:	30 19       	mov	r9,1
800079cc:	f2 08 0d 08 	divu	r8,r9,r8
800079d0:	10 9c       	mov	r12,r8
800079d2:	f8 06 12 00 	clz	r6,r12
800079d6:	c0 41       	brne	800079de <__avr32_udiv64+0xac>
800079d8:	18 1b       	sub	r11,r12
800079da:	30 19       	mov	r9,1
800079dc:	c4 08       	rjmp	80007a5c <__avr32_udiv64+0x12a>
800079de:	ec 01 11 20 	rsub	r1,r6,32
800079e2:	f4 01 0a 49 	lsr	r9,r10,r1
800079e6:	f8 06 09 4c 	lsl	r12,r12,r6
800079ea:	f6 06 09 48 	lsl	r8,r11,r6
800079ee:	f6 01 0a 41 	lsr	r1,r11,r1
800079f2:	f3 e8 10 08 	or	r8,r9,r8
800079f6:	f8 03 16 10 	lsr	r3,r12,0x10
800079fa:	eb dc c0 10 	bfextu	r5,r12,0x0,0x10
800079fe:	e2 03 0d 00 	divu	r0,r1,r3
80007a02:	f0 0b 16 10 	lsr	r11,r8,0x10
80007a06:	00 9e       	mov	lr,r0
80007a08:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007a0c:	e0 05 02 49 	mul	r9,r0,r5
80007a10:	12 3b       	cp.w	r11,r9
80007a12:	c0 a2       	brcc	80007a26 <__avr32_udiv64+0xf4>
80007a14:	20 1e       	sub	lr,1
80007a16:	18 0b       	add	r11,r12
80007a18:	18 3b       	cp.w	r11,r12
80007a1a:	c0 63       	brcs	80007a26 <__avr32_udiv64+0xf4>
80007a1c:	12 3b       	cp.w	r11,r9
80007a1e:	f7 be 03 01 	sublo	lr,1
80007a22:	f7 dc e3 0b 	addcs	r11,r11,r12
80007a26:	12 1b       	sub	r11,r9
80007a28:	f1 d8 c0 10 	bfextu	r8,r8,0x0,0x10
80007a2c:	f6 03 0d 02 	divu	r2,r11,r3
80007a30:	f1 e3 11 08 	or	r8,r8,r3<<0x10
80007a34:	04 99       	mov	r9,r2
80007a36:	e4 05 02 4b 	mul	r11,r2,r5
80007a3a:	16 38       	cp.w	r8,r11
80007a3c:	c0 a2       	brcc	80007a50 <__avr32_udiv64+0x11e>
80007a3e:	20 19       	sub	r9,1
80007a40:	18 08       	add	r8,r12
80007a42:	18 38       	cp.w	r8,r12
80007a44:	c0 63       	brcs	80007a50 <__avr32_udiv64+0x11e>
80007a46:	16 38       	cp.w	r8,r11
80007a48:	f7 b9 03 01 	sublo	r9,1
80007a4c:	f1 dc e3 08 	addcs	r8,r8,r12
80007a50:	f4 06 09 43 	lsl	r3,r10,r6
80007a54:	f0 0b 01 0b 	sub	r11,r8,r11
80007a58:	f3 ee 11 09 	or	r9,r9,lr<<0x10
80007a5c:	f8 06 16 10 	lsr	r6,r12,0x10
80007a60:	fd dc c0 10 	bfextu	lr,r12,0x0,0x10
80007a64:	f6 06 0d 00 	divu	r0,r11,r6
80007a68:	e6 0b 16 10 	lsr	r11,r3,0x10
80007a6c:	00 9a       	mov	r10,r0
80007a6e:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007a72:	e0 0e 02 48 	mul	r8,r0,lr
80007a76:	10 3b       	cp.w	r11,r8
80007a78:	c0 a2       	brcc	80007a8c <__avr32_udiv64+0x15a>
80007a7a:	20 1a       	sub	r10,1
80007a7c:	18 0b       	add	r11,r12
80007a7e:	18 3b       	cp.w	r11,r12
80007a80:	c0 63       	brcs	80007a8c <__avr32_udiv64+0x15a>
80007a82:	10 3b       	cp.w	r11,r8
80007a84:	f7 ba 03 01 	sublo	r10,1
80007a88:	f7 dc e3 0b 	addcs	r11,r11,r12
80007a8c:	f6 08 01 01 	sub	r1,r11,r8
80007a90:	e7 d3 c0 10 	bfextu	r3,r3,0x0,0x10
80007a94:	e2 06 0d 00 	divu	r0,r1,r6
80007a98:	e7 e1 11 03 	or	r3,r3,r1<<0x10
80007a9c:	00 98       	mov	r8,r0
80007a9e:	e0 0e 02 4b 	mul	r11,r0,lr
80007aa2:	16 33       	cp.w	r3,r11
80007aa4:	c0 82       	brcc	80007ab4 <__avr32_udiv64+0x182>
80007aa6:	20 18       	sub	r8,1
80007aa8:	18 03       	add	r3,r12
80007aaa:	18 33       	cp.w	r3,r12
80007aac:	c0 43       	brcs	80007ab4 <__avr32_udiv64+0x182>
80007aae:	16 33       	cp.w	r3,r11
80007ab0:	f7 b8 03 01 	sublo	r8,1
80007ab4:	f1 ea 11 08 	or	r8,r8,r10<<0x10
80007ab8:	c6 98       	rjmp	80007b8a <__avr32_udiv64+0x258>
80007aba:	16 39       	cp.w	r9,r11
80007abc:	e0 8b 00 65 	brhi	80007b86 <__avr32_udiv64+0x254>
80007ac0:	f2 09 12 00 	clz	r9,r9
80007ac4:	c0 b1       	brne	80007ada <__avr32_udiv64+0x1a8>
80007ac6:	10 3a       	cp.w	r10,r8
80007ac8:	5f 2a       	srhs	r10
80007aca:	1c 3b       	cp.w	r11,lr
80007acc:	5f b8       	srhi	r8
80007ace:	10 4a       	or	r10,r8
80007ad0:	f2 0a 18 00 	cp.b	r10,r9
80007ad4:	c5 90       	breq	80007b86 <__avr32_udiv64+0x254>
80007ad6:	30 18       	mov	r8,1
80007ad8:	c5 98       	rjmp	80007b8a <__avr32_udiv64+0x258>
80007ada:	f0 09 09 46 	lsl	r6,r8,r9
80007ade:	f2 03 11 20 	rsub	r3,r9,32
80007ae2:	fc 09 09 4e 	lsl	lr,lr,r9
80007ae6:	f0 03 0a 48 	lsr	r8,r8,r3
80007aea:	f6 09 09 4c 	lsl	r12,r11,r9
80007aee:	f4 03 0a 42 	lsr	r2,r10,r3
80007af2:	ef 46 ff f4 	st.w	r7[-12],r6
80007af6:	f6 03 0a 43 	lsr	r3,r11,r3
80007afa:	18 42       	or	r2,r12
80007afc:	f1 ee 10 0c 	or	r12,r8,lr
80007b00:	f8 01 16 10 	lsr	r1,r12,0x10
80007b04:	ed dc c0 10 	bfextu	r6,r12,0x0,0x10
80007b08:	e6 01 0d 04 	divu	r4,r3,r1
80007b0c:	e4 03 16 10 	lsr	r3,r2,0x10
80007b10:	08 9e       	mov	lr,r4
80007b12:	e7 e5 11 03 	or	r3,r3,r5<<0x10
80007b16:	e8 06 02 48 	mul	r8,r4,r6
80007b1a:	10 33       	cp.w	r3,r8
80007b1c:	c0 a2       	brcc	80007b30 <__avr32_udiv64+0x1fe>
80007b1e:	20 1e       	sub	lr,1
80007b20:	18 03       	add	r3,r12
80007b22:	18 33       	cp.w	r3,r12
80007b24:	c0 63       	brcs	80007b30 <__avr32_udiv64+0x1fe>
80007b26:	10 33       	cp.w	r3,r8
80007b28:	f7 be 03 01 	sublo	lr,1
80007b2c:	e7 dc e3 03 	addcs	r3,r3,r12
80007b30:	10 13       	sub	r3,r8
80007b32:	f7 d2 c0 10 	bfextu	r11,r2,0x0,0x10
80007b36:	e6 01 0d 00 	divu	r0,r3,r1
80007b3a:	f7 e1 11 0b 	or	r11,r11,r1<<0x10
80007b3e:	00 98       	mov	r8,r0
80007b40:	e0 06 02 46 	mul	r6,r0,r6
80007b44:	0c 3b       	cp.w	r11,r6
80007b46:	c0 a2       	brcc	80007b5a <__avr32_udiv64+0x228>
80007b48:	20 18       	sub	r8,1
80007b4a:	18 0b       	add	r11,r12
80007b4c:	18 3b       	cp.w	r11,r12
80007b4e:	c0 63       	brcs	80007b5a <__avr32_udiv64+0x228>
80007b50:	0c 3b       	cp.w	r11,r6
80007b52:	f7 dc e3 0b 	addcs	r11,r11,r12
80007b56:	f7 b8 03 01 	sublo	r8,1
80007b5a:	f1 ee 11 08 	or	r8,r8,lr<<0x10
80007b5e:	ee f4 ff f4 	ld.w	r4,r7[-12]
80007b62:	0c 1b       	sub	r11,r6
80007b64:	f0 04 06 42 	mulu.d	r2,r8,r4
80007b68:	06 95       	mov	r5,r3
80007b6a:	16 35       	cp.w	r5,r11
80007b6c:	e0 8b 00 0a 	brhi	80007b80 <__avr32_udiv64+0x24e>
80007b70:	5f 0b       	sreq	r11
80007b72:	f4 09 09 49 	lsl	r9,r10,r9
80007b76:	12 32       	cp.w	r2,r9
80007b78:	5f b9       	srhi	r9
80007b7a:	f7 e9 00 09 	and	r9,r11,r9
80007b7e:	c0 60       	breq	80007b8a <__avr32_udiv64+0x258>
80007b80:	20 18       	sub	r8,1
80007b82:	30 09       	mov	r9,0
80007b84:	c0 38       	rjmp	80007b8a <__avr32_udiv64+0x258>
80007b86:	30 09       	mov	r9,0
80007b88:	12 98       	mov	r8,r9
80007b8a:	10 9a       	mov	r10,r8
80007b8c:	12 93       	mov	r3,r9
80007b8e:	10 92       	mov	r2,r8
80007b90:	12 9b       	mov	r11,r9
80007b92:	2f dd       	sub	sp,-12
80007b94:	d8 32       	popm	r0-r7,pc

80007b96 <memcpy>:
80007b96:	58 8a       	cp.w	r10,8
80007b98:	c2 f5       	brlt	80007bf6 <memcpy+0x60>
80007b9a:	f9 eb 10 09 	or	r9,r12,r11
80007b9e:	e2 19 00 03 	andl	r9,0x3,COH
80007ba2:	e0 81 00 97 	brne	80007cd0 <memcpy+0x13a>
80007ba6:	e0 4a 00 20 	cp.w	r10,32
80007baa:	c3 b4       	brge	80007c20 <memcpy+0x8a>
80007bac:	f4 08 14 02 	asr	r8,r10,0x2
80007bb0:	f0 09 11 08 	rsub	r9,r8,8
80007bb4:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80007bb8:	76 69       	ld.w	r9,r11[0x18]
80007bba:	99 69       	st.w	r12[0x18],r9
80007bbc:	76 59       	ld.w	r9,r11[0x14]
80007bbe:	99 59       	st.w	r12[0x14],r9
80007bc0:	76 49       	ld.w	r9,r11[0x10]
80007bc2:	99 49       	st.w	r12[0x10],r9
80007bc4:	76 39       	ld.w	r9,r11[0xc]
80007bc6:	99 39       	st.w	r12[0xc],r9
80007bc8:	76 29       	ld.w	r9,r11[0x8]
80007bca:	99 29       	st.w	r12[0x8],r9
80007bcc:	76 19       	ld.w	r9,r11[0x4]
80007bce:	99 19       	st.w	r12[0x4],r9
80007bd0:	76 09       	ld.w	r9,r11[0x0]
80007bd2:	99 09       	st.w	r12[0x0],r9
80007bd4:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80007bd8:	f8 08 00 28 	add	r8,r12,r8<<0x2
80007bdc:	e0 1a 00 03 	andl	r10,0x3
80007be0:	f4 0a 11 04 	rsub	r10,r10,4
80007be4:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007be8:	17 a9       	ld.ub	r9,r11[0x2]
80007bea:	b0 a9       	st.b	r8[0x2],r9
80007bec:	17 99       	ld.ub	r9,r11[0x1]
80007bee:	b0 99       	st.b	r8[0x1],r9
80007bf0:	17 89       	ld.ub	r9,r11[0x0]
80007bf2:	b0 89       	st.b	r8[0x0],r9
80007bf4:	5e fc       	retal	r12
80007bf6:	f4 0a 11 09 	rsub	r10,r10,9
80007bfa:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80007bfe:	17 f9       	ld.ub	r9,r11[0x7]
80007c00:	b8 f9       	st.b	r12[0x7],r9
80007c02:	17 e9       	ld.ub	r9,r11[0x6]
80007c04:	b8 e9       	st.b	r12[0x6],r9
80007c06:	17 d9       	ld.ub	r9,r11[0x5]
80007c08:	b8 d9       	st.b	r12[0x5],r9
80007c0a:	17 c9       	ld.ub	r9,r11[0x4]
80007c0c:	b8 c9       	st.b	r12[0x4],r9
80007c0e:	17 b9       	ld.ub	r9,r11[0x3]
80007c10:	b8 b9       	st.b	r12[0x3],r9
80007c12:	17 a9       	ld.ub	r9,r11[0x2]
80007c14:	b8 a9       	st.b	r12[0x2],r9
80007c16:	17 99       	ld.ub	r9,r11[0x1]
80007c18:	b8 99       	st.b	r12[0x1],r9
80007c1a:	17 89       	ld.ub	r9,r11[0x0]
80007c1c:	b8 89       	st.b	r12[0x0],r9
80007c1e:	5e fc       	retal	r12
80007c20:	eb cd 40 c0 	pushm	r6-r7,lr
80007c24:	18 99       	mov	r9,r12
80007c26:	22 0a       	sub	r10,32
80007c28:	b7 07       	ld.d	r6,r11++
80007c2a:	b3 26       	st.d	r9++,r6
80007c2c:	b7 07       	ld.d	r6,r11++
80007c2e:	b3 26       	st.d	r9++,r6
80007c30:	b7 07       	ld.d	r6,r11++
80007c32:	b3 26       	st.d	r9++,r6
80007c34:	b7 07       	ld.d	r6,r11++
80007c36:	b3 26       	st.d	r9++,r6
80007c38:	22 0a       	sub	r10,32
80007c3a:	cf 74       	brge	80007c28 <memcpy+0x92>
80007c3c:	2f 0a       	sub	r10,-16
80007c3e:	c0 65       	brlt	80007c4a <memcpy+0xb4>
80007c40:	b7 07       	ld.d	r6,r11++
80007c42:	b3 26       	st.d	r9++,r6
80007c44:	b7 07       	ld.d	r6,r11++
80007c46:	b3 26       	st.d	r9++,r6
80007c48:	21 0a       	sub	r10,16
80007c4a:	5c 3a       	neg	r10
80007c4c:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80007c50:	d7 03       	nop
80007c52:	d7 03       	nop
80007c54:	f7 36 00 0e 	ld.ub	r6,r11[14]
80007c58:	f3 66 00 0e 	st.b	r9[14],r6
80007c5c:	f7 36 00 0d 	ld.ub	r6,r11[13]
80007c60:	f3 66 00 0d 	st.b	r9[13],r6
80007c64:	f7 36 00 0c 	ld.ub	r6,r11[12]
80007c68:	f3 66 00 0c 	st.b	r9[12],r6
80007c6c:	f7 36 00 0b 	ld.ub	r6,r11[11]
80007c70:	f3 66 00 0b 	st.b	r9[11],r6
80007c74:	f7 36 00 0a 	ld.ub	r6,r11[10]
80007c78:	f3 66 00 0a 	st.b	r9[10],r6
80007c7c:	f7 36 00 09 	ld.ub	r6,r11[9]
80007c80:	f3 66 00 09 	st.b	r9[9],r6
80007c84:	f7 36 00 08 	ld.ub	r6,r11[8]
80007c88:	f3 66 00 08 	st.b	r9[8],r6
80007c8c:	f7 36 00 07 	ld.ub	r6,r11[7]
80007c90:	f3 66 00 07 	st.b	r9[7],r6
80007c94:	f7 36 00 06 	ld.ub	r6,r11[6]
80007c98:	f3 66 00 06 	st.b	r9[6],r6
80007c9c:	f7 36 00 05 	ld.ub	r6,r11[5]
80007ca0:	f3 66 00 05 	st.b	r9[5],r6
80007ca4:	f7 36 00 04 	ld.ub	r6,r11[4]
80007ca8:	f3 66 00 04 	st.b	r9[4],r6
80007cac:	f7 36 00 03 	ld.ub	r6,r11[3]
80007cb0:	f3 66 00 03 	st.b	r9[3],r6
80007cb4:	f7 36 00 02 	ld.ub	r6,r11[2]
80007cb8:	f3 66 00 02 	st.b	r9[2],r6
80007cbc:	f7 36 00 01 	ld.ub	r6,r11[1]
80007cc0:	f3 66 00 01 	st.b	r9[1],r6
80007cc4:	f7 36 00 00 	ld.ub	r6,r11[0]
80007cc8:	f3 66 00 00 	st.b	r9[0],r6
80007ccc:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80007cd0:	20 1a       	sub	r10,1
80007cd2:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80007cd6:	f8 0a 0b 09 	st.b	r12[r10],r9
80007cda:	cf b1       	brne	80007cd0 <memcpy+0x13a>
80007cdc:	5e fc       	retal	r12

80007cde <memset>:
80007cde:	18 98       	mov	r8,r12
80007ce0:	c0 38       	rjmp	80007ce6 <memset+0x8>
80007ce2:	10 cb       	st.b	r8++,r11
80007ce4:	20 1a       	sub	r10,1
80007ce6:	58 0a       	cp.w	r10,0
80007ce8:	cf d1       	brne	80007ce2 <memset+0x4>
80007cea:	5e fc       	retal	r12

80007cec <strncpy>:
80007cec:	30 08       	mov	r8,0
80007cee:	10 3a       	cp.w	r10,r8
80007cf0:	5e 0c       	reteq	r12
80007cf2:	f6 08 07 09 	ld.ub	r9,r11[r8]
80007cf6:	f8 08 0b 09 	st.b	r12[r8],r9
80007cfa:	2f f8       	sub	r8,-1
80007cfc:	58 09       	cp.w	r9,0
80007cfe:	cf 81       	brne	80007cee <strncpy+0x2>
80007d00:	10 3a       	cp.w	r10,r8
80007d02:	5e 0c       	reteq	r12
80007d04:	f8 08 0b 09 	st.b	r12[r8],r9
80007d08:	2f f8       	sub	r8,-1
80007d0a:	cf bb       	rjmp	80007d00 <strncpy+0x14>

Disassembly of section .exception:

80007e00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80007e00:	c0 08       	rjmp	80007e00 <_evba>
	...

80007e04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80007e04:	c0 08       	rjmp	80007e04 <_handle_TLB_Multiple_Hit>
	...

80007e08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80007e08:	c0 08       	rjmp	80007e08 <_handle_Bus_Error_Data_Fetch>
	...

80007e0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
80007e0c:	c0 08       	rjmp	80007e0c <_handle_Bus_Error_Instruction_Fetch>
	...

80007e10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80007e10:	c0 08       	rjmp	80007e10 <_handle_NMI>
	...

80007e14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80007e14:	c0 08       	rjmp	80007e14 <_handle_Instruction_Address>
	...

80007e18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80007e18:	c0 08       	rjmp	80007e18 <_handle_ITLB_Protection>
	...

80007e1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
80007e1c:	c0 08       	rjmp	80007e1c <_handle_Breakpoint>
	...

80007e20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80007e20:	c0 08       	rjmp	80007e20 <_handle_Illegal_Opcode>
	...

80007e24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80007e24:	c0 08       	rjmp	80007e24 <_handle_Unimplemented_Instruction>
	...

80007e28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80007e28:	c0 08       	rjmp	80007e28 <_handle_Privilege_Violation>
	...

80007e2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR UC3.
_handle_Floating_Point:
	rjmp $
80007e2c:	c0 08       	rjmp	80007e2c <_handle_Floating_Point>
	...

80007e30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR UC3.
_handle_Coprocessor_Absent:
	rjmp $
80007e30:	c0 08       	rjmp	80007e30 <_handle_Coprocessor_Absent>
	...

80007e34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80007e34:	c0 08       	rjmp	80007e34 <_handle_Data_Address_Read>
	...

80007e38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80007e38:	c0 08       	rjmp	80007e38 <_handle_Data_Address_Write>
	...

80007e3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
80007e3c:	c0 08       	rjmp	80007e3c <_handle_DTLB_Protection_Read>
	...

80007e40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80007e40:	c0 08       	rjmp	80007e40 <_handle_DTLB_Protection_Write>
	...

80007e44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80007e44:	c0 08       	rjmp	80007e44 <_handle_DTLB_Modified>
	...

80007e50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80007e50:	c0 08       	rjmp	80007e50 <_handle_ITLB_Miss>
	...

80007e60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80007e60:	c0 08       	rjmp	80007e60 <_handle_DTLB_Miss_Read>
	...

80007e70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80007e70:	c0 08       	rjmp	80007e70 <_handle_DTLB_Miss_Write>
	...

80007f00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	lda.w   pc, SCALLYield
80007f00:	fe cf 26 50 	sub	pc,pc,9808

80007f04 <_int0>:
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
	rete
.endr
80007f04:	30 0c       	mov	r12,0
80007f06:	fe b0 f5 dd 	rcall	80006ac0 <_get_interrupt_handler>
80007f0a:	58 0c       	cp.w	r12,0
80007f0c:	f8 0f 17 10 	movne	pc,r12
80007f10:	d6 03       	rete

80007f12 <_int1>:
80007f12:	30 1c       	mov	r12,1
80007f14:	fe b0 f5 d6 	rcall	80006ac0 <_get_interrupt_handler>
80007f18:	58 0c       	cp.w	r12,0
80007f1a:	f8 0f 17 10 	movne	pc,r12
80007f1e:	d6 03       	rete

80007f20 <_int2>:
80007f20:	30 2c       	mov	r12,2
80007f22:	fe b0 f5 cf 	rcall	80006ac0 <_get_interrupt_handler>
80007f26:	58 0c       	cp.w	r12,0
80007f28:	f8 0f 17 10 	movne	pc,r12
80007f2c:	d6 03       	rete

80007f2e <_int3>:
80007f2e:	30 3c       	mov	r12,3
80007f30:	fe b0 f5 c8 	rcall	80006ac0 <_get_interrupt_handler>
80007f34:	58 0c       	cp.w	r12,0
80007f36:	f8 0f 17 10 	movne	pc,r12
80007f3a:	d6 03       	rete
80007f3c:	d7 03       	nop
80007f3e:	d7 03       	nop
80007f40:	d7 03       	nop
80007f42:	d7 03       	nop
80007f44:	d7 03       	nop
80007f46:	d7 03       	nop
80007f48:	d7 03       	nop
80007f4a:	d7 03       	nop
80007f4c:	d7 03       	nop
80007f4e:	d7 03       	nop
80007f50:	d7 03       	nop
80007f52:	d7 03       	nop
80007f54:	d7 03       	nop
80007f56:	d7 03       	nop
80007f58:	d7 03       	nop
80007f5a:	d7 03       	nop
80007f5c:	d7 03       	nop
80007f5e:	d7 03       	nop
80007f60:	d7 03       	nop
80007f62:	d7 03       	nop
80007f64:	d7 03       	nop
80007f66:	d7 03       	nop
80007f68:	d7 03       	nop
80007f6a:	d7 03       	nop
80007f6c:	d7 03       	nop
80007f6e:	d7 03       	nop
80007f70:	d7 03       	nop
80007f72:	d7 03       	nop
80007f74:	d7 03       	nop
80007f76:	d7 03       	nop
80007f78:	d7 03       	nop
80007f7a:	d7 03       	nop
80007f7c:	d7 03       	nop
80007f7e:	d7 03       	nop
80007f80:	d7 03       	nop
80007f82:	d7 03       	nop
80007f84:	d7 03       	nop
80007f86:	d7 03       	nop
80007f88:	d7 03       	nop
80007f8a:	d7 03       	nop
80007f8c:	d7 03       	nop
80007f8e:	d7 03       	nop
80007f90:	d7 03       	nop
80007f92:	d7 03       	nop
80007f94:	d7 03       	nop
80007f96:	d7 03       	nop
80007f98:	d7 03       	nop
80007f9a:	d7 03       	nop
80007f9c:	d7 03       	nop
80007f9e:	d7 03       	nop
80007fa0:	d7 03       	nop
80007fa2:	d7 03       	nop
80007fa4:	d7 03       	nop
80007fa6:	d7 03       	nop
80007fa8:	d7 03       	nop
80007faa:	d7 03       	nop
80007fac:	d7 03       	nop
80007fae:	d7 03       	nop
80007fb0:	d7 03       	nop
80007fb2:	d7 03       	nop
80007fb4:	d7 03       	nop
80007fb6:	d7 03       	nop
80007fb8:	d7 03       	nop
80007fba:	d7 03       	nop
80007fbc:	d7 03       	nop
80007fbe:	d7 03       	nop
80007fc0:	d7 03       	nop
80007fc2:	d7 03       	nop
80007fc4:	d7 03       	nop
80007fc6:	d7 03       	nop
80007fc8:	d7 03       	nop
80007fca:	d7 03       	nop
80007fcc:	d7 03       	nop
80007fce:	d7 03       	nop
80007fd0:	d7 03       	nop
80007fd2:	d7 03       	nop
80007fd4:	d7 03       	nop
80007fd6:	d7 03       	nop
80007fd8:	d7 03       	nop
80007fda:	d7 03       	nop
80007fdc:	d7 03       	nop
80007fde:	d7 03       	nop
80007fe0:	d7 03       	nop
80007fe2:	d7 03       	nop
80007fe4:	d7 03       	nop
80007fe6:	d7 03       	nop
80007fe8:	d7 03       	nop
80007fea:	d7 03       	nop
80007fec:	d7 03       	nop
80007fee:	d7 03       	nop
80007ff0:	d7 03       	nop
80007ff2:	d7 03       	nop
80007ff4:	d7 03       	nop
80007ff6:	d7 03       	nop
80007ff8:	d7 03       	nop
80007ffa:	d7 03       	nop
80007ffc:	d7 03       	nop
80007ffe:	d7 03       	nop
